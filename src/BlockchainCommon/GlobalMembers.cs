using System;
using System.Collections.Generic;
using System.Diagnostics;

#define SKEIN_USE_ASM
#define SKEIN_LOOP

public static class GlobalMembers
{
	public static std::error_code make_error_code(CryptoNote.error.BlockchainExplorerErrorCodes e)
	{
	  return std::error_code((int)e, CryptoNote.error.BlockchainExplorerErrorCategory.INSTANCE);
	}
	#if MSVC
	public static char suppressMSVCWarningLNK4221;
	#endif

	#if MSVC
	public static char suppressMSVCWarningLNK4221;
	#endif

	#if MSVC
	public static char suppressMSVCWarningLNK4221;
	#endif


	public static readonly char GENERIC_PATH_SEPARATOR = '/';

	#if _WIN32
	public static readonly char NATIVE_PATH_SEPARATOR = '\\';
	#else
	public static readonly char NATIVE_PATH_SEPARATOR = '/';
	#endif


	public static int findExtensionPosition(string filename)
	{
	  var pos = filename.LastIndexOf('.');

	  if (pos != -1)
	  {
		var slashPos = filename.LastIndexOf(GENERIC_PATH_SEPARATOR);
		if (slashPos != -1 && slashPos > pos)
		{
		  return -1;
		}
	  }

	  return pos;
	}

	  public static Action m_handler;
//C++ TO C# CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in C#):
  private static object handleSignal_m_mutex = new object();

	  public static void handleSignal()
	  {
	//C++ TO C# CONVERTER NOTE: This static local variable declaration (not allowed in C#) has been moved just prior to the method:
	//	static object m_mutex;
		std::unique_lock<object> @lock = new std::unique_lock<object>(handleSignal_m_mutex, std::try_to_lock);
		if (!@lock.owns_lock())
		{
		  return;
		}
		m_handler();
	  }


	#if WIN32
//C++ TO C# CONVERTER NOTE: WINAPI is not available in C#:
//ORIGINAL LINE: int WINAPI winHandler(uint type)
	public static int winHandler(uint type)
	{
	  if (CTRL_C_EVENT == type || CTRL_BREAK_EVENT == type)
	  {
		handleSignal();
		return 1;
	  }
	  else
	  {
		std::cerr << "Got control signal " << (int)type << ". Exiting without saving...";
		return 0;
	  }
	  return 1;
	}

	#else

	public static void posixHandler(int UnnamedParameter)
	{
	  handleSignal();
	}
	#endif

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rf1(r,c) (r)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define word_in(x,c) (*((uint*)(x)+(c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define word_out(x,c,v) (*((uint*)(x)+(c)) = (v))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define s(x,c) x[c]
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define si(y,x,c) (s(y,c) = word_in(x, c))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define so(y,x,c) word_out(y, c, s(x,c))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define state_in(y,x) si(y,x,0); si(y,x,1); si(y,x,2); si(y,x,3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define state_out(y,x) so(y,x,0); so(y,x,1); so(y,x,2); so(y,x,3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define round(rm,y,x,k) rm(y,x,k,0); rm(y,x,k,1); rm(y,x,k,2); rm(y,x,k,3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define to_byte(x) ((x) & 0xff)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bval(x,n) to_byte((x) >> (8 * (n)))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fwd_var(x,r,c) ( r == 0 ? ( c == 0 ? s(x,0) : c == 1 ? s(x,1) : c == 2 ? s(x,2) : s(x,3)) : r == 1 ? ( c == 0 ? s(x,1) : c == 1 ? s(x,2) : c == 2 ? s(x,3) : s(x,0)) : r == 2 ? ( c == 0 ? s(x,2) : c == 1 ? s(x,3) : c == 2 ? s(x,0) : s(x,1)) : ( c == 0 ? s(x,3) : c == 1 ? s(x,0) : c == 2 ? s(x,1) : s(x,2)))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fwd_rnd(y,x,k,c) (s(y,c) = (k)[c] ^ four_tables(x,t_use(f,n),fwd_var,rf1,c))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sb_data(w) { w(0x63), w(0x7c), w(0x77), w(0x7b), w(0xf2), w(0x6b), w(0x6f), w(0xc5), w(0x30), w(0x01), w(0x67), w(0x2b), w(0xfe), w(0xd7), w(0xab), w(0x76), w(0xca), w(0x82), w(0xc9), w(0x7d), w(0xfa), w(0x59), w(0x47), w(0xf0), w(0xad), w(0xd4), w(0xa2), w(0xaf), w(0x9c), w(0xa4), w(0x72), w(0xc0), w(0xb7), w(0xfd), w(0x93), w(0x26), w(0x36), w(0x3f), w(0xf7), w(0xcc), w(0x34), w(0xa5), w(0xe5), w(0xf1), w(0x71), w(0xd8), w(0x31), w(0x15), w(0x04), w(0xc7), w(0x23), w(0xc3), w(0x18), w(0x96), w(0x05), w(0x9a), w(0x07), w(0x12), w(0x80), w(0xe2), w(0xeb), w(0x27), w(0xb2), w(0x75), w(0x09), w(0x83), w(0x2c), w(0x1a), w(0x1b), w(0x6e), w(0x5a), w(0xa0), w(0x52), w(0x3b), w(0xd6), w(0xb3), w(0x29), w(0xe3), w(0x2f), w(0x84), w(0x53), w(0xd1), w(0x00), w(0xed), w(0x20), w(0xfc), w(0xb1), w(0x5b), w(0x6a), w(0xcb), w(0xbe), w(0x39), w(0x4a), w(0x4c), w(0x58), w(0xcf), w(0xd0), w(0xef), w(0xaa), w(0xfb), w(0x43), w(0x4d), w(0x33), w(0x85), w(0x45), w(0xf9), w(0x02), w(0x7f), w(0x50), w(0x3c), w(0x9f), w(0xa8), w(0x51), w(0xa3), w(0x40), w(0x8f), w(0x92), w(0x9d), w(0x38), w(0xf5), w(0xbc), w(0xb6), w(0xda), w(0x21), w(0x10), w(0xff), w(0xf3), w(0xd2), w(0xcd), w(0x0c), w(0x13), w(0xec), w(0x5f), w(0x97), w(0x44), w(0x17), w(0xc4), w(0xa7), w(0x7e), w(0x3d), w(0x64), w(0x5d), w(0x19), w(0x73), w(0x60), w(0x81), w(0x4f), w(0xdc), w(0x22), w(0x2a), w(0x90), w(0x88), w(0x46), w(0xee), w(0xb8), w(0x14), w(0xde), w(0x5e), w(0x0b), w(0xdb), w(0xe0), w(0x32), w(0x3a), w(0x0a), w(0x49), w(0x06), w(0x24), w(0x5c), w(0xc2), w(0xd3), w(0xac), w(0x62), w(0x91), w(0x95), w(0xe4), w(0x79), w(0xe7), w(0xc8), w(0x37), w(0x6d), w(0x8d), w(0xd5), w(0x4e), w(0xa9), w(0x6c), w(0x56), w(0xf4), w(0xea), w(0x65), w(0x7a), w(0xae), w(0x08), w(0xba), w(0x78), w(0x25), w(0x2e), w(0x1c), w(0xa6), w(0xb4), w(0xc6), w(0xe8), w(0xdd), w(0x74), w(0x1f), w(0x4b), w(0xbd), w(0x8b), w(0x8a), w(0x70), w(0x3e), w(0xb5), w(0x66), w(0x48), w(0x03), w(0xf6), w(0x0e), w(0x61), w(0x35), w(0x57), w(0xb9), w(0x86), w(0xc1), w(0x1d), w(0x9e), w(0xe1), w(0xf8), w(0x98), w(0x11), w(0x69), w(0xd9), w(0x8e), w(0x94), w(0x9b), w(0x1e), w(0x87), w(0xe9), w(0xce), w(0x55), w(0x28), w(0xdf), w(0x8c), w(0xa1), w(0x89), w(0x0d), w(0xbf), w(0xe6), w(0x42), w(0x68), w(0x41), w(0x99), w(0x2d), w(0x0f), w(0xb0), w(0x54), w(0xbb), w(0x16) }

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rc_data(w) { w(0x01), w(0x02), w(0x04), w(0x08), w(0x10),w(0x20), w(0x40), w(0x80), w(0x1b), w(0x36) }

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bytes2word(b0, b1, b2, b3) (((uint)(b3) << 24) | ((uint)(b2) << 16) | ((uint)(b1) << 8) | (b0))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define h0(x) (x)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define w0(p) bytes2word(p, 0, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define w1(p) bytes2word(0, p, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define w2(p) bytes2word(0, 0, p, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define w3(p) bytes2word(0, 0, 0, p)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define u0(p) bytes2word(f2(p), p, p, f3(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define u1(p) bytes2word(f3(p), f2(p), p, p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define u2(p) bytes2word(p, f3(p), f2(p), p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define u3(p) bytes2word(p, p, f3(p), f2(p))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define v0(p) bytes2word(fe(p), f9(p), fd(p), fb(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define v1(p) bytes2word(fb(p), fe(p), f9(p), fd(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define v2(p) bytes2word(fd(p), fb(p), fe(p), f9(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define v3(p) bytes2word(f9(p), fd(p), fb(p), fe(p))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f2(x) ((x<<1) ^ (((x>>7) & 1) * WPOLY))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f4(x) ((x<<2) ^ (((x>>6) & 1) * WPOLY) ^ (((x>>6) & 2) * WPOLY))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f8(x) ((x<<3) ^ (((x>>5) & 1) * WPOLY) ^ (((x>>5) & 2) * WPOLY) ^ (((x>>5) & 4) * WPOLY))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f3(x) (f2(x) ^ x)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f9(x) (f8(x) ^ x)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fb(x) (f8(x) ^ f2(x) ^ x)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fd(x) (f8(x) ^ f4(x) ^ x)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fe(x) (f8(x) ^ f4(x) ^ f2(x))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define t_dec(m,n) t_##m##n
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define t_set(m,n) t_##m##n
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define t_use(m,n) t_##m##n

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define d_4(t,n,b,e,f,g,h) ALIGN const t n[4][256] = { b(e), b(f), b(g), b(h) }

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define four_tables(x,tab,vf,rf,c) (tab[0][bval(vf(x,0,c),rf(0,c))] ^ tab[1][bval(vf(x,1,c),rf(1,c))] ^ tab[2][bval(vf(x,2,c),rf(2,c))] ^ tab[3][bval(vf(x,3,c),rf(3,c))])

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'ALIGN' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static readonly ALIGN[,] uint t_fn =
	{
		{(((uint)((f2(0x63) ^ 0x63)) << 24) | ((uint)(0x63) << 16) | ((uint)(0x63) << 8) | (((0x63 << 1) ^ (((0x63>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x7c) ^ 0x7c)) << 24) | ((uint)(0x7c) << 16) | ((uint)(0x7c) << 8) | (((0x7c << 1) ^ (((0x7c>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x77) ^ 0x77)) << 24) | ((uint)(0x77) << 16) | ((uint)(0x77) << 8) | (((0x77 << 1) ^ (((0x77>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x7b) ^ 0x7b)) << 24) | ((uint)(0x7b) << 16) | ((uint)(0x7b) << 8) | (((0x7b << 1) ^ (((0x7b>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xf2) ^ 0xf2)) << 24) | ((uint)(0xf2) << 16) | ((uint)(0xf2) << 8) | (((0xf2 << 1) ^ (((0xf2>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x6b) ^ 0x6b)) << 24) | ((uint)(0x6b) << 16) | ((uint)(0x6b) << 8) | (((0x6b << 1) ^ (((0x6b>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x6f) ^ 0x6f)) << 24) | ((uint)(0x6f) << 16) | ((uint)(0x6f) << 8) | (((0x6f << 1) ^ (((0x6f>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xc5) ^ 0xc5)) << 24) | ((uint)(0xc5) << 16) | ((uint)(0xc5) << 8) | (((0xc5 << 1) ^ (((0xc5>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x30) ^ 0x30)) << 24) | ((uint)(0x30) << 16) | ((uint)(0x30) << 8) | (((0x30 << 1) ^ (((0x30>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x01) ^ 0x01)) << 24) | ((uint)(0x01) << 16) | ((uint)(0x01) << 8) | (((0x01 << 1) ^ (((0x01>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x67) ^ 0x67)) << 24) | ((uint)(0x67) << 16) | ((uint)(0x67) << 8) | (((0x67 << 1) ^ (((0x67>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x2b) ^ 0x2b)) << 24) | ((uint)(0x2b) << 16) | ((uint)(0x2b) << 8) | (((0x2b << 1) ^ (((0x2b>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xfe) ^ 0xfe)) << 24) | ((uint)(0xfe) << 16) | ((uint)(0xfe) << 8) | (((0xfe << 1) ^ (((0xfe>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xd7) ^ 0xd7)) << 24) | ((uint)(0xd7) << 16) | ((uint)(0xd7) << 8) | (((0xd7 << 1) ^ (((0xd7>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xab) ^ 0xab)) << 24) | ((uint)(0xab) << 16) | ((uint)(0xab) << 8) | (((0xab << 1) ^ (((0xab>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x76) ^ 0x76)) << 24) | ((uint)(0x76) << 16) | ((uint)(0x76) << 8) | (((0x76 << 1) ^ (((0x76>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xca) ^ 0xca)) << 24) | ((uint)(0xca) << 16) | ((uint)(0xca) << 8) | (((0xca << 1) ^ (((0xca>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x82) ^ 0x82)) << 24) | ((uint)(0x82) << 16) | ((uint)(0x82) << 8) | (((0x82 << 1) ^ (((0x82>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xc9) ^ 0xc9)) << 24) | ((uint)(0xc9) << 16) | ((uint)(0xc9) << 8) | (((0xc9 << 1) ^ (((0xc9>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x7d) ^ 0x7d)) << 24) | ((uint)(0x7d) << 16) | ((uint)(0x7d) << 8) | (((0x7d << 1) ^ (((0x7d>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xfa) ^ 0xfa)) << 24) | ((uint)(0xfa) << 16) | ((uint)(0xfa) << 8) | (((0xfa << 1) ^ (((0xfa>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x59) ^ 0x59)) << 24) | ((uint)(0x59) << 16) | ((uint)(0x59) << 8) | (((0x59 << 1) ^ (((0x59>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x47) ^ 0x47)) << 24) | ((uint)(0x47) << 16) | ((uint)(0x47) << 8) | (((0x47 << 1) ^ (((0x47>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xf0) ^ 0xf0)) << 24) | ((uint)(0xf0) << 16) | ((uint)(0xf0) << 8) | (((0xf0 << 1) ^ (((0xf0>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xad) ^ 0xad)) << 24) | ((uint)(0xad) << 16) | ((uint)(0xad) << 8) | (((0xad << 1) ^ (((0xad>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xd4) ^ 0xd4)) << 24) | ((uint)(0xd4) << 16) | ((uint)(0xd4) << 8) | (((0xd4 << 1) ^ (((0xd4>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xa2) ^ 0xa2)) << 24) | ((uint)(0xa2) << 16) | ((uint)(0xa2) << 8) | (((0xa2 << 1) ^ (((0xa2>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xaf) ^ 0xaf)) << 24) | ((uint)(0xaf) << 16) | ((uint)(0xaf) << 8) | (((0xaf << 1) ^ (((0xaf>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x9c) ^ 0x9c)) << 24) | ((uint)(0x9c) << 16) | ((uint)(0x9c) << 8) | (((0x9c << 1) ^ (((0x9c>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xa4) ^ 0xa4)) << 24) | ((uint)(0xa4) << 16) | ((uint)(0xa4) << 8) | (((0xa4 << 1) ^ (((0xa4>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x72) ^ 0x72)) << 24) | ((uint)(0x72) << 16) | ((uint)(0x72) << 8) | (((0x72 << 1) ^ (((0x72>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xc0) ^ 0xc0)) << 24) | ((uint)(0xc0) << 16) | ((uint)(0xc0) << 8) | (((0xc0 << 1) ^ (((0xc0>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xb7) ^ 0xb7)) << 24) | ((uint)(0xb7) << 16) | ((uint)(0xb7) << 8) | (((0xb7 << 1) ^ (((0xb7>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xfd) ^ 0xfd)) << 24) | ((uint)(0xfd) << 16) | ((uint)(0xfd) << 8) | (((0xfd << 1) ^ (((0xfd>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x93) ^ 0x93)) << 24) | ((uint)(0x93) << 16) | ((uint)(0x93) << 8) | (((0x93 << 1) ^ (((0x93>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x26) ^ 0x26)) << 24) | ((uint)(0x26) << 16) | ((uint)(0x26) << 8) | (((0x26 << 1) ^ (((0x26>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x36) ^ 0x36)) << 24) | ((uint)(0x36) << 16) | ((uint)(0x36) << 8) | (((0x36 << 1) ^ (((0x36>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x3f) ^ 0x3f)) << 24) | ((uint)(0x3f) << 16) | ((uint)(0x3f) << 8) | (((0x3f << 1) ^ (((0x3f>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xf7) ^ 0xf7)) << 24) | ((uint)(0xf7) << 16) | ((uint)(0xf7) << 8) | (((0xf7 << 1) ^ (((0xf7>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xcc) ^ 0xcc)) << 24) | ((uint)(0xcc) << 16) | ((uint)(0xcc) << 8) | (((0xcc << 1) ^ (((0xcc>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x34) ^ 0x34)) << 24) | ((uint)(0x34) << 16) | ((uint)(0x34) << 8) | (((0x34 << 1) ^ (((0x34>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xa5) ^ 0xa5)) << 24) | ((uint)(0xa5) << 16) | ((uint)(0xa5) << 8) | (((0xa5 << 1) ^ (((0xa5>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xe5) ^ 0xe5)) << 24) | ((uint)(0xe5) << 16) | ((uint)(0xe5) << 8) | (((0xe5 << 1) ^ (((0xe5>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xf1) ^ 0xf1)) << 24) | ((uint)(0xf1) << 16) | ((uint)(0xf1) << 8) | (((0xf1 << 1) ^ (((0xf1>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x71) ^ 0x71)) << 24) | ((uint)(0x71) << 16) | ((uint)(0x71) << 8) | (((0x71 << 1) ^ (((0x71>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xd8) ^ 0xd8)) << 24) | ((uint)(0xd8) << 16) | ((uint)(0xd8) << 8) | (((0xd8 << 1) ^ (((0xd8>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x31) ^ 0x31)) << 24) | ((uint)(0x31) << 16) | ((uint)(0x31) << 8) | (((0x31 << 1) ^ (((0x31>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x15) ^ 0x15)) << 24) | ((uint)(0x15) << 16) | ((uint)(0x15) << 8) | (((0x15 << 1) ^ (((0x15>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x04) ^ 0x04)) << 24) | ((uint)(0x04) << 16) | ((uint)(0x04) << 8) | (((0x04 << 1) ^ (((0x04>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xc7) ^ 0xc7)) << 24) | ((uint)(0xc7) << 16) | ((uint)(0xc7) << 8) | (((0xc7 << 1) ^ (((0xc7>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x23) ^ 0x23)) << 24) | ((uint)(0x23) << 16) | ((uint)(0x23) << 8) | (((0x23 << 1) ^ (((0x23>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xc3) ^ 0xc3)) << 24) | ((uint)(0xc3) << 16) | ((uint)(0xc3) << 8) | (((0xc3 << 1) ^ (((0xc3>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x18) ^ 0x18)) << 24) | ((uint)(0x18) << 16) | ((uint)(0x18) << 8) | (((0x18 << 1) ^ (((0x18>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x96) ^ 0x96)) << 24) | ((uint)(0x96) << 16) | ((uint)(0x96) << 8) | (((0x96 << 1) ^ (((0x96>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x05) ^ 0x05)) << 24) | ((uint)(0x05) << 16) | ((uint)(0x05) << 8) | (((0x05 << 1) ^ (((0x05>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x9a) ^ 0x9a)) << 24) | ((uint)(0x9a) << 16) | ((uint)(0x9a) << 8) | (((0x9a << 1) ^ (((0x9a>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x07) ^ 0x07)) << 24) | ((uint)(0x07) << 16) | ((uint)(0x07) << 8) | (((0x07 << 1) ^ (((0x07>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x12) ^ 0x12)) << 24) | ((uint)(0x12) << 16) | ((uint)(0x12) << 8) | (((0x12 << 1) ^ (((0x12>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x80) ^ 0x80)) << 24) | ((uint)(0x80) << 16) | ((uint)(0x80) << 8) | (((0x80 << 1) ^ (((0x80>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xe2) ^ 0xe2)) << 24) | ((uint)(0xe2) << 16) | ((uint)(0xe2) << 8) | (((0xe2 << 1) ^ (((0xe2>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xeb) ^ 0xeb)) << 24) | ((uint)(0xeb) << 16) | ((uint)(0xeb) << 8) | (((0xeb << 1) ^ (((0xeb>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x27) ^ 0x27)) << 24) | ((uint)(0x27) << 16) | ((uint)(0x27) << 8) | (((0x27 << 1) ^ (((0x27>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xb2) ^ 0xb2)) << 24) | ((uint)(0xb2) << 16) | ((uint)(0xb2) << 8) | (((0xb2 << 1) ^ (((0xb2>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x75) ^ 0x75)) << 24) | ((uint)(0x75) << 16) | ((uint)(0x75) << 8) | (((0x75 << 1) ^ (((0x75>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x09) ^ 0x09)) << 24) | ((uint)(0x09) << 16) | ((uint)(0x09) << 8) | (((0x09 << 1) ^ (((0x09>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x83) ^ 0x83)) << 24) | ((uint)(0x83) << 16) | ((uint)(0x83) << 8) | (((0x83 << 1) ^ (((0x83>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x2c) ^ 0x2c)) << 24) | ((uint)(0x2c) << 16) | ((uint)(0x2c) << 8) | (((0x2c << 1) ^ (((0x2c>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x1a) ^ 0x1a)) << 24) | ((uint)(0x1a) << 16) | ((uint)(0x1a) << 8) | (((0x1a << 1) ^ (((0x1a>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x1b) ^ 0x1b)) << 24) | ((uint)(0x1b) << 16) | ((uint)(0x1b) << 8) | (((0x1b << 1) ^ (((0x1b>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x6e) ^ 0x6e)) << 24) | ((uint)(0x6e) << 16) | ((uint)(0x6e) << 8) | (((0x6e << 1) ^ (((0x6e>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x5a) ^ 0x5a)) << 24) | ((uint)(0x5a) << 16) | ((uint)(0x5a) << 8) | (((0x5a << 1) ^ (((0x5a>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xa0) ^ 0xa0)) << 24) | ((uint)(0xa0) << 16) | ((uint)(0xa0) << 8) | (((0xa0 << 1) ^ (((0xa0>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x52) ^ 0x52)) << 24) | ((uint)(0x52) << 16) | ((uint)(0x52) << 8) | (((0x52 << 1) ^ (((0x52>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x3b) ^ 0x3b)) << 24) | ((uint)(0x3b) << 16) | ((uint)(0x3b) << 8) | (((0x3b << 1) ^ (((0x3b>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xd6) ^ 0xd6)) << 24) | ((uint)(0xd6) << 16) | ((uint)(0xd6) << 8) | (((0xd6 << 1) ^ (((0xd6>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xb3) ^ 0xb3)) << 24) | ((uint)(0xb3) << 16) | ((uint)(0xb3) << 8) | (((0xb3 << 1) ^ (((0xb3>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x29) ^ 0x29)) << 24) | ((uint)(0x29) << 16) | ((uint)(0x29) << 8) | (((0x29 << 1) ^ (((0x29>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xe3) ^ 0xe3)) << 24) | ((uint)(0xe3) << 16) | ((uint)(0xe3) << 8) | (((0xe3 << 1) ^ (((0xe3>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x2f) ^ 0x2f)) << 24) | ((uint)(0x2f) << 16) | ((uint)(0x2f) << 8) | (((0x2f << 1) ^ (((0x2f>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x84) ^ 0x84)) << 24) | ((uint)(0x84) << 16) | ((uint)(0x84) << 8) | (((0x84 << 1) ^ (((0x84>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x53) ^ 0x53)) << 24) | ((uint)(0x53) << 16) | ((uint)(0x53) << 8) | (((0x53 << 1) ^ (((0x53>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xd1) ^ 0xd1)) << 24) | ((uint)(0xd1) << 16) | ((uint)(0xd1) << 8) | (((0xd1 << 1) ^ (((0xd1>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x00) ^ 0x00)) << 24) | ((uint)(0x00) << 16) | ((uint)(0x00) << 8) | (((0x00 << 1) ^ (((0x00>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xed) ^ 0xed)) << 24) | ((uint)(0xed) << 16) | ((uint)(0xed) << 8) | (((0xed << 1) ^ (((0xed>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x20) ^ 0x20)) << 24) | ((uint)(0x20) << 16) | ((uint)(0x20) << 8) | (((0x20 << 1) ^ (((0x20>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xfc) ^ 0xfc)) << 24) | ((uint)(0xfc) << 16) | ((uint)(0xfc) << 8) | (((0xfc << 1) ^ (((0xfc>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xb1) ^ 0xb1)) << 24) | ((uint)(0xb1) << 16) | ((uint)(0xb1) << 8) | (((0xb1 << 1) ^ (((0xb1>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x5b) ^ 0x5b)) << 24) | ((uint)(0x5b) << 16) | ((uint)(0x5b) << 8) | (((0x5b << 1) ^ (((0x5b>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x6a) ^ 0x6a)) << 24) | ((uint)(0x6a) << 16) | ((uint)(0x6a) << 8) | (((0x6a << 1) ^ (((0x6a>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xcb) ^ 0xcb)) << 24) | ((uint)(0xcb) << 16) | ((uint)(0xcb) << 8) | (((0xcb << 1) ^ (((0xcb>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xbe) ^ 0xbe)) << 24) | ((uint)(0xbe) << 16) | ((uint)(0xbe) << 8) | (((0xbe << 1) ^ (((0xbe>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x39) ^ 0x39)) << 24) | ((uint)(0x39) << 16) | ((uint)(0x39) << 8) | (((0x39 << 1) ^ (((0x39>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x4a) ^ 0x4a)) << 24) | ((uint)(0x4a) << 16) | ((uint)(0x4a) << 8) | (((0x4a << 1) ^ (((0x4a>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x4c) ^ 0x4c)) << 24) | ((uint)(0x4c) << 16) | ((uint)(0x4c) << 8) | (((0x4c << 1) ^ (((0x4c>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x58) ^ 0x58)) << 24) | ((uint)(0x58) << 16) | ((uint)(0x58) << 8) | (((0x58 << 1) ^ (((0x58>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xcf) ^ 0xcf)) << 24) | ((uint)(0xcf) << 16) | ((uint)(0xcf) << 8) | (((0xcf << 1) ^ (((0xcf>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xd0) ^ 0xd0)) << 24) | ((uint)(0xd0) << 16) | ((uint)(0xd0) << 8) | (((0xd0 << 1) ^ (((0xd0>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xef) ^ 0xef)) << 24) | ((uint)(0xef) << 16) | ((uint)(0xef) << 8) | (((0xef << 1) ^ (((0xef>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xaa) ^ 0xaa)) << 24) | ((uint)(0xaa) << 16) | ((uint)(0xaa) << 8) | (((0xaa << 1) ^ (((0xaa>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xfb) ^ 0xfb)) << 24) | ((uint)(0xfb) << 16) | ((uint)(0xfb) << 8) | (((0xfb << 1) ^ (((0xfb>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x43) ^ 0x43)) << 24) | ((uint)(0x43) << 16) | ((uint)(0x43) << 8) | (((0x43 << 1) ^ (((0x43>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x4d) ^ 0x4d)) << 24) | ((uint)(0x4d) << 16) | ((uint)(0x4d) << 8) | (((0x4d << 1) ^ (((0x4d>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x33) ^ 0x33)) << 24) | ((uint)(0x33) << 16) | ((uint)(0x33) << 8) | (((0x33 << 1) ^ (((0x33>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x85) ^ 0x85)) << 24) | ((uint)(0x85) << 16) | ((uint)(0x85) << 8) | (((0x85 << 1) ^ (((0x85>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x45) ^ 0x45)) << 24) | ((uint)(0x45) << 16) | ((uint)(0x45) << 8) | (((0x45 << 1) ^ (((0x45>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xf9) ^ 0xf9)) << 24) | ((uint)(0xf9) << 16) | ((uint)(0xf9) << 8) | (((0xf9 << 1) ^ (((0xf9>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x02) ^ 0x02)) << 24) | ((uint)(0x02) << 16) | ((uint)(0x02) << 8) | (((0x02 << 1) ^ (((0x02>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x7f) ^ 0x7f)) << 24) | ((uint)(0x7f) << 16) | ((uint)(0x7f) << 8) | (((0x7f << 1) ^ (((0x7f>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x50) ^ 0x50)) << 24) | ((uint)(0x50) << 16) | ((uint)(0x50) << 8) | (((0x50 << 1) ^ (((0x50>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x3c) ^ 0x3c)) << 24) | ((uint)(0x3c) << 16) | ((uint)(0x3c) << 8) | (((0x3c << 1) ^ (((0x3c>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x9f) ^ 0x9f)) << 24) | ((uint)(0x9f) << 16) | ((uint)(0x9f) << 8) | (((0x9f << 1) ^ (((0x9f>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xa8) ^ 0xa8)) << 24) | ((uint)(0xa8) << 16) | ((uint)(0xa8) << 8) | (((0xa8 << 1) ^ (((0xa8>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x51) ^ 0x51)) << 24) | ((uint)(0x51) << 16) | ((uint)(0x51) << 8) | (((0x51 << 1) ^ (((0x51>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xa3) ^ 0xa3)) << 24) | ((uint)(0xa3) << 16) | ((uint)(0xa3) << 8) | (((0xa3 << 1) ^ (((0xa3>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x40) ^ 0x40)) << 24) | ((uint)(0x40) << 16) | ((uint)(0x40) << 8) | (((0x40 << 1) ^ (((0x40>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x8f) ^ 0x8f)) << 24) | ((uint)(0x8f) << 16) | ((uint)(0x8f) << 8) | (((0x8f << 1) ^ (((0x8f>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x92) ^ 0x92)) << 24) | ((uint)(0x92) << 16) | ((uint)(0x92) << 8) | (((0x92 << 1) ^ (((0x92>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x9d) ^ 0x9d)) << 24) | ((uint)(0x9d) << 16) | ((uint)(0x9d) << 8) | (((0x9d << 1) ^ (((0x9d>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x38) ^ 0x38)) << 24) | ((uint)(0x38) << 16) | ((uint)(0x38) << 8) | (((0x38 << 1) ^ (((0x38>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xf5) ^ 0xf5)) << 24) | ((uint)(0xf5) << 16) | ((uint)(0xf5) << 8) | (((0xf5 << 1) ^ (((0xf5>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xbc) ^ 0xbc)) << 24) | ((uint)(0xbc) << 16) | ((uint)(0xbc) << 8) | (((0xbc << 1) ^ (((0xbc>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xb6) ^ 0xb6)) << 24) | ((uint)(0xb6) << 16) | ((uint)(0xb6) << 8) | (((0xb6 << 1) ^ (((0xb6>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xda) ^ 0xda)) << 24) | ((uint)(0xda) << 16) | ((uint)(0xda) << 8) | (((0xda << 1) ^ (((0xda>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x21) ^ 0x21)) << 24) | ((uint)(0x21) << 16) | ((uint)(0x21) << 8) | (((0x21 << 1) ^ (((0x21>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x10) ^ 0x10)) << 24) | ((uint)(0x10) << 16) | ((uint)(0x10) << 8) | (((0x10 << 1) ^ (((0x10>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xff) ^ 0xff)) << 24) | ((uint)(0xff) << 16) | ((uint)(0xff) << 8) | (((0xff << 1) ^ (((0xff>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xf3) ^ 0xf3)) << 24) | ((uint)(0xf3) << 16) | ((uint)(0xf3) << 8) | (((0xf3 << 1) ^ (((0xf3>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xd2) ^ 0xd2)) << 24) | ((uint)(0xd2) << 16) | ((uint)(0xd2) << 8) | (((0xd2 << 1) ^ (((0xd2>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xcd) ^ 0xcd)) << 24) | ((uint)(0xcd) << 16) | ((uint)(0xcd) << 8) | (((0xcd << 1) ^ (((0xcd>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x0c) ^ 0x0c)) << 24) | ((uint)(0x0c) << 16) | ((uint)(0x0c) << 8) | (((0x0c << 1) ^ (((0x0c>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x13) ^ 0x13)) << 24) | ((uint)(0x13) << 16) | ((uint)(0x13) << 8) | (((0x13 << 1) ^ (((0x13>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xec) ^ 0xec)) << 24) | ((uint)(0xec) << 16) | ((uint)(0xec) << 8) | (((0xec << 1) ^ (((0xec>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x5f) ^ 0x5f)) << 24) | ((uint)(0x5f) << 16) | ((uint)(0x5f) << 8) | (((0x5f << 1) ^ (((0x5f>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x97) ^ 0x97)) << 24) | ((uint)(0x97) << 16) | ((uint)(0x97) << 8) | (((0x97 << 1) ^ (((0x97>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x44) ^ 0x44)) << 24) | ((uint)(0x44) << 16) | ((uint)(0x44) << 8) | (((0x44 << 1) ^ (((0x44>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x17) ^ 0x17)) << 24) | ((uint)(0x17) << 16) | ((uint)(0x17) << 8) | (((0x17 << 1) ^ (((0x17>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xc4) ^ 0xc4)) << 24) | ((uint)(0xc4) << 16) | ((uint)(0xc4) << 8) | (((0xc4 << 1) ^ (((0xc4>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xa7) ^ 0xa7)) << 24) | ((uint)(0xa7) << 16) | ((uint)(0xa7) << 8) | (((0xa7 << 1) ^ (((0xa7>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x7e) ^ 0x7e)) << 24) | ((uint)(0x7e) << 16) | ((uint)(0x7e) << 8) | (((0x7e << 1) ^ (((0x7e>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x3d) ^ 0x3d)) << 24) | ((uint)(0x3d) << 16) | ((uint)(0x3d) << 8) | (((0x3d << 1) ^ (((0x3d>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x64) ^ 0x64)) << 24) | ((uint)(0x64) << 16) | ((uint)(0x64) << 8) | (((0x64 << 1) ^ (((0x64>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x5d) ^ 0x5d)) << 24) | ((uint)(0x5d) << 16) | ((uint)(0x5d) << 8) | (((0x5d << 1) ^ (((0x5d>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x19) ^ 0x19)) << 24) | ((uint)(0x19) << 16) | ((uint)(0x19) << 8) | (((0x19 << 1) ^ (((0x19>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x73) ^ 0x73)) << 24) | ((uint)(0x73) << 16) | ((uint)(0x73) << 8) | (((0x73 << 1) ^ (((0x73>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x60) ^ 0x60)) << 24) | ((uint)(0x60) << 16) | ((uint)(0x60) << 8) | (((0x60 << 1) ^ (((0x60>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x81) ^ 0x81)) << 24) | ((uint)(0x81) << 16) | ((uint)(0x81) << 8) | (((0x81 << 1) ^ (((0x81>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x4f) ^ 0x4f)) << 24) | ((uint)(0x4f) << 16) | ((uint)(0x4f) << 8) | (((0x4f << 1) ^ (((0x4f>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xdc) ^ 0xdc)) << 24) | ((uint)(0xdc) << 16) | ((uint)(0xdc) << 8) | (((0xdc << 1) ^ (((0xdc>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x22) ^ 0x22)) << 24) | ((uint)(0x22) << 16) | ((uint)(0x22) << 8) | (((0x22 << 1) ^ (((0x22>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x2a) ^ 0x2a)) << 24) | ((uint)(0x2a) << 16) | ((uint)(0x2a) << 8) | (((0x2a << 1) ^ (((0x2a>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x90) ^ 0x90)) << 24) | ((uint)(0x90) << 16) | ((uint)(0x90) << 8) | (((0x90 << 1) ^ (((0x90>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x88) ^ 0x88)) << 24) | ((uint)(0x88) << 16) | ((uint)(0x88) << 8) | (((0x88 << 1) ^ (((0x88>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x46) ^ 0x46)) << 24) | ((uint)(0x46) << 16) | ((uint)(0x46) << 8) | (((0x46 << 1) ^ (((0x46>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xee) ^ 0xee)) << 24) | ((uint)(0xee) << 16) | ((uint)(0xee) << 8) | (((0xee << 1) ^ (((0xee>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xb8) ^ 0xb8)) << 24) | ((uint)(0xb8) << 16) | ((uint)(0xb8) << 8) | (((0xb8 << 1) ^ (((0xb8>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x14) ^ 0x14)) << 24) | ((uint)(0x14) << 16) | ((uint)(0x14) << 8) | (((0x14 << 1) ^ (((0x14>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xde) ^ 0xde)) << 24) | ((uint)(0xde) << 16) | ((uint)(0xde) << 8) | (((0xde << 1) ^ (((0xde>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x5e) ^ 0x5e)) << 24) | ((uint)(0x5e) << 16) | ((uint)(0x5e) << 8) | (((0x5e << 1) ^ (((0x5e>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x0b) ^ 0x0b)) << 24) | ((uint)(0x0b) << 16) | ((uint)(0x0b) << 8) | (((0x0b << 1) ^ (((0x0b>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xdb) ^ 0xdb)) << 24) | ((uint)(0xdb) << 16) | ((uint)(0xdb) << 8) | (((0xdb << 1) ^ (((0xdb>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xe0) ^ 0xe0)) << 24) | ((uint)(0xe0) << 16) | ((uint)(0xe0) << 8) | (((0xe0 << 1) ^ (((0xe0>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x32) ^ 0x32)) << 24) | ((uint)(0x32) << 16) | ((uint)(0x32) << 8) | (((0x32 << 1) ^ (((0x32>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x3a) ^ 0x3a)) << 24) | ((uint)(0x3a) << 16) | ((uint)(0x3a) << 8) | (((0x3a << 1) ^ (((0x3a>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x0a) ^ 0x0a)) << 24) | ((uint)(0x0a) << 16) | ((uint)(0x0a) << 8) | (((0x0a << 1) ^ (((0x0a>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x49) ^ 0x49)) << 24) | ((uint)(0x49) << 16) | ((uint)(0x49) << 8) | (((0x49 << 1) ^ (((0x49>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x06) ^ 0x06)) << 24) | ((uint)(0x06) << 16) | ((uint)(0x06) << 8) | (((0x06 << 1) ^ (((0x06>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x24) ^ 0x24)) << 24) | ((uint)(0x24) << 16) | ((uint)(0x24) << 8) | (((0x24 << 1) ^ (((0x24>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x5c) ^ 0x5c)) << 24) | ((uint)(0x5c) << 16) | ((uint)(0x5c) << 8) | (((0x5c << 1) ^ (((0x5c>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xc2) ^ 0xc2)) << 24) | ((uint)(0xc2) << 16) | ((uint)(0xc2) << 8) | (((0xc2 << 1) ^ (((0xc2>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xd3) ^ 0xd3)) << 24) | ((uint)(0xd3) << 16) | ((uint)(0xd3) << 8) | (((0xd3 << 1) ^ (((0xd3>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xac) ^ 0xac)) << 24) | ((uint)(0xac) << 16) | ((uint)(0xac) << 8) | (((0xac << 1) ^ (((0xac>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x62) ^ 0x62)) << 24) | ((uint)(0x62) << 16) | ((uint)(0x62) << 8) | (((0x62 << 1) ^ (((0x62>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x91) ^ 0x91)) << 24) | ((uint)(0x91) << 16) | ((uint)(0x91) << 8) | (((0x91 << 1) ^ (((0x91>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x95) ^ 0x95)) << 24) | ((uint)(0x95) << 16) | ((uint)(0x95) << 8) | (((0x95 << 1) ^ (((0x95>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xe4) ^ 0xe4)) << 24) | ((uint)(0xe4) << 16) | ((uint)(0xe4) << 8) | (((0xe4 << 1) ^ (((0xe4>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x79) ^ 0x79)) << 24) | ((uint)(0x79) << 16) | ((uint)(0x79) << 8) | (((0x79 << 1) ^ (((0x79>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xe7) ^ 0xe7)) << 24) | ((uint)(0xe7) << 16) | ((uint)(0xe7) << 8) | (((0xe7 << 1) ^ (((0xe7>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xc8) ^ 0xc8)) << 24) | ((uint)(0xc8) << 16) | ((uint)(0xc8) << 8) | (((0xc8 << 1) ^ (((0xc8>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x37) ^ 0x37)) << 24) | ((uint)(0x37) << 16) | ((uint)(0x37) << 8) | (((0x37 << 1) ^ (((0x37>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x6d) ^ 0x6d)) << 24) | ((uint)(0x6d) << 16) | ((uint)(0x6d) << 8) | (((0x6d << 1) ^ (((0x6d>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x8d) ^ 0x8d)) << 24) | ((uint)(0x8d) << 16) | ((uint)(0x8d) << 8) | (((0x8d << 1) ^ (((0x8d>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xd5) ^ 0xd5)) << 24) | ((uint)(0xd5) << 16) | ((uint)(0xd5) << 8) | (((0xd5 << 1) ^ (((0xd5>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x4e) ^ 0x4e)) << 24) | ((uint)(0x4e) << 16) | ((uint)(0x4e) << 8) | (((0x4e << 1) ^ (((0x4e>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xa9) ^ 0xa9)) << 24) | ((uint)(0xa9) << 16) | ((uint)(0xa9) << 8) | (((0xa9 << 1) ^ (((0xa9>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x6c) ^ 0x6c)) << 24) | ((uint)(0x6c) << 16) | ((uint)(0x6c) << 8) | (((0x6c << 1) ^ (((0x6c>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x56) ^ 0x56)) << 24) | ((uint)(0x56) << 16) | ((uint)(0x56) << 8) | (((0x56 << 1) ^ (((0x56>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xf4) ^ 0xf4)) << 24) | ((uint)(0xf4) << 16) | ((uint)(0xf4) << 8) | (((0xf4 << 1) ^ (((0xf4>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xea) ^ 0xea)) << 24) | ((uint)(0xea) << 16) | ((uint)(0xea) << 8) | (((0xea << 1) ^ (((0xea>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x65) ^ 0x65)) << 24) | ((uint)(0x65) << 16) | ((uint)(0x65) << 8) | (((0x65 << 1) ^ (((0x65>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x7a) ^ 0x7a)) << 24) | ((uint)(0x7a) << 16) | ((uint)(0x7a) << 8) | (((0x7a << 1) ^ (((0x7a>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xae) ^ 0xae)) << 24) | ((uint)(0xae) << 16) | ((uint)(0xae) << 8) | (((0xae << 1) ^ (((0xae>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x08) ^ 0x08)) << 24) | ((uint)(0x08) << 16) | ((uint)(0x08) << 8) | (((0x08 << 1) ^ (((0x08>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xba) ^ 0xba)) << 24) | ((uint)(0xba) << 16) | ((uint)(0xba) << 8) | (((0xba << 1) ^ (((0xba>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x78) ^ 0x78)) << 24) | ((uint)(0x78) << 16) | ((uint)(0x78) << 8) | (((0x78 << 1) ^ (((0x78>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x25) ^ 0x25)) << 24) | ((uint)(0x25) << 16) | ((uint)(0x25) << 8) | (((0x25 << 1) ^ (((0x25>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x2e) ^ 0x2e)) << 24) | ((uint)(0x2e) << 16) | ((uint)(0x2e) << 8) | (((0x2e << 1) ^ (((0x2e>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x1c) ^ 0x1c)) << 24) | ((uint)(0x1c) << 16) | ((uint)(0x1c) << 8) | (((0x1c << 1) ^ (((0x1c>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xa6) ^ 0xa6)) << 24) | ((uint)(0xa6) << 16) | ((uint)(0xa6) << 8) | (((0xa6 << 1) ^ (((0xa6>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xb4) ^ 0xb4)) << 24) | ((uint)(0xb4) << 16) | ((uint)(0xb4) << 8) | (((0xb4 << 1) ^ (((0xb4>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xc6) ^ 0xc6)) << 24) | ((uint)(0xc6) << 16) | ((uint)(0xc6) << 8) | (((0xc6 << 1) ^ (((0xc6>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xe8) ^ 0xe8)) << 24) | ((uint)(0xe8) << 16) | ((uint)(0xe8) << 8) | (((0xe8 << 1) ^ (((0xe8>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xdd) ^ 0xdd)) << 24) | ((uint)(0xdd) << 16) | ((uint)(0xdd) << 8) | (((0xdd << 1) ^ (((0xdd>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x74) ^ 0x74)) << 24) | ((uint)(0x74) << 16) | ((uint)(0x74) << 8) | (((0x74 << 1) ^ (((0x74>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x1f) ^ 0x1f)) << 24) | ((uint)(0x1f) << 16) | ((uint)(0x1f) << 8) | (((0x1f << 1) ^ (((0x1f>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x4b) ^ 0x4b)) << 24) | ((uint)(0x4b) << 16) | ((uint)(0x4b) << 8) | (((0x4b << 1) ^ (((0x4b>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xbd) ^ 0xbd)) << 24) | ((uint)(0xbd) << 16) | ((uint)(0xbd) << 8) | (((0xbd << 1) ^ (((0xbd>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x8b) ^ 0x8b)) << 24) | ((uint)(0x8b) << 16) | ((uint)(0x8b) << 8) | (((0x8b << 1) ^ (((0x8b>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x8a) ^ 0x8a)) << 24) | ((uint)(0x8a) << 16) | ((uint)(0x8a) << 8) | (((0x8a << 1) ^ (((0x8a>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x70) ^ 0x70)) << 24) | ((uint)(0x70) << 16) | ((uint)(0x70) << 8) | (((0x70 << 1) ^ (((0x70>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x3e) ^ 0x3e)) << 24) | ((uint)(0x3e) << 16) | ((uint)(0x3e) << 8) | (((0x3e << 1) ^ (((0x3e>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xb5) ^ 0xb5)) << 24) | ((uint)(0xb5) << 16) | ((uint)(0xb5) << 8) | (((0xb5 << 1) ^ (((0xb5>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x66) ^ 0x66)) << 24) | ((uint)(0x66) << 16) | ((uint)(0x66) << 8) | (((0x66 << 1) ^ (((0x66>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x48) ^ 0x48)) << 24) | ((uint)(0x48) << 16) | ((uint)(0x48) << 8) | (((0x48 << 1) ^ (((0x48>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x03) ^ 0x03)) << 24) | ((uint)(0x03) << 16) | ((uint)(0x03) << 8) | (((0x03 << 1) ^ (((0x03>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xf6) ^ 0xf6)) << 24) | ((uint)(0xf6) << 16) | ((uint)(0xf6) << 8) | (((0xf6 << 1) ^ (((0xf6>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x0e) ^ 0x0e)) << 24) | ((uint)(0x0e) << 16) | ((uint)(0x0e) << 8) | (((0x0e << 1) ^ (((0x0e>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x61) ^ 0x61)) << 24) | ((uint)(0x61) << 16) | ((uint)(0x61) << 8) | (((0x61 << 1) ^ (((0x61>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x35) ^ 0x35)) << 24) | ((uint)(0x35) << 16) | ((uint)(0x35) << 8) | (((0x35 << 1) ^ (((0x35>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x57) ^ 0x57)) << 24) | ((uint)(0x57) << 16) | ((uint)(0x57) << 8) | (((0x57 << 1) ^ (((0x57>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xb9) ^ 0xb9)) << 24) | ((uint)(0xb9) << 16) | ((uint)(0xb9) << 8) | (((0xb9 << 1) ^ (((0xb9>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x86) ^ 0x86)) << 24) | ((uint)(0x86) << 16) | ((uint)(0x86) << 8) | (((0x86 << 1) ^ (((0x86>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xc1) ^ 0xc1)) << 24) | ((uint)(0xc1) << 16) | ((uint)(0xc1) << 8) | (((0xc1 << 1) ^ (((0xc1>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x1d) ^ 0x1d)) << 24) | ((uint)(0x1d) << 16) | ((uint)(0x1d) << 8) | (((0x1d << 1) ^ (((0x1d>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x9e) ^ 0x9e)) << 24) | ((uint)(0x9e) << 16) | ((uint)(0x9e) << 8) | (((0x9e << 1) ^ (((0x9e>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xe1) ^ 0xe1)) << 24) | ((uint)(0xe1) << 16) | ((uint)(0xe1) << 8) | (((0xe1 << 1) ^ (((0xe1>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xf8) ^ 0xf8)) << 24) | ((uint)(0xf8) << 16) | ((uint)(0xf8) << 8) | (((0xf8 << 1) ^ (((0xf8>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x98) ^ 0x98)) << 24) | ((uint)(0x98) << 16) | ((uint)(0x98) << 8) | (((0x98 << 1) ^ (((0x98>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x11) ^ 0x11)) << 24) | ((uint)(0x11) << 16) | ((uint)(0x11) << 8) | (((0x11 << 1) ^ (((0x11>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x69) ^ 0x69)) << 24) | ((uint)(0x69) << 16) | ((uint)(0x69) << 8) | (((0x69 << 1) ^ (((0x69>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xd9) ^ 0xd9)) << 24) | ((uint)(0xd9) << 16) | ((uint)(0xd9) << 8) | (((0xd9 << 1) ^ (((0xd9>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x8e) ^ 0x8e)) << 24) | ((uint)(0x8e) << 16) | ((uint)(0x8e) << 8) | (((0x8e << 1) ^ (((0x8e>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x94) ^ 0x94)) << 24) | ((uint)(0x94) << 16) | ((uint)(0x94) << 8) | (((0x94 << 1) ^ (((0x94>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x9b) ^ 0x9b)) << 24) | ((uint)(0x9b) << 16) | ((uint)(0x9b) << 8) | (((0x9b << 1) ^ (((0x9b>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x1e) ^ 0x1e)) << 24) | ((uint)(0x1e) << 16) | ((uint)(0x1e) << 8) | (((0x1e << 1) ^ (((0x1e>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x87) ^ 0x87)) << 24) | ((uint)(0x87) << 16) | ((uint)(0x87) << 8) | (((0x87 << 1) ^ (((0x87>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xe9) ^ 0xe9)) << 24) | ((uint)(0xe9) << 16) | ((uint)(0xe9) << 8) | (((0xe9 << 1) ^ (((0xe9>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xce) ^ 0xce)) << 24) | ((uint)(0xce) << 16) | ((uint)(0xce) << 8) | (((0xce << 1) ^ (((0xce>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x55) ^ 0x55)) << 24) | ((uint)(0x55) << 16) | ((uint)(0x55) << 8) | (((0x55 << 1) ^ (((0x55>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x28) ^ 0x28)) << 24) | ((uint)(0x28) << 16) | ((uint)(0x28) << 8) | (((0x28 << 1) ^ (((0x28>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xdf) ^ 0xdf)) << 24) | ((uint)(0xdf) << 16) | ((uint)(0xdf) << 8) | (((0xdf << 1) ^ (((0xdf>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x8c) ^ 0x8c)) << 24) | ((uint)(0x8c) << 16) | ((uint)(0x8c) << 8) | (((0x8c << 1) ^ (((0x8c>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xa1) ^ 0xa1)) << 24) | ((uint)(0xa1) << 16) | ((uint)(0xa1) << 8) | (((0xa1 << 1) ^ (((0xa1>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x89) ^ 0x89)) << 24) | ((uint)(0x89) << 16) | ((uint)(0x89) << 8) | (((0x89 << 1) ^ (((0x89>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x0d) ^ 0x0d)) << 24) | ((uint)(0x0d) << 16) | ((uint)(0x0d) << 8) | (((0x0d << 1) ^ (((0x0d>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xbf) ^ 0xbf)) << 24) | ((uint)(0xbf) << 16) | ((uint)(0xbf) << 8) | (((0xbf << 1) ^ (((0xbf>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xe6) ^ 0xe6)) << 24) | ((uint)(0xe6) << 16) | ((uint)(0xe6) << 8) | (((0xe6 << 1) ^ (((0xe6>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x42) ^ 0x42)) << 24) | ((uint)(0x42) << 16) | ((uint)(0x42) << 8) | (((0x42 << 1) ^ (((0x42>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x68) ^ 0x68)) << 24) | ((uint)(0x68) << 16) | ((uint)(0x68) << 8) | (((0x68 << 1) ^ (((0x68>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x41) ^ 0x41)) << 24) | ((uint)(0x41) << 16) | ((uint)(0x41) << 8) | (((0x41 << 1) ^ (((0x41>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x99) ^ 0x99)) << 24) | ((uint)(0x99) << 16) | ((uint)(0x99) << 8) | (((0x99 << 1) ^ (((0x99>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x2d) ^ 0x2d)) << 24) | ((uint)(0x2d) << 16) | ((uint)(0x2d) << 8) | (((0x2d << 1) ^ (((0x2d>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x0f) ^ 0x0f)) << 24) | ((uint)(0x0f) << 16) | ((uint)(0x0f) << 8) | (((0x0f << 1) ^ (((0x0f>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xb0) ^ 0xb0)) << 24) | ((uint)(0xb0) << 16) | ((uint)(0xb0) << 8) | (((0xb0 << 1) ^ (((0xb0>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x54) ^ 0x54)) << 24) | ((uint)(0x54) << 16) | ((uint)(0x54) << 8) | (((0x54 << 1) ^ (((0x54>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0xbb) ^ 0xbb)) << 24) | ((uint)(0xbb) << 16) | ((uint)(0xbb) << 8) | (((0xbb << 1) ^ (((0xbb>>7) & 1) * DefineConstants.WPOLY)))), (((uint)((f2(0x16) ^ 0x16)) << 24) | ((uint)(0x16) << 16) | ((uint)(0x16) << 8) | (((0x16 << 1) ^ (((0x16>>7) & 1) * DefineConstants.WPOLY))))},
		{(((uint)(0x63) << 24) | ((uint)(0x63) << 16) | ((uint)(((0x63 << 1) ^ (((0x63>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x63) ^ 0x63))), (((uint)(0x7c) << 24) | ((uint)(0x7c) << 16) | ((uint)(((0x7c << 1) ^ (((0x7c>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x7c) ^ 0x7c))), (((uint)(0x77) << 24) | ((uint)(0x77) << 16) | ((uint)(((0x77 << 1) ^ (((0x77>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x77) ^ 0x77))), (((uint)(0x7b) << 24) | ((uint)(0x7b) << 16) | ((uint)(((0x7b << 1) ^ (((0x7b>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x7b) ^ 0x7b))), (((uint)(0xf2) << 24) | ((uint)(0xf2) << 16) | ((uint)(((0xf2 << 1) ^ (((0xf2>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xf2) ^ 0xf2))), (((uint)(0x6b) << 24) | ((uint)(0x6b) << 16) | ((uint)(((0x6b << 1) ^ (((0x6b>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x6b) ^ 0x6b))), (((uint)(0x6f) << 24) | ((uint)(0x6f) << 16) | ((uint)(((0x6f << 1) ^ (((0x6f>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x6f) ^ 0x6f))), (((uint)(0xc5) << 24) | ((uint)(0xc5) << 16) | ((uint)(((0xc5 << 1) ^ (((0xc5>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xc5) ^ 0xc5))), (((uint)(0x30) << 24) | ((uint)(0x30) << 16) | ((uint)(((0x30 << 1) ^ (((0x30>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x30) ^ 0x30))), (((uint)(0x01) << 24) | ((uint)(0x01) << 16) | ((uint)(((0x01 << 1) ^ (((0x01>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x01) ^ 0x01))), (((uint)(0x67) << 24) | ((uint)(0x67) << 16) | ((uint)(((0x67 << 1) ^ (((0x67>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x67) ^ 0x67))), (((uint)(0x2b) << 24) | ((uint)(0x2b) << 16) | ((uint)(((0x2b << 1) ^ (((0x2b>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x2b) ^ 0x2b))), (((uint)(0xfe) << 24) | ((uint)(0xfe) << 16) | ((uint)(((0xfe << 1) ^ (((0xfe>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xfe) ^ 0xfe))), (((uint)(0xd7) << 24) | ((uint)(0xd7) << 16) | ((uint)(((0xd7 << 1) ^ (((0xd7>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xd7) ^ 0xd7))), (((uint)(0xab) << 24) | ((uint)(0xab) << 16) | ((uint)(((0xab << 1) ^ (((0xab>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xab) ^ 0xab))), (((uint)(0x76) << 24) | ((uint)(0x76) << 16) | ((uint)(((0x76 << 1) ^ (((0x76>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x76) ^ 0x76))), (((uint)(0xca) << 24) | ((uint)(0xca) << 16) | ((uint)(((0xca << 1) ^ (((0xca>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xca) ^ 0xca))), (((uint)(0x82) << 24) | ((uint)(0x82) << 16) | ((uint)(((0x82 << 1) ^ (((0x82>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x82) ^ 0x82))), (((uint)(0xc9) << 24) | ((uint)(0xc9) << 16) | ((uint)(((0xc9 << 1) ^ (((0xc9>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xc9) ^ 0xc9))), (((uint)(0x7d) << 24) | ((uint)(0x7d) << 16) | ((uint)(((0x7d << 1) ^ (((0x7d>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x7d) ^ 0x7d))), (((uint)(0xfa) << 24) | ((uint)(0xfa) << 16) | ((uint)(((0xfa << 1) ^ (((0xfa>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xfa) ^ 0xfa))), (((uint)(0x59) << 24) | ((uint)(0x59) << 16) | ((uint)(((0x59 << 1) ^ (((0x59>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x59) ^ 0x59))), (((uint)(0x47) << 24) | ((uint)(0x47) << 16) | ((uint)(((0x47 << 1) ^ (((0x47>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x47) ^ 0x47))), (((uint)(0xf0) << 24) | ((uint)(0xf0) << 16) | ((uint)(((0xf0 << 1) ^ (((0xf0>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xf0) ^ 0xf0))), (((uint)(0xad) << 24) | ((uint)(0xad) << 16) | ((uint)(((0xad << 1) ^ (((0xad>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xad) ^ 0xad))), (((uint)(0xd4) << 24) | ((uint)(0xd4) << 16) | ((uint)(((0xd4 << 1) ^ (((0xd4>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xd4) ^ 0xd4))), (((uint)(0xa2) << 24) | ((uint)(0xa2) << 16) | ((uint)(((0xa2 << 1) ^ (((0xa2>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xa2) ^ 0xa2))), (((uint)(0xaf) << 24) | ((uint)(0xaf) << 16) | ((uint)(((0xaf << 1) ^ (((0xaf>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xaf) ^ 0xaf))), (((uint)(0x9c) << 24) | ((uint)(0x9c) << 16) | ((uint)(((0x9c << 1) ^ (((0x9c>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x9c) ^ 0x9c))), (((uint)(0xa4) << 24) | ((uint)(0xa4) << 16) | ((uint)(((0xa4 << 1) ^ (((0xa4>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xa4) ^ 0xa4))), (((uint)(0x72) << 24) | ((uint)(0x72) << 16) | ((uint)(((0x72 << 1) ^ (((0x72>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x72) ^ 0x72))), (((uint)(0xc0) << 24) | ((uint)(0xc0) << 16) | ((uint)(((0xc0 << 1) ^ (((0xc0>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xc0) ^ 0xc0))), (((uint)(0xb7) << 24) | ((uint)(0xb7) << 16) | ((uint)(((0xb7 << 1) ^ (((0xb7>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xb7) ^ 0xb7))), (((uint)(0xfd) << 24) | ((uint)(0xfd) << 16) | ((uint)(((0xfd << 1) ^ (((0xfd>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xfd) ^ 0xfd))), (((uint)(0x93) << 24) | ((uint)(0x93) << 16) | ((uint)(((0x93 << 1) ^ (((0x93>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x93) ^ 0x93))), (((uint)(0x26) << 24) | ((uint)(0x26) << 16) | ((uint)(((0x26 << 1) ^ (((0x26>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x26) ^ 0x26))), (((uint)(0x36) << 24) | ((uint)(0x36) << 16) | ((uint)(((0x36 << 1) ^ (((0x36>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x36) ^ 0x36))), (((uint)(0x3f) << 24) | ((uint)(0x3f) << 16) | ((uint)(((0x3f << 1) ^ (((0x3f>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x3f) ^ 0x3f))), (((uint)(0xf7) << 24) | ((uint)(0xf7) << 16) | ((uint)(((0xf7 << 1) ^ (((0xf7>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xf7) ^ 0xf7))), (((uint)(0xcc) << 24) | ((uint)(0xcc) << 16) | ((uint)(((0xcc << 1) ^ (((0xcc>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xcc) ^ 0xcc))), (((uint)(0x34) << 24) | ((uint)(0x34) << 16) | ((uint)(((0x34 << 1) ^ (((0x34>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x34) ^ 0x34))), (((uint)(0xa5) << 24) | ((uint)(0xa5) << 16) | ((uint)(((0xa5 << 1) ^ (((0xa5>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xa5) ^ 0xa5))), (((uint)(0xe5) << 24) | ((uint)(0xe5) << 16) | ((uint)(((0xe5 << 1) ^ (((0xe5>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xe5) ^ 0xe5))), (((uint)(0xf1) << 24) | ((uint)(0xf1) << 16) | ((uint)(((0xf1 << 1) ^ (((0xf1>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xf1) ^ 0xf1))), (((uint)(0x71) << 24) | ((uint)(0x71) << 16) | ((uint)(((0x71 << 1) ^ (((0x71>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x71) ^ 0x71))), (((uint)(0xd8) << 24) | ((uint)(0xd8) << 16) | ((uint)(((0xd8 << 1) ^ (((0xd8>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xd8) ^ 0xd8))), (((uint)(0x31) << 24) | ((uint)(0x31) << 16) | ((uint)(((0x31 << 1) ^ (((0x31>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x31) ^ 0x31))), (((uint)(0x15) << 24) | ((uint)(0x15) << 16) | ((uint)(((0x15 << 1) ^ (((0x15>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x15) ^ 0x15))), (((uint)(0x04) << 24) | ((uint)(0x04) << 16) | ((uint)(((0x04 << 1) ^ (((0x04>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x04) ^ 0x04))), (((uint)(0xc7) << 24) | ((uint)(0xc7) << 16) | ((uint)(((0xc7 << 1) ^ (((0xc7>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xc7) ^ 0xc7))), (((uint)(0x23) << 24) | ((uint)(0x23) << 16) | ((uint)(((0x23 << 1) ^ (((0x23>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x23) ^ 0x23))), (((uint)(0xc3) << 24) | ((uint)(0xc3) << 16) | ((uint)(((0xc3 << 1) ^ (((0xc3>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xc3) ^ 0xc3))), (((uint)(0x18) << 24) | ((uint)(0x18) << 16) | ((uint)(((0x18 << 1) ^ (((0x18>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x18) ^ 0x18))), (((uint)(0x96) << 24) | ((uint)(0x96) << 16) | ((uint)(((0x96 << 1) ^ (((0x96>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x96) ^ 0x96))), (((uint)(0x05) << 24) | ((uint)(0x05) << 16) | ((uint)(((0x05 << 1) ^ (((0x05>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x05) ^ 0x05))), (((uint)(0x9a) << 24) | ((uint)(0x9a) << 16) | ((uint)(((0x9a << 1) ^ (((0x9a>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x9a) ^ 0x9a))), (((uint)(0x07) << 24) | ((uint)(0x07) << 16) | ((uint)(((0x07 << 1) ^ (((0x07>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x07) ^ 0x07))), (((uint)(0x12) << 24) | ((uint)(0x12) << 16) | ((uint)(((0x12 << 1) ^ (((0x12>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x12) ^ 0x12))), (((uint)(0x80) << 24) | ((uint)(0x80) << 16) | ((uint)(((0x80 << 1) ^ (((0x80>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x80) ^ 0x80))), (((uint)(0xe2) << 24) | ((uint)(0xe2) << 16) | ((uint)(((0xe2 << 1) ^ (((0xe2>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xe2) ^ 0xe2))), (((uint)(0xeb) << 24) | ((uint)(0xeb) << 16) | ((uint)(((0xeb << 1) ^ (((0xeb>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xeb) ^ 0xeb))), (((uint)(0x27) << 24) | ((uint)(0x27) << 16) | ((uint)(((0x27 << 1) ^ (((0x27>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x27) ^ 0x27))), (((uint)(0xb2) << 24) | ((uint)(0xb2) << 16) | ((uint)(((0xb2 << 1) ^ (((0xb2>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xb2) ^ 0xb2))), (((uint)(0x75) << 24) | ((uint)(0x75) << 16) | ((uint)(((0x75 << 1) ^ (((0x75>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x75) ^ 0x75))), (((uint)(0x09) << 24) | ((uint)(0x09) << 16) | ((uint)(((0x09 << 1) ^ (((0x09>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x09) ^ 0x09))), (((uint)(0x83) << 24) | ((uint)(0x83) << 16) | ((uint)(((0x83 << 1) ^ (((0x83>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x83) ^ 0x83))), (((uint)(0x2c) << 24) | ((uint)(0x2c) << 16) | ((uint)(((0x2c << 1) ^ (((0x2c>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x2c) ^ 0x2c))), (((uint)(0x1a) << 24) | ((uint)(0x1a) << 16) | ((uint)(((0x1a << 1) ^ (((0x1a>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x1a) ^ 0x1a))), (((uint)(0x1b) << 24) | ((uint)(0x1b) << 16) | ((uint)(((0x1b << 1) ^ (((0x1b>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x1b) ^ 0x1b))), (((uint)(0x6e) << 24) | ((uint)(0x6e) << 16) | ((uint)(((0x6e << 1) ^ (((0x6e>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x6e) ^ 0x6e))), (((uint)(0x5a) << 24) | ((uint)(0x5a) << 16) | ((uint)(((0x5a << 1) ^ (((0x5a>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x5a) ^ 0x5a))), (((uint)(0xa0) << 24) | ((uint)(0xa0) << 16) | ((uint)(((0xa0 << 1) ^ (((0xa0>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xa0) ^ 0xa0))), (((uint)(0x52) << 24) | ((uint)(0x52) << 16) | ((uint)(((0x52 << 1) ^ (((0x52>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x52) ^ 0x52))), (((uint)(0x3b) << 24) | ((uint)(0x3b) << 16) | ((uint)(((0x3b << 1) ^ (((0x3b>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x3b) ^ 0x3b))), (((uint)(0xd6) << 24) | ((uint)(0xd6) << 16) | ((uint)(((0xd6 << 1) ^ (((0xd6>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xd6) ^ 0xd6))), (((uint)(0xb3) << 24) | ((uint)(0xb3) << 16) | ((uint)(((0xb3 << 1) ^ (((0xb3>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xb3) ^ 0xb3))), (((uint)(0x29) << 24) | ((uint)(0x29) << 16) | ((uint)(((0x29 << 1) ^ (((0x29>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x29) ^ 0x29))), (((uint)(0xe3) << 24) | ((uint)(0xe3) << 16) | ((uint)(((0xe3 << 1) ^ (((0xe3>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xe3) ^ 0xe3))), (((uint)(0x2f) << 24) | ((uint)(0x2f) << 16) | ((uint)(((0x2f << 1) ^ (((0x2f>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x2f) ^ 0x2f))), (((uint)(0x84) << 24) | ((uint)(0x84) << 16) | ((uint)(((0x84 << 1) ^ (((0x84>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x84) ^ 0x84))), (((uint)(0x53) << 24) | ((uint)(0x53) << 16) | ((uint)(((0x53 << 1) ^ (((0x53>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x53) ^ 0x53))), (((uint)(0xd1) << 24) | ((uint)(0xd1) << 16) | ((uint)(((0xd1 << 1) ^ (((0xd1>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xd1) ^ 0xd1))), (((uint)(0x00) << 24) | ((uint)(0x00) << 16) | ((uint)(((0x00 << 1) ^ (((0x00>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x00) ^ 0x00))), (((uint)(0xed) << 24) | ((uint)(0xed) << 16) | ((uint)(((0xed << 1) ^ (((0xed>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xed) ^ 0xed))), (((uint)(0x20) << 24) | ((uint)(0x20) << 16) | ((uint)(((0x20 << 1) ^ (((0x20>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x20) ^ 0x20))), (((uint)(0xfc) << 24) | ((uint)(0xfc) << 16) | ((uint)(((0xfc << 1) ^ (((0xfc>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xfc) ^ 0xfc))), (((uint)(0xb1) << 24) | ((uint)(0xb1) << 16) | ((uint)(((0xb1 << 1) ^ (((0xb1>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xb1) ^ 0xb1))), (((uint)(0x5b) << 24) | ((uint)(0x5b) << 16) | ((uint)(((0x5b << 1) ^ (((0x5b>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x5b) ^ 0x5b))), (((uint)(0x6a) << 24) | ((uint)(0x6a) << 16) | ((uint)(((0x6a << 1) ^ (((0x6a>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x6a) ^ 0x6a))), (((uint)(0xcb) << 24) | ((uint)(0xcb) << 16) | ((uint)(((0xcb << 1) ^ (((0xcb>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xcb) ^ 0xcb))), (((uint)(0xbe) << 24) | ((uint)(0xbe) << 16) | ((uint)(((0xbe << 1) ^ (((0xbe>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xbe) ^ 0xbe))), (((uint)(0x39) << 24) | ((uint)(0x39) << 16) | ((uint)(((0x39 << 1) ^ (((0x39>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x39) ^ 0x39))), (((uint)(0x4a) << 24) | ((uint)(0x4a) << 16) | ((uint)(((0x4a << 1) ^ (((0x4a>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x4a) ^ 0x4a))), (((uint)(0x4c) << 24) | ((uint)(0x4c) << 16) | ((uint)(((0x4c << 1) ^ (((0x4c>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x4c) ^ 0x4c))), (((uint)(0x58) << 24) | ((uint)(0x58) << 16) | ((uint)(((0x58 << 1) ^ (((0x58>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x58) ^ 0x58))), (((uint)(0xcf) << 24) | ((uint)(0xcf) << 16) | ((uint)(((0xcf << 1) ^ (((0xcf>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xcf) ^ 0xcf))), (((uint)(0xd0) << 24) | ((uint)(0xd0) << 16) | ((uint)(((0xd0 << 1) ^ (((0xd0>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xd0) ^ 0xd0))), (((uint)(0xef) << 24) | ((uint)(0xef) << 16) | ((uint)(((0xef << 1) ^ (((0xef>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xef) ^ 0xef))), (((uint)(0xaa) << 24) | ((uint)(0xaa) << 16) | ((uint)(((0xaa << 1) ^ (((0xaa>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xaa) ^ 0xaa))), (((uint)(0xfb) << 24) | ((uint)(0xfb) << 16) | ((uint)(((0xfb << 1) ^ (((0xfb>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xfb) ^ 0xfb))), (((uint)(0x43) << 24) | ((uint)(0x43) << 16) | ((uint)(((0x43 << 1) ^ (((0x43>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x43) ^ 0x43))), (((uint)(0x4d) << 24) | ((uint)(0x4d) << 16) | ((uint)(((0x4d << 1) ^ (((0x4d>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x4d) ^ 0x4d))), (((uint)(0x33) << 24) | ((uint)(0x33) << 16) | ((uint)(((0x33 << 1) ^ (((0x33>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x33) ^ 0x33))), (((uint)(0x85) << 24) | ((uint)(0x85) << 16) | ((uint)(((0x85 << 1) ^ (((0x85>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x85) ^ 0x85))), (((uint)(0x45) << 24) | ((uint)(0x45) << 16) | ((uint)(((0x45 << 1) ^ (((0x45>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x45) ^ 0x45))), (((uint)(0xf9) << 24) | ((uint)(0xf9) << 16) | ((uint)(((0xf9 << 1) ^ (((0xf9>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xf9) ^ 0xf9))), (((uint)(0x02) << 24) | ((uint)(0x02) << 16) | ((uint)(((0x02 << 1) ^ (((0x02>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x02) ^ 0x02))), (((uint)(0x7f) << 24) | ((uint)(0x7f) << 16) | ((uint)(((0x7f << 1) ^ (((0x7f>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x7f) ^ 0x7f))), (((uint)(0x50) << 24) | ((uint)(0x50) << 16) | ((uint)(((0x50 << 1) ^ (((0x50>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x50) ^ 0x50))), (((uint)(0x3c) << 24) | ((uint)(0x3c) << 16) | ((uint)(((0x3c << 1) ^ (((0x3c>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x3c) ^ 0x3c))), (((uint)(0x9f) << 24) | ((uint)(0x9f) << 16) | ((uint)(((0x9f << 1) ^ (((0x9f>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x9f) ^ 0x9f))), (((uint)(0xa8) << 24) | ((uint)(0xa8) << 16) | ((uint)(((0xa8 << 1) ^ (((0xa8>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xa8) ^ 0xa8))), (((uint)(0x51) << 24) | ((uint)(0x51) << 16) | ((uint)(((0x51 << 1) ^ (((0x51>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x51) ^ 0x51))), (((uint)(0xa3) << 24) | ((uint)(0xa3) << 16) | ((uint)(((0xa3 << 1) ^ (((0xa3>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xa3) ^ 0xa3))), (((uint)(0x40) << 24) | ((uint)(0x40) << 16) | ((uint)(((0x40 << 1) ^ (((0x40>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x40) ^ 0x40))), (((uint)(0x8f) << 24) | ((uint)(0x8f) << 16) | ((uint)(((0x8f << 1) ^ (((0x8f>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x8f) ^ 0x8f))), (((uint)(0x92) << 24) | ((uint)(0x92) << 16) | ((uint)(((0x92 << 1) ^ (((0x92>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x92) ^ 0x92))), (((uint)(0x9d) << 24) | ((uint)(0x9d) << 16) | ((uint)(((0x9d << 1) ^ (((0x9d>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x9d) ^ 0x9d))), (((uint)(0x38) << 24) | ((uint)(0x38) << 16) | ((uint)(((0x38 << 1) ^ (((0x38>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x38) ^ 0x38))), (((uint)(0xf5) << 24) | ((uint)(0xf5) << 16) | ((uint)(((0xf5 << 1) ^ (((0xf5>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xf5) ^ 0xf5))), (((uint)(0xbc) << 24) | ((uint)(0xbc) << 16) | ((uint)(((0xbc << 1) ^ (((0xbc>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xbc) ^ 0xbc))), (((uint)(0xb6) << 24) | ((uint)(0xb6) << 16) | ((uint)(((0xb6 << 1) ^ (((0xb6>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xb6) ^ 0xb6))), (((uint)(0xda) << 24) | ((uint)(0xda) << 16) | ((uint)(((0xda << 1) ^ (((0xda>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xda) ^ 0xda))), (((uint)(0x21) << 24) | ((uint)(0x21) << 16) | ((uint)(((0x21 << 1) ^ (((0x21>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x21) ^ 0x21))), (((uint)(0x10) << 24) | ((uint)(0x10) << 16) | ((uint)(((0x10 << 1) ^ (((0x10>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x10) ^ 0x10))), (((uint)(0xff) << 24) | ((uint)(0xff) << 16) | ((uint)(((0xff << 1) ^ (((0xff>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xff) ^ 0xff))), (((uint)(0xf3) << 24) | ((uint)(0xf3) << 16) | ((uint)(((0xf3 << 1) ^ (((0xf3>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xf3) ^ 0xf3))), (((uint)(0xd2) << 24) | ((uint)(0xd2) << 16) | ((uint)(((0xd2 << 1) ^ (((0xd2>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xd2) ^ 0xd2))), (((uint)(0xcd) << 24) | ((uint)(0xcd) << 16) | ((uint)(((0xcd << 1) ^ (((0xcd>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xcd) ^ 0xcd))), (((uint)(0x0c) << 24) | ((uint)(0x0c) << 16) | ((uint)(((0x0c << 1) ^ (((0x0c>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x0c) ^ 0x0c))), (((uint)(0x13) << 24) | ((uint)(0x13) << 16) | ((uint)(((0x13 << 1) ^ (((0x13>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x13) ^ 0x13))), (((uint)(0xec) << 24) | ((uint)(0xec) << 16) | ((uint)(((0xec << 1) ^ (((0xec>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xec) ^ 0xec))), (((uint)(0x5f) << 24) | ((uint)(0x5f) << 16) | ((uint)(((0x5f << 1) ^ (((0x5f>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x5f) ^ 0x5f))), (((uint)(0x97) << 24) | ((uint)(0x97) << 16) | ((uint)(((0x97 << 1) ^ (((0x97>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x97) ^ 0x97))), (((uint)(0x44) << 24) | ((uint)(0x44) << 16) | ((uint)(((0x44 << 1) ^ (((0x44>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x44) ^ 0x44))), (((uint)(0x17) << 24) | ((uint)(0x17) << 16) | ((uint)(((0x17 << 1) ^ (((0x17>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x17) ^ 0x17))), (((uint)(0xc4) << 24) | ((uint)(0xc4) << 16) | ((uint)(((0xc4 << 1) ^ (((0xc4>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xc4) ^ 0xc4))), (((uint)(0xa7) << 24) | ((uint)(0xa7) << 16) | ((uint)(((0xa7 << 1) ^ (((0xa7>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xa7) ^ 0xa7))), (((uint)(0x7e) << 24) | ((uint)(0x7e) << 16) | ((uint)(((0x7e << 1) ^ (((0x7e>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x7e) ^ 0x7e))), (((uint)(0x3d) << 24) | ((uint)(0x3d) << 16) | ((uint)(((0x3d << 1) ^ (((0x3d>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x3d) ^ 0x3d))), (((uint)(0x64) << 24) | ((uint)(0x64) << 16) | ((uint)(((0x64 << 1) ^ (((0x64>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x64) ^ 0x64))), (((uint)(0x5d) << 24) | ((uint)(0x5d) << 16) | ((uint)(((0x5d << 1) ^ (((0x5d>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x5d) ^ 0x5d))), (((uint)(0x19) << 24) | ((uint)(0x19) << 16) | ((uint)(((0x19 << 1) ^ (((0x19>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x19) ^ 0x19))), (((uint)(0x73) << 24) | ((uint)(0x73) << 16) | ((uint)(((0x73 << 1) ^ (((0x73>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x73) ^ 0x73))), (((uint)(0x60) << 24) | ((uint)(0x60) << 16) | ((uint)(((0x60 << 1) ^ (((0x60>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x60) ^ 0x60))), (((uint)(0x81) << 24) | ((uint)(0x81) << 16) | ((uint)(((0x81 << 1) ^ (((0x81>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x81) ^ 0x81))), (((uint)(0x4f) << 24) | ((uint)(0x4f) << 16) | ((uint)(((0x4f << 1) ^ (((0x4f>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x4f) ^ 0x4f))), (((uint)(0xdc) << 24) | ((uint)(0xdc) << 16) | ((uint)(((0xdc << 1) ^ (((0xdc>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xdc) ^ 0xdc))), (((uint)(0x22) << 24) | ((uint)(0x22) << 16) | ((uint)(((0x22 << 1) ^ (((0x22>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x22) ^ 0x22))), (((uint)(0x2a) << 24) | ((uint)(0x2a) << 16) | ((uint)(((0x2a << 1) ^ (((0x2a>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x2a) ^ 0x2a))), (((uint)(0x90) << 24) | ((uint)(0x90) << 16) | ((uint)(((0x90 << 1) ^ (((0x90>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x90) ^ 0x90))), (((uint)(0x88) << 24) | ((uint)(0x88) << 16) | ((uint)(((0x88 << 1) ^ (((0x88>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x88) ^ 0x88))), (((uint)(0x46) << 24) | ((uint)(0x46) << 16) | ((uint)(((0x46 << 1) ^ (((0x46>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x46) ^ 0x46))), (((uint)(0xee) << 24) | ((uint)(0xee) << 16) | ((uint)(((0xee << 1) ^ (((0xee>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xee) ^ 0xee))), (((uint)(0xb8) << 24) | ((uint)(0xb8) << 16) | ((uint)(((0xb8 << 1) ^ (((0xb8>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xb8) ^ 0xb8))), (((uint)(0x14) << 24) | ((uint)(0x14) << 16) | ((uint)(((0x14 << 1) ^ (((0x14>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x14) ^ 0x14))), (((uint)(0xde) << 24) | ((uint)(0xde) << 16) | ((uint)(((0xde << 1) ^ (((0xde>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xde) ^ 0xde))), (((uint)(0x5e) << 24) | ((uint)(0x5e) << 16) | ((uint)(((0x5e << 1) ^ (((0x5e>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x5e) ^ 0x5e))), (((uint)(0x0b) << 24) | ((uint)(0x0b) << 16) | ((uint)(((0x0b << 1) ^ (((0x0b>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x0b) ^ 0x0b))), (((uint)(0xdb) << 24) | ((uint)(0xdb) << 16) | ((uint)(((0xdb << 1) ^ (((0xdb>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xdb) ^ 0xdb))), (((uint)(0xe0) << 24) | ((uint)(0xe0) << 16) | ((uint)(((0xe0 << 1) ^ (((0xe0>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xe0) ^ 0xe0))), (((uint)(0x32) << 24) | ((uint)(0x32) << 16) | ((uint)(((0x32 << 1) ^ (((0x32>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x32) ^ 0x32))), (((uint)(0x3a) << 24) | ((uint)(0x3a) << 16) | ((uint)(((0x3a << 1) ^ (((0x3a>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x3a) ^ 0x3a))), (((uint)(0x0a) << 24) | ((uint)(0x0a) << 16) | ((uint)(((0x0a << 1) ^ (((0x0a>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x0a) ^ 0x0a))), (((uint)(0x49) << 24) | ((uint)(0x49) << 16) | ((uint)(((0x49 << 1) ^ (((0x49>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x49) ^ 0x49))), (((uint)(0x06) << 24) | ((uint)(0x06) << 16) | ((uint)(((0x06 << 1) ^ (((0x06>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x06) ^ 0x06))), (((uint)(0x24) << 24) | ((uint)(0x24) << 16) | ((uint)(((0x24 << 1) ^ (((0x24>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x24) ^ 0x24))), (((uint)(0x5c) << 24) | ((uint)(0x5c) << 16) | ((uint)(((0x5c << 1) ^ (((0x5c>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x5c) ^ 0x5c))), (((uint)(0xc2) << 24) | ((uint)(0xc2) << 16) | ((uint)(((0xc2 << 1) ^ (((0xc2>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xc2) ^ 0xc2))), (((uint)(0xd3) << 24) | ((uint)(0xd3) << 16) | ((uint)(((0xd3 << 1) ^ (((0xd3>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xd3) ^ 0xd3))), (((uint)(0xac) << 24) | ((uint)(0xac) << 16) | ((uint)(((0xac << 1) ^ (((0xac>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xac) ^ 0xac))), (((uint)(0x62) << 24) | ((uint)(0x62) << 16) | ((uint)(((0x62 << 1) ^ (((0x62>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x62) ^ 0x62))), (((uint)(0x91) << 24) | ((uint)(0x91) << 16) | ((uint)(((0x91 << 1) ^ (((0x91>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x91) ^ 0x91))), (((uint)(0x95) << 24) | ((uint)(0x95) << 16) | ((uint)(((0x95 << 1) ^ (((0x95>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x95) ^ 0x95))), (((uint)(0xe4) << 24) | ((uint)(0xe4) << 16) | ((uint)(((0xe4 << 1) ^ (((0xe4>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xe4) ^ 0xe4))), (((uint)(0x79) << 24) | ((uint)(0x79) << 16) | ((uint)(((0x79 << 1) ^ (((0x79>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x79) ^ 0x79))), (((uint)(0xe7) << 24) | ((uint)(0xe7) << 16) | ((uint)(((0xe7 << 1) ^ (((0xe7>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xe7) ^ 0xe7))), (((uint)(0xc8) << 24) | ((uint)(0xc8) << 16) | ((uint)(((0xc8 << 1) ^ (((0xc8>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xc8) ^ 0xc8))), (((uint)(0x37) << 24) | ((uint)(0x37) << 16) | ((uint)(((0x37 << 1) ^ (((0x37>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x37) ^ 0x37))), (((uint)(0x6d) << 24) | ((uint)(0x6d) << 16) | ((uint)(((0x6d << 1) ^ (((0x6d>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x6d) ^ 0x6d))), (((uint)(0x8d) << 24) | ((uint)(0x8d) << 16) | ((uint)(((0x8d << 1) ^ (((0x8d>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x8d) ^ 0x8d))), (((uint)(0xd5) << 24) | ((uint)(0xd5) << 16) | ((uint)(((0xd5 << 1) ^ (((0xd5>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xd5) ^ 0xd5))), (((uint)(0x4e) << 24) | ((uint)(0x4e) << 16) | ((uint)(((0x4e << 1) ^ (((0x4e>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x4e) ^ 0x4e))), (((uint)(0xa9) << 24) | ((uint)(0xa9) << 16) | ((uint)(((0xa9 << 1) ^ (((0xa9>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xa9) ^ 0xa9))), (((uint)(0x6c) << 24) | ((uint)(0x6c) << 16) | ((uint)(((0x6c << 1) ^ (((0x6c>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x6c) ^ 0x6c))), (((uint)(0x56) << 24) | ((uint)(0x56) << 16) | ((uint)(((0x56 << 1) ^ (((0x56>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x56) ^ 0x56))), (((uint)(0xf4) << 24) | ((uint)(0xf4) << 16) | ((uint)(((0xf4 << 1) ^ (((0xf4>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xf4) ^ 0xf4))), (((uint)(0xea) << 24) | ((uint)(0xea) << 16) | ((uint)(((0xea << 1) ^ (((0xea>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xea) ^ 0xea))), (((uint)(0x65) << 24) | ((uint)(0x65) << 16) | ((uint)(((0x65 << 1) ^ (((0x65>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x65) ^ 0x65))), (((uint)(0x7a) << 24) | ((uint)(0x7a) << 16) | ((uint)(((0x7a << 1) ^ (((0x7a>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x7a) ^ 0x7a))), (((uint)(0xae) << 24) | ((uint)(0xae) << 16) | ((uint)(((0xae << 1) ^ (((0xae>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xae) ^ 0xae))), (((uint)(0x08) << 24) | ((uint)(0x08) << 16) | ((uint)(((0x08 << 1) ^ (((0x08>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x08) ^ 0x08))), (((uint)(0xba) << 24) | ((uint)(0xba) << 16) | ((uint)(((0xba << 1) ^ (((0xba>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xba) ^ 0xba))), (((uint)(0x78) << 24) | ((uint)(0x78) << 16) | ((uint)(((0x78 << 1) ^ (((0x78>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x78) ^ 0x78))), (((uint)(0x25) << 24) | ((uint)(0x25) << 16) | ((uint)(((0x25 << 1) ^ (((0x25>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x25) ^ 0x25))), (((uint)(0x2e) << 24) | ((uint)(0x2e) << 16) | ((uint)(((0x2e << 1) ^ (((0x2e>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x2e) ^ 0x2e))), (((uint)(0x1c) << 24) | ((uint)(0x1c) << 16) | ((uint)(((0x1c << 1) ^ (((0x1c>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x1c) ^ 0x1c))), (((uint)(0xa6) << 24) | ((uint)(0xa6) << 16) | ((uint)(((0xa6 << 1) ^ (((0xa6>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xa6) ^ 0xa6))), (((uint)(0xb4) << 24) | ((uint)(0xb4) << 16) | ((uint)(((0xb4 << 1) ^ (((0xb4>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xb4) ^ 0xb4))), (((uint)(0xc6) << 24) | ((uint)(0xc6) << 16) | ((uint)(((0xc6 << 1) ^ (((0xc6>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xc6) ^ 0xc6))), (((uint)(0xe8) << 24) | ((uint)(0xe8) << 16) | ((uint)(((0xe8 << 1) ^ (((0xe8>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xe8) ^ 0xe8))), (((uint)(0xdd) << 24) | ((uint)(0xdd) << 16) | ((uint)(((0xdd << 1) ^ (((0xdd>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xdd) ^ 0xdd))), (((uint)(0x74) << 24) | ((uint)(0x74) << 16) | ((uint)(((0x74 << 1) ^ (((0x74>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x74) ^ 0x74))), (((uint)(0x1f) << 24) | ((uint)(0x1f) << 16) | ((uint)(((0x1f << 1) ^ (((0x1f>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x1f) ^ 0x1f))), (((uint)(0x4b) << 24) | ((uint)(0x4b) << 16) | ((uint)(((0x4b << 1) ^ (((0x4b>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x4b) ^ 0x4b))), (((uint)(0xbd) << 24) | ((uint)(0xbd) << 16) | ((uint)(((0xbd << 1) ^ (((0xbd>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xbd) ^ 0xbd))), (((uint)(0x8b) << 24) | ((uint)(0x8b) << 16) | ((uint)(((0x8b << 1) ^ (((0x8b>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x8b) ^ 0x8b))), (((uint)(0x8a) << 24) | ((uint)(0x8a) << 16) | ((uint)(((0x8a << 1) ^ (((0x8a>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x8a) ^ 0x8a))), (((uint)(0x70) << 24) | ((uint)(0x70) << 16) | ((uint)(((0x70 << 1) ^ (((0x70>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x70) ^ 0x70))), (((uint)(0x3e) << 24) | ((uint)(0x3e) << 16) | ((uint)(((0x3e << 1) ^ (((0x3e>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x3e) ^ 0x3e))), (((uint)(0xb5) << 24) | ((uint)(0xb5) << 16) | ((uint)(((0xb5 << 1) ^ (((0xb5>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xb5) ^ 0xb5))), (((uint)(0x66) << 24) | ((uint)(0x66) << 16) | ((uint)(((0x66 << 1) ^ (((0x66>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x66) ^ 0x66))), (((uint)(0x48) << 24) | ((uint)(0x48) << 16) | ((uint)(((0x48 << 1) ^ (((0x48>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x48) ^ 0x48))), (((uint)(0x03) << 24) | ((uint)(0x03) << 16) | ((uint)(((0x03 << 1) ^ (((0x03>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x03) ^ 0x03))), (((uint)(0xf6) << 24) | ((uint)(0xf6) << 16) | ((uint)(((0xf6 << 1) ^ (((0xf6>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xf6) ^ 0xf6))), (((uint)(0x0e) << 24) | ((uint)(0x0e) << 16) | ((uint)(((0x0e << 1) ^ (((0x0e>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x0e) ^ 0x0e))), (((uint)(0x61) << 24) | ((uint)(0x61) << 16) | ((uint)(((0x61 << 1) ^ (((0x61>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x61) ^ 0x61))), (((uint)(0x35) << 24) | ((uint)(0x35) << 16) | ((uint)(((0x35 << 1) ^ (((0x35>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x35) ^ 0x35))), (((uint)(0x57) << 24) | ((uint)(0x57) << 16) | ((uint)(((0x57 << 1) ^ (((0x57>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x57) ^ 0x57))), (((uint)(0xb9) << 24) | ((uint)(0xb9) << 16) | ((uint)(((0xb9 << 1) ^ (((0xb9>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xb9) ^ 0xb9))), (((uint)(0x86) << 24) | ((uint)(0x86) << 16) | ((uint)(((0x86 << 1) ^ (((0x86>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x86) ^ 0x86))), (((uint)(0xc1) << 24) | ((uint)(0xc1) << 16) | ((uint)(((0xc1 << 1) ^ (((0xc1>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xc1) ^ 0xc1))), (((uint)(0x1d) << 24) | ((uint)(0x1d) << 16) | ((uint)(((0x1d << 1) ^ (((0x1d>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x1d) ^ 0x1d))), (((uint)(0x9e) << 24) | ((uint)(0x9e) << 16) | ((uint)(((0x9e << 1) ^ (((0x9e>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x9e) ^ 0x9e))), (((uint)(0xe1) << 24) | ((uint)(0xe1) << 16) | ((uint)(((0xe1 << 1) ^ (((0xe1>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xe1) ^ 0xe1))), (((uint)(0xf8) << 24) | ((uint)(0xf8) << 16) | ((uint)(((0xf8 << 1) ^ (((0xf8>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xf8) ^ 0xf8))), (((uint)(0x98) << 24) | ((uint)(0x98) << 16) | ((uint)(((0x98 << 1) ^ (((0x98>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x98) ^ 0x98))), (((uint)(0x11) << 24) | ((uint)(0x11) << 16) | ((uint)(((0x11 << 1) ^ (((0x11>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x11) ^ 0x11))), (((uint)(0x69) << 24) | ((uint)(0x69) << 16) | ((uint)(((0x69 << 1) ^ (((0x69>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x69) ^ 0x69))), (((uint)(0xd9) << 24) | ((uint)(0xd9) << 16) | ((uint)(((0xd9 << 1) ^ (((0xd9>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xd9) ^ 0xd9))), (((uint)(0x8e) << 24) | ((uint)(0x8e) << 16) | ((uint)(((0x8e << 1) ^ (((0x8e>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x8e) ^ 0x8e))), (((uint)(0x94) << 24) | ((uint)(0x94) << 16) | ((uint)(((0x94 << 1) ^ (((0x94>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x94) ^ 0x94))), (((uint)(0x9b) << 24) | ((uint)(0x9b) << 16) | ((uint)(((0x9b << 1) ^ (((0x9b>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x9b) ^ 0x9b))), (((uint)(0x1e) << 24) | ((uint)(0x1e) << 16) | ((uint)(((0x1e << 1) ^ (((0x1e>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x1e) ^ 0x1e))), (((uint)(0x87) << 24) | ((uint)(0x87) << 16) | ((uint)(((0x87 << 1) ^ (((0x87>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x87) ^ 0x87))), (((uint)(0xe9) << 24) | ((uint)(0xe9) << 16) | ((uint)(((0xe9 << 1) ^ (((0xe9>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xe9) ^ 0xe9))), (((uint)(0xce) << 24) | ((uint)(0xce) << 16) | ((uint)(((0xce << 1) ^ (((0xce>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xce) ^ 0xce))), (((uint)(0x55) << 24) | ((uint)(0x55) << 16) | ((uint)(((0x55 << 1) ^ (((0x55>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x55) ^ 0x55))), (((uint)(0x28) << 24) | ((uint)(0x28) << 16) | ((uint)(((0x28 << 1) ^ (((0x28>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x28) ^ 0x28))), (((uint)(0xdf) << 24) | ((uint)(0xdf) << 16) | ((uint)(((0xdf << 1) ^ (((0xdf>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xdf) ^ 0xdf))), (((uint)(0x8c) << 24) | ((uint)(0x8c) << 16) | ((uint)(((0x8c << 1) ^ (((0x8c>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x8c) ^ 0x8c))), (((uint)(0xa1) << 24) | ((uint)(0xa1) << 16) | ((uint)(((0xa1 << 1) ^ (((0xa1>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xa1) ^ 0xa1))), (((uint)(0x89) << 24) | ((uint)(0x89) << 16) | ((uint)(((0x89 << 1) ^ (((0x89>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x89) ^ 0x89))), (((uint)(0x0d) << 24) | ((uint)(0x0d) << 16) | ((uint)(((0x0d << 1) ^ (((0x0d>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x0d) ^ 0x0d))), (((uint)(0xbf) << 24) | ((uint)(0xbf) << 16) | ((uint)(((0xbf << 1) ^ (((0xbf>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xbf) ^ 0xbf))), (((uint)(0xe6) << 24) | ((uint)(0xe6) << 16) | ((uint)(((0xe6 << 1) ^ (((0xe6>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xe6) ^ 0xe6))), (((uint)(0x42) << 24) | ((uint)(0x42) << 16) | ((uint)(((0x42 << 1) ^ (((0x42>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x42) ^ 0x42))), (((uint)(0x68) << 24) | ((uint)(0x68) << 16) | ((uint)(((0x68 << 1) ^ (((0x68>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x68) ^ 0x68))), (((uint)(0x41) << 24) | ((uint)(0x41) << 16) | ((uint)(((0x41 << 1) ^ (((0x41>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x41) ^ 0x41))), (((uint)(0x99) << 24) | ((uint)(0x99) << 16) | ((uint)(((0x99 << 1) ^ (((0x99>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x99) ^ 0x99))), (((uint)(0x2d) << 24) | ((uint)(0x2d) << 16) | ((uint)(((0x2d << 1) ^ (((0x2d>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x2d) ^ 0x2d))), (((uint)(0x0f) << 24) | ((uint)(0x0f) << 16) | ((uint)(((0x0f << 1) ^ (((0x0f>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x0f) ^ 0x0f))), (((uint)(0xb0) << 24) | ((uint)(0xb0) << 16) | ((uint)(((0xb0 << 1) ^ (((0xb0>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xb0) ^ 0xb0))), (((uint)(0x54) << 24) | ((uint)(0x54) << 16) | ((uint)(((0x54 << 1) ^ (((0x54>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x54) ^ 0x54))), (((uint)(0xbb) << 24) | ((uint)(0xbb) << 16) | ((uint)(((0xbb << 1) ^ (((0xbb>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0xbb) ^ 0xbb))), (((uint)(0x16) << 24) | ((uint)(0x16) << 16) | ((uint)(((0x16 << 1) ^ (((0x16>>7) & 1) * DefineConstants.WPOLY))) << 8) | ((f2(0x16) ^ 0x16)))},
		{(((uint)(0x63) << 24) | ((uint)(((0x63 << 1) ^ (((0x63>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x63) ^ 0x63)) << 8) | (0x63)), (((uint)(0x7c) << 24) | ((uint)(((0x7c << 1) ^ (((0x7c>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x7c) ^ 0x7c)) << 8) | (0x7c)), (((uint)(0x77) << 24) | ((uint)(((0x77 << 1) ^ (((0x77>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x77) ^ 0x77)) << 8) | (0x77)), (((uint)(0x7b) << 24) | ((uint)(((0x7b << 1) ^ (((0x7b>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x7b) ^ 0x7b)) << 8) | (0x7b)), (((uint)(0xf2) << 24) | ((uint)(((0xf2 << 1) ^ (((0xf2>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xf2) ^ 0xf2)) << 8) | (0xf2)), (((uint)(0x6b) << 24) | ((uint)(((0x6b << 1) ^ (((0x6b>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x6b) ^ 0x6b)) << 8) | (0x6b)), (((uint)(0x6f) << 24) | ((uint)(((0x6f << 1) ^ (((0x6f>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x6f) ^ 0x6f)) << 8) | (0x6f)), (((uint)(0xc5) << 24) | ((uint)(((0xc5 << 1) ^ (((0xc5>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xc5) ^ 0xc5)) << 8) | (0xc5)), (((uint)(0x30) << 24) | ((uint)(((0x30 << 1) ^ (((0x30>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x30) ^ 0x30)) << 8) | (0x30)), (((uint)(0x01) << 24) | ((uint)(((0x01 << 1) ^ (((0x01>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x01) ^ 0x01)) << 8) | (0x01)), (((uint)(0x67) << 24) | ((uint)(((0x67 << 1) ^ (((0x67>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x67) ^ 0x67)) << 8) | (0x67)), (((uint)(0x2b) << 24) | ((uint)(((0x2b << 1) ^ (((0x2b>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x2b) ^ 0x2b)) << 8) | (0x2b)), (((uint)(0xfe) << 24) | ((uint)(((0xfe << 1) ^ (((0xfe>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xfe) ^ 0xfe)) << 8) | (0xfe)), (((uint)(0xd7) << 24) | ((uint)(((0xd7 << 1) ^ (((0xd7>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xd7) ^ 0xd7)) << 8) | (0xd7)), (((uint)(0xab) << 24) | ((uint)(((0xab << 1) ^ (((0xab>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xab) ^ 0xab)) << 8) | (0xab)), (((uint)(0x76) << 24) | ((uint)(((0x76 << 1) ^ (((0x76>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x76) ^ 0x76)) << 8) | (0x76)), (((uint)(0xca) << 24) | ((uint)(((0xca << 1) ^ (((0xca>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xca) ^ 0xca)) << 8) | (0xca)), (((uint)(0x82) << 24) | ((uint)(((0x82 << 1) ^ (((0x82>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x82) ^ 0x82)) << 8) | (0x82)), (((uint)(0xc9) << 24) | ((uint)(((0xc9 << 1) ^ (((0xc9>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xc9) ^ 0xc9)) << 8) | (0xc9)), (((uint)(0x7d) << 24) | ((uint)(((0x7d << 1) ^ (((0x7d>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x7d) ^ 0x7d)) << 8) | (0x7d)), (((uint)(0xfa) << 24) | ((uint)(((0xfa << 1) ^ (((0xfa>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xfa) ^ 0xfa)) << 8) | (0xfa)), (((uint)(0x59) << 24) | ((uint)(((0x59 << 1) ^ (((0x59>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x59) ^ 0x59)) << 8) | (0x59)), (((uint)(0x47) << 24) | ((uint)(((0x47 << 1) ^ (((0x47>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x47) ^ 0x47)) << 8) | (0x47)), (((uint)(0xf0) << 24) | ((uint)(((0xf0 << 1) ^ (((0xf0>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xf0) ^ 0xf0)) << 8) | (0xf0)), (((uint)(0xad) << 24) | ((uint)(((0xad << 1) ^ (((0xad>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xad) ^ 0xad)) << 8) | (0xad)), (((uint)(0xd4) << 24) | ((uint)(((0xd4 << 1) ^ (((0xd4>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xd4) ^ 0xd4)) << 8) | (0xd4)), (((uint)(0xa2) << 24) | ((uint)(((0xa2 << 1) ^ (((0xa2>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xa2) ^ 0xa2)) << 8) | (0xa2)), (((uint)(0xaf) << 24) | ((uint)(((0xaf << 1) ^ (((0xaf>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xaf) ^ 0xaf)) << 8) | (0xaf)), (((uint)(0x9c) << 24) | ((uint)(((0x9c << 1) ^ (((0x9c>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x9c) ^ 0x9c)) << 8) | (0x9c)), (((uint)(0xa4) << 24) | ((uint)(((0xa4 << 1) ^ (((0xa4>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xa4) ^ 0xa4)) << 8) | (0xa4)), (((uint)(0x72) << 24) | ((uint)(((0x72 << 1) ^ (((0x72>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x72) ^ 0x72)) << 8) | (0x72)), (((uint)(0xc0) << 24) | ((uint)(((0xc0 << 1) ^ (((0xc0>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xc0) ^ 0xc0)) << 8) | (0xc0)), (((uint)(0xb7) << 24) | ((uint)(((0xb7 << 1) ^ (((0xb7>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xb7) ^ 0xb7)) << 8) | (0xb7)), (((uint)(0xfd) << 24) | ((uint)(((0xfd << 1) ^ (((0xfd>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xfd) ^ 0xfd)) << 8) | (0xfd)), (((uint)(0x93) << 24) | ((uint)(((0x93 << 1) ^ (((0x93>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x93) ^ 0x93)) << 8) | (0x93)), (((uint)(0x26) << 24) | ((uint)(((0x26 << 1) ^ (((0x26>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x26) ^ 0x26)) << 8) | (0x26)), (((uint)(0x36) << 24) | ((uint)(((0x36 << 1) ^ (((0x36>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x36) ^ 0x36)) << 8) | (0x36)), (((uint)(0x3f) << 24) | ((uint)(((0x3f << 1) ^ (((0x3f>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x3f) ^ 0x3f)) << 8) | (0x3f)), (((uint)(0xf7) << 24) | ((uint)(((0xf7 << 1) ^ (((0xf7>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xf7) ^ 0xf7)) << 8) | (0xf7)), (((uint)(0xcc) << 24) | ((uint)(((0xcc << 1) ^ (((0xcc>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xcc) ^ 0xcc)) << 8) | (0xcc)), (((uint)(0x34) << 24) | ((uint)(((0x34 << 1) ^ (((0x34>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x34) ^ 0x34)) << 8) | (0x34)), (((uint)(0xa5) << 24) | ((uint)(((0xa5 << 1) ^ (((0xa5>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xa5) ^ 0xa5)) << 8) | (0xa5)), (((uint)(0xe5) << 24) | ((uint)(((0xe5 << 1) ^ (((0xe5>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xe5) ^ 0xe5)) << 8) | (0xe5)), (((uint)(0xf1) << 24) | ((uint)(((0xf1 << 1) ^ (((0xf1>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xf1) ^ 0xf1)) << 8) | (0xf1)), (((uint)(0x71) << 24) | ((uint)(((0x71 << 1) ^ (((0x71>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x71) ^ 0x71)) << 8) | (0x71)), (((uint)(0xd8) << 24) | ((uint)(((0xd8 << 1) ^ (((0xd8>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xd8) ^ 0xd8)) << 8) | (0xd8)), (((uint)(0x31) << 24) | ((uint)(((0x31 << 1) ^ (((0x31>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x31) ^ 0x31)) << 8) | (0x31)), (((uint)(0x15) << 24) | ((uint)(((0x15 << 1) ^ (((0x15>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x15) ^ 0x15)) << 8) | (0x15)), (((uint)(0x04) << 24) | ((uint)(((0x04 << 1) ^ (((0x04>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x04) ^ 0x04)) << 8) | (0x04)), (((uint)(0xc7) << 24) | ((uint)(((0xc7 << 1) ^ (((0xc7>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xc7) ^ 0xc7)) << 8) | (0xc7)), (((uint)(0x23) << 24) | ((uint)(((0x23 << 1) ^ (((0x23>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x23) ^ 0x23)) << 8) | (0x23)), (((uint)(0xc3) << 24) | ((uint)(((0xc3 << 1) ^ (((0xc3>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xc3) ^ 0xc3)) << 8) | (0xc3)), (((uint)(0x18) << 24) | ((uint)(((0x18 << 1) ^ (((0x18>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x18) ^ 0x18)) << 8) | (0x18)), (((uint)(0x96) << 24) | ((uint)(((0x96 << 1) ^ (((0x96>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x96) ^ 0x96)) << 8) | (0x96)), (((uint)(0x05) << 24) | ((uint)(((0x05 << 1) ^ (((0x05>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x05) ^ 0x05)) << 8) | (0x05)), (((uint)(0x9a) << 24) | ((uint)(((0x9a << 1) ^ (((0x9a>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x9a) ^ 0x9a)) << 8) | (0x9a)), (((uint)(0x07) << 24) | ((uint)(((0x07 << 1) ^ (((0x07>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x07) ^ 0x07)) << 8) | (0x07)), (((uint)(0x12) << 24) | ((uint)(((0x12 << 1) ^ (((0x12>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x12) ^ 0x12)) << 8) | (0x12)), (((uint)(0x80) << 24) | ((uint)(((0x80 << 1) ^ (((0x80>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x80) ^ 0x80)) << 8) | (0x80)), (((uint)(0xe2) << 24) | ((uint)(((0xe2 << 1) ^ (((0xe2>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xe2) ^ 0xe2)) << 8) | (0xe2)), (((uint)(0xeb) << 24) | ((uint)(((0xeb << 1) ^ (((0xeb>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xeb) ^ 0xeb)) << 8) | (0xeb)), (((uint)(0x27) << 24) | ((uint)(((0x27 << 1) ^ (((0x27>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x27) ^ 0x27)) << 8) | (0x27)), (((uint)(0xb2) << 24) | ((uint)(((0xb2 << 1) ^ (((0xb2>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xb2) ^ 0xb2)) << 8) | (0xb2)), (((uint)(0x75) << 24) | ((uint)(((0x75 << 1) ^ (((0x75>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x75) ^ 0x75)) << 8) | (0x75)), (((uint)(0x09) << 24) | ((uint)(((0x09 << 1) ^ (((0x09>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x09) ^ 0x09)) << 8) | (0x09)), (((uint)(0x83) << 24) | ((uint)(((0x83 << 1) ^ (((0x83>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x83) ^ 0x83)) << 8) | (0x83)), (((uint)(0x2c) << 24) | ((uint)(((0x2c << 1) ^ (((0x2c>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x2c) ^ 0x2c)) << 8) | (0x2c)), (((uint)(0x1a) << 24) | ((uint)(((0x1a << 1) ^ (((0x1a>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x1a) ^ 0x1a)) << 8) | (0x1a)), (((uint)(0x1b) << 24) | ((uint)(((0x1b << 1) ^ (((0x1b>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x1b) ^ 0x1b)) << 8) | (0x1b)), (((uint)(0x6e) << 24) | ((uint)(((0x6e << 1) ^ (((0x6e>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x6e) ^ 0x6e)) << 8) | (0x6e)), (((uint)(0x5a) << 24) | ((uint)(((0x5a << 1) ^ (((0x5a>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x5a) ^ 0x5a)) << 8) | (0x5a)), (((uint)(0xa0) << 24) | ((uint)(((0xa0 << 1) ^ (((0xa0>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xa0) ^ 0xa0)) << 8) | (0xa0)), (((uint)(0x52) << 24) | ((uint)(((0x52 << 1) ^ (((0x52>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x52) ^ 0x52)) << 8) | (0x52)), (((uint)(0x3b) << 24) | ((uint)(((0x3b << 1) ^ (((0x3b>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x3b) ^ 0x3b)) << 8) | (0x3b)), (((uint)(0xd6) << 24) | ((uint)(((0xd6 << 1) ^ (((0xd6>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xd6) ^ 0xd6)) << 8) | (0xd6)), (((uint)(0xb3) << 24) | ((uint)(((0xb3 << 1) ^ (((0xb3>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xb3) ^ 0xb3)) << 8) | (0xb3)), (((uint)(0x29) << 24) | ((uint)(((0x29 << 1) ^ (((0x29>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x29) ^ 0x29)) << 8) | (0x29)), (((uint)(0xe3) << 24) | ((uint)(((0xe3 << 1) ^ (((0xe3>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xe3) ^ 0xe3)) << 8) | (0xe3)), (((uint)(0x2f) << 24) | ((uint)(((0x2f << 1) ^ (((0x2f>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x2f) ^ 0x2f)) << 8) | (0x2f)), (((uint)(0x84) << 24) | ((uint)(((0x84 << 1) ^ (((0x84>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x84) ^ 0x84)) << 8) | (0x84)), (((uint)(0x53) << 24) | ((uint)(((0x53 << 1) ^ (((0x53>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x53) ^ 0x53)) << 8) | (0x53)), (((uint)(0xd1) << 24) | ((uint)(((0xd1 << 1) ^ (((0xd1>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xd1) ^ 0xd1)) << 8) | (0xd1)), (((uint)(0x00) << 24) | ((uint)(((0x00 << 1) ^ (((0x00>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x00) ^ 0x00)) << 8) | (0x00)), (((uint)(0xed) << 24) | ((uint)(((0xed << 1) ^ (((0xed>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xed) ^ 0xed)) << 8) | (0xed)), (((uint)(0x20) << 24) | ((uint)(((0x20 << 1) ^ (((0x20>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x20) ^ 0x20)) << 8) | (0x20)), (((uint)(0xfc) << 24) | ((uint)(((0xfc << 1) ^ (((0xfc>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xfc) ^ 0xfc)) << 8) | (0xfc)), (((uint)(0xb1) << 24) | ((uint)(((0xb1 << 1) ^ (((0xb1>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xb1) ^ 0xb1)) << 8) | (0xb1)), (((uint)(0x5b) << 24) | ((uint)(((0x5b << 1) ^ (((0x5b>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x5b) ^ 0x5b)) << 8) | (0x5b)), (((uint)(0x6a) << 24) | ((uint)(((0x6a << 1) ^ (((0x6a>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x6a) ^ 0x6a)) << 8) | (0x6a)), (((uint)(0xcb) << 24) | ((uint)(((0xcb << 1) ^ (((0xcb>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xcb) ^ 0xcb)) << 8) | (0xcb)), (((uint)(0xbe) << 24) | ((uint)(((0xbe << 1) ^ (((0xbe>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xbe) ^ 0xbe)) << 8) | (0xbe)), (((uint)(0x39) << 24) | ((uint)(((0x39 << 1) ^ (((0x39>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x39) ^ 0x39)) << 8) | (0x39)), (((uint)(0x4a) << 24) | ((uint)(((0x4a << 1) ^ (((0x4a>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x4a) ^ 0x4a)) << 8) | (0x4a)), (((uint)(0x4c) << 24) | ((uint)(((0x4c << 1) ^ (((0x4c>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x4c) ^ 0x4c)) << 8) | (0x4c)), (((uint)(0x58) << 24) | ((uint)(((0x58 << 1) ^ (((0x58>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x58) ^ 0x58)) << 8) | (0x58)), (((uint)(0xcf) << 24) | ((uint)(((0xcf << 1) ^ (((0xcf>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xcf) ^ 0xcf)) << 8) | (0xcf)), (((uint)(0xd0) << 24) | ((uint)(((0xd0 << 1) ^ (((0xd0>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xd0) ^ 0xd0)) << 8) | (0xd0)), (((uint)(0xef) << 24) | ((uint)(((0xef << 1) ^ (((0xef>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xef) ^ 0xef)) << 8) | (0xef)), (((uint)(0xaa) << 24) | ((uint)(((0xaa << 1) ^ (((0xaa>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xaa) ^ 0xaa)) << 8) | (0xaa)), (((uint)(0xfb) << 24) | ((uint)(((0xfb << 1) ^ (((0xfb>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xfb) ^ 0xfb)) << 8) | (0xfb)), (((uint)(0x43) << 24) | ((uint)(((0x43 << 1) ^ (((0x43>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x43) ^ 0x43)) << 8) | (0x43)), (((uint)(0x4d) << 24) | ((uint)(((0x4d << 1) ^ (((0x4d>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x4d) ^ 0x4d)) << 8) | (0x4d)), (((uint)(0x33) << 24) | ((uint)(((0x33 << 1) ^ (((0x33>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x33) ^ 0x33)) << 8) | (0x33)), (((uint)(0x85) << 24) | ((uint)(((0x85 << 1) ^ (((0x85>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x85) ^ 0x85)) << 8) | (0x85)), (((uint)(0x45) << 24) | ((uint)(((0x45 << 1) ^ (((0x45>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x45) ^ 0x45)) << 8) | (0x45)), (((uint)(0xf9) << 24) | ((uint)(((0xf9 << 1) ^ (((0xf9>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xf9) ^ 0xf9)) << 8) | (0xf9)), (((uint)(0x02) << 24) | ((uint)(((0x02 << 1) ^ (((0x02>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x02) ^ 0x02)) << 8) | (0x02)), (((uint)(0x7f) << 24) | ((uint)(((0x7f << 1) ^ (((0x7f>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x7f) ^ 0x7f)) << 8) | (0x7f)), (((uint)(0x50) << 24) | ((uint)(((0x50 << 1) ^ (((0x50>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x50) ^ 0x50)) << 8) | (0x50)), (((uint)(0x3c) << 24) | ((uint)(((0x3c << 1) ^ (((0x3c>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x3c) ^ 0x3c)) << 8) | (0x3c)), (((uint)(0x9f) << 24) | ((uint)(((0x9f << 1) ^ (((0x9f>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x9f) ^ 0x9f)) << 8) | (0x9f)), (((uint)(0xa8) << 24) | ((uint)(((0xa8 << 1) ^ (((0xa8>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xa8) ^ 0xa8)) << 8) | (0xa8)), (((uint)(0x51) << 24) | ((uint)(((0x51 << 1) ^ (((0x51>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x51) ^ 0x51)) << 8) | (0x51)), (((uint)(0xa3) << 24) | ((uint)(((0xa3 << 1) ^ (((0xa3>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xa3) ^ 0xa3)) << 8) | (0xa3)), (((uint)(0x40) << 24) | ((uint)(((0x40 << 1) ^ (((0x40>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x40) ^ 0x40)) << 8) | (0x40)), (((uint)(0x8f) << 24) | ((uint)(((0x8f << 1) ^ (((0x8f>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x8f) ^ 0x8f)) << 8) | (0x8f)), (((uint)(0x92) << 24) | ((uint)(((0x92 << 1) ^ (((0x92>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x92) ^ 0x92)) << 8) | (0x92)), (((uint)(0x9d) << 24) | ((uint)(((0x9d << 1) ^ (((0x9d>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x9d) ^ 0x9d)) << 8) | (0x9d)), (((uint)(0x38) << 24) | ((uint)(((0x38 << 1) ^ (((0x38>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x38) ^ 0x38)) << 8) | (0x38)), (((uint)(0xf5) << 24) | ((uint)(((0xf5 << 1) ^ (((0xf5>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xf5) ^ 0xf5)) << 8) | (0xf5)), (((uint)(0xbc) << 24) | ((uint)(((0xbc << 1) ^ (((0xbc>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xbc) ^ 0xbc)) << 8) | (0xbc)), (((uint)(0xb6) << 24) | ((uint)(((0xb6 << 1) ^ (((0xb6>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xb6) ^ 0xb6)) << 8) | (0xb6)), (((uint)(0xda) << 24) | ((uint)(((0xda << 1) ^ (((0xda>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xda) ^ 0xda)) << 8) | (0xda)), (((uint)(0x21) << 24) | ((uint)(((0x21 << 1) ^ (((0x21>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x21) ^ 0x21)) << 8) | (0x21)), (((uint)(0x10) << 24) | ((uint)(((0x10 << 1) ^ (((0x10>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x10) ^ 0x10)) << 8) | (0x10)), (((uint)(0xff) << 24) | ((uint)(((0xff << 1) ^ (((0xff>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xff) ^ 0xff)) << 8) | (0xff)), (((uint)(0xf3) << 24) | ((uint)(((0xf3 << 1) ^ (((0xf3>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xf3) ^ 0xf3)) << 8) | (0xf3)), (((uint)(0xd2) << 24) | ((uint)(((0xd2 << 1) ^ (((0xd2>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xd2) ^ 0xd2)) << 8) | (0xd2)), (((uint)(0xcd) << 24) | ((uint)(((0xcd << 1) ^ (((0xcd>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xcd) ^ 0xcd)) << 8) | (0xcd)), (((uint)(0x0c) << 24) | ((uint)(((0x0c << 1) ^ (((0x0c>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x0c) ^ 0x0c)) << 8) | (0x0c)), (((uint)(0x13) << 24) | ((uint)(((0x13 << 1) ^ (((0x13>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x13) ^ 0x13)) << 8) | (0x13)), (((uint)(0xec) << 24) | ((uint)(((0xec << 1) ^ (((0xec>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xec) ^ 0xec)) << 8) | (0xec)), (((uint)(0x5f) << 24) | ((uint)(((0x5f << 1) ^ (((0x5f>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x5f) ^ 0x5f)) << 8) | (0x5f)), (((uint)(0x97) << 24) | ((uint)(((0x97 << 1) ^ (((0x97>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x97) ^ 0x97)) << 8) | (0x97)), (((uint)(0x44) << 24) | ((uint)(((0x44 << 1) ^ (((0x44>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x44) ^ 0x44)) << 8) | (0x44)), (((uint)(0x17) << 24) | ((uint)(((0x17 << 1) ^ (((0x17>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x17) ^ 0x17)) << 8) | (0x17)), (((uint)(0xc4) << 24) | ((uint)(((0xc4 << 1) ^ (((0xc4>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xc4) ^ 0xc4)) << 8) | (0xc4)), (((uint)(0xa7) << 24) | ((uint)(((0xa7 << 1) ^ (((0xa7>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xa7) ^ 0xa7)) << 8) | (0xa7)), (((uint)(0x7e) << 24) | ((uint)(((0x7e << 1) ^ (((0x7e>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x7e) ^ 0x7e)) << 8) | (0x7e)), (((uint)(0x3d) << 24) | ((uint)(((0x3d << 1) ^ (((0x3d>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x3d) ^ 0x3d)) << 8) | (0x3d)), (((uint)(0x64) << 24) | ((uint)(((0x64 << 1) ^ (((0x64>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x64) ^ 0x64)) << 8) | (0x64)), (((uint)(0x5d) << 24) | ((uint)(((0x5d << 1) ^ (((0x5d>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x5d) ^ 0x5d)) << 8) | (0x5d)), (((uint)(0x19) << 24) | ((uint)(((0x19 << 1) ^ (((0x19>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x19) ^ 0x19)) << 8) | (0x19)), (((uint)(0x73) << 24) | ((uint)(((0x73 << 1) ^ (((0x73>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x73) ^ 0x73)) << 8) | (0x73)), (((uint)(0x60) << 24) | ((uint)(((0x60 << 1) ^ (((0x60>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x60) ^ 0x60)) << 8) | (0x60)), (((uint)(0x81) << 24) | ((uint)(((0x81 << 1) ^ (((0x81>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x81) ^ 0x81)) << 8) | (0x81)), (((uint)(0x4f) << 24) | ((uint)(((0x4f << 1) ^ (((0x4f>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x4f) ^ 0x4f)) << 8) | (0x4f)), (((uint)(0xdc) << 24) | ((uint)(((0xdc << 1) ^ (((0xdc>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xdc) ^ 0xdc)) << 8) | (0xdc)), (((uint)(0x22) << 24) | ((uint)(((0x22 << 1) ^ (((0x22>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x22) ^ 0x22)) << 8) | (0x22)), (((uint)(0x2a) << 24) | ((uint)(((0x2a << 1) ^ (((0x2a>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x2a) ^ 0x2a)) << 8) | (0x2a)), (((uint)(0x90) << 24) | ((uint)(((0x90 << 1) ^ (((0x90>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x90) ^ 0x90)) << 8) | (0x90)), (((uint)(0x88) << 24) | ((uint)(((0x88 << 1) ^ (((0x88>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x88) ^ 0x88)) << 8) | (0x88)), (((uint)(0x46) << 24) | ((uint)(((0x46 << 1) ^ (((0x46>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x46) ^ 0x46)) << 8) | (0x46)), (((uint)(0xee) << 24) | ((uint)(((0xee << 1) ^ (((0xee>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xee) ^ 0xee)) << 8) | (0xee)), (((uint)(0xb8) << 24) | ((uint)(((0xb8 << 1) ^ (((0xb8>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xb8) ^ 0xb8)) << 8) | (0xb8)), (((uint)(0x14) << 24) | ((uint)(((0x14 << 1) ^ (((0x14>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x14) ^ 0x14)) << 8) | (0x14)), (((uint)(0xde) << 24) | ((uint)(((0xde << 1) ^ (((0xde>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xde) ^ 0xde)) << 8) | (0xde)), (((uint)(0x5e) << 24) | ((uint)(((0x5e << 1) ^ (((0x5e>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x5e) ^ 0x5e)) << 8) | (0x5e)), (((uint)(0x0b) << 24) | ((uint)(((0x0b << 1) ^ (((0x0b>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x0b) ^ 0x0b)) << 8) | (0x0b)), (((uint)(0xdb) << 24) | ((uint)(((0xdb << 1) ^ (((0xdb>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xdb) ^ 0xdb)) << 8) | (0xdb)), (((uint)(0xe0) << 24) | ((uint)(((0xe0 << 1) ^ (((0xe0>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xe0) ^ 0xe0)) << 8) | (0xe0)), (((uint)(0x32) << 24) | ((uint)(((0x32 << 1) ^ (((0x32>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x32) ^ 0x32)) << 8) | (0x32)), (((uint)(0x3a) << 24) | ((uint)(((0x3a << 1) ^ (((0x3a>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x3a) ^ 0x3a)) << 8) | (0x3a)), (((uint)(0x0a) << 24) | ((uint)(((0x0a << 1) ^ (((0x0a>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x0a) ^ 0x0a)) << 8) | (0x0a)), (((uint)(0x49) << 24) | ((uint)(((0x49 << 1) ^ (((0x49>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x49) ^ 0x49)) << 8) | (0x49)), (((uint)(0x06) << 24) | ((uint)(((0x06 << 1) ^ (((0x06>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x06) ^ 0x06)) << 8) | (0x06)), (((uint)(0x24) << 24) | ((uint)(((0x24 << 1) ^ (((0x24>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x24) ^ 0x24)) << 8) | (0x24)), (((uint)(0x5c) << 24) | ((uint)(((0x5c << 1) ^ (((0x5c>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x5c) ^ 0x5c)) << 8) | (0x5c)), (((uint)(0xc2) << 24) | ((uint)(((0xc2 << 1) ^ (((0xc2>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xc2) ^ 0xc2)) << 8) | (0xc2)), (((uint)(0xd3) << 24) | ((uint)(((0xd3 << 1) ^ (((0xd3>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xd3) ^ 0xd3)) << 8) | (0xd3)), (((uint)(0xac) << 24) | ((uint)(((0xac << 1) ^ (((0xac>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xac) ^ 0xac)) << 8) | (0xac)), (((uint)(0x62) << 24) | ((uint)(((0x62 << 1) ^ (((0x62>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x62) ^ 0x62)) << 8) | (0x62)), (((uint)(0x91) << 24) | ((uint)(((0x91 << 1) ^ (((0x91>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x91) ^ 0x91)) << 8) | (0x91)), (((uint)(0x95) << 24) | ((uint)(((0x95 << 1) ^ (((0x95>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x95) ^ 0x95)) << 8) | (0x95)), (((uint)(0xe4) << 24) | ((uint)(((0xe4 << 1) ^ (((0xe4>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xe4) ^ 0xe4)) << 8) | (0xe4)), (((uint)(0x79) << 24) | ((uint)(((0x79 << 1) ^ (((0x79>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x79) ^ 0x79)) << 8) | (0x79)), (((uint)(0xe7) << 24) | ((uint)(((0xe7 << 1) ^ (((0xe7>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xe7) ^ 0xe7)) << 8) | (0xe7)), (((uint)(0xc8) << 24) | ((uint)(((0xc8 << 1) ^ (((0xc8>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xc8) ^ 0xc8)) << 8) | (0xc8)), (((uint)(0x37) << 24) | ((uint)(((0x37 << 1) ^ (((0x37>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x37) ^ 0x37)) << 8) | (0x37)), (((uint)(0x6d) << 24) | ((uint)(((0x6d << 1) ^ (((0x6d>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x6d) ^ 0x6d)) << 8) | (0x6d)), (((uint)(0x8d) << 24) | ((uint)(((0x8d << 1) ^ (((0x8d>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x8d) ^ 0x8d)) << 8) | (0x8d)), (((uint)(0xd5) << 24) | ((uint)(((0xd5 << 1) ^ (((0xd5>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xd5) ^ 0xd5)) << 8) | (0xd5)), (((uint)(0x4e) << 24) | ((uint)(((0x4e << 1) ^ (((0x4e>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x4e) ^ 0x4e)) << 8) | (0x4e)), (((uint)(0xa9) << 24) | ((uint)(((0xa9 << 1) ^ (((0xa9>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xa9) ^ 0xa9)) << 8) | (0xa9)), (((uint)(0x6c) << 24) | ((uint)(((0x6c << 1) ^ (((0x6c>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x6c) ^ 0x6c)) << 8) | (0x6c)), (((uint)(0x56) << 24) | ((uint)(((0x56 << 1) ^ (((0x56>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x56) ^ 0x56)) << 8) | (0x56)), (((uint)(0xf4) << 24) | ((uint)(((0xf4 << 1) ^ (((0xf4>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xf4) ^ 0xf4)) << 8) | (0xf4)), (((uint)(0xea) << 24) | ((uint)(((0xea << 1) ^ (((0xea>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xea) ^ 0xea)) << 8) | (0xea)), (((uint)(0x65) << 24) | ((uint)(((0x65 << 1) ^ (((0x65>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x65) ^ 0x65)) << 8) | (0x65)), (((uint)(0x7a) << 24) | ((uint)(((0x7a << 1) ^ (((0x7a>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x7a) ^ 0x7a)) << 8) | (0x7a)), (((uint)(0xae) << 24) | ((uint)(((0xae << 1) ^ (((0xae>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xae) ^ 0xae)) << 8) | (0xae)), (((uint)(0x08) << 24) | ((uint)(((0x08 << 1) ^ (((0x08>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x08) ^ 0x08)) << 8) | (0x08)), (((uint)(0xba) << 24) | ((uint)(((0xba << 1) ^ (((0xba>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xba) ^ 0xba)) << 8) | (0xba)), (((uint)(0x78) << 24) | ((uint)(((0x78 << 1) ^ (((0x78>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x78) ^ 0x78)) << 8) | (0x78)), (((uint)(0x25) << 24) | ((uint)(((0x25 << 1) ^ (((0x25>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x25) ^ 0x25)) << 8) | (0x25)), (((uint)(0x2e) << 24) | ((uint)(((0x2e << 1) ^ (((0x2e>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x2e) ^ 0x2e)) << 8) | (0x2e)), (((uint)(0x1c) << 24) | ((uint)(((0x1c << 1) ^ (((0x1c>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x1c) ^ 0x1c)) << 8) | (0x1c)), (((uint)(0xa6) << 24) | ((uint)(((0xa6 << 1) ^ (((0xa6>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xa6) ^ 0xa6)) << 8) | (0xa6)), (((uint)(0xb4) << 24) | ((uint)(((0xb4 << 1) ^ (((0xb4>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xb4) ^ 0xb4)) << 8) | (0xb4)), (((uint)(0xc6) << 24) | ((uint)(((0xc6 << 1) ^ (((0xc6>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xc6) ^ 0xc6)) << 8) | (0xc6)), (((uint)(0xe8) << 24) | ((uint)(((0xe8 << 1) ^ (((0xe8>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xe8) ^ 0xe8)) << 8) | (0xe8)), (((uint)(0xdd) << 24) | ((uint)(((0xdd << 1) ^ (((0xdd>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xdd) ^ 0xdd)) << 8) | (0xdd)), (((uint)(0x74) << 24) | ((uint)(((0x74 << 1) ^ (((0x74>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x74) ^ 0x74)) << 8) | (0x74)), (((uint)(0x1f) << 24) | ((uint)(((0x1f << 1) ^ (((0x1f>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x1f) ^ 0x1f)) << 8) | (0x1f)), (((uint)(0x4b) << 24) | ((uint)(((0x4b << 1) ^ (((0x4b>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x4b) ^ 0x4b)) << 8) | (0x4b)), (((uint)(0xbd) << 24) | ((uint)(((0xbd << 1) ^ (((0xbd>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xbd) ^ 0xbd)) << 8) | (0xbd)), (((uint)(0x8b) << 24) | ((uint)(((0x8b << 1) ^ (((0x8b>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x8b) ^ 0x8b)) << 8) | (0x8b)), (((uint)(0x8a) << 24) | ((uint)(((0x8a << 1) ^ (((0x8a>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x8a) ^ 0x8a)) << 8) | (0x8a)), (((uint)(0x70) << 24) | ((uint)(((0x70 << 1) ^ (((0x70>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x70) ^ 0x70)) << 8) | (0x70)), (((uint)(0x3e) << 24) | ((uint)(((0x3e << 1) ^ (((0x3e>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x3e) ^ 0x3e)) << 8) | (0x3e)), (((uint)(0xb5) << 24) | ((uint)(((0xb5 << 1) ^ (((0xb5>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xb5) ^ 0xb5)) << 8) | (0xb5)), (((uint)(0x66) << 24) | ((uint)(((0x66 << 1) ^ (((0x66>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x66) ^ 0x66)) << 8) | (0x66)), (((uint)(0x48) << 24) | ((uint)(((0x48 << 1) ^ (((0x48>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x48) ^ 0x48)) << 8) | (0x48)), (((uint)(0x03) << 24) | ((uint)(((0x03 << 1) ^ (((0x03>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x03) ^ 0x03)) << 8) | (0x03)), (((uint)(0xf6) << 24) | ((uint)(((0xf6 << 1) ^ (((0xf6>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xf6) ^ 0xf6)) << 8) | (0xf6)), (((uint)(0x0e) << 24) | ((uint)(((0x0e << 1) ^ (((0x0e>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x0e) ^ 0x0e)) << 8) | (0x0e)), (((uint)(0x61) << 24) | ((uint)(((0x61 << 1) ^ (((0x61>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x61) ^ 0x61)) << 8) | (0x61)), (((uint)(0x35) << 24) | ((uint)(((0x35 << 1) ^ (((0x35>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x35) ^ 0x35)) << 8) | (0x35)), (((uint)(0x57) << 24) | ((uint)(((0x57 << 1) ^ (((0x57>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x57) ^ 0x57)) << 8) | (0x57)), (((uint)(0xb9) << 24) | ((uint)(((0xb9 << 1) ^ (((0xb9>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xb9) ^ 0xb9)) << 8) | (0xb9)), (((uint)(0x86) << 24) | ((uint)(((0x86 << 1) ^ (((0x86>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x86) ^ 0x86)) << 8) | (0x86)), (((uint)(0xc1) << 24) | ((uint)(((0xc1 << 1) ^ (((0xc1>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xc1) ^ 0xc1)) << 8) | (0xc1)), (((uint)(0x1d) << 24) | ((uint)(((0x1d << 1) ^ (((0x1d>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x1d) ^ 0x1d)) << 8) | (0x1d)), (((uint)(0x9e) << 24) | ((uint)(((0x9e << 1) ^ (((0x9e>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x9e) ^ 0x9e)) << 8) | (0x9e)), (((uint)(0xe1) << 24) | ((uint)(((0xe1 << 1) ^ (((0xe1>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xe1) ^ 0xe1)) << 8) | (0xe1)), (((uint)(0xf8) << 24) | ((uint)(((0xf8 << 1) ^ (((0xf8>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xf8) ^ 0xf8)) << 8) | (0xf8)), (((uint)(0x98) << 24) | ((uint)(((0x98 << 1) ^ (((0x98>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x98) ^ 0x98)) << 8) | (0x98)), (((uint)(0x11) << 24) | ((uint)(((0x11 << 1) ^ (((0x11>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x11) ^ 0x11)) << 8) | (0x11)), (((uint)(0x69) << 24) | ((uint)(((0x69 << 1) ^ (((0x69>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x69) ^ 0x69)) << 8) | (0x69)), (((uint)(0xd9) << 24) | ((uint)(((0xd9 << 1) ^ (((0xd9>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xd9) ^ 0xd9)) << 8) | (0xd9)), (((uint)(0x8e) << 24) | ((uint)(((0x8e << 1) ^ (((0x8e>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x8e) ^ 0x8e)) << 8) | (0x8e)), (((uint)(0x94) << 24) | ((uint)(((0x94 << 1) ^ (((0x94>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x94) ^ 0x94)) << 8) | (0x94)), (((uint)(0x9b) << 24) | ((uint)(((0x9b << 1) ^ (((0x9b>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x9b) ^ 0x9b)) << 8) | (0x9b)), (((uint)(0x1e) << 24) | ((uint)(((0x1e << 1) ^ (((0x1e>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x1e) ^ 0x1e)) << 8) | (0x1e)), (((uint)(0x87) << 24) | ((uint)(((0x87 << 1) ^ (((0x87>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x87) ^ 0x87)) << 8) | (0x87)), (((uint)(0xe9) << 24) | ((uint)(((0xe9 << 1) ^ (((0xe9>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xe9) ^ 0xe9)) << 8) | (0xe9)), (((uint)(0xce) << 24) | ((uint)(((0xce << 1) ^ (((0xce>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xce) ^ 0xce)) << 8) | (0xce)), (((uint)(0x55) << 24) | ((uint)(((0x55 << 1) ^ (((0x55>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x55) ^ 0x55)) << 8) | (0x55)), (((uint)(0x28) << 24) | ((uint)(((0x28 << 1) ^ (((0x28>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x28) ^ 0x28)) << 8) | (0x28)), (((uint)(0xdf) << 24) | ((uint)(((0xdf << 1) ^ (((0xdf>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xdf) ^ 0xdf)) << 8) | (0xdf)), (((uint)(0x8c) << 24) | ((uint)(((0x8c << 1) ^ (((0x8c>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x8c) ^ 0x8c)) << 8) | (0x8c)), (((uint)(0xa1) << 24) | ((uint)(((0xa1 << 1) ^ (((0xa1>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xa1) ^ 0xa1)) << 8) | (0xa1)), (((uint)(0x89) << 24) | ((uint)(((0x89 << 1) ^ (((0x89>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x89) ^ 0x89)) << 8) | (0x89)), (((uint)(0x0d) << 24) | ((uint)(((0x0d << 1) ^ (((0x0d>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x0d) ^ 0x0d)) << 8) | (0x0d)), (((uint)(0xbf) << 24) | ((uint)(((0xbf << 1) ^ (((0xbf>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xbf) ^ 0xbf)) << 8) | (0xbf)), (((uint)(0xe6) << 24) | ((uint)(((0xe6 << 1) ^ (((0xe6>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xe6) ^ 0xe6)) << 8) | (0xe6)), (((uint)(0x42) << 24) | ((uint)(((0x42 << 1) ^ (((0x42>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x42) ^ 0x42)) << 8) | (0x42)), (((uint)(0x68) << 24) | ((uint)(((0x68 << 1) ^ (((0x68>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x68) ^ 0x68)) << 8) | (0x68)), (((uint)(0x41) << 24) | ((uint)(((0x41 << 1) ^ (((0x41>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x41) ^ 0x41)) << 8) | (0x41)), (((uint)(0x99) << 24) | ((uint)(((0x99 << 1) ^ (((0x99>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x99) ^ 0x99)) << 8) | (0x99)), (((uint)(0x2d) << 24) | ((uint)(((0x2d << 1) ^ (((0x2d>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x2d) ^ 0x2d)) << 8) | (0x2d)), (((uint)(0x0f) << 24) | ((uint)(((0x0f << 1) ^ (((0x0f>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x0f) ^ 0x0f)) << 8) | (0x0f)), (((uint)(0xb0) << 24) | ((uint)(((0xb0 << 1) ^ (((0xb0>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xb0) ^ 0xb0)) << 8) | (0xb0)), (((uint)(0x54) << 24) | ((uint)(((0x54 << 1) ^ (((0x54>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x54) ^ 0x54)) << 8) | (0x54)), (((uint)(0xbb) << 24) | ((uint)(((0xbb << 1) ^ (((0xbb>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0xbb) ^ 0xbb)) << 8) | (0xbb)), (((uint)(0x16) << 24) | ((uint)(((0x16 << 1) ^ (((0x16>>7) & 1) * DefineConstants.WPOLY))) << 16) | ((uint)((f2(0x16) ^ 0x16)) << 8) | (0x16))},
		{(((uint)(((0x63 << 1) ^ (((0x63>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x63) ^ 0x63)) << 16) | ((uint)(0x63) << 8) | (0x63)), (((uint)(((0x7c << 1) ^ (((0x7c>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x7c) ^ 0x7c)) << 16) | ((uint)(0x7c) << 8) | (0x7c)), (((uint)(((0x77 << 1) ^ (((0x77>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x77) ^ 0x77)) << 16) | ((uint)(0x77) << 8) | (0x77)), (((uint)(((0x7b << 1) ^ (((0x7b>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x7b) ^ 0x7b)) << 16) | ((uint)(0x7b) << 8) | (0x7b)), (((uint)(((0xf2 << 1) ^ (((0xf2>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xf2) ^ 0xf2)) << 16) | ((uint)(0xf2) << 8) | (0xf2)), (((uint)(((0x6b << 1) ^ (((0x6b>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x6b) ^ 0x6b)) << 16) | ((uint)(0x6b) << 8) | (0x6b)), (((uint)(((0x6f << 1) ^ (((0x6f>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x6f) ^ 0x6f)) << 16) | ((uint)(0x6f) << 8) | (0x6f)), (((uint)(((0xc5 << 1) ^ (((0xc5>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xc5) ^ 0xc5)) << 16) | ((uint)(0xc5) << 8) | (0xc5)), (((uint)(((0x30 << 1) ^ (((0x30>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x30) ^ 0x30)) << 16) | ((uint)(0x30) << 8) | (0x30)), (((uint)(((0x01 << 1) ^ (((0x01>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x01) ^ 0x01)) << 16) | ((uint)(0x01) << 8) | (0x01)), (((uint)(((0x67 << 1) ^ (((0x67>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x67) ^ 0x67)) << 16) | ((uint)(0x67) << 8) | (0x67)), (((uint)(((0x2b << 1) ^ (((0x2b>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x2b) ^ 0x2b)) << 16) | ((uint)(0x2b) << 8) | (0x2b)), (((uint)(((0xfe << 1) ^ (((0xfe>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xfe) ^ 0xfe)) << 16) | ((uint)(0xfe) << 8) | (0xfe)), (((uint)(((0xd7 << 1) ^ (((0xd7>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xd7) ^ 0xd7)) << 16) | ((uint)(0xd7) << 8) | (0xd7)), (((uint)(((0xab << 1) ^ (((0xab>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xab) ^ 0xab)) << 16) | ((uint)(0xab) << 8) | (0xab)), (((uint)(((0x76 << 1) ^ (((0x76>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x76) ^ 0x76)) << 16) | ((uint)(0x76) << 8) | (0x76)), (((uint)(((0xca << 1) ^ (((0xca>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xca) ^ 0xca)) << 16) | ((uint)(0xca) << 8) | (0xca)), (((uint)(((0x82 << 1) ^ (((0x82>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x82) ^ 0x82)) << 16) | ((uint)(0x82) << 8) | (0x82)), (((uint)(((0xc9 << 1) ^ (((0xc9>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xc9) ^ 0xc9)) << 16) | ((uint)(0xc9) << 8) | (0xc9)), (((uint)(((0x7d << 1) ^ (((0x7d>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x7d) ^ 0x7d)) << 16) | ((uint)(0x7d) << 8) | (0x7d)), (((uint)(((0xfa << 1) ^ (((0xfa>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xfa) ^ 0xfa)) << 16) | ((uint)(0xfa) << 8) | (0xfa)), (((uint)(((0x59 << 1) ^ (((0x59>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x59) ^ 0x59)) << 16) | ((uint)(0x59) << 8) | (0x59)), (((uint)(((0x47 << 1) ^ (((0x47>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x47) ^ 0x47)) << 16) | ((uint)(0x47) << 8) | (0x47)), (((uint)(((0xf0 << 1) ^ (((0xf0>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xf0) ^ 0xf0)) << 16) | ((uint)(0xf0) << 8) | (0xf0)), (((uint)(((0xad << 1) ^ (((0xad>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xad) ^ 0xad)) << 16) | ((uint)(0xad) << 8) | (0xad)), (((uint)(((0xd4 << 1) ^ (((0xd4>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xd4) ^ 0xd4)) << 16) | ((uint)(0xd4) << 8) | (0xd4)), (((uint)(((0xa2 << 1) ^ (((0xa2>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xa2) ^ 0xa2)) << 16) | ((uint)(0xa2) << 8) | (0xa2)), (((uint)(((0xaf << 1) ^ (((0xaf>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xaf) ^ 0xaf)) << 16) | ((uint)(0xaf) << 8) | (0xaf)), (((uint)(((0x9c << 1) ^ (((0x9c>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x9c) ^ 0x9c)) << 16) | ((uint)(0x9c) << 8) | (0x9c)), (((uint)(((0xa4 << 1) ^ (((0xa4>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xa4) ^ 0xa4)) << 16) | ((uint)(0xa4) << 8) | (0xa4)), (((uint)(((0x72 << 1) ^ (((0x72>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x72) ^ 0x72)) << 16) | ((uint)(0x72) << 8) | (0x72)), (((uint)(((0xc0 << 1) ^ (((0xc0>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xc0) ^ 0xc0)) << 16) | ((uint)(0xc0) << 8) | (0xc0)), (((uint)(((0xb7 << 1) ^ (((0xb7>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xb7) ^ 0xb7)) << 16) | ((uint)(0xb7) << 8) | (0xb7)), (((uint)(((0xfd << 1) ^ (((0xfd>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xfd) ^ 0xfd)) << 16) | ((uint)(0xfd) << 8) | (0xfd)), (((uint)(((0x93 << 1) ^ (((0x93>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x93) ^ 0x93)) << 16) | ((uint)(0x93) << 8) | (0x93)), (((uint)(((0x26 << 1) ^ (((0x26>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x26) ^ 0x26)) << 16) | ((uint)(0x26) << 8) | (0x26)), (((uint)(((0x36 << 1) ^ (((0x36>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x36) ^ 0x36)) << 16) | ((uint)(0x36) << 8) | (0x36)), (((uint)(((0x3f << 1) ^ (((0x3f>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x3f) ^ 0x3f)) << 16) | ((uint)(0x3f) << 8) | (0x3f)), (((uint)(((0xf7 << 1) ^ (((0xf7>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xf7) ^ 0xf7)) << 16) | ((uint)(0xf7) << 8) | (0xf7)), (((uint)(((0xcc << 1) ^ (((0xcc>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xcc) ^ 0xcc)) << 16) | ((uint)(0xcc) << 8) | (0xcc)), (((uint)(((0x34 << 1) ^ (((0x34>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x34) ^ 0x34)) << 16) | ((uint)(0x34) << 8) | (0x34)), (((uint)(((0xa5 << 1) ^ (((0xa5>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xa5) ^ 0xa5)) << 16) | ((uint)(0xa5) << 8) | (0xa5)), (((uint)(((0xe5 << 1) ^ (((0xe5>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xe5) ^ 0xe5)) << 16) | ((uint)(0xe5) << 8) | (0xe5)), (((uint)(((0xf1 << 1) ^ (((0xf1>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xf1) ^ 0xf1)) << 16) | ((uint)(0xf1) << 8) | (0xf1)), (((uint)(((0x71 << 1) ^ (((0x71>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x71) ^ 0x71)) << 16) | ((uint)(0x71) << 8) | (0x71)), (((uint)(((0xd8 << 1) ^ (((0xd8>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xd8) ^ 0xd8)) << 16) | ((uint)(0xd8) << 8) | (0xd8)), (((uint)(((0x31 << 1) ^ (((0x31>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x31) ^ 0x31)) << 16) | ((uint)(0x31) << 8) | (0x31)), (((uint)(((0x15 << 1) ^ (((0x15>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x15) ^ 0x15)) << 16) | ((uint)(0x15) << 8) | (0x15)), (((uint)(((0x04 << 1) ^ (((0x04>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x04) ^ 0x04)) << 16) | ((uint)(0x04) << 8) | (0x04)), (((uint)(((0xc7 << 1) ^ (((0xc7>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xc7) ^ 0xc7)) << 16) | ((uint)(0xc7) << 8) | (0xc7)), (((uint)(((0x23 << 1) ^ (((0x23>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x23) ^ 0x23)) << 16) | ((uint)(0x23) << 8) | (0x23)), (((uint)(((0xc3 << 1) ^ (((0xc3>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xc3) ^ 0xc3)) << 16) | ((uint)(0xc3) << 8) | (0xc3)), (((uint)(((0x18 << 1) ^ (((0x18>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x18) ^ 0x18)) << 16) | ((uint)(0x18) << 8) | (0x18)), (((uint)(((0x96 << 1) ^ (((0x96>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x96) ^ 0x96)) << 16) | ((uint)(0x96) << 8) | (0x96)), (((uint)(((0x05 << 1) ^ (((0x05>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x05) ^ 0x05)) << 16) | ((uint)(0x05) << 8) | (0x05)), (((uint)(((0x9a << 1) ^ (((0x9a>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x9a) ^ 0x9a)) << 16) | ((uint)(0x9a) << 8) | (0x9a)), (((uint)(((0x07 << 1) ^ (((0x07>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x07) ^ 0x07)) << 16) | ((uint)(0x07) << 8) | (0x07)), (((uint)(((0x12 << 1) ^ (((0x12>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x12) ^ 0x12)) << 16) | ((uint)(0x12) << 8) | (0x12)), (((uint)(((0x80 << 1) ^ (((0x80>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x80) ^ 0x80)) << 16) | ((uint)(0x80) << 8) | (0x80)), (((uint)(((0xe2 << 1) ^ (((0xe2>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xe2) ^ 0xe2)) << 16) | ((uint)(0xe2) << 8) | (0xe2)), (((uint)(((0xeb << 1) ^ (((0xeb>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xeb) ^ 0xeb)) << 16) | ((uint)(0xeb) << 8) | (0xeb)), (((uint)(((0x27 << 1) ^ (((0x27>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x27) ^ 0x27)) << 16) | ((uint)(0x27) << 8) | (0x27)), (((uint)(((0xb2 << 1) ^ (((0xb2>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xb2) ^ 0xb2)) << 16) | ((uint)(0xb2) << 8) | (0xb2)), (((uint)(((0x75 << 1) ^ (((0x75>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x75) ^ 0x75)) << 16) | ((uint)(0x75) << 8) | (0x75)), (((uint)(((0x09 << 1) ^ (((0x09>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x09) ^ 0x09)) << 16) | ((uint)(0x09) << 8) | (0x09)), (((uint)(((0x83 << 1) ^ (((0x83>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x83) ^ 0x83)) << 16) | ((uint)(0x83) << 8) | (0x83)), (((uint)(((0x2c << 1) ^ (((0x2c>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x2c) ^ 0x2c)) << 16) | ((uint)(0x2c) << 8) | (0x2c)), (((uint)(((0x1a << 1) ^ (((0x1a>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x1a) ^ 0x1a)) << 16) | ((uint)(0x1a) << 8) | (0x1a)), (((uint)(((0x1b << 1) ^ (((0x1b>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x1b) ^ 0x1b)) << 16) | ((uint)(0x1b) << 8) | (0x1b)), (((uint)(((0x6e << 1) ^ (((0x6e>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x6e) ^ 0x6e)) << 16) | ((uint)(0x6e) << 8) | (0x6e)), (((uint)(((0x5a << 1) ^ (((0x5a>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x5a) ^ 0x5a)) << 16) | ((uint)(0x5a) << 8) | (0x5a)), (((uint)(((0xa0 << 1) ^ (((0xa0>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xa0) ^ 0xa0)) << 16) | ((uint)(0xa0) << 8) | (0xa0)), (((uint)(((0x52 << 1) ^ (((0x52>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x52) ^ 0x52)) << 16) | ((uint)(0x52) << 8) | (0x52)), (((uint)(((0x3b << 1) ^ (((0x3b>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x3b) ^ 0x3b)) << 16) | ((uint)(0x3b) << 8) | (0x3b)), (((uint)(((0xd6 << 1) ^ (((0xd6>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xd6) ^ 0xd6)) << 16) | ((uint)(0xd6) << 8) | (0xd6)), (((uint)(((0xb3 << 1) ^ (((0xb3>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xb3) ^ 0xb3)) << 16) | ((uint)(0xb3) << 8) | (0xb3)), (((uint)(((0x29 << 1) ^ (((0x29>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x29) ^ 0x29)) << 16) | ((uint)(0x29) << 8) | (0x29)), (((uint)(((0xe3 << 1) ^ (((0xe3>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xe3) ^ 0xe3)) << 16) | ((uint)(0xe3) << 8) | (0xe3)), (((uint)(((0x2f << 1) ^ (((0x2f>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x2f) ^ 0x2f)) << 16) | ((uint)(0x2f) << 8) | (0x2f)), (((uint)(((0x84 << 1) ^ (((0x84>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x84) ^ 0x84)) << 16) | ((uint)(0x84) << 8) | (0x84)), (((uint)(((0x53 << 1) ^ (((0x53>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x53) ^ 0x53)) << 16) | ((uint)(0x53) << 8) | (0x53)), (((uint)(((0xd1 << 1) ^ (((0xd1>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xd1) ^ 0xd1)) << 16) | ((uint)(0xd1) << 8) | (0xd1)), (((uint)(((0x00 << 1) ^ (((0x00>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x00) ^ 0x00)) << 16) | ((uint)(0x00) << 8) | (0x00)), (((uint)(((0xed << 1) ^ (((0xed>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xed) ^ 0xed)) << 16) | ((uint)(0xed) << 8) | (0xed)), (((uint)(((0x20 << 1) ^ (((0x20>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x20) ^ 0x20)) << 16) | ((uint)(0x20) << 8) | (0x20)), (((uint)(((0xfc << 1) ^ (((0xfc>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xfc) ^ 0xfc)) << 16) | ((uint)(0xfc) << 8) | (0xfc)), (((uint)(((0xb1 << 1) ^ (((0xb1>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xb1) ^ 0xb1)) << 16) | ((uint)(0xb1) << 8) | (0xb1)), (((uint)(((0x5b << 1) ^ (((0x5b>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x5b) ^ 0x5b)) << 16) | ((uint)(0x5b) << 8) | (0x5b)), (((uint)(((0x6a << 1) ^ (((0x6a>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x6a) ^ 0x6a)) << 16) | ((uint)(0x6a) << 8) | (0x6a)), (((uint)(((0xcb << 1) ^ (((0xcb>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xcb) ^ 0xcb)) << 16) | ((uint)(0xcb) << 8) | (0xcb)), (((uint)(((0xbe << 1) ^ (((0xbe>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xbe) ^ 0xbe)) << 16) | ((uint)(0xbe) << 8) | (0xbe)), (((uint)(((0x39 << 1) ^ (((0x39>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x39) ^ 0x39)) << 16) | ((uint)(0x39) << 8) | (0x39)), (((uint)(((0x4a << 1) ^ (((0x4a>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x4a) ^ 0x4a)) << 16) | ((uint)(0x4a) << 8) | (0x4a)), (((uint)(((0x4c << 1) ^ (((0x4c>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x4c) ^ 0x4c)) << 16) | ((uint)(0x4c) << 8) | (0x4c)), (((uint)(((0x58 << 1) ^ (((0x58>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x58) ^ 0x58)) << 16) | ((uint)(0x58) << 8) | (0x58)), (((uint)(((0xcf << 1) ^ (((0xcf>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xcf) ^ 0xcf)) << 16) | ((uint)(0xcf) << 8) | (0xcf)), (((uint)(((0xd0 << 1) ^ (((0xd0>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xd0) ^ 0xd0)) << 16) | ((uint)(0xd0) << 8) | (0xd0)), (((uint)(((0xef << 1) ^ (((0xef>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xef) ^ 0xef)) << 16) | ((uint)(0xef) << 8) | (0xef)), (((uint)(((0xaa << 1) ^ (((0xaa>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xaa) ^ 0xaa)) << 16) | ((uint)(0xaa) << 8) | (0xaa)), (((uint)(((0xfb << 1) ^ (((0xfb>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xfb) ^ 0xfb)) << 16) | ((uint)(0xfb) << 8) | (0xfb)), (((uint)(((0x43 << 1) ^ (((0x43>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x43) ^ 0x43)) << 16) | ((uint)(0x43) << 8) | (0x43)), (((uint)(((0x4d << 1) ^ (((0x4d>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x4d) ^ 0x4d)) << 16) | ((uint)(0x4d) << 8) | (0x4d)), (((uint)(((0x33 << 1) ^ (((0x33>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x33) ^ 0x33)) << 16) | ((uint)(0x33) << 8) | (0x33)), (((uint)(((0x85 << 1) ^ (((0x85>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x85) ^ 0x85)) << 16) | ((uint)(0x85) << 8) | (0x85)), (((uint)(((0x45 << 1) ^ (((0x45>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x45) ^ 0x45)) << 16) | ((uint)(0x45) << 8) | (0x45)), (((uint)(((0xf9 << 1) ^ (((0xf9>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xf9) ^ 0xf9)) << 16) | ((uint)(0xf9) << 8) | (0xf9)), (((uint)(((0x02 << 1) ^ (((0x02>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x02) ^ 0x02)) << 16) | ((uint)(0x02) << 8) | (0x02)), (((uint)(((0x7f << 1) ^ (((0x7f>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x7f) ^ 0x7f)) << 16) | ((uint)(0x7f) << 8) | (0x7f)), (((uint)(((0x50 << 1) ^ (((0x50>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x50) ^ 0x50)) << 16) | ((uint)(0x50) << 8) | (0x50)), (((uint)(((0x3c << 1) ^ (((0x3c>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x3c) ^ 0x3c)) << 16) | ((uint)(0x3c) << 8) | (0x3c)), (((uint)(((0x9f << 1) ^ (((0x9f>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x9f) ^ 0x9f)) << 16) | ((uint)(0x9f) << 8) | (0x9f)), (((uint)(((0xa8 << 1) ^ (((0xa8>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xa8) ^ 0xa8)) << 16) | ((uint)(0xa8) << 8) | (0xa8)), (((uint)(((0x51 << 1) ^ (((0x51>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x51) ^ 0x51)) << 16) | ((uint)(0x51) << 8) | (0x51)), (((uint)(((0xa3 << 1) ^ (((0xa3>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xa3) ^ 0xa3)) << 16) | ((uint)(0xa3) << 8) | (0xa3)), (((uint)(((0x40 << 1) ^ (((0x40>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x40) ^ 0x40)) << 16) | ((uint)(0x40) << 8) | (0x40)), (((uint)(((0x8f << 1) ^ (((0x8f>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x8f) ^ 0x8f)) << 16) | ((uint)(0x8f) << 8) | (0x8f)), (((uint)(((0x92 << 1) ^ (((0x92>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x92) ^ 0x92)) << 16) | ((uint)(0x92) << 8) | (0x92)), (((uint)(((0x9d << 1) ^ (((0x9d>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x9d) ^ 0x9d)) << 16) | ((uint)(0x9d) << 8) | (0x9d)), (((uint)(((0x38 << 1) ^ (((0x38>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x38) ^ 0x38)) << 16) | ((uint)(0x38) << 8) | (0x38)), (((uint)(((0xf5 << 1) ^ (((0xf5>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xf5) ^ 0xf5)) << 16) | ((uint)(0xf5) << 8) | (0xf5)), (((uint)(((0xbc << 1) ^ (((0xbc>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xbc) ^ 0xbc)) << 16) | ((uint)(0xbc) << 8) | (0xbc)), (((uint)(((0xb6 << 1) ^ (((0xb6>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xb6) ^ 0xb6)) << 16) | ((uint)(0xb6) << 8) | (0xb6)), (((uint)(((0xda << 1) ^ (((0xda>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xda) ^ 0xda)) << 16) | ((uint)(0xda) << 8) | (0xda)), (((uint)(((0x21 << 1) ^ (((0x21>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x21) ^ 0x21)) << 16) | ((uint)(0x21) << 8) | (0x21)), (((uint)(((0x10 << 1) ^ (((0x10>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x10) ^ 0x10)) << 16) | ((uint)(0x10) << 8) | (0x10)), (((uint)(((0xff << 1) ^ (((0xff>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xff) ^ 0xff)) << 16) | ((uint)(0xff) << 8) | (0xff)), (((uint)(((0xf3 << 1) ^ (((0xf3>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xf3) ^ 0xf3)) << 16) | ((uint)(0xf3) << 8) | (0xf3)), (((uint)(((0xd2 << 1) ^ (((0xd2>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xd2) ^ 0xd2)) << 16) | ((uint)(0xd2) << 8) | (0xd2)), (((uint)(((0xcd << 1) ^ (((0xcd>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xcd) ^ 0xcd)) << 16) | ((uint)(0xcd) << 8) | (0xcd)), (((uint)(((0x0c << 1) ^ (((0x0c>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x0c) ^ 0x0c)) << 16) | ((uint)(0x0c) << 8) | (0x0c)), (((uint)(((0x13 << 1) ^ (((0x13>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x13) ^ 0x13)) << 16) | ((uint)(0x13) << 8) | (0x13)), (((uint)(((0xec << 1) ^ (((0xec>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xec) ^ 0xec)) << 16) | ((uint)(0xec) << 8) | (0xec)), (((uint)(((0x5f << 1) ^ (((0x5f>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x5f) ^ 0x5f)) << 16) | ((uint)(0x5f) << 8) | (0x5f)), (((uint)(((0x97 << 1) ^ (((0x97>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x97) ^ 0x97)) << 16) | ((uint)(0x97) << 8) | (0x97)), (((uint)(((0x44 << 1) ^ (((0x44>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x44) ^ 0x44)) << 16) | ((uint)(0x44) << 8) | (0x44)), (((uint)(((0x17 << 1) ^ (((0x17>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x17) ^ 0x17)) << 16) | ((uint)(0x17) << 8) | (0x17)), (((uint)(((0xc4 << 1) ^ (((0xc4>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xc4) ^ 0xc4)) << 16) | ((uint)(0xc4) << 8) | (0xc4)), (((uint)(((0xa7 << 1) ^ (((0xa7>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xa7) ^ 0xa7)) << 16) | ((uint)(0xa7) << 8) | (0xa7)), (((uint)(((0x7e << 1) ^ (((0x7e>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x7e) ^ 0x7e)) << 16) | ((uint)(0x7e) << 8) | (0x7e)), (((uint)(((0x3d << 1) ^ (((0x3d>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x3d) ^ 0x3d)) << 16) | ((uint)(0x3d) << 8) | (0x3d)), (((uint)(((0x64 << 1) ^ (((0x64>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x64) ^ 0x64)) << 16) | ((uint)(0x64) << 8) | (0x64)), (((uint)(((0x5d << 1) ^ (((0x5d>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x5d) ^ 0x5d)) << 16) | ((uint)(0x5d) << 8) | (0x5d)), (((uint)(((0x19 << 1) ^ (((0x19>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x19) ^ 0x19)) << 16) | ((uint)(0x19) << 8) | (0x19)), (((uint)(((0x73 << 1) ^ (((0x73>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x73) ^ 0x73)) << 16) | ((uint)(0x73) << 8) | (0x73)), (((uint)(((0x60 << 1) ^ (((0x60>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x60) ^ 0x60)) << 16) | ((uint)(0x60) << 8) | (0x60)), (((uint)(((0x81 << 1) ^ (((0x81>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x81) ^ 0x81)) << 16) | ((uint)(0x81) << 8) | (0x81)), (((uint)(((0x4f << 1) ^ (((0x4f>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x4f) ^ 0x4f)) << 16) | ((uint)(0x4f) << 8) | (0x4f)), (((uint)(((0xdc << 1) ^ (((0xdc>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xdc) ^ 0xdc)) << 16) | ((uint)(0xdc) << 8) | (0xdc)), (((uint)(((0x22 << 1) ^ (((0x22>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x22) ^ 0x22)) << 16) | ((uint)(0x22) << 8) | (0x22)), (((uint)(((0x2a << 1) ^ (((0x2a>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x2a) ^ 0x2a)) << 16) | ((uint)(0x2a) << 8) | (0x2a)), (((uint)(((0x90 << 1) ^ (((0x90>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x90) ^ 0x90)) << 16) | ((uint)(0x90) << 8) | (0x90)), (((uint)(((0x88 << 1) ^ (((0x88>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x88) ^ 0x88)) << 16) | ((uint)(0x88) << 8) | (0x88)), (((uint)(((0x46 << 1) ^ (((0x46>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x46) ^ 0x46)) << 16) | ((uint)(0x46) << 8) | (0x46)), (((uint)(((0xee << 1) ^ (((0xee>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xee) ^ 0xee)) << 16) | ((uint)(0xee) << 8) | (0xee)), (((uint)(((0xb8 << 1) ^ (((0xb8>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xb8) ^ 0xb8)) << 16) | ((uint)(0xb8) << 8) | (0xb8)), (((uint)(((0x14 << 1) ^ (((0x14>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x14) ^ 0x14)) << 16) | ((uint)(0x14) << 8) | (0x14)), (((uint)(((0xde << 1) ^ (((0xde>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xde) ^ 0xde)) << 16) | ((uint)(0xde) << 8) | (0xde)), (((uint)(((0x5e << 1) ^ (((0x5e>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x5e) ^ 0x5e)) << 16) | ((uint)(0x5e) << 8) | (0x5e)), (((uint)(((0x0b << 1) ^ (((0x0b>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x0b) ^ 0x0b)) << 16) | ((uint)(0x0b) << 8) | (0x0b)), (((uint)(((0xdb << 1) ^ (((0xdb>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xdb) ^ 0xdb)) << 16) | ((uint)(0xdb) << 8) | (0xdb)), (((uint)(((0xe0 << 1) ^ (((0xe0>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xe0) ^ 0xe0)) << 16) | ((uint)(0xe0) << 8) | (0xe0)), (((uint)(((0x32 << 1) ^ (((0x32>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x32) ^ 0x32)) << 16) | ((uint)(0x32) << 8) | (0x32)), (((uint)(((0x3a << 1) ^ (((0x3a>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x3a) ^ 0x3a)) << 16) | ((uint)(0x3a) << 8) | (0x3a)), (((uint)(((0x0a << 1) ^ (((0x0a>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x0a) ^ 0x0a)) << 16) | ((uint)(0x0a) << 8) | (0x0a)), (((uint)(((0x49 << 1) ^ (((0x49>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x49) ^ 0x49)) << 16) | ((uint)(0x49) << 8) | (0x49)), (((uint)(((0x06 << 1) ^ (((0x06>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x06) ^ 0x06)) << 16) | ((uint)(0x06) << 8) | (0x06)), (((uint)(((0x24 << 1) ^ (((0x24>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x24) ^ 0x24)) << 16) | ((uint)(0x24) << 8) | (0x24)), (((uint)(((0x5c << 1) ^ (((0x5c>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x5c) ^ 0x5c)) << 16) | ((uint)(0x5c) << 8) | (0x5c)), (((uint)(((0xc2 << 1) ^ (((0xc2>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xc2) ^ 0xc2)) << 16) | ((uint)(0xc2) << 8) | (0xc2)), (((uint)(((0xd3 << 1) ^ (((0xd3>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xd3) ^ 0xd3)) << 16) | ((uint)(0xd3) << 8) | (0xd3)), (((uint)(((0xac << 1) ^ (((0xac>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xac) ^ 0xac)) << 16) | ((uint)(0xac) << 8) | (0xac)), (((uint)(((0x62 << 1) ^ (((0x62>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x62) ^ 0x62)) << 16) | ((uint)(0x62) << 8) | (0x62)), (((uint)(((0x91 << 1) ^ (((0x91>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x91) ^ 0x91)) << 16) | ((uint)(0x91) << 8) | (0x91)), (((uint)(((0x95 << 1) ^ (((0x95>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x95) ^ 0x95)) << 16) | ((uint)(0x95) << 8) | (0x95)), (((uint)(((0xe4 << 1) ^ (((0xe4>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xe4) ^ 0xe4)) << 16) | ((uint)(0xe4) << 8) | (0xe4)), (((uint)(((0x79 << 1) ^ (((0x79>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x79) ^ 0x79)) << 16) | ((uint)(0x79) << 8) | (0x79)), (((uint)(((0xe7 << 1) ^ (((0xe7>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xe7) ^ 0xe7)) << 16) | ((uint)(0xe7) << 8) | (0xe7)), (((uint)(((0xc8 << 1) ^ (((0xc8>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xc8) ^ 0xc8)) << 16) | ((uint)(0xc8) << 8) | (0xc8)), (((uint)(((0x37 << 1) ^ (((0x37>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x37) ^ 0x37)) << 16) | ((uint)(0x37) << 8) | (0x37)), (((uint)(((0x6d << 1) ^ (((0x6d>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x6d) ^ 0x6d)) << 16) | ((uint)(0x6d) << 8) | (0x6d)), (((uint)(((0x8d << 1) ^ (((0x8d>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x8d) ^ 0x8d)) << 16) | ((uint)(0x8d) << 8) | (0x8d)), (((uint)(((0xd5 << 1) ^ (((0xd5>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xd5) ^ 0xd5)) << 16) | ((uint)(0xd5) << 8) | (0xd5)), (((uint)(((0x4e << 1) ^ (((0x4e>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x4e) ^ 0x4e)) << 16) | ((uint)(0x4e) << 8) | (0x4e)), (((uint)(((0xa9 << 1) ^ (((0xa9>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xa9) ^ 0xa9)) << 16) | ((uint)(0xa9) << 8) | (0xa9)), (((uint)(((0x6c << 1) ^ (((0x6c>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x6c) ^ 0x6c)) << 16) | ((uint)(0x6c) << 8) | (0x6c)), (((uint)(((0x56 << 1) ^ (((0x56>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x56) ^ 0x56)) << 16) | ((uint)(0x56) << 8) | (0x56)), (((uint)(((0xf4 << 1) ^ (((0xf4>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xf4) ^ 0xf4)) << 16) | ((uint)(0xf4) << 8) | (0xf4)), (((uint)(((0xea << 1) ^ (((0xea>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xea) ^ 0xea)) << 16) | ((uint)(0xea) << 8) | (0xea)), (((uint)(((0x65 << 1) ^ (((0x65>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x65) ^ 0x65)) << 16) | ((uint)(0x65) << 8) | (0x65)), (((uint)(((0x7a << 1) ^ (((0x7a>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x7a) ^ 0x7a)) << 16) | ((uint)(0x7a) << 8) | (0x7a)), (((uint)(((0xae << 1) ^ (((0xae>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xae) ^ 0xae)) << 16) | ((uint)(0xae) << 8) | (0xae)), (((uint)(((0x08 << 1) ^ (((0x08>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x08) ^ 0x08)) << 16) | ((uint)(0x08) << 8) | (0x08)), (((uint)(((0xba << 1) ^ (((0xba>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xba) ^ 0xba)) << 16) | ((uint)(0xba) << 8) | (0xba)), (((uint)(((0x78 << 1) ^ (((0x78>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x78) ^ 0x78)) << 16) | ((uint)(0x78) << 8) | (0x78)), (((uint)(((0x25 << 1) ^ (((0x25>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x25) ^ 0x25)) << 16) | ((uint)(0x25) << 8) | (0x25)), (((uint)(((0x2e << 1) ^ (((0x2e>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x2e) ^ 0x2e)) << 16) | ((uint)(0x2e) << 8) | (0x2e)), (((uint)(((0x1c << 1) ^ (((0x1c>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x1c) ^ 0x1c)) << 16) | ((uint)(0x1c) << 8) | (0x1c)), (((uint)(((0xa6 << 1) ^ (((0xa6>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xa6) ^ 0xa6)) << 16) | ((uint)(0xa6) << 8) | (0xa6)), (((uint)(((0xb4 << 1) ^ (((0xb4>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xb4) ^ 0xb4)) << 16) | ((uint)(0xb4) << 8) | (0xb4)), (((uint)(((0xc6 << 1) ^ (((0xc6>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xc6) ^ 0xc6)) << 16) | ((uint)(0xc6) << 8) | (0xc6)), (((uint)(((0xe8 << 1) ^ (((0xe8>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xe8) ^ 0xe8)) << 16) | ((uint)(0xe8) << 8) | (0xe8)), (((uint)(((0xdd << 1) ^ (((0xdd>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xdd) ^ 0xdd)) << 16) | ((uint)(0xdd) << 8) | (0xdd)), (((uint)(((0x74 << 1) ^ (((0x74>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x74) ^ 0x74)) << 16) | ((uint)(0x74) << 8) | (0x74)), (((uint)(((0x1f << 1) ^ (((0x1f>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x1f) ^ 0x1f)) << 16) | ((uint)(0x1f) << 8) | (0x1f)), (((uint)(((0x4b << 1) ^ (((0x4b>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x4b) ^ 0x4b)) << 16) | ((uint)(0x4b) << 8) | (0x4b)), (((uint)(((0xbd << 1) ^ (((0xbd>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xbd) ^ 0xbd)) << 16) | ((uint)(0xbd) << 8) | (0xbd)), (((uint)(((0x8b << 1) ^ (((0x8b>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x8b) ^ 0x8b)) << 16) | ((uint)(0x8b) << 8) | (0x8b)), (((uint)(((0x8a << 1) ^ (((0x8a>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x8a) ^ 0x8a)) << 16) | ((uint)(0x8a) << 8) | (0x8a)), (((uint)(((0x70 << 1) ^ (((0x70>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x70) ^ 0x70)) << 16) | ((uint)(0x70) << 8) | (0x70)), (((uint)(((0x3e << 1) ^ (((0x3e>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x3e) ^ 0x3e)) << 16) | ((uint)(0x3e) << 8) | (0x3e)), (((uint)(((0xb5 << 1) ^ (((0xb5>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xb5) ^ 0xb5)) << 16) | ((uint)(0xb5) << 8) | (0xb5)), (((uint)(((0x66 << 1) ^ (((0x66>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x66) ^ 0x66)) << 16) | ((uint)(0x66) << 8) | (0x66)), (((uint)(((0x48 << 1) ^ (((0x48>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x48) ^ 0x48)) << 16) | ((uint)(0x48) << 8) | (0x48)), (((uint)(((0x03 << 1) ^ (((0x03>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x03) ^ 0x03)) << 16) | ((uint)(0x03) << 8) | (0x03)), (((uint)(((0xf6 << 1) ^ (((0xf6>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xf6) ^ 0xf6)) << 16) | ((uint)(0xf6) << 8) | (0xf6)), (((uint)(((0x0e << 1) ^ (((0x0e>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x0e) ^ 0x0e)) << 16) | ((uint)(0x0e) << 8) | (0x0e)), (((uint)(((0x61 << 1) ^ (((0x61>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x61) ^ 0x61)) << 16) | ((uint)(0x61) << 8) | (0x61)), (((uint)(((0x35 << 1) ^ (((0x35>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x35) ^ 0x35)) << 16) | ((uint)(0x35) << 8) | (0x35)), (((uint)(((0x57 << 1) ^ (((0x57>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x57) ^ 0x57)) << 16) | ((uint)(0x57) << 8) | (0x57)), (((uint)(((0xb9 << 1) ^ (((0xb9>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xb9) ^ 0xb9)) << 16) | ((uint)(0xb9) << 8) | (0xb9)), (((uint)(((0x86 << 1) ^ (((0x86>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x86) ^ 0x86)) << 16) | ((uint)(0x86) << 8) | (0x86)), (((uint)(((0xc1 << 1) ^ (((0xc1>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xc1) ^ 0xc1)) << 16) | ((uint)(0xc1) << 8) | (0xc1)), (((uint)(((0x1d << 1) ^ (((0x1d>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x1d) ^ 0x1d)) << 16) | ((uint)(0x1d) << 8) | (0x1d)), (((uint)(((0x9e << 1) ^ (((0x9e>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x9e) ^ 0x9e)) << 16) | ((uint)(0x9e) << 8) | (0x9e)), (((uint)(((0xe1 << 1) ^ (((0xe1>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xe1) ^ 0xe1)) << 16) | ((uint)(0xe1) << 8) | (0xe1)), (((uint)(((0xf8 << 1) ^ (((0xf8>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xf8) ^ 0xf8)) << 16) | ((uint)(0xf8) << 8) | (0xf8)), (((uint)(((0x98 << 1) ^ (((0x98>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x98) ^ 0x98)) << 16) | ((uint)(0x98) << 8) | (0x98)), (((uint)(((0x11 << 1) ^ (((0x11>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x11) ^ 0x11)) << 16) | ((uint)(0x11) << 8) | (0x11)), (((uint)(((0x69 << 1) ^ (((0x69>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x69) ^ 0x69)) << 16) | ((uint)(0x69) << 8) | (0x69)), (((uint)(((0xd9 << 1) ^ (((0xd9>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xd9) ^ 0xd9)) << 16) | ((uint)(0xd9) << 8) | (0xd9)), (((uint)(((0x8e << 1) ^ (((0x8e>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x8e) ^ 0x8e)) << 16) | ((uint)(0x8e) << 8) | (0x8e)), (((uint)(((0x94 << 1) ^ (((0x94>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x94) ^ 0x94)) << 16) | ((uint)(0x94) << 8) | (0x94)), (((uint)(((0x9b << 1) ^ (((0x9b>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x9b) ^ 0x9b)) << 16) | ((uint)(0x9b) << 8) | (0x9b)), (((uint)(((0x1e << 1) ^ (((0x1e>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x1e) ^ 0x1e)) << 16) | ((uint)(0x1e) << 8) | (0x1e)), (((uint)(((0x87 << 1) ^ (((0x87>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x87) ^ 0x87)) << 16) | ((uint)(0x87) << 8) | (0x87)), (((uint)(((0xe9 << 1) ^ (((0xe9>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xe9) ^ 0xe9)) << 16) | ((uint)(0xe9) << 8) | (0xe9)), (((uint)(((0xce << 1) ^ (((0xce>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xce) ^ 0xce)) << 16) | ((uint)(0xce) << 8) | (0xce)), (((uint)(((0x55 << 1) ^ (((0x55>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x55) ^ 0x55)) << 16) | ((uint)(0x55) << 8) | (0x55)), (((uint)(((0x28 << 1) ^ (((0x28>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x28) ^ 0x28)) << 16) | ((uint)(0x28) << 8) | (0x28)), (((uint)(((0xdf << 1) ^ (((0xdf>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xdf) ^ 0xdf)) << 16) | ((uint)(0xdf) << 8) | (0xdf)), (((uint)(((0x8c << 1) ^ (((0x8c>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x8c) ^ 0x8c)) << 16) | ((uint)(0x8c) << 8) | (0x8c)), (((uint)(((0xa1 << 1) ^ (((0xa1>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xa1) ^ 0xa1)) << 16) | ((uint)(0xa1) << 8) | (0xa1)), (((uint)(((0x89 << 1) ^ (((0x89>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x89) ^ 0x89)) << 16) | ((uint)(0x89) << 8) | (0x89)), (((uint)(((0x0d << 1) ^ (((0x0d>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x0d) ^ 0x0d)) << 16) | ((uint)(0x0d) << 8) | (0x0d)), (((uint)(((0xbf << 1) ^ (((0xbf>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xbf) ^ 0xbf)) << 16) | ((uint)(0xbf) << 8) | (0xbf)), (((uint)(((0xe6 << 1) ^ (((0xe6>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xe6) ^ 0xe6)) << 16) | ((uint)(0xe6) << 8) | (0xe6)), (((uint)(((0x42 << 1) ^ (((0x42>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x42) ^ 0x42)) << 16) | ((uint)(0x42) << 8) | (0x42)), (((uint)(((0x68 << 1) ^ (((0x68>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x68) ^ 0x68)) << 16) | ((uint)(0x68) << 8) | (0x68)), (((uint)(((0x41 << 1) ^ (((0x41>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x41) ^ 0x41)) << 16) | ((uint)(0x41) << 8) | (0x41)), (((uint)(((0x99 << 1) ^ (((0x99>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x99) ^ 0x99)) << 16) | ((uint)(0x99) << 8) | (0x99)), (((uint)(((0x2d << 1) ^ (((0x2d>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x2d) ^ 0x2d)) << 16) | ((uint)(0x2d) << 8) | (0x2d)), (((uint)(((0x0f << 1) ^ (((0x0f>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x0f) ^ 0x0f)) << 16) | ((uint)(0x0f) << 8) | (0x0f)), (((uint)(((0xb0 << 1) ^ (((0xb0>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xb0) ^ 0xb0)) << 16) | ((uint)(0xb0) << 8) | (0xb0)), (((uint)(((0x54 << 1) ^ (((0x54>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x54) ^ 0x54)) << 16) | ((uint)(0x54) << 8) | (0x54)), (((uint)(((0xbb << 1) ^ (((0xbb>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0xbb) ^ 0xbb)) << 16) | ((uint)(0xbb) << 8) | (0xbb)), (((uint)(((0x16 << 1) ^ (((0x16>>7) & 1) * DefineConstants.WPOLY))) << 24) | ((uint)((f2(0x16) ^ 0x16)) << 16) | ((uint)(0x16) << 8) | (0x16))}
	};



	public static STATIC INLINE void aesb_single_round(ushort in, ushort @out, ushort expandedKey)
	{
	  uint[] b0 = Arrays.InitializeWithDefaultInstances<uint>(4);
	  uint[] b1 = Arrays.InitializeWithDefaultInstances<uint>(4);
	  uint kp = (uint) expandedKey;
	  (b0[0] = ((uint)(in) + (0)));
	  (b0[1] = ((uint)(in) + (1)));
	  (b0[2] = ((uint)(in) + (2)));
	  (b0[3] = ((uint)(in) + (3)));

	  (b1[0] = (kp)[0] ^ (t_fn[0][((((0 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 0 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 0 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 1 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 1 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 2 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 2 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 3 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 3 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((3)))) & 0xff)]));
	  (b1[1] = (kp)[1] ^ (t_fn[0][((((0 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[2] = (kp)[2] ^ (t_fn[0][((((0 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[3] = (kp)[3] ^ (t_fn[0][((((0 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));

	  ((uint)(@out) + (0) = (b1[0]));
	  ((uint)(@out) + (1) = (b1[1]));
	  ((uint)(@out) + (2) = (b1[2]));
	  ((uint)(@out) + (3) = (b1[3]));
	}

	public static STATIC INLINE void aesb_pseudo_round(ushort in, ushort @out, ushort expandedKey)
	{
	  uint[] b0 = Arrays.InitializeWithDefaultInstances<uint>(4);
	  uint[] b1 = Arrays.InitializeWithDefaultInstances<uint>(4);
	  uint kp = (uint) expandedKey;
	  (b0[0] = ((uint)(in) + (0)));
	  (b0[1] = ((uint)(in) + (1)));
	  (b0[2] = ((uint)(in) + (2)));
	  (b0[3] = ((uint)(in) + (3)));

	  (b1[0] = (kp)[0] ^ (t_fn[0][((((0 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 0 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 0 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 1 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 1 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 2 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 2 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 3 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 3 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((3)))) & 0xff)]));
	  (b1[1] = (kp)[1] ^ (t_fn[0][((((0 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[2] = (kp)[2] ^ (t_fn[0][((((0 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[3] = (kp)[3] ^ (t_fn[0][((((0 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[0] = (kp + 1 * DefineConstants.N_COLS)[0] ^ (t_fn[0][((((0 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 0 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 0 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 1 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 1 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 2 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 2 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 3 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 3 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((3)))) & 0xff)]));
	  (b0[1] = (kp + 1 * DefineConstants.N_COLS)[1] ^ (t_fn[0][((((0 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[2] = (kp + 1 * DefineConstants.N_COLS)[2] ^ (t_fn[0][((((0 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[3] = (kp + 1 * DefineConstants.N_COLS)[3] ^ (t_fn[0][((((0 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[0] = (kp + 2 * DefineConstants.N_COLS)[0] ^ (t_fn[0][((((0 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 0 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 0 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 1 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 1 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 2 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 2 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 3 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 3 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((3)))) & 0xff)]));
	  (b1[1] = (kp + 2 * DefineConstants.N_COLS)[1] ^ (t_fn[0][((((0 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[2] = (kp + 2 * DefineConstants.N_COLS)[2] ^ (t_fn[0][((((0 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[3] = (kp + 2 * DefineConstants.N_COLS)[3] ^ (t_fn[0][((((0 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[0] = (kp + 3 * DefineConstants.N_COLS)[0] ^ (t_fn[0][((((0 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 0 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 0 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 1 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 1 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 2 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 2 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 3 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 3 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((3)))) & 0xff)]));
	  (b0[1] = (kp + 3 * DefineConstants.N_COLS)[1] ^ (t_fn[0][((((0 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[2] = (kp + 3 * DefineConstants.N_COLS)[2] ^ (t_fn[0][((((0 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[3] = (kp + 3 * DefineConstants.N_COLS)[3] ^ (t_fn[0][((((0 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[0] = (kp + 4 * DefineConstants.N_COLS)[0] ^ (t_fn[0][((((0 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 0 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 0 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 1 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 1 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 2 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 2 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 3 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 3 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((3)))) & 0xff)]));
	  (b1[1] = (kp + 4 * DefineConstants.N_COLS)[1] ^ (t_fn[0][((((0 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[2] = (kp + 4 * DefineConstants.N_COLS)[2] ^ (t_fn[0][((((0 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[3] = (kp + 4 * DefineConstants.N_COLS)[3] ^ (t_fn[0][((((0 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[0] = (kp + 5 * DefineConstants.N_COLS)[0] ^ (t_fn[0][((((0 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 0 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 0 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 1 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 1 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 2 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 2 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 3 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 3 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((3)))) & 0xff)]));
	  (b0[1] = (kp + 5 * DefineConstants.N_COLS)[1] ^ (t_fn[0][((((0 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[2] = (kp + 5 * DefineConstants.N_COLS)[2] ^ (t_fn[0][((((0 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[3] = (kp + 5 * DefineConstants.N_COLS)[3] ^ (t_fn[0][((((0 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[0] = (kp + 6 * DefineConstants.N_COLS)[0] ^ (t_fn[0][((((0 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 0 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 0 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 1 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 1 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 2 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 2 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 3 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 3 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((3)))) & 0xff)]));
	  (b1[1] = (kp + 6 * DefineConstants.N_COLS)[1] ^ (t_fn[0][((((0 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[2] = (kp + 6 * DefineConstants.N_COLS)[2] ^ (t_fn[0][((((0 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[3] = (kp + 6 * DefineConstants.N_COLS)[3] ^ (t_fn[0][((((0 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[0] = (kp + 7 * DefineConstants.N_COLS)[0] ^ (t_fn[0][((((0 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 0 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 0 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 1 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 1 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 2 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 2 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 3 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 3 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((3)))) & 0xff)]));
	  (b0[1] = (kp + 7 * DefineConstants.N_COLS)[1] ^ (t_fn[0][((((0 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[2] = (kp + 7 * DefineConstants.N_COLS)[2] ^ (t_fn[0][((((0 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[3] = (kp + 7 * DefineConstants.N_COLS)[3] ^ (t_fn[0][((((0 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[0] = (kp + 8 * DefineConstants.N_COLS)[0] ^ (t_fn[0][((((0 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 0 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 0 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 1 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 1 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 2 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 2 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (0 == 0 ? s(b0,0) : 0 == 1 ? s(b0,1) : 0 == 2 ? s(b0,2) : s(b0,3)) : 3 == 1 ? (0 == 0 ? s(b0,1) : 0 == 1 ? s(b0,2) : 0 == 2 ? s(b0,3) : s(b0,0)) : 3 == 2 ? (0 == 0 ? s(b0,2) : 0 == 1 ? s(b0,3) : 0 == 2 ? s(b0,0) : s(b0,1)) : (0 == 0 ? s(b0,3) : 0 == 1 ? s(b0,0) : 0 == 2 ? s(b0,1) : s(b0,2)))) >> (8 * ((3)))) & 0xff)]));
	  (b1[1] = (kp + 8 * DefineConstants.N_COLS)[1] ^ (t_fn[0][((((0 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (1 == 0 ? b0[0] : 1 == 1 ? b0[1] : 1 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (1 == 0 ? b0[1] : 1 == 1 ? b0[2] : 1 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (1 == 0 ? b0[2] : 1 == 1 ? b0[3] : 1 == 2 ? b0[0] : b0[1]) : (1 == 0 ? b0[3] : 1 == 1 ? b0[0] : 1 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[2] = (kp + 8 * DefineConstants.N_COLS)[2] ^ (t_fn[0][((((0 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (2 == 0 ? b0[0] : 2 == 1 ? b0[1] : 2 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (2 == 0 ? b0[1] : 2 == 1 ? b0[2] : 2 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (2 == 0 ? b0[2] : 2 == 1 ? b0[3] : 2 == 2 ? b0[0] : b0[1]) : (2 == 0 ? b0[3] : 2 == 1 ? b0[0] : 2 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b1[3] = (kp + 8 * DefineConstants.N_COLS)[3] ^ (t_fn[0][((((0 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 0 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 0 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 1 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 1 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 2 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 2 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (3 == 0 ? b0[0] : 3 == 1 ? b0[1] : 3 == 2 ? b0[2] : b0[3]) : 3 == 1 ? (3 == 0 ? b0[1] : 3 == 1 ? b0[2] : 3 == 2 ? b0[3] : b0[0]) : 3 == 2 ? (3 == 0 ? b0[2] : 3 == 1 ? b0[3] : 3 == 2 ? b0[0] : b0[1]) : (3 == 0 ? b0[3] : 3 == 1 ? b0[0] : 3 == 2 ? b0[1] : b0[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[0] = (kp + 9 * DefineConstants.N_COLS)[0] ^ (t_fn[0][((((0 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 0 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 0 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 1 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 1 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 2 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 2 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (0 == 0 ? s(b1,0) : 0 == 1 ? s(b1,1) : 0 == 2 ? s(b1,2) : s(b1,3)) : 3 == 1 ? (0 == 0 ? s(b1,1) : 0 == 1 ? s(b1,2) : 0 == 2 ? s(b1,3) : s(b1,0)) : 3 == 2 ? (0 == 0 ? s(b1,2) : 0 == 1 ? s(b1,3) : 0 == 2 ? s(b1,0) : s(b1,1)) : (0 == 0 ? s(b1,3) : 0 == 1 ? s(b1,0) : 0 == 2 ? s(b1,1) : s(b1,2)))) >> (8 * ((3)))) & 0xff)]));
	  (b0[1] = (kp + 9 * DefineConstants.N_COLS)[1] ^ (t_fn[0][((((0 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (1 == 0 ? b1[0] : 1 == 1 ? b1[1] : 1 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (1 == 0 ? b1[1] : 1 == 1 ? b1[2] : 1 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (1 == 0 ? b1[2] : 1 == 1 ? b1[3] : 1 == 2 ? b1[0] : b1[1]) : (1 == 0 ? b1[3] : 1 == 1 ? b1[0] : 1 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[2] = (kp + 9 * DefineConstants.N_COLS)[2] ^ (t_fn[0][((((0 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (2 == 0 ? b1[0] : 2 == 1 ? b1[1] : 2 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (2 == 0 ? b1[1] : 2 == 1 ? b1[2] : 2 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (2 == 0 ? b1[2] : 2 == 1 ? b1[3] : 2 == 2 ? b1[0] : b1[1]) : (2 == 0 ? b1[3] : 2 == 1 ? b1[0] : 2 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));
	  (b0[3] = (kp + 9 * DefineConstants.N_COLS)[3] ^ (t_fn[0][((((0 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 0 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 0 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((0)))) & 0xff)] ^ t_fn[1][((((1 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 1 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 1 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((1)))) & 0xff)] ^ t_fn[2][((((2 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 2 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 2 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((2)))) & 0xff)] ^ t_fn[3][((((3 == 0 ? (3 == 0 ? b1[0] : 3 == 1 ? b1[1] : 3 == 2 ? b1[2] : b1[3]) : 3 == 1 ? (3 == 0 ? b1[1] : 3 == 1 ? b1[2] : 3 == 2 ? b1[3] : b1[0]) : 3 == 2 ? (3 == 0 ? b1[2] : 3 == 1 ? b1[3] : 3 == 2 ? b1[0] : b1[1]) : (3 == 0 ? b1[3] : 3 == 1 ? b1[0] : 3 == 2 ? b1[1] : b1[2]))) >> (8 * ((3)))) & 0xff)]));

	  ((uint)(@out) + (0) = (b0[0]));
	  ((uint)(@out) + (1) = (b0[1]));
	  ((uint)(@out) + (2) = (b0[2]));
	  ((uint)(@out) + (3) = (b0[3]));
	}


	#if __cplusplus
	#endif


	public static void blake256_init(state S)
	{
		S.h[0] = 0x6A09E667;
		S.h[1] = 0xBB67AE85;
		S.h[2] = 0x3C6EF372;
		S.h[3] = 0xA54FF53A;
		S.h[4] = 0x510E527F;
		S.h[5] = 0x9B05688C;
		S.h[6] = 0x1F83D9AB;
		S.h[7] = 0x5BE0CD19;
		S.t[0] = S.t[1] = S.buflen = S.nullt = 0;
		S.s[0] = S.s[1] = S.s[2] = S.s[3] = 0;
	}
	public static void blake224_init(state S)
	{
		S.h[0] = 0xC1059ED8;
		S.h[1] = 0x367CD507;
		S.h[2] = 0x3070DD17;
		S.h[3] = 0xF70E5939;
		S.h[4] = 0xFFC00B31;
		S.h[5] = 0x68581511;
		S.h[6] = 0x64F98FA7;
		S.h[7] = 0xBEFA4FA4;
		S.t[0] = S.t[1] = S.buflen = S.nullt = 0;
		S.s[0] = S.s[1] = S.s[2] = S.s[3] = 0;
	}

// datalen = number of bits

//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'data', so pointers on this parameter are left unchanged:
	public static void blake256_update(state S, ushort * data, ulong datalen)
	{
		int left = S.buflen >> 3;
		int fill = 64 - left;

		if (left != 0 && (((datalen >> 3) & 0x3F) >= (uint) fill))
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy((object)(S.buf + left), (object) data, fill);
			S.t[0] += 512;
			if (S.t[0] == 0)
			{
				S.t[1]++;
			}
			blake256_compress(S, S.buf);
			data += fill;
			datalen -= (fill << 3);
			left = 0;
		}

		while (datalen >= 512)
		{
			S.t[0] += 512;
			if (S.t[0] == 0)
			{
				S.t[1]++;
			}
			blake256_compress(S, new ushort(data));
			data += 64;
			datalen -= 512;
		}

		if (datalen > 0)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy((object)(S.buf + left), (object) data, datalen >> 3);
			S.buflen = (left << 3) + (int)datalen;
		}
		else
		{
			S.buflen = 0;
		}
	}

// datalen = number of bits
	public static void blake224_update(state S, ushort data, ulong datalen)
	{
		blake256_update(S, data, new ulong(datalen));
	}

	public static void blake256_final(state S, ushort digest)
	{
		blake256_final_h(S, digest, 0x81, 0x01);
	}
	public static void blake224_final(state S, ushort digest)
	{
		blake256_final_h(S, digest, 0x80, 0x00);
	}

// inlen = number of bytes

	public static void blake256_hash(ushort @out, ushort in, ulong inlen)
	{
		state S = new state();
		blake256_init(S);
		blake256_update(S, in, inlen * 8);
		blake256_final(S, @out);
	}

// inlen = number of bytes
	public static void blake224_hash(ushort @out, ushort in, ulong inlen)
	{
		state S = new state();
		blake224_init(S);
		blake224_update(S, in, inlen * 8);
		blake224_final(S, @out);
	}

// keylen = number of bytes

	/* HMAC functions: */

	public static void hmac_blake256_init(hmac_state S, ushort _key, ulong keylen)
	{
		ushort key = _key;
		ushort[] keyhash = Arrays.InitializeWithDefaultInstances<ushort>(32);
		ushort[] pad = Arrays.InitializeWithDefaultInstances<ushort>(64);
		ulong i = new ulong();

		if (keylen > 64)
		{
			blake256_hash(keyhash, key, new ulong(keylen));
			key = keyhash;
			keylen = 32;
		}

		blake256_init(S.inner);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(pad, 0x36, 64);
		for (i = 0; i < keylen; ++i)
		{
			pad[i] ^= key[i];
		}
		blake256_update(S.inner, pad, 512);

		blake256_init(S.outer);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(pad, 0x5c, 64);
		for (i = 0; i < keylen; ++i)
		{
			pad[i] ^= key[i];
		}
		blake256_update(S.outer, pad, 512);

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(keyhash, 0, 32);
	}

// keylen = number of bytes
	public static void hmac_blake224_init(hmac_state S, ushort _key, ulong keylen)
	{
		ushort key = _key;
		ushort[] keyhash = Arrays.InitializeWithDefaultInstances<ushort>(32);
		ushort[] pad = Arrays.InitializeWithDefaultInstances<ushort>(64);
		ulong i = new ulong();

		if (keylen > 64)
		{
			blake256_hash(keyhash, key, new ulong(keylen));
			key = keyhash;
			keylen = 28;
		}

		blake224_init(S.inner);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(pad, 0x36, 64);
		for (i = 0; i < keylen; ++i)
		{
			pad[i] ^= key[i];
		}
		blake224_update(S.inner, pad, 512);

		blake224_init(S.outer);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(pad, 0x5c, 64);
		for (i = 0; i < keylen; ++i)
		{
			pad[i] ^= key[i];
		}
		blake224_update(S.outer, pad, 512);

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(keyhash, 0, 32);
	}

// datalen = number of bits

	public static void hmac_blake256_update(hmac_state S, ushort data, ulong datalen)
	{
	  // update the inner state
	  blake256_update(S.inner, data, new ulong(datalen));
	}

// datalen = number of bits
	public static void hmac_blake224_update(hmac_state S, ushort data, ulong datalen)
	{
	  // update the inner state
	  blake224_update(S.inner, data, new ulong(datalen));
	}

	public static void hmac_blake256_final(hmac_state S, ushort digest)
	{
		ushort[] ihash = Arrays.InitializeWithDefaultInstances<ushort>(32);
		blake256_final(S.inner, ihash);
		blake256_update(S.outer, ihash, 256);
		blake256_final(S.outer, digest);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(ihash, 0, 32);
	}
	public static void hmac_blake224_final(hmac_state S, ushort digest)
	{
		ushort[] ihash = Arrays.InitializeWithDefaultInstances<ushort>(32);
		blake224_final(S.inner, ihash);
		blake224_update(S.outer, ihash, 224);
		blake224_final(S.outer, digest);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(ihash, 0, 32);
	}

// keylen = number of bytes; inlen = number of bytes

	public static void hmac_blake256_hash(ushort @out, ushort key, ulong keylen, ushort in, ulong inlen)
	{
		hmac_state S = new hmac_state();
		hmac_blake256_init(S, key, new ulong(keylen));
		hmac_blake256_update(S, in, inlen * 8);
		hmac_blake256_final(S, @out);
	}

// keylen = number of bytes; inlen = number of bytes
	public static void hmac_blake224_hash(ushort @out, ushort key, ulong keylen, ushort in, ulong inlen)
	{
		hmac_state S = new hmac_state();
		hmac_blake224_init(S, key, new ulong(keylen));
		hmac_blake224_update(S, in, inlen * 8);
		hmac_blake224_final(S, @out);
	}



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define U8TO32(p) (((uint)((p)[0]) << 24) | ((uint)((p)[1]) << 16) | ((uint)((p)[2]) << 8) | ((uint)((p)[3]) ))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define U32TO8(p, v) (p)[0] = (ushort)((v) >> 24); (p)[1] = (ushort)((v) >> 16); (p)[2] = (ushort)((v) >> 8); (p)[3] = (ushort)((v) );

	public static readonly ushort[,] sigma =
	{
		{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
		{14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
		{11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
		{7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8},
		{9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13},
		{2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9},
		{12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11},
		{13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10},
		{6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5},
		{10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0},
		{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
		{14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
		{11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
		{7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8}
	};

	public static readonly uint[] cst = {0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344, 0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89, 0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C, 0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917};

	internal ushort[] padding = {0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};


	public static void blake256_compress(state S, ushort block)
	{
		uint[] v = Arrays.InitializeWithDefaultInstances<uint>(16);
		uint[] m = Arrays.InitializeWithDefaultInstances<uint>(16);
		uint i = new uint();

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ROT(x,n) (((x)<<(32-n))|((x)>>(n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(a,b,c,d,e) v[a] += (m[sigma[i][e]] ^ cst[sigma[i][e+1]]) + v[b]; v[d] = ROT(v[d] ^ v[a],16); v[c] += v[d]; v[b] = ROT(v[b] ^ v[c],12); v[a] += (m[sigma[i][e+1]] ^ cst[sigma[i][e]])+v[b]; v[d] = ROT(v[d] ^ v[a], 8); v[c] += v[d]; v[b] = ROT(v[b] ^ v[c], 7);

		for (i = 0; i < 16; ++i)
		{
			m[i] = (((uint)((block + i * 4)[0]) << 24) | ((uint)((block + i * 4)[1]) << 16) | ((uint)((block + i * 4)[2]) << 8) | ((uint)((block + i * 4)[3])));
		}
		for (i = 0; i < 8; ++i)
		{
			v[i] = S.h[i];
		}
		v[8] = S.s[0] ^ 0x243F6A88;
		v[9] = S.s[1] ^ 0x85A308D3;
		v[10] = S.s[2] ^ 0x13198A2E;
		v[11] = S.s[3] ^ 0x03707344;
		v[12] = 0xA4093822;
		v[13] = 0x299F31D0;
		v[14] = 0x082EFA98;
		v[15] = 0xEC4E6C89;

		if (S.nullt == 0)
		{
			v[12] ^= S.t[0];
			v[13] ^= S.t[0];
			v[14] ^= S.t[1];
			v[15] ^= S.t[1];
		}

		for (i = 0; i < 14; ++i)
		{
			v[0] += (m[sigma[i, 0]] ^ cst[sigma[i, 0 + 1]]) + v[4];
			v[12] = (((v[12] ^ v[0]) << (32 - 16)) | ((v[12] ^ v[0])>>(16)));
			v[8] += v[12];
			v[4] = (((v[4] ^ v[8]) << (32 - 12)) | ((v[4] ^ v[8])>>(12)));
			v[0] += (m[sigma[i, 0 + 1]] ^ cst[sigma[i, 0]]) + v[4];
			v[12] = (((v[12] ^ v[0]) << (32 - 8)) | ((v[12] ^ v[0])>>(8)));
			v[8] += v[12];
			v[4] = (((v[4] ^ v[8]) << (32 - 7)) | ((v[4] ^ v[8])>>(7)));
			v[1] += (m[sigma[i, 2]] ^ cst[sigma[i, 2 + 1]]) + v[5];
			v[13] = (((v[13] ^ v[1]) << (32 - 16)) | ((v[13] ^ v[1])>>(16)));
			v[9] += v[13];
			v[5] = (((v[5] ^ v[9]) << (32 - 12)) | ((v[5] ^ v[9])>>(12)));
			v[1] += (m[sigma[i, 2 + 1]] ^ cst[sigma[i, 2]]) + v[5];
			v[13] = (((v[13] ^ v[1]) << (32 - 8)) | ((v[13] ^ v[1])>>(8)));
			v[9] += v[13];
			v[5] = (((v[5] ^ v[9]) << (32 - 7)) | ((v[5] ^ v[9])>>(7)));
			v[2] += (m[sigma[i, 4]] ^ cst[sigma[i, 4 + 1]]) + v[6];
			v[14] = (((v[14] ^ v[2]) << (32 - 16)) | ((v[14] ^ v[2])>>(16)));
			v[10] += v[14];
			v[6] = (((v[6] ^ v[10]) << (32 - 12)) | ((v[6] ^ v[10])>>(12)));
			v[2] += (m[sigma[i, 4 + 1]] ^ cst[sigma[i, 4]]) + v[6];
			v[14] = (((v[14] ^ v[2]) << (32 - 8)) | ((v[14] ^ v[2])>>(8)));
			v[10] += v[14];
			v[6] = (((v[6] ^ v[10]) << (32 - 7)) | ((v[6] ^ v[10])>>(7)));
			v[3] += (m[sigma[i, 6]] ^ cst[sigma[i, 6 + 1]]) + v[7];
			v[15] = (((v[15] ^ v[3]) << (32 - 16)) | ((v[15] ^ v[3])>>(16)));
			v[11] += v[15];
			v[7] = (((v[7] ^ v[11]) << (32 - 12)) | ((v[7] ^ v[11])>>(12)));
			v[3] += (m[sigma[i, 6 + 1]] ^ cst[sigma[i, 6]]) + v[7];
			v[15] = (((v[15] ^ v[3]) << (32 - 8)) | ((v[15] ^ v[3])>>(8)));
			v[11] += v[15];
			v[7] = (((v[7] ^ v[11]) << (32 - 7)) | ((v[7] ^ v[11])>>(7)));
			v[3] += (m[sigma[i, 14]] ^ cst[sigma[i, 14 + 1]]) + v[4];
			v[14] = (((v[14] ^ v[3]) << (32 - 16)) | ((v[14] ^ v[3])>>(16)));
			v[9] += v[14];
			v[4] = (((v[4] ^ v[9]) << (32 - 12)) | ((v[4] ^ v[9])>>(12)));
			v[3] += (m[sigma[i, 14 + 1]] ^ cst[sigma[i, 14]]) + v[4];
			v[14] = (((v[14] ^ v[3]) << (32 - 8)) | ((v[14] ^ v[3])>>(8)));
			v[9] += v[14];
			v[4] = (((v[4] ^ v[9]) << (32 - 7)) | ((v[4] ^ v[9])>>(7)));
			v[2] += (m[sigma[i, 12]] ^ cst[sigma[i, 12 + 1]]) + v[7];
			v[13] = (((v[13] ^ v[2]) << (32 - 16)) | ((v[13] ^ v[2])>>(16)));
			v[8] += v[13];
			v[7] = (((v[7] ^ v[8]) << (32 - 12)) | ((v[7] ^ v[8])>>(12)));
			v[2] += (m[sigma[i, 12 + 1]] ^ cst[sigma[i, 12]]) + v[7];
			v[13] = (((v[13] ^ v[2]) << (32 - 8)) | ((v[13] ^ v[2])>>(8)));
			v[8] += v[13];
			v[7] = (((v[7] ^ v[8]) << (32 - 7)) | ((v[7] ^ v[8])>>(7)));
			v[0] += (m[sigma[i, 8]] ^ cst[sigma[i, 8 + 1]]) + v[5];
			v[15] = (((v[15] ^ v[0]) << (32 - 16)) | ((v[15] ^ v[0])>>(16)));
			v[10] += v[15];
			v[5] = (((v[5] ^ v[10]) << (32 - 12)) | ((v[5] ^ v[10])>>(12)));
			v[0] += (m[sigma[i, 8 + 1]] ^ cst[sigma[i, 8]]) + v[5];
			v[15] = (((v[15] ^ v[0]) << (32 - 8)) | ((v[15] ^ v[0])>>(8)));
			v[10] += v[15];
			v[5] = (((v[5] ^ v[10]) << (32 - 7)) | ((v[5] ^ v[10])>>(7)));
			v[1] += (m[sigma[i, 10]] ^ cst[sigma[i, 10 + 1]]) + v[6];
			v[12] = (((v[12] ^ v[1]) << (32 - 16)) | ((v[12] ^ v[1])>>(16)));
			v[11] += v[12];
			v[6] = (((v[6] ^ v[11]) << (32 - 12)) | ((v[6] ^ v[11])>>(12)));
			v[1] += (m[sigma[i, 10 + 1]] ^ cst[sigma[i, 10]]) + v[6];
			v[12] = (((v[12] ^ v[1]) << (32 - 8)) | ((v[12] ^ v[1])>>(8)));
			v[11] += v[12];
			v[6] = (((v[6] ^ v[11]) << (32 - 7)) | ((v[6] ^ v[11])>>(7)));
		}

		for (i = 0; i < 16; ++i)
		{
			S.h[i % 8] ^= v[i];
		}
		for (i = 0; i < 8; ++i)
		{
			S.h[i] ^= S.s[i % 4];
		}
	}

	public static void blake256_final_h(state S, ushort digest, ushort pa, ushort pb)
	{
		ushort[] msglen = Arrays.InitializeWithDefaultInstances<ushort>(8);
		uint lo = S.t[0] + S.buflen;
		uint hi = S.t[1];
		if (lo < (uint) S.buflen)
		{
			hi++;
		}
		(msglen + 0)[0] = (ushort)((hi) >> 24);
		(msglen + 0)[1] = (ushort)((hi) >> 16);
		(msglen + 0)[2] = (ushort)((hi) >> 8);
		(msglen + 0)[3] = (ushort)((hi));
		(msglen + 4)[0] = (ushort)((lo) >> 24);
		(msglen + 4)[1] = (ushort)((lo) >> 16);
		(msglen + 4)[2] = (ushort)((lo) >> 8);
		(msglen + 4)[3] = (ushort)((lo));

		if (S.buflen == 440)
		{ // one padding byte
			S.t[0] -= 8;
			blake256_update(S, pa, 8);
		}
		else
		{
			if (S.buflen < 440)
			{ // enough space to fill the block
				if (S.buflen == 0)
				{
					S.nullt = 1;
				}
				S.t[0] -= 440 - S.buflen;
				blake256_update(S, padding, 440 - S.buflen);
			}
			else
			{ // need 2 compressions
				S.t[0] -= 512 - S.buflen;
				blake256_update(S, padding, 512 - S.buflen);
				S.t[0] -= 440;
				blake256_update(S, padding + 1, 440);
				S.nullt = 1;
			}
			blake256_update(S, pb, 8);
			S.t[0] -= 8;
		}
		S.t[0] -= 64;
		blake256_update(S, msglen, 64);

		(digest + 0)[0] = (ushort)((S.h[0]) >> 24);
		(digest + 0)[1] = (ushort)((S.h[0]) >> 16);
		(digest + 0)[2] = (ushort)((S.h[0]) >> 8);
		(digest + 0)[3] = (ushort)((S.h[0]));
		(digest + 4)[0] = (ushort)((S.h[1]) >> 24);
		(digest + 4)[1] = (ushort)((S.h[1]) >> 16);
		(digest + 4)[2] = (ushort)((S.h[1]) >> 8);
		(digest + 4)[3] = (ushort)((S.h[1]));
		(digest + 8)[0] = (ushort)((S.h[2]) >> 24);
		(digest + 8)[1] = (ushort)((S.h[2]) >> 16);
		(digest + 8)[2] = (ushort)((S.h[2]) >> 8);
		(digest + 8)[3] = (ushort)((S.h[2]));
		(digest + 12)[0] = (ushort)((S.h[3]) >> 24);
		(digest + 12)[1] = (ushort)((S.h[3]) >> 16);
		(digest + 12)[2] = (ushort)((S.h[3]) >> 8);
		(digest + 12)[3] = (ushort)((S.h[3]));
		(digest + 16)[0] = (ushort)((S.h[4]) >> 24);
		(digest + 16)[1] = (ushort)((S.h[4]) >> 16);
		(digest + 16)[2] = (ushort)((S.h[4]) >> 8);
		(digest + 16)[3] = (ushort)((S.h[4]));
		(digest + 20)[0] = (ushort)((S.h[5]) >> 24);
		(digest + 20)[1] = (ushort)((S.h[5]) >> 16);
		(digest + 20)[2] = (ushort)((S.h[5]) >> 8);
		(digest + 20)[3] = (ushort)((S.h[5]));
		(digest + 24)[0] = (ushort)((S.h[6]) >> 24);
		(digest + 24)[1] = (ushort)((S.h[6]) >> 16);
		(digest + 24)[2] = (ushort)((S.h[6]) >> 8);
		(digest + 24)[3] = (ushort)((S.h[6]));
		(digest + 28)[0] = (ushort)((S.h[7]) >> 24);
		(digest + 28)[1] = (ushort)((S.h[7]) >> 16);
		(digest + 28)[2] = (ushort)((S.h[7]) >> 8);
		(digest + 28)[3] = (ushort)((S.h[7]));
	}


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define inline __inline
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IDENT32(x) ((uint) (x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IDENT64(x) ((ulong) (x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32(x) ((((uint) (x) & 0x000000ff) << 24) | (((uint) (x) & 0x0000ff00) << 8) | (((uint) (x) & 0x00ff0000) >> 8) | (((uint) (x) & 0xff000000) >> 24))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64(x) ((((ulong) (x) & 0x00000000000000ff) << 56) | (((ulong) (x) & 0x000000000000ff00) << 40) | (((ulong) (x) & 0x0000000000ff0000) << 24) | (((ulong) (x) & 0x00000000ff000000) << 8) | (((ulong) (x) & 0x000000ff00000000) >> 8) | (((ulong) (x) & 0x0000ff0000000000) >> 24) | (((ulong) (x) & 0x00ff000000000000) >> 40) | (((ulong) (x) & 0xff00000000000000) >> 56))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32LE IDENT32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32BE SWAP32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32le ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32be swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32le mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32be mem_inplace_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32le memcpy_ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32be memcpy_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64LE IDENT64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64BE SWAP64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64le ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64be swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64le mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64be mem_inplace_swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64le memcpy_ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64be memcpy_swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32BE IDENT32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32LE SWAP32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32be ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32le swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32be mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32le mem_inplace_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32be memcpy_ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32le memcpy_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64BE IDENT64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64LE SWAP64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64be ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64le swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64be mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64le mem_inplace_swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64be memcpy_ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64le memcpy_swap64

	/*
	 * The following macros are used to obtain exact-width results.
	 */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define U8V(v) ((ushort)(v) & UINT8_C(0xFF))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define U32V(v) ((uint)(v) & UINT32_C(0xFFFFFFFF))

	/*
	 * The following macros load words from an array of bytes with
	 * different types of endianness, and vice versa.
	 */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define U8TO32_LITTLE(p) SWAP32LE(((uint*)(p))[0])
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define U32TO8_LITTLE(p, v) (((uint*)(p))[0] = SWAP32LE(v))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ROTATE(v,c) (rol32(v,c))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define XOR(v,w) ((v) ^ (w))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define PLUS(v,w) (U32V((v) + (w)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define PLUSONE(v) (PLUS((v),1))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define QUARTERROUND(a,b,c,d) a = PLUS(a,b); d = ROTATE(XOR(d,a),16); c = PLUS(c,d); b = ROTATE(XOR(b,c),12); a = PLUS(a,b); d = ROTATE(XOR(d,a), 8); c = PLUS(c,d); b = ROTATE(XOR(b,c), 7);

	internal const string sigma = "expand 32-byte k";


/* From ge_add.c */


	/* From ge_add.c */

	public static void ge_add(ge_p1p1 r, ge_p3 p, ge_cached q)
	{
	  int[] t0 = Arrays.InitializeWithDefaultInstances<int>(10);
	  fe_add(r.X, p.Y, p.X);
	  fe_sub(r.Y, p.Y, p.X);
	  fe_mul(r.Z, r.X, q.YplusX);
	  fe_mul(r.Y, r.Y, q.YminusX);
	  fe_mul(r.T, q.T2d, p.T);
	  fe_mul(r.X, p.Z, q.Z);
	  fe_add(t0, r.X, r.X);
	  fe_sub(r.X, r.Z, r.Y);
	  fe_add(r.Y, r.Z, r.Y);
	  fe_add(r.Z, t0, r.T);
	  fe_sub(r.T, t0, r.T);
	}

	/* From ge_double_scalarmult.c, modified */

//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const ge_precomp ge_Bi[8];
	public static void ge_dsm_precomp(ge_cached[] r, ge_p3 s)
	{
	  ge_p1p1 t = new ge_p1p1();
	  ge_p3 s2 = new ge_p3();
	  ge_p3 u = new ge_p3();
	  ge_p3_to_cached(r[0], s);
	  ge_p3_dbl(t, s);
	  ge_p1p1_to_p3(s2, t);
	  ge_add(t, s2, r[0]);
	  ge_p1p1_to_p3(u, t);
	  ge_p3_to_cached(r[1], u);
	  ge_add(t, s2, r[1]);
	  ge_p1p1_to_p3(u, t);
	  ge_p3_to_cached(r[2], u);
	  ge_add(t, s2, r[2]);
	  ge_p1p1_to_p3(u, t);
	  ge_p3_to_cached(r[3], u);
	  ge_add(t, s2, r[3]);
	  ge_p1p1_to_p3(u, t);
	  ge_p3_to_cached(r[4], u);
	  ge_add(t, s2, r[4]);
	  ge_p1p1_to_p3(u, t);
	  ge_p3_to_cached(r[5], u);
	  ge_add(t, s2, r[5]);
	  ge_p1p1_to_p3(u, t);
	  ge_p3_to_cached(r[6], u);
	  ge_add(t, s2, r[6]);
	  ge_p1p1_to_p3(u, t);
	  ge_p3_to_cached(r[7], u);
	}

/*
r = a * A + b * B
where a = a[0]+256*a[1]+...+256^31 a[31].
and b = b[0]+256*b[1]+...+256^31 b[31].
B is the Ed25519 base point (x,4/5) with x positive.
*/

	public static void ge_double_scalarmult_base_vartime(ge_p2 r, byte a, ge_p3 A, byte b)
	{
	  string aslide = new string(new char[256]);
	  string bslide = new string(new char[256]);
	  ge_cached[] Ai = Arrays.InitializeWithDefaultInstances<ge_cached>(8); // A, 3A, 5A, 7A, 9A, 11A, 13A, 15A
	  ge_p1p1 t = new ge_p1p1();
	  ge_p3 u = new ge_p3();
	  int i;

	  slide(ref aslide, a);
	  slide(ref bslide, b);
	  ge_dsm_precomp(Ai, A);

	  ge_p2_0(r);

	  for (i = 255; i >= 0; --i)
	  {
		if (aslide[i] || bslide[i])
		{
			break;
		}
	  }

	  for (; i >= 0; --i)
	  {
		ge_p2_dbl(t, r);

		if (aslide[i] > 0)
		{
		  ge_p1p1_to_p3(u, t);
		  ge_add(t, u, Ai[aslide[i] / 2]);
		}
		else if (aslide[i] < 0)
		{
		  ge_p1p1_to_p3(u, t);
		  ge_sub(t, u, Ai[(-aslide[i]) / 2]);
		}

		if (bslide[i] > 0)
		{
		  ge_p1p1_to_p3(u, t);
		  ge_madd(t, u, ge_Bi[bslide[i] / 2]);
		}
		else if (bslide[i] < 0)
		{
		  ge_p1p1_to_p3(u, t);
		  ge_msub(t, u, ge_Bi[(-bslide[i]) / 2]);
		}

		ge_p1p1_to_p2(r, t);
	  }
	}

	/* From ge_frombytes.c, modified */

//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const int fe_sqrtm1[10];
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const int fe_d[10];

/* From ge_frombytes.c, modified */

	public static int ge_frombytes_vartime(ge_p3 h, byte[] s)
	{
	  int[] u = Arrays.InitializeWithDefaultInstances<int>(10);
	  int[] v = Arrays.InitializeWithDefaultInstances<int>(10);
	  int[] vxx = Arrays.InitializeWithDefaultInstances<int>(10);
	  int[] check = Arrays.InitializeWithDefaultInstances<int>(10);

	  /* From fe_frombytes.c */

	  long h0 = load_4(s);
	  long h1 = load_3(s + 4) << 6;
	  long h2 = load_3(s + 7) << 5;
	  long h3 = load_3(s + 10) << 3;
	  long h4 = load_3(s + 13) << 2;
	  long h5 = load_4(s + 16);
	  long h6 = load_3(s + 20) << 7;
	  long h7 = load_3(s + 23) << 5;
	  long h8 = load_3(s + 26) << 4;
	  long h9 = (load_3(s + 29) & 8388607) << 2;
	  long carry0 = new long();
	  long carry1 = new long();
	  long carry2 = new long();
	  long carry3 = new long();
	  long carry4 = new long();
	  long carry5 = new long();
	  long carry6 = new long();
	  long carry7 = new long();
	  long carry8 = new long();
	  long carry9 = new long();

	  /* Validate the number to be canonical */
	  if (h9 == 33554428 && h8 == 268435440 && h7 == 536870880 && h6 == 2147483520 && h5 == 4294967295 && h4 == 67108860 && h3 == 134217720 && h2 == 536870880 && h1 == 1073741760 && h0 >= 4294967277)
	  {
		return -1;
	  }

	  carry9 = (h9 + (long)(1 << 24)) >> 25;
	  h0 += carry9 * 19;
	  h9 -= carry9 << 25;
	  carry1 = (h1 + (long)(1 << 24)) >> 25;
	  h2 += carry1;
	  h1 -= carry1 << 25;
	  carry3 = (h3 + (long)(1 << 24)) >> 25;
	  h4 += carry3;
	  h3 -= carry3 << 25;
	  carry5 = (h5 + (long)(1 << 24)) >> 25;
	  h6 += carry5;
	  h5 -= carry5 << 25;
	  carry7 = (h7 + (long)(1 << 24)) >> 25;
	  h8 += carry7;
	  h7 -= carry7 << 25;

	  carry0 = (h0 + (long)(1 << 25)) >> 26;
	  h1 += carry0;
	  h0 -= carry0 << 26;
	  carry2 = (h2 + (long)(1 << 25)) >> 26;
	  h3 += carry2;
	  h2 -= carry2 << 26;
	  carry4 = (h4 + (long)(1 << 25)) >> 26;
	  h5 += carry4;
	  h4 -= carry4 << 26;
	  carry6 = (h6 + (long)(1 << 25)) >> 26;
	  h7 += carry6;
	  h6 -= carry6 << 26;
	  carry8 = (h8 + (long)(1 << 25)) >> 26;
	  h9 += carry8;
	  h8 -= carry8 << 26;

	  h.Y[0] = (int) h0;
	  h.Y[1] = (int) h1;
	  h.Y[2] = (int) h2;
	  h.Y[3] = (int) h3;
	  h.Y[4] = (int) h4;
	  h.Y[5] = (int) h5;
	  h.Y[6] = (int) h6;
	  h.Y[7] = (int) h7;
	  h.Y[8] = (int) h8;
	  h.Y[9] = (int) h9;

	  /* End fe_frombytes.c */

	  fe_1(h.Z);
	  fe_sq(u, h.Y);
	  fe_mul(v, u, fe_d);
	  fe_sub(u, u, h.Z); // u = y^2-1
	  fe_add(v, v, h.Z); // v = dy^2+1

	  fe_divpowm1(h.X, u, v); // x = uv^3(uv^7)^((q-5)/8)

	  fe_sq(vxx, h.X);
	  fe_mul(vxx, vxx, v);
	  fe_sub(check, vxx, u); // vx^2-u
	  if (fe_isnonzero(check) != 0)
	  {
		fe_add(check, vxx, u); // vx^2+u
		if (fe_isnonzero(check) != 0)
		{
		  return -1;
		}
		fe_mul(h.X, h.X, fe_sqrtm1);
	  }

	  if (fe_isnegative(h.X) != (s[31] >> 7))
	  {
		/* If x = 0, the sign must be positive */
		if (fe_isnonzero(h.X) == 0)
		{
		  return -1;
		}
		fe_neg(h.X, h.X);
	  }

	  fe_mul(h.T, h.X, h.Y);
	  return 0;
	}

/* From ge_p1p1_to_p2.c */

/*
r = p
*/


	/* From ge_p1p1_to_p2.c */

	public static void ge_p1p1_to_p2(ge_p2 r, ge_p1p1 p)
	{
	  fe_mul(r.X, p.X, p.T);
	  fe_mul(r.Y, p.Y, p.Z);
	  fe_mul(r.Z, p.Z, p.T);
	}

/* From ge_p1p1_to_p3.c */

/*
r = p
*/


	/* From ge_p1p1_to_p3.c */

	public static void ge_p1p1_to_p3(ge_p3 r, ge_p1p1 p)
	{
	  fe_mul(r.X, p.X, p.T);
	  fe_mul(r.Y, p.Y, p.Z);
	  fe_mul(r.Z, p.Z, p.T);
	  fe_mul(r.T, p.X, p.Y);
	}

/* From ge_p2_dbl.c */

/*
r = 2 * p
*/


	/* From ge_p2_dbl.c */

	public static void ge_p2_dbl(ge_p1p1 r, ge_p2 p)
	{
	  int[] t0 = Arrays.InitializeWithDefaultInstances<int>(10);
	  fe_sq(r.X, p.X);
	  fe_sq(r.Z, p.Y);
	  fe_sq2(r.T, p.Z);
	  fe_add(r.Y, p.X, p.Y);
	  fe_sq(t0, r.Y);
	  fe_add(r.Y, r.Z, r.X);
	  fe_sub(r.Z, r.Z, r.X);
	  fe_sub(r.X, t0, r.Y);
	  fe_sub(r.T, r.T, r.Z);
	}

	/* From ge_p3_to_cached.c */

//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const int fe_d2[10];

/* From ge_p3_to_cached.c */

/*
r = p
*/

	public static void ge_p3_to_cached(ge_cached r, ge_p3 p)
	{
	  fe_add(r.YplusX, p.Y, p.X);
	  fe_sub(r.YminusX, p.Y, p.X);
	  fe_copy(r.Z, p.Z);
	  fe_mul(r.T2d, p.T, fe_d2);
	}

/* From ge_p3_to_p2.c */

/*
r = p
*/


	/* From ge_p3_to_p2.c */

	public static void ge_p3_to_p2(ge_p2 r, ge_p3 p)
	{
	  fe_copy(r.X, p.X);
	  fe_copy(r.Y, p.Y);
	  fe_copy(r.Z, p.Z);
	}

/* From ge_p3_tobytes.c */


	/* From ge_p3_tobytes.c */

	public static void ge_p3_tobytes(byte[] s, ge_p3 h)
	{
	  int[] recip = Arrays.InitializeWithDefaultInstances<int>(10);
	  int[] x = Arrays.InitializeWithDefaultInstances<int>(10);
	  int[] y = Arrays.InitializeWithDefaultInstances<int>(10);

	  fe_invert(recip, h.Z);
	  fe_mul(x, h.X, recip);
	  fe_mul(y, h.Y, recip);
	  fe_tobytes(s, y);
	  s[31] ^= fe_isnegative(x) << 7;
	}

	/* From ge_scalarmult_base.c */

//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const ge_precomp ge_base[32][8];

/*
h = a * B
where a = a[0]+256*a[1]+...+256^31 a[31]
B is the Ed25519 base point (x,4/5) with x positive.

Preconditions:
  a[31] <= 127
*/

	public static void ge_scalarmult_base(ge_p3 h, byte[] a)
	{
	  string e = new string(new char[64]);
	  char carry;
	  ge_p1p1 r = new ge_p1p1();
	  ge_p2 s = new ge_p2();
	  ge_precomp t = new ge_precomp();
	  int i;

	  for (i = 0; i < 32; ++i)
	  {
		e = StringFunctions.ChangeCharacter(e, 2 * i + 0, (a[i] >> 0) & 15);
		e = StringFunctions.ChangeCharacter(e, 2 * i + 1, (a[i] >> 4) & 15);
	  }
	  /* each e[i] is between 0 and 15 */
	  /* e[63] is between 0 and 7 */

	  carry = 0;
	  for (i = 0; i < 63; ++i)
	  {
		e[i] += carry;
		carry = e[i] + 8;
		carry >>= 4;
		e[i] -= carry << 4;
	  }
	  e[63] += carry;
	  /* each e[i] is between -8 and 8 */

	  ge_p3_0(h);
	  for (i = 1; i < 64; i += 2)
	  {
		select(t, i / 2, e[i]);
		ge_madd(r, h, t);
		ge_p1p1_to_p3(h, r);
	  }

	  ge_p3_dbl(r, h);
	  ge_p1p1_to_p2(s, r);
	  ge_p2_dbl(r, s);
	  ge_p1p1_to_p2(s, r);
	  ge_p2_dbl(r, s);
	  ge_p1p1_to_p2(s, r);
	  ge_p2_dbl(r, s);
	  ge_p1p1_to_p3(h, r);

	  for (i = 0; i < 64; i += 2)
	  {
		select(t, i / 2, e[i]);
		ge_madd(r, h, t);
		ge_p1p1_to_p3(h, r);
	  }
	}

/* From ge_sub.c */

/*
r = p - q
*/


	/* From ge_sub.c */

	public static void ge_sub(ge_p1p1 r, ge_p3 p, ge_cached q)
	{
	  int[] t0 = Arrays.InitializeWithDefaultInstances<int>(10);
	  fe_add(r.X, p.Y, p.X);
	  fe_sub(r.Y, p.Y, p.X);
	  fe_mul(r.Z, r.X, q.YminusX);
	  fe_mul(r.Y, r.Y, q.YplusX);
	  fe_mul(r.T, q.T2d, p.T);
	  fe_mul(r.X, p.Z, q.Z);
	  fe_add(t0, r.X, r.X);
	  fe_sub(r.X, r.Z, r.Y);
	  fe_add(r.Y, r.Z, r.Y);
	  fe_sub(r.Z, t0, r.T);
	  fe_add(r.T, t0, r.T);
	}

/* From ge_tobytes.c */


	/* From ge_tobytes.c */

	public static void ge_tobytes(byte[] s, ge_p2 h)
	{
	  int[] recip = Arrays.InitializeWithDefaultInstances<int>(10);
	  int[] x = Arrays.InitializeWithDefaultInstances<int>(10);
	  int[] y = Arrays.InitializeWithDefaultInstances<int>(10);

	  fe_invert(recip, h.Z);
	  fe_mul(x, h.X, recip);
	  fe_mul(y, h.Y, recip);
	  fe_tobytes(s, y);
	  s[31] ^= fe_isnegative(x) << 7;
	}

/* From sc_reduce.c */

/*
Input:
  s[0]+256*s[1]+...+256^63*s[63] = s

Output:
  s[0]+256*s[1]+...+256^31*s[31] = s mod l
  where l = 2^252 + 27742317777372353535851937790883648493.
  Overwrites s in place.
*/


	/* From sc_reduce.c */

	public static void sc_reduce(byte[] s)
	{
	  long s0 = 2097151 & load_3(s);
	  long s1 = 2097151 & (load_4(s + 2) >> 5);
	  long s2 = 2097151 & (load_3(s + 5) >> 2);
	  long s3 = 2097151 & (load_4(s + 7) >> 7);
	  long s4 = 2097151 & (load_4(s + 10) >> 4);
	  long s5 = 2097151 & (load_3(s + 13) >> 1);
	  long s6 = 2097151 & (load_4(s + 15) >> 6);
	  long s7 = 2097151 & (load_3(s + 18) >> 3);
	  long s8 = 2097151 & load_3(s + 21);
	  long s9 = 2097151 & (load_4(s + 23) >> 5);
	  long s10 = 2097151 & (load_3(s + 26) >> 2);
	  long s11 = 2097151 & (load_4(s + 28) >> 7);
	  long s12 = 2097151 & (load_4(s + 31) >> 4);
	  long s13 = 2097151 & (load_3(s + 34) >> 1);
	  long s14 = 2097151 & (load_4(s + 36) >> 6);
	  long s15 = 2097151 & (load_3(s + 39) >> 3);
	  long s16 = 2097151 & load_3(s + 42);
	  long s17 = 2097151 & (load_4(s + 44) >> 5);
	  long s18 = 2097151 & (load_3(s + 47) >> 2);
	  long s19 = 2097151 & (load_4(s + 49) >> 7);
	  long s20 = 2097151 & (load_4(s + 52) >> 4);
	  long s21 = 2097151 & (load_3(s + 55) >> 1);
	  long s22 = 2097151 & (load_4(s + 57) >> 6);
	  long s23 = (load_4(s + 60) >> 3);
	  long carry0 = new long();
	  long carry1 = new long();
	  long carry2 = new long();
	  long carry3 = new long();
	  long carry4 = new long();
	  long carry5 = new long();
	  long carry6 = new long();
	  long carry7 = new long();
	  long carry8 = new long();
	  long carry9 = new long();
	  long carry10 = new long();
	  long carry11 = new long();
	  long carry12 = new long();
	  long carry13 = new long();
	  long carry14 = new long();
	  long carry15 = new long();
	  long carry16 = new long();

	  s11 += s23 * 666643;
	  s12 += s23 * 470296;
	  s13 += s23 * 654183;
	  s14 -= s23 * 997805;
	  s15 += s23 * 136657;
	  s16 -= s23 * 683901;

	  s10 += s22 * 666643;
	  s11 += s22 * 470296;
	  s12 += s22 * 654183;
	  s13 -= s22 * 997805;
	  s14 += s22 * 136657;
	  s15 -= s22 * 683901;

	  s9 += s21 * 666643;
	  s10 += s21 * 470296;
	  s11 += s21 * 654183;
	  s12 -= s21 * 997805;
	  s13 += s21 * 136657;
	  s14 -= s21 * 683901;

	  s8 += s20 * 666643;
	  s9 += s20 * 470296;
	  s10 += s20 * 654183;
	  s11 -= s20 * 997805;
	  s12 += s20 * 136657;
	  s13 -= s20 * 683901;

	  s7 += s19 * 666643;
	  s8 += s19 * 470296;
	  s9 += s19 * 654183;
	  s10 -= s19 * 997805;
	  s11 += s19 * 136657;
	  s12 -= s19 * 683901;

	  s6 += s18 * 666643;
	  s7 += s18 * 470296;
	  s8 += s18 * 654183;
	  s9 -= s18 * 997805;
	  s10 += s18 * 136657;
	  s11 -= s18 * 683901;

	  carry6 = (s6 + (1 << 20)) >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry8 = (s8 + (1 << 20)) >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry10 = (s10 + (1 << 20)) >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;
	  carry12 = (s12 + (1 << 20)) >> 21;
	  s13 += carry12;
	  s12 -= carry12 << 21;
	  carry14 = (s14 + (1 << 20)) >> 21;
	  s15 += carry14;
	  s14 -= carry14 << 21;
	  carry16 = (s16 + (1 << 20)) >> 21;
	  s17 += carry16;
	  s16 -= carry16 << 21;

	  carry7 = (s7 + (1 << 20)) >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry9 = (s9 + (1 << 20)) >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry11 = (s11 + (1 << 20)) >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;
	  carry13 = (s13 + (1 << 20)) >> 21;
	  s14 += carry13;
	  s13 -= carry13 << 21;
	  carry15 = (s15 + (1 << 20)) >> 21;
	  s16 += carry15;
	  s15 -= carry15 << 21;

	  s5 += s17 * 666643;
	  s6 += s17 * 470296;
	  s7 += s17 * 654183;
	  s8 -= s17 * 997805;
	  s9 += s17 * 136657;
	  s10 -= s17 * 683901;

	  s4 += s16 * 666643;
	  s5 += s16 * 470296;
	  s6 += s16 * 654183;
	  s7 -= s16 * 997805;
	  s8 += s16 * 136657;
	  s9 -= s16 * 683901;

	  s3 += s15 * 666643;
	  s4 += s15 * 470296;
	  s5 += s15 * 654183;
	  s6 -= s15 * 997805;
	  s7 += s15 * 136657;
	  s8 -= s15 * 683901;

	  s2 += s14 * 666643;
	  s3 += s14 * 470296;
	  s4 += s14 * 654183;
	  s5 -= s14 * 997805;
	  s6 += s14 * 136657;
	  s7 -= s14 * 683901;

	  s1 += s13 * 666643;
	  s2 += s13 * 470296;
	  s3 += s13 * 654183;
	  s4 -= s13 * 997805;
	  s5 += s13 * 136657;
	  s6 -= s13 * 683901;

	  s0 += s12 * 666643;
	  s1 += s12 * 470296;
	  s2 += s12 * 654183;
	  s3 -= s12 * 997805;
	  s4 += s12 * 136657;
	  s5 -= s12 * 683901;
	  s12 = 0;

	  carry0 = (s0 + (1 << 20)) >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry2 = (s2 + (1 << 20)) >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry4 = (s4 + (1 << 20)) >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry6 = (s6 + (1 << 20)) >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry8 = (s8 + (1 << 20)) >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry10 = (s10 + (1 << 20)) >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;

	  carry1 = (s1 + (1 << 20)) >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry3 = (s3 + (1 << 20)) >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry5 = (s5 + (1 << 20)) >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry7 = (s7 + (1 << 20)) >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry9 = (s9 + (1 << 20)) >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry11 = (s11 + (1 << 20)) >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;

	  s0 += s12 * 666643;
	  s1 += s12 * 470296;
	  s2 += s12 * 654183;
	  s3 -= s12 * 997805;
	  s4 += s12 * 136657;
	  s5 -= s12 * 683901;
	  s12 = 0;

	  carry0 = s0 >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry1 = s1 >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry2 = s2 >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry3 = s3 >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry4 = s4 >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry5 = s5 >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry6 = s6 >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry7 = s7 >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry8 = s8 >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry9 = s9 >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry10 = s10 >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;
	  carry11 = s11 >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;

	  s0 += s12 * 666643;
	  s1 += s12 * 470296;
	  s2 += s12 * 654183;
	  s3 -= s12 * 997805;
	  s4 += s12 * 136657;
	  s5 -= s12 * 683901;

	  carry0 = s0 >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry1 = s1 >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry2 = s2 >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry3 = s3 >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry4 = s4 >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry5 = s5 >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry6 = s6 >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry7 = s7 >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry8 = s8 >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry9 = s9 >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry10 = s10 >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;

	  s[0] = (byte)(s0 >> 0);
	  s[1] = (byte)(s0 >> 8);
	  s[2] = (byte)((s0 >> 16) | (s1 << 5));
	  s[3] = (byte)(s1 >> 3);
	  s[4] = (byte)(s1 >> 11);
	  s[5] = (byte)((s1 >> 19) | (s2 << 2));
	  s[6] = (byte)(s2 >> 6);
	  s[7] = (byte)((s2 >> 14) | (s3 << 7));
	  s[8] = (byte)(s3 >> 1);
	  s[9] = (byte)(s3 >> 9);
	  s[10] = (byte)((s3 >> 17) | (s4 << 4));
	  s[11] = (byte)(s4 >> 4);
	  s[12] = (byte)(s4 >> 12);
	  s[13] = (byte)((s4 >> 20) | (s5 << 1));
	  s[14] = (byte)(s5 >> 7);
	  s[15] = (byte)((s5 >> 15) | (s6 << 6));
	  s[16] = (byte)(s6 >> 2);
	  s[17] = (byte)(s6 >> 10);
	  s[18] = (byte)((s6 >> 18) | (s7 << 3));
	  s[19] = (byte)(s7 >> 5);
	  s[20] = (byte)(s7 >> 13);
	  s[21] = (byte)(s8 >> 0);
	  s[22] = (byte)(s8 >> 8);
	  s[23] = (byte)((s8 >> 16) | (s9 << 5));
	  s[24] = (byte)(s9 >> 3);
	  s[25] = (byte)(s9 >> 11);
	  s[26] = (byte)((s9 >> 19) | (s10 << 2));
	  s[27] = (byte)(s10 >> 6);
	  s[28] = (byte)((s10 >> 14) | (s11 << 7));
	  s[29] = (byte)(s11 >> 1);
	  s[30] = (byte)(s11 >> 9);
	  s[31] = (byte)(s11 >> 17);
	}

/* Assumes that a[31] <= 127 */

	/* New code */

	public static void ge_scalarmult(ge_p2 r, byte[] a, ge_p3 A)
	{
	  string e = new string(new char[64]);
	  int carry;
	  int carry2;
	  int i;
	  ge_cached[] Ai = Arrays.InitializeWithDefaultInstances<ge_cached>(8); // 1 * A, 2 * A, ..., 8 * A
	  ge_p1p1 t = new ge_p1p1();
	  ge_p3 u = new ge_p3();

	  carry = 0; // 0..1
	  for (i = 0; i < 31; i++)
	  {
		carry += a[i]; // 0..256
		carry2 = (carry + 8) >> 4; // 0..16
		e = StringFunctions.ChangeCharacter(e, 2 * i, carry - (carry2 << 4)); // -8..7
		carry = (carry2 + 8) >> 4; // 0..1
		e = StringFunctions.ChangeCharacter(e, 2 * i + 1, carry2 - (carry << 4)); // -8..7
	  }
	  carry += a[31]; // 0..128
	  carry2 = (carry + 8) >> 4; // 0..8
	  e = StringFunctions.ChangeCharacter(e, 62, carry - (carry2 << 4)); // -8..7
	  e = StringFunctions.ChangeCharacter(e, 63, carry2); // 0..8

	  ge_p3_to_cached(Ai[0], A);
	  for (i = 0; i < 7; i++)
	  {
		ge_add(t, A, Ai[i]);
		ge_p1p1_to_p3(u, t);
		ge_p3_to_cached(Ai[i + 1], u);
	  }

	  ge_p2_0(r);
	  for (i = 63; i >= 0; i--)
	  {
		char b = e[i];
		byte bnegative = negative(b);
		byte babs = b - (((-bnegative) & b) << 1);
		ge_cached cur = new ge_cached();
		ge_cached minuscur = new ge_cached();
		ge_p2_dbl(t, r);
		ge_p1p1_to_p2(r, t);
		ge_p2_dbl(t, r);
		ge_p1p1_to_p2(r, t);
		ge_p2_dbl(t, r);
		ge_p1p1_to_p2(r, t);
		ge_p2_dbl(t, r);
		ge_p1p1_to_p3(u, t);
		ge_cached_0(cur);
		ge_cached_cmov(cur, Ai[0], equal(babs, 1));
		ge_cached_cmov(cur, Ai[1], equal(babs, 2));
		ge_cached_cmov(cur, Ai[2], equal(babs, 3));
		ge_cached_cmov(cur, Ai[3], equal(babs, 4));
		ge_cached_cmov(cur, Ai[4], equal(babs, 5));
		ge_cached_cmov(cur, Ai[5], equal(babs, 6));
		ge_cached_cmov(cur, Ai[6], equal(babs, 7));
		ge_cached_cmov(cur, Ai[7], equal(babs, 8));
		fe_copy(minuscur.YplusX, cur.YminusX);
		fe_copy(minuscur.YminusX, cur.YplusX);
		fe_copy(minuscur.Z, cur.Z);
		fe_neg(minuscur.T2d, cur.T2d);
		ge_cached_cmov(cur, minuscur, bnegative);
		ge_add(t, u, cur);
		ge_p1p1_to_p2(r, t);
	  }
	}
	public static void ge_double_scalarmult_precomp_vartime(ge_p2 r, byte a, ge_p3 A, byte b, ge_cached[] Bi)
	{
	  string aslide = new string(new char[256]);
	  string bslide = new string(new char[256]);
	  ge_cached[] Ai = Arrays.InitializeWithDefaultInstances<ge_cached>(8); // A, 3A, 5A, 7A, 9A, 11A, 13A, 15A
	  ge_p1p1 t = new ge_p1p1();
	  ge_p3 u = new ge_p3();
	  int i;

	  slide(ref aslide, a);
	  slide(ref bslide, b);
	  ge_dsm_precomp(Ai, A);

	  ge_p2_0(r);

	  for (i = 255; i >= 0; --i)
	  {
		if (aslide[i] || bslide[i])
		{
			break;
		}
	  }

	  for (; i >= 0; --i)
	  {
		ge_p2_dbl(t, r);

		if (aslide[i] > 0)
		{
		  ge_p1p1_to_p3(u, t);
		  ge_add(t, u, Ai[aslide[i] / 2]);
		}
		else if (aslide[i] < 0)
		{
		  ge_p1p1_to_p3(u, t);
		  ge_sub(t, u, Ai[(-aslide[i]) / 2]);
		}

		if (bslide[i] > 0)
		{
		  ge_p1p1_to_p3(u, t);
		  ge_add(t, u, Bi[bslide[i] / 2]);
		}
		else if (bslide[i] < 0)
		{
		  ge_p1p1_to_p3(u, t);
		  ge_sub(t, u, Bi[(-bslide[i]) / 2]);
		}

		ge_p1p1_to_p2(r, t);
	  }
	}
	public static int ge_check_subgroup_precomp_vartime(ge_cached[] p)
	{
	  ge_p3 s = new ge_p3();
	  ge_p1p1 t = new ge_p1p1();
	  ge_p2 u = new ge_p2();
	  ge_p3_0(s);
	  ge_add(t, s, p + 7);
	  ge_p1p1_to_p3(s, t);
	  ge_add(t, s, p);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_add(t, s, p + 2);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_add(t, s, p + 3);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_sub(t, s, p);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_sub(t, s, p + 1);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_sub(t, s, p);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_sub(t, s, p + 5);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_add(t, s, p + 1);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_sub(t, s, p);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_sub(t, s, p + 1);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_sub(t, s, p + 6);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_add(t, s, p + 5);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_add(t, s, p + 5);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_add(t, s, p + 4);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_add(t, s, p + 1);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_add(t, s, p + 1);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_add(t, s, p + 6);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_add(t, s, p + 1);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_sub(t, s, p + 1);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_sub(t, s, p + 2);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_sub(t, s, p + 5);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_sub(t, s, p + 2);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p2(u, t);
	  ge_p2_dbl(t, u);
	  ge_p1p1_to_p3(s, t);
	  ge_add(t, s, p);
	  fe_sub(t.Y, t.Y, t.T);
	  return fe_isnonzero(t.Y);
	}
	public static void ge_mul8(ge_p1p1 r, ge_p2 t)
	{
	  ge_p2 u = new ge_p2();
	  ge_p2_dbl(r, t);
	  ge_p1p1_to_p2(u, r);
	  ge_p2_dbl(r, u);
	  ge_p1p1_to_p2(u, r);
	  ge_p2_dbl(r, u);
	}
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const int fe_ma2[10];
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const int fe_ma[10];
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const int fe_fffb1[10];
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const int fe_fffb2[10];
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const int fe_fffb3[10];
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const int fe_fffb4[10];
	public static void ge_fromfe_frombytes_vartime(ge_p2 r, byte s)
	{
	  int[] u = Arrays.InitializeWithDefaultInstances<int>(10);
	  int v = new int();
	  int w = new int();
	  int x = new int();
	  int y = new int();
	  int z = new int();
	  byte sign;

	  /* From fe_frombytes.c */

	  long h0 = load_4(s);
	  long h1 = load_3(s + 4) << 6;
	  long h2 = load_3(s + 7) << 5;
	  long h3 = load_3(s + 10) << 3;
	  long h4 = load_3(s + 13) << 2;
	  long h5 = load_4(s + 16);
	  long h6 = load_3(s + 20) << 7;
	  long h7 = load_3(s + 23) << 5;
	  long h8 = load_3(s + 26) << 4;
	  long h9 = load_3(s + 29) << 2;
	  long carry0 = new long();
	  long carry1 = new long();
	  long carry2 = new long();
	  long carry3 = new long();
	  long carry4 = new long();
	  long carry5 = new long();
	  long carry6 = new long();
	  long carry7 = new long();
	  long carry8 = new long();
	  long carry9 = new long();

	  carry9 = (h9 + (long)(1 << 24)) >> 25;
	  h0 += carry9 * 19;
	  h9 -= carry9 << 25;
	  carry1 = (h1 + (long)(1 << 24)) >> 25;
	  h2 += carry1;
	  h1 -= carry1 << 25;
	  carry3 = (h3 + (long)(1 << 24)) >> 25;
	  h4 += carry3;
	  h3 -= carry3 << 25;
	  carry5 = (h5 + (long)(1 << 24)) >> 25;
	  h6 += carry5;
	  h5 -= carry5 << 25;
	  carry7 = (h7 + (long)(1 << 24)) >> 25;
	  h8 += carry7;
	  h7 -= carry7 << 25;

	  carry0 = (h0 + (long)(1 << 25)) >> 26;
	  h1 += carry0;
	  h0 -= carry0 << 26;
	  carry2 = (h2 + (long)(1 << 25)) >> 26;
	  h3 += carry2;
	  h2 -= carry2 << 26;
	  carry4 = (h4 + (long)(1 << 25)) >> 26;
	  h5 += carry4;
	  h4 -= carry4 << 26;
	  carry6 = (h6 + (long)(1 << 25)) >> 26;
	  h7 += carry6;
	  h6 -= carry6 << 26;
	  carry8 = (h8 + (long)(1 << 25)) >> 26;
	  h9 += carry8;
	  h8 -= carry8 << 26;

	  u[0] = (int) h0;
	  u[1] = (int) h1;
	  u[2] = (int) h2;
	  u[3] = (int) h3;
	  u[4] = (int) h4;
	  u[5] = (int) h5;
	  u[6] = (int) h6;
	  u[7] = (int) h7;
	  u[8] = (int) h8;
	  u[9] = (int) h9;

	  /* End fe_frombytes.c */

	  fe_sq2(new int(v), u); // 2 * u^2
	  fe_1(new int(w));
	  fe_add(new int(w), new int(v), new int(w)); // w = 2 * u^2 + 1
	  fe_sq(new int(x), new int(w)); // w^2
	  fe_mul(new int(y), fe_ma2, new int(v)); // -2 * A^2 * u^2
	  fe_add(new int(x), new int(x), new int(y)); // x = w^2 - 2 * A^2 * u^2
	  fe_divpowm1(r.X, new int(w), new int(x)); // (w / x)^(m + 1)
	  fe_sq(new int(y), r.X);
	  fe_mul(new int(x), new int(y), new int(x));
	  fe_sub(new int(y), new int(w), new int(x));
	  fe_copy(new int(z), fe_ma);
	  if (fe_isnonzero(new int(y)) != 0)
	  {
		fe_add(new int(y), new int(w), new int(x));
		if (fe_isnonzero(new int(y)) != 0)
		{
		  goto negative;
		}
		else
		{
		  fe_mul(r.X, r.X, fe_fffb1);
		}
	  }
	  else
	  {
		fe_mul(r.X, r.X, fe_fffb2);
	  }
	  fe_mul(r.X, r.X, u); // u * sqrt(2 * A * (A + 2) * w / x)
	  fe_mul(new int(z), new int(z), new int(v)); // -2 * A * u^2
	  sign = 0;
	  goto setsign;
	negative:
	  fe_mul(new int(x), new int(x), fe_sqrtm1);
	  fe_sub(new int(y), new int(w), new int(x));
	  if (fe_isnonzero(new int(y)) != 0)
	  {
		Debug.Assert((fe_add(y, w, x), fe_isnonzero(new int(y)) == 0));
		fe_mul(r.X, r.X, fe_fffb3);
	  }
	  else
	  {
		fe_mul(r.X, r.X, fe_fffb4);
	  }
	  /* r->X = sqrt(A * (A + 2) * w / x) */
	  /* z = -A */
	  sign = 1;
	setsign:
	  if (fe_isnegative(r.X) != sign)
	  {
		Debug.Assert(fe_isnonzero(r.X));
		fe_neg(r.X, r.X);
	  }
	  fe_add(r.Z, new int(z), new int(w));
	  fe_sub(r.Y, new int(z), new int(w));
	  fe_mul(r.X, r.X, r.Z);
	#if !NDEBUG
	  {
		int[] check_x = Arrays.InitializeWithDefaultInstances<int>(10);
		int check_y = new int();
		int check_iz = new int();
		int check_v = new int();
		fe_invert(new int(check_iz), r.Z);
		fe_mul(check_x, r.X, new int(check_iz));
		fe_mul(new int(check_y), r.Y, new int(check_iz));
		fe_sq(check_x, check_x);
		fe_sq(new int(check_y), new int(check_y));
		fe_mul(new int(check_v), check_x, new int(check_y));
		fe_mul(new int(check_v), fe_d, new int(check_v));
		fe_add(new int(check_v), new int(check_v), check_x);
		fe_sub(new int(check_v), new int(check_v), new int(check_y));
		fe_1(check_x);
		fe_add(new int(check_v), new int(check_v), check_x);
		Debug.Assert(fe_isnonzero(new int(check_v)) == 0);
	  }
	#endif
	}
	public static void sc_0(byte[] s)
	{
	  int i;
	  for (i = 0; i < 32; i++)
	  {
		s[i] = 0;
	  }
	}
	public static void sc_reduce32(byte[] s)
	{
	  long s0 = 2097151 & load_3(s);
	  long s1 = 2097151 & (load_4(s + 2) >> 5);
	  long s2 = 2097151 & (load_3(s + 5) >> 2);
	  long s3 = 2097151 & (load_4(s + 7) >> 7);
	  long s4 = 2097151 & (load_4(s + 10) >> 4);
	  long s5 = 2097151 & (load_3(s + 13) >> 1);
	  long s6 = 2097151 & (load_4(s + 15) >> 6);
	  long s7 = 2097151 & (load_3(s + 18) >> 3);
	  long s8 = 2097151 & load_3(s + 21);
	  long s9 = 2097151 & (load_4(s + 23) >> 5);
	  long s10 = 2097151 & (load_3(s + 26) >> 2);
	  long s11 = (load_4(s + 28) >> 7);
	  long s12 = 0;
	  long carry0 = new long();
	  long carry1 = new long();
	  long carry2 = new long();
	  long carry3 = new long();
	  long carry4 = new long();
	  long carry5 = new long();
	  long carry6 = new long();
	  long carry7 = new long();
	  long carry8 = new long();
	  long carry9 = new long();
	  long carry10 = new long();
	  long carry11 = new long();

	  carry0 = (s0 + (1 << 20)) >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry2 = (s2 + (1 << 20)) >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry4 = (s4 + (1 << 20)) >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry6 = (s6 + (1 << 20)) >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry8 = (s8 + (1 << 20)) >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry10 = (s10 + (1 << 20)) >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;

	  carry1 = (s1 + (1 << 20)) >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry3 = (s3 + (1 << 20)) >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry5 = (s5 + (1 << 20)) >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry7 = (s7 + (1 << 20)) >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry9 = (s9 + (1 << 20)) >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry11 = (s11 + (1 << 20)) >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;

	  s0 += s12 * 666643;
	  s1 += s12 * 470296;
	  s2 += s12 * 654183;
	  s3 -= s12 * 997805;
	  s4 += s12 * 136657;
	  s5 -= s12 * 683901;
	  s12 = 0;

	  carry0 = s0 >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry1 = s1 >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry2 = s2 >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry3 = s3 >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry4 = s4 >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry5 = s5 >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry6 = s6 >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry7 = s7 >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry8 = s8 >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry9 = s9 >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry10 = s10 >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;
	  carry11 = s11 >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;

	  s0 += s12 * 666643;
	  s1 += s12 * 470296;
	  s2 += s12 * 654183;
	  s3 -= s12 * 997805;
	  s4 += s12 * 136657;
	  s5 -= s12 * 683901;

	  carry0 = s0 >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry1 = s1 >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry2 = s2 >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry3 = s3 >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry4 = s4 >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry5 = s5 >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry6 = s6 >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry7 = s7 >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry8 = s8 >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry9 = s9 >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry10 = s10 >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;

	  s[0] = (byte)(s0 >> 0);
	  s[1] = (byte)(s0 >> 8);
	  s[2] = (byte)((s0 >> 16) | (s1 << 5));
	  s[3] = (byte)(s1 >> 3);
	  s[4] = (byte)(s1 >> 11);
	  s[5] = (byte)((s1 >> 19) | (s2 << 2));
	  s[6] = (byte)(s2 >> 6);
	  s[7] = (byte)((s2 >> 14) | (s3 << 7));
	  s[8] = (byte)(s3 >> 1);
	  s[9] = (byte)(s3 >> 9);
	  s[10] = (byte)((s3 >> 17) | (s4 << 4));
	  s[11] = (byte)(s4 >> 4);
	  s[12] = (byte)(s4 >> 12);
	  s[13] = (byte)((s4 >> 20) | (s5 << 1));
	  s[14] = (byte)(s5 >> 7);
	  s[15] = (byte)((s5 >> 15) | (s6 << 6));
	  s[16] = (byte)(s6 >> 2);
	  s[17] = (byte)(s6 >> 10);
	  s[18] = (byte)((s6 >> 18) | (s7 << 3));
	  s[19] = (byte)(s7 >> 5);
	  s[20] = (byte)(s7 >> 13);
	  s[21] = (byte)(s8 >> 0);
	  s[22] = (byte)(s8 >> 8);
	  s[23] = (byte)((s8 >> 16) | (s9 << 5));
	  s[24] = (byte)(s9 >> 3);
	  s[25] = (byte)(s9 >> 11);
	  s[26] = (byte)((s9 >> 19) | (s10 << 2));
	  s[27] = (byte)(s10 >> 6);
	  s[28] = (byte)((s10 >> 14) | (s11 << 7));
	  s[29] = (byte)(s11 >> 1);
	  s[30] = (byte)(s11 >> 9);
	  s[31] = (byte)(s11 >> 17);
	}
	public static void sc_add(byte[] s, byte a, byte b)
	{
	  long a0 = 2097151 & load_3(a);
	  long a1 = 2097151 & (load_4(a + 2) >> 5);
	  long a2 = 2097151 & (load_3(a + 5) >> 2);
	  long a3 = 2097151 & (load_4(a + 7) >> 7);
	  long a4 = 2097151 & (load_4(a + 10) >> 4);
	  long a5 = 2097151 & (load_3(a + 13) >> 1);
	  long a6 = 2097151 & (load_4(a + 15) >> 6);
	  long a7 = 2097151 & (load_3(a + 18) >> 3);
	  long a8 = 2097151 & load_3(a + 21);
	  long a9 = 2097151 & (load_4(a + 23) >> 5);
	  long a10 = 2097151 & (load_3(a + 26) >> 2);
	  long a11 = (load_4(a + 28) >> 7);
	  long b0 = 2097151 & load_3(b);
	  long b1 = 2097151 & (load_4(b + 2) >> 5);
	  long b2 = 2097151 & (load_3(b + 5) >> 2);
	  long b3 = 2097151 & (load_4(b + 7) >> 7);
	  long b4 = 2097151 & (load_4(b + 10) >> 4);
	  long b5 = 2097151 & (load_3(b + 13) >> 1);
	  long b6 = 2097151 & (load_4(b + 15) >> 6);
	  long b7 = 2097151 & (load_3(b + 18) >> 3);
	  long b8 = 2097151 & load_3(b + 21);
	  long b9 = 2097151 & (load_4(b + 23) >> 5);
	  long b10 = 2097151 & (load_3(b + 26) >> 2);
	  long b11 = (load_4(b + 28) >> 7);
	  long s0 = a0 + b0;
	  long s1 = a1 + b1;
	  long s2 = a2 + b2;
	  long s3 = a3 + b3;
	  long s4 = a4 + b4;
	  long s5 = a5 + b5;
	  long s6 = a6 + b6;
	  long s7 = a7 + b7;
	  long s8 = a8 + b8;
	  long s9 = a9 + b9;
	  long s10 = a10 + b10;
	  long s11 = a11 + b11;
	  long s12 = 0;
	  long carry0 = new long();
	  long carry1 = new long();
	  long carry2 = new long();
	  long carry3 = new long();
	  long carry4 = new long();
	  long carry5 = new long();
	  long carry6 = new long();
	  long carry7 = new long();
	  long carry8 = new long();
	  long carry9 = new long();
	  long carry10 = new long();
	  long carry11 = new long();

	  carry0 = (s0 + (1 << 20)) >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry2 = (s2 + (1 << 20)) >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry4 = (s4 + (1 << 20)) >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry6 = (s6 + (1 << 20)) >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry8 = (s8 + (1 << 20)) >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry10 = (s10 + (1 << 20)) >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;

	  carry1 = (s1 + (1 << 20)) >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry3 = (s3 + (1 << 20)) >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry5 = (s5 + (1 << 20)) >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry7 = (s7 + (1 << 20)) >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry9 = (s9 + (1 << 20)) >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry11 = (s11 + (1 << 20)) >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;

	  s0 += s12 * 666643;
	  s1 += s12 * 470296;
	  s2 += s12 * 654183;
	  s3 -= s12 * 997805;
	  s4 += s12 * 136657;
	  s5 -= s12 * 683901;
	  s12 = 0;

	  carry0 = s0 >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry1 = s1 >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry2 = s2 >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry3 = s3 >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry4 = s4 >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry5 = s5 >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry6 = s6 >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry7 = s7 >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry8 = s8 >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry9 = s9 >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry10 = s10 >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;
	  carry11 = s11 >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;

	  s0 += s12 * 666643;
	  s1 += s12 * 470296;
	  s2 += s12 * 654183;
	  s3 -= s12 * 997805;
	  s4 += s12 * 136657;
	  s5 -= s12 * 683901;

	  carry0 = s0 >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry1 = s1 >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry2 = s2 >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry3 = s3 >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry4 = s4 >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry5 = s5 >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry6 = s6 >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry7 = s7 >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry8 = s8 >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry9 = s9 >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry10 = s10 >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;

	  s[0] = (byte)(s0 >> 0);
	  s[1] = (byte)(s0 >> 8);
	  s[2] = (byte)((s0 >> 16) | (s1 << 5));
	  s[3] = (byte)(s1 >> 3);
	  s[4] = (byte)(s1 >> 11);
	  s[5] = (byte)((s1 >> 19) | (s2 << 2));
	  s[6] = (byte)(s2 >> 6);
	  s[7] = (byte)((s2 >> 14) | (s3 << 7));
	  s[8] = (byte)(s3 >> 1);
	  s[9] = (byte)(s3 >> 9);
	  s[10] = (byte)((s3 >> 17) | (s4 << 4));
	  s[11] = (byte)(s4 >> 4);
	  s[12] = (byte)(s4 >> 12);
	  s[13] = (byte)((s4 >> 20) | (s5 << 1));
	  s[14] = (byte)(s5 >> 7);
	  s[15] = (byte)((s5 >> 15) | (s6 << 6));
	  s[16] = (byte)(s6 >> 2);
	  s[17] = (byte)(s6 >> 10);
	  s[18] = (byte)((s6 >> 18) | (s7 << 3));
	  s[19] = (byte)(s7 >> 5);
	  s[20] = (byte)(s7 >> 13);
	  s[21] = (byte)(s8 >> 0);
	  s[22] = (byte)(s8 >> 8);
	  s[23] = (byte)((s8 >> 16) | (s9 << 5));
	  s[24] = (byte)(s9 >> 3);
	  s[25] = (byte)(s9 >> 11);
	  s[26] = (byte)((s9 >> 19) | (s10 << 2));
	  s[27] = (byte)(s10 >> 6);
	  s[28] = (byte)((s10 >> 14) | (s11 << 7));
	  s[29] = (byte)(s11 >> 1);
	  s[30] = (byte)(s11 >> 9);
	  s[31] = (byte)(s11 >> 17);
	}
	public static void sc_sub(byte[] s, byte a, byte b)
	{
	  long a0 = 2097151 & load_3(a);
	  long a1 = 2097151 & (load_4(a + 2) >> 5);
	  long a2 = 2097151 & (load_3(a + 5) >> 2);
	  long a3 = 2097151 & (load_4(a + 7) >> 7);
	  long a4 = 2097151 & (load_4(a + 10) >> 4);
	  long a5 = 2097151 & (load_3(a + 13) >> 1);
	  long a6 = 2097151 & (load_4(a + 15) >> 6);
	  long a7 = 2097151 & (load_3(a + 18) >> 3);
	  long a8 = 2097151 & load_3(a + 21);
	  long a9 = 2097151 & (load_4(a + 23) >> 5);
	  long a10 = 2097151 & (load_3(a + 26) >> 2);
	  long a11 = (load_4(a + 28) >> 7);
	  long b0 = 2097151 & load_3(b);
	  long b1 = 2097151 & (load_4(b + 2) >> 5);
	  long b2 = 2097151 & (load_3(b + 5) >> 2);
	  long b3 = 2097151 & (load_4(b + 7) >> 7);
	  long b4 = 2097151 & (load_4(b + 10) >> 4);
	  long b5 = 2097151 & (load_3(b + 13) >> 1);
	  long b6 = 2097151 & (load_4(b + 15) >> 6);
	  long b7 = 2097151 & (load_3(b + 18) >> 3);
	  long b8 = 2097151 & load_3(b + 21);
	  long b9 = 2097151 & (load_4(b + 23) >> 5);
	  long b10 = 2097151 & (load_3(b + 26) >> 2);
	  long b11 = (load_4(b + 28) >> 7);
	  long s0 = a0 - b0;
	  long s1 = a1 - b1;
	  long s2 = a2 - b2;
	  long s3 = a3 - b3;
	  long s4 = a4 - b4;
	  long s5 = a5 - b5;
	  long s6 = a6 - b6;
	  long s7 = a7 - b7;
	  long s8 = a8 - b8;
	  long s9 = a9 - b9;
	  long s10 = a10 - b10;
	  long s11 = a11 - b11;
	  long s12 = 0;
	  long carry0 = new long();
	  long carry1 = new long();
	  long carry2 = new long();
	  long carry3 = new long();
	  long carry4 = new long();
	  long carry5 = new long();
	  long carry6 = new long();
	  long carry7 = new long();
	  long carry8 = new long();
	  long carry9 = new long();
	  long carry10 = new long();
	  long carry11 = new long();

	  carry0 = (s0 + (1 << 20)) >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry2 = (s2 + (1 << 20)) >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry4 = (s4 + (1 << 20)) >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry6 = (s6 + (1 << 20)) >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry8 = (s8 + (1 << 20)) >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry10 = (s10 + (1 << 20)) >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;

	  carry1 = (s1 + (1 << 20)) >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry3 = (s3 + (1 << 20)) >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry5 = (s5 + (1 << 20)) >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry7 = (s7 + (1 << 20)) >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry9 = (s9 + (1 << 20)) >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry11 = (s11 + (1 << 20)) >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;

	  s0 += s12 * 666643;
	  s1 += s12 * 470296;
	  s2 += s12 * 654183;
	  s3 -= s12 * 997805;
	  s4 += s12 * 136657;
	  s5 -= s12 * 683901;
	  s12 = 0;

	  carry0 = s0 >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry1 = s1 >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry2 = s2 >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry3 = s3 >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry4 = s4 >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry5 = s5 >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry6 = s6 >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry7 = s7 >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry8 = s8 >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry9 = s9 >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry10 = s10 >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;
	  carry11 = s11 >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;

	  s0 += s12 * 666643;
	  s1 += s12 * 470296;
	  s2 += s12 * 654183;
	  s3 -= s12 * 997805;
	  s4 += s12 * 136657;
	  s5 -= s12 * 683901;

	  carry0 = s0 >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry1 = s1 >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry2 = s2 >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry3 = s3 >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry4 = s4 >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry5 = s5 >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry6 = s6 >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry7 = s7 >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry8 = s8 >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry9 = s9 >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry10 = s10 >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;

	  s[0] = (byte)(s0 >> 0);
	  s[1] = (byte)(s0 >> 8);
	  s[2] = (byte)((s0 >> 16) | (s1 << 5));
	  s[3] = (byte)(s1 >> 3);
	  s[4] = (byte)(s1 >> 11);
	  s[5] = (byte)((s1 >> 19) | (s2 << 2));
	  s[6] = (byte)(s2 >> 6);
	  s[7] = (byte)((s2 >> 14) | (s3 << 7));
	  s[8] = (byte)(s3 >> 1);
	  s[9] = (byte)(s3 >> 9);
	  s[10] = (byte)((s3 >> 17) | (s4 << 4));
	  s[11] = (byte)(s4 >> 4);
	  s[12] = (byte)(s4 >> 12);
	  s[13] = (byte)((s4 >> 20) | (s5 << 1));
	  s[14] = (byte)(s5 >> 7);
	  s[15] = (byte)((s5 >> 15) | (s6 << 6));
	  s[16] = (byte)(s6 >> 2);
	  s[17] = (byte)(s6 >> 10);
	  s[18] = (byte)((s6 >> 18) | (s7 << 3));
	  s[19] = (byte)(s7 >> 5);
	  s[20] = (byte)(s7 >> 13);
	  s[21] = (byte)(s8 >> 0);
	  s[22] = (byte)(s8 >> 8);
	  s[23] = (byte)((s8 >> 16) | (s9 << 5));
	  s[24] = (byte)(s9 >> 3);
	  s[25] = (byte)(s9 >> 11);
	  s[26] = (byte)((s9 >> 19) | (s10 << 2));
	  s[27] = (byte)(s10 >> 6);
	  s[28] = (byte)((s10 >> 14) | (s11 << 7));
	  s[29] = (byte)(s11 >> 1);
	  s[30] = (byte)(s11 >> 9);
	  s[31] = (byte)(s11 >> 17);
	}

/*
Input:
  a[0]+256*a[1]+...+256^31*a[31] = a
  b[0]+256*b[1]+...+256^31*b[31] = b
  c[0]+256*c[1]+...+256^31*c[31] = c

Output:
  s[0]+256*s[1]+...+256^31*s[31] = (c-ab) mod l
  where l = 2^252 + 27742317777372353535851937790883648493.
*/

	public static void sc_mulsub(byte[] s, byte a, byte b, byte c)
	{
	  long a0 = 2097151 & load_3(a);
	  long a1 = 2097151 & (load_4(a + 2) >> 5);
	  long a2 = 2097151 & (load_3(a + 5) >> 2);
	  long a3 = 2097151 & (load_4(a + 7) >> 7);
	  long a4 = 2097151 & (load_4(a + 10) >> 4);
	  long a5 = 2097151 & (load_3(a + 13) >> 1);
	  long a6 = 2097151 & (load_4(a + 15) >> 6);
	  long a7 = 2097151 & (load_3(a + 18) >> 3);
	  long a8 = 2097151 & load_3(a + 21);
	  long a9 = 2097151 & (load_4(a + 23) >> 5);
	  long a10 = 2097151 & (load_3(a + 26) >> 2);
	  long a11 = (load_4(a + 28) >> 7);
	  long b0 = 2097151 & load_3(b);
	  long b1 = 2097151 & (load_4(b + 2) >> 5);
	  long b2 = 2097151 & (load_3(b + 5) >> 2);
	  long b3 = 2097151 & (load_4(b + 7) >> 7);
	  long b4 = 2097151 & (load_4(b + 10) >> 4);
	  long b5 = 2097151 & (load_3(b + 13) >> 1);
	  long b6 = 2097151 & (load_4(b + 15) >> 6);
	  long b7 = 2097151 & (load_3(b + 18) >> 3);
	  long b8 = 2097151 & load_3(b + 21);
	  long b9 = 2097151 & (load_4(b + 23) >> 5);
	  long b10 = 2097151 & (load_3(b + 26) >> 2);
	  long b11 = (load_4(b + 28) >> 7);
	  long c0 = 2097151 & load_3(c);
	  long c1 = 2097151 & (load_4(c + 2) >> 5);
	  long c2 = 2097151 & (load_3(c + 5) >> 2);
	  long c3 = 2097151 & (load_4(c + 7) >> 7);
	  long c4 = 2097151 & (load_4(c + 10) >> 4);
	  long c5 = 2097151 & (load_3(c + 13) >> 1);
	  long c6 = 2097151 & (load_4(c + 15) >> 6);
	  long c7 = 2097151 & (load_3(c + 18) >> 3);
	  long c8 = 2097151 & load_3(c + 21);
	  long c9 = 2097151 & (load_4(c + 23) >> 5);
	  long c10 = 2097151 & (load_3(c + 26) >> 2);
	  long c11 = (load_4(c + 28) >> 7);
	  long s0 = new long();
	  long s1 = new long();
	  long s2 = new long();
	  long s3 = new long();
	  long s4 = new long();
	  long s5 = new long();
	  long s6 = new long();
	  long s7 = new long();
	  long s8 = new long();
	  long s9 = new long();
	  long s10 = new long();
	  long s11 = new long();
	  long s12 = new long();
	  long s13 = new long();
	  long s14 = new long();
	  long s15 = new long();
	  long s16 = new long();
	  long s17 = new long();
	  long s18 = new long();
	  long s19 = new long();
	  long s20 = new long();
	  long s21 = new long();
	  long s22 = new long();
	  long s23 = new long();
	  long carry0 = new long();
	  long carry1 = new long();
	  long carry2 = new long();
	  long carry3 = new long();
	  long carry4 = new long();
	  long carry5 = new long();
	  long carry6 = new long();
	  long carry7 = new long();
	  long carry8 = new long();
	  long carry9 = new long();
	  long carry10 = new long();
	  long carry11 = new long();
	  long carry12 = new long();
	  long carry13 = new long();
	  long carry14 = new long();
	  long carry15 = new long();
	  long carry16 = new long();
	  long carry17 = new long();
	  long carry18 = new long();
	  long carry19 = new long();
	  long carry20 = new long();
	  long carry21 = new long();
	  long carry22 = new long();

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s0 = c0 - a0 *b0;
	  s0.CopyFrom(c0 - a0 * b0);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s1 = c1 - (a0 *b1 + a1 *b0);
	  s1.CopyFrom(c1 - (a0 * b1 + a1 * b0));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s2 = c2 - (a0 *b2 + a1 *b1 + a2 *b0);
	  s2.CopyFrom(c2 - (a0 * b2 + a1 * b1 + a2 * b0));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s3 = c3 - (a0 *b3 + a1 *b2 + a2 *b1 + a3 *b0);
	  s3.CopyFrom(c3 - (a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s4 = c4 - (a0 *b4 + a1 *b3 + a2 *b2 + a3 *b1 + a4 *b0);
	  s4.CopyFrom(c4 - (a0 * b4 + a1 * b3 + a2 * b2 + a3 * b1 + a4 * b0));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s5 = c5 - (a0 *b5 + a1 *b4 + a2 *b3 + a3 *b2 + a4 *b1 + a5 *b0);
	  s5.CopyFrom(c5 - (a0 * b5 + a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1 + a5 * b0));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s6 = c6 - (a0 *b6 + a1 *b5 + a2 *b4 + a3 *b3 + a4 *b2 + a5 *b1 + a6 *b0);
	  s6.CopyFrom(c6 - (a0 * b6 + a1 * b5 + a2 * b4 + a3 * b3 + a4 * b2 + a5 * b1 + a6 * b0));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s7 = c7 - (a0 *b7 + a1 *b6 + a2 *b5 + a3 *b4 + a4 *b3 + a5 *b2 + a6 *b1 + a7 *b0);
	  s7.CopyFrom(c7 - (a0 * b7 + a1 * b6 + a2 * b5 + a3 * b4 + a4 * b3 + a5 * b2 + a6 * b1 + a7 * b0));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s8 = c8 - (a0 *b8 + a1 *b7 + a2 *b6 + a3 *b5 + a4 *b4 + a5 *b3 + a6 *b2 + a7 *b1 + a8 *b0);
	  s8.CopyFrom(c8 - (a0 * b8 + a1 * b7 + a2 * b6 + a3 * b5 + a4 * b4 + a5 * b3 + a6 * b2 + a7 * b1 + a8 * b0));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s9 = c9 - (a0 *b9 + a1 *b8 + a2 *b7 + a3 *b6 + a4 *b5 + a5 *b4 + a6 *b3 + a7 *b2 + a8 *b1 + a9 *b0);
	  s9.CopyFrom(c9 - (a0 * b9 + a1 * b8 + a2 * b7 + a3 * b6 + a4 * b5 + a5 * b4 + a6 * b3 + a7 * b2 + a8 * b1 + a9 * b0));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s10 = c10 - (a0 *b10 + a1 *b9 + a2 *b8 + a3 *b7 + a4 *b6 + a5 *b5 + a6 *b4 + a7 *b3 + a8 *b2 + a9 *b1 + a10 *b0);
	  s10.CopyFrom(c10 - (a0 * b10 + a1 * b9 + a2 * b8 + a3 * b7 + a4 * b6 + a5 * b5 + a6 * b4 + a7 * b3 + a8 * b2 + a9 * b1 + a10 * b0));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s11 = c11 - (a0 *b11 + a1 *b10 + a2 *b9 + a3 *b8 + a4 *b7 + a5 *b6 + a6 *b5 + a7 *b4 + a8 *b3 + a9 *b2 + a10 *b1 + a11 *b0);
	  s11.CopyFrom(c11 - (a0 * b11 + a1 * b10 + a2 * b9 + a3 * b8 + a4 * b7 + a5 * b6 + a6 * b5 + a7 * b4 + a8 * b3 + a9 * b2 + a10 * b1 + a11 * b0));
	  s12 = -(a1 * b11 + a2 * b10 + a3 * b9 + a4 * b8 + a5 * b7 + a6 * b6 + a7 * b5 + a8 * b4 + a9 * b3 + a10 * b2 + a11 * b1);
	  s13 = -(a2 * b11 + a3 * b10 + a4 * b9 + a5 * b8 + a6 * b7 + a7 * b6 + a8 * b5 + a9 * b4 + a10 * b3 + a11 * b2);
	  s14 = -(a3 * b11 + a4 * b10 + a5 * b9 + a6 * b8 + a7 * b7 + a8 * b6 + a9 * b5 + a10 * b4 + a11 * b3);
	  s15 = -(a4 * b11 + a5 * b10 + a6 * b9 + a7 * b8 + a8 * b7 + a9 * b6 + a10 * b5 + a11 * b4);
	  s16 = -(a5 * b11 + a6 * b10 + a7 * b9 + a8 * b8 + a9 * b7 + a10 * b6 + a11 * b5);
	  s17 = -(a6 * b11 + a7 * b10 + a8 * b9 + a9 * b8 + a10 * b7 + a11 * b6);
	  s18 = -(a7 * b11 + a8 * b10 + a9 * b9 + a10 * b8 + a11 * b7);
	  s19 = -(a8 * b11 + a9 * b10 + a10 * b9 + a11 * b8);
	  s20 = -(a9 * b11 + a10 * b10 + a11 * b9);
	  s21 = -(a10 * b11 + a11 * b10);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: s22 = -a11 *b11;
	  s22.CopyFrom(-a11 * b11);
	  s23 = 0;

	  carry0 = (s0 + (1 << 20)) >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry2 = (s2 + (1 << 20)) >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry4 = (s4 + (1 << 20)) >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry6 = (s6 + (1 << 20)) >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry8 = (s8 + (1 << 20)) >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry10 = (s10 + (1 << 20)) >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;
	  carry12 = (s12 + (1 << 20)) >> 21;
	  s13 += carry12;
	  s12 -= carry12 << 21;
	  carry14 = (s14 + (1 << 20)) >> 21;
	  s15 += carry14;
	  s14 -= carry14 << 21;
	  carry16 = (s16 + (1 << 20)) >> 21;
	  s17 += carry16;
	  s16 -= carry16 << 21;
	  carry18 = (s18 + (1 << 20)) >> 21;
	  s19 += carry18;
	  s18 -= carry18 << 21;
	  carry20 = (s20 + (1 << 20)) >> 21;
	  s21 += carry20;
	  s20 -= carry20 << 21;
	  carry22 = (s22 + (1 << 20)) >> 21;
	  s23 += carry22;
	  s22 -= carry22 << 21;

	  carry1 = (s1 + (1 << 20)) >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry3 = (s3 + (1 << 20)) >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry5 = (s5 + (1 << 20)) >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry7 = (s7 + (1 << 20)) >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry9 = (s9 + (1 << 20)) >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry11 = (s11 + (1 << 20)) >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;
	  carry13 = (s13 + (1 << 20)) >> 21;
	  s14 += carry13;
	  s13 -= carry13 << 21;
	  carry15 = (s15 + (1 << 20)) >> 21;
	  s16 += carry15;
	  s15 -= carry15 << 21;
	  carry17 = (s17 + (1 << 20)) >> 21;
	  s18 += carry17;
	  s17 -= carry17 << 21;
	  carry19 = (s19 + (1 << 20)) >> 21;
	  s20 += carry19;
	  s19 -= carry19 << 21;
	  carry21 = (s21 + (1 << 20)) >> 21;
	  s22 += carry21;
	  s21 -= carry21 << 21;

	  s11 += s23 * 666643;
	  s12 += s23 * 470296;
	  s13 += s23 * 654183;
	  s14 -= s23 * 997805;
	  s15 += s23 * 136657;
	  s16 -= s23 * 683901;

	  s10 += s22 * 666643;
	  s11 += s22 * 470296;
	  s12 += s22 * 654183;
	  s13 -= s22 * 997805;
	  s14 += s22 * 136657;
	  s15 -= s22 * 683901;

	  s9 += s21 * 666643;
	  s10 += s21 * 470296;
	  s11 += s21 * 654183;
	  s12 -= s21 * 997805;
	  s13 += s21 * 136657;
	  s14 -= s21 * 683901;

	  s8 += s20 * 666643;
	  s9 += s20 * 470296;
	  s10 += s20 * 654183;
	  s11 -= s20 * 997805;
	  s12 += s20 * 136657;
	  s13 -= s20 * 683901;

	  s7 += s19 * 666643;
	  s8 += s19 * 470296;
	  s9 += s19 * 654183;
	  s10 -= s19 * 997805;
	  s11 += s19 * 136657;
	  s12 -= s19 * 683901;

	  s6 += s18 * 666643;
	  s7 += s18 * 470296;
	  s8 += s18 * 654183;
	  s9 -= s18 * 997805;
	  s10 += s18 * 136657;
	  s11 -= s18 * 683901;

	  carry6 = (s6 + (1 << 20)) >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry8 = (s8 + (1 << 20)) >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry10 = (s10 + (1 << 20)) >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;
	  carry12 = (s12 + (1 << 20)) >> 21;
	  s13 += carry12;
	  s12 -= carry12 << 21;
	  carry14 = (s14 + (1 << 20)) >> 21;
	  s15 += carry14;
	  s14 -= carry14 << 21;
	  carry16 = (s16 + (1 << 20)) >> 21;
	  s17 += carry16;
	  s16 -= carry16 << 21;

	  carry7 = (s7 + (1 << 20)) >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry9 = (s9 + (1 << 20)) >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry11 = (s11 + (1 << 20)) >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;
	  carry13 = (s13 + (1 << 20)) >> 21;
	  s14 += carry13;
	  s13 -= carry13 << 21;
	  carry15 = (s15 + (1 << 20)) >> 21;
	  s16 += carry15;
	  s15 -= carry15 << 21;

	  s5 += s17 * 666643;
	  s6 += s17 * 470296;
	  s7 += s17 * 654183;
	  s8 -= s17 * 997805;
	  s9 += s17 * 136657;
	  s10 -= s17 * 683901;

	  s4 += s16 * 666643;
	  s5 += s16 * 470296;
	  s6 += s16 * 654183;
	  s7 -= s16 * 997805;
	  s8 += s16 * 136657;
	  s9 -= s16 * 683901;

	  s3 += s15 * 666643;
	  s4 += s15 * 470296;
	  s5 += s15 * 654183;
	  s6 -= s15 * 997805;
	  s7 += s15 * 136657;
	  s8 -= s15 * 683901;

	  s2 += s14 * 666643;
	  s3 += s14 * 470296;
	  s4 += s14 * 654183;
	  s5 -= s14 * 997805;
	  s6 += s14 * 136657;
	  s7 -= s14 * 683901;

	  s1 += s13 * 666643;
	  s2 += s13 * 470296;
	  s3 += s13 * 654183;
	  s4 -= s13 * 997805;
	  s5 += s13 * 136657;
	  s6 -= s13 * 683901;

	  s0 += s12 * 666643;
	  s1 += s12 * 470296;
	  s2 += s12 * 654183;
	  s3 -= s12 * 997805;
	  s4 += s12 * 136657;
	  s5 -= s12 * 683901;
	  s12 = 0;

	  carry0 = (s0 + (1 << 20)) >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry2 = (s2 + (1 << 20)) >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry4 = (s4 + (1 << 20)) >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry6 = (s6 + (1 << 20)) >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry8 = (s8 + (1 << 20)) >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry10 = (s10 + (1 << 20)) >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;

	  carry1 = (s1 + (1 << 20)) >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry3 = (s3 + (1 << 20)) >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry5 = (s5 + (1 << 20)) >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry7 = (s7 + (1 << 20)) >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry9 = (s9 + (1 << 20)) >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry11 = (s11 + (1 << 20)) >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;

	  s0 += s12 * 666643;
	  s1 += s12 * 470296;
	  s2 += s12 * 654183;
	  s3 -= s12 * 997805;
	  s4 += s12 * 136657;
	  s5 -= s12 * 683901;
	  s12 = 0;

	  carry0 = s0 >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry1 = s1 >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry2 = s2 >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry3 = s3 >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry4 = s4 >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry5 = s5 >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry6 = s6 >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry7 = s7 >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry8 = s8 >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry9 = s9 >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry10 = s10 >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;
	  carry11 = s11 >> 21;
	  s12 += carry11;
	  s11 -= carry11 << 21;

	  s0 += s12 * 666643;
	  s1 += s12 * 470296;
	  s2 += s12 * 654183;
	  s3 -= s12 * 997805;
	  s4 += s12 * 136657;
	  s5 -= s12 * 683901;

	  carry0 = s0 >> 21;
	  s1 += carry0;
	  s0 -= carry0 << 21;
	  carry1 = s1 >> 21;
	  s2 += carry1;
	  s1 -= carry1 << 21;
	  carry2 = s2 >> 21;
	  s3 += carry2;
	  s2 -= carry2 << 21;
	  carry3 = s3 >> 21;
	  s4 += carry3;
	  s3 -= carry3 << 21;
	  carry4 = s4 >> 21;
	  s5 += carry4;
	  s4 -= carry4 << 21;
	  carry5 = s5 >> 21;
	  s6 += carry5;
	  s5 -= carry5 << 21;
	  carry6 = s6 >> 21;
	  s7 += carry6;
	  s6 -= carry6 << 21;
	  carry7 = s7 >> 21;
	  s8 += carry7;
	  s7 -= carry7 << 21;
	  carry8 = s8 >> 21;
	  s9 += carry8;
	  s8 -= carry8 << 21;
	  carry9 = s9 >> 21;
	  s10 += carry9;
	  s9 -= carry9 << 21;
	  carry10 = s10 >> 21;
	  s11 += carry10;
	  s10 -= carry10 << 21;

	  s[0] = (byte)(s0 >> 0);
	  s[1] = (byte)(s0 >> 8);
	  s[2] = (byte)((s0 >> 16) | (s1 << 5));
	  s[3] = (byte)(s1 >> 3);
	  s[4] = (byte)(s1 >> 11);
	  s[5] = (byte)((s1 >> 19) | (s2 << 2));
	  s[6] = (byte)(s2 >> 6);
	  s[7] = (byte)((s2 >> 14) | (s3 << 7));
	  s[8] = (byte)(s3 >> 1);
	  s[9] = (byte)(s3 >> 9);
	  s[10] = (byte)((s3 >> 17) | (s4 << 4));
	  s[11] = (byte)(s4 >> 4);
	  s[12] = (byte)(s4 >> 12);
	  s[13] = (byte)((s4 >> 20) | (s5 << 1));
	  s[14] = (byte)(s5 >> 7);
	  s[15] = (byte)((s5 >> 15) | (s6 << 6));
	  s[16] = (byte)(s6 >> 2);
	  s[17] = (byte)(s6 >> 10);
	  s[18] = (byte)((s6 >> 18) | (s7 << 3));
	  s[19] = (byte)(s7 >> 5);
	  s[20] = (byte)(s7 >> 13);
	  s[21] = (byte)(s8 >> 0);
	  s[22] = (byte)(s8 >> 8);
	  s[23] = (byte)((s8 >> 16) | (s9 << 5));
	  s[24] = (byte)(s9 >> 3);
	  s[25] = (byte)(s9 >> 11);
	  s[26] = (byte)((s9 >> 19) | (s10 << 2));
	  s[27] = (byte)(s10 >> 6);
	  s[28] = (byte)((s10 >> 14) | (s11 << 7));
	  s[29] = (byte)(s11 >> 1);
	  s[30] = (byte)(s11 >> 9);
	  s[31] = (byte)(s11 >> 17);
	}
	public static int sc_check(byte s)
	{
	  long s0 = load_4(s);
	  long s1 = load_4(s + 4);
	  long s2 = load_4(s + 8);
	  long s3 = load_4(s + 12);
	  long s4 = load_4(s + 16);
	  long s5 = load_4(s + 20);
	  long s6 = load_4(s + 24);
	  long s7 = load_4(s + 28);
	  return (int)((signum(1559614444 - s0) + (signum(1477600026 - s1) << 1) + (signum(2734136534 - s2) << 2) + (signum(350157278 - s3) << 3) + (signum(-s4) << 4) + (signum(-s5) << 5) + (signum(-s6) << 6) + (signum(268435456 - s7) << 7)) >> 8);
	}
	public static int sc_isnonzero(byte[] s)
	{
	  return (((int)(s[0] | s[1] | s[2] | s[3] | s[4] | s[5] | s[6] | s[7] | s[8] | s[9] | s[10] | s[11] | s[12] | s[13] | s[14] | s[15] | s[16] | s[17] | s[18] | s[19] | s[20] | s[21] | s[22] | s[23] | s[24] | s[25] | s[26] | s[27] | s[28] | s[29] | s[30] | s[31]) - 1) >> 8) + 1;
	}

/* From fe_mul.c */

/*
h = f * g
Can overlap h with f or g.

Preconditions:
   |f| bounded by 1.65*2^26,1.65*2^25,1.65*2^26,1.65*2^25,etc.
   |g| bounded by 1.65*2^26,1.65*2^25,1.65*2^26,1.65*2^25,etc.

Postconditions:
   |h| bounded by 1.01*2^25,1.01*2^24,1.01*2^25,1.01*2^24,etc.
*/

/*
Notes on implementation strategy:

Using schoolbook multiplication.
Karatsuba would save a little in some cost models.

Most multiplications by 2 and 19 are 32-bit precomputations;
cheaper than 64-bit postcomputations.

There is one remaining multiplication by 19 in the carry chain;
one *19 precomputation can be merged into this,
but the resulting data flow is considerably less clean.

There are 12 carries below.
10 of them are 2-way parallelizable and vectorizable.
Can get away with 11 carries, but then data flow is much deeper.

With tighter constraints on inputs can squeeze carries into int32.
*/



	/* Predeclarations */

	internal static void fe_mul(int[] h, int[] f, int[] g)
	{
	  int f0 = f[0];
	  int f1 = f[1];
	  int f2 = f[2];
	  int f3 = f[3];
	  int f4 = f[4];
	  int f5 = f[5];
	  int f6 = f[6];
	  int f7 = f[7];
	  int f8 = f[8];
	  int f9 = f[9];
	  int g0 = g[0];
	  int g1 = g[1];
	  int g2 = g[2];
	  int g3 = g[3];
	  int g4 = g[4];
	  int g5 = g[5];
	  int g6 = g[6];
	  int g7 = g[7];
	  int g8 = g[8];
	  int g9 = g[9];
	  int g1_19 = 19 * g1; // 1.959375*2^29
	  int g2_19 = 19 * g2; // 1.959375*2^30; still ok
	  int g3_19 = 19 * g3;
	  int g4_19 = 19 * g4;
	  int g5_19 = 19 * g5;
	  int g6_19 = 19 * g6;
	  int g7_19 = 19 * g7;
	  int g8_19 = 19 * g8;
	  int g9_19 = 19 * g9;
	  int f1_2 = 2 * f1;
	  int f3_2 = 2 * f3;
	  int f5_2 = 2 * f5;
	  int f7_2 = 2 * f7;
	  int f9_2 = 2 * f9;
	  long f0g0 = f0 * (long) g0;
	  long f0g1 = f0 * (long) g1;
	  long f0g2 = f0 * (long) g2;
	  long f0g3 = f0 * (long) g3;
	  long f0g4 = f0 * (long) g4;
	  long f0g5 = f0 * (long) g5;
	  long f0g6 = f0 * (long) g6;
	  long f0g7 = f0 * (long) g7;
	  long f0g8 = f0 * (long) g8;
	  long f0g9 = f0 * (long) g9;
	  long f1g0 = f1 * (long) g0;
	  long f1g1_2 = f1_2 * (long) g1;
	  long f1g2 = f1 * (long) g2;
	  long f1g3_2 = f1_2 * (long) g3;
	  long f1g4 = f1 * (long) g4;
	  long f1g5_2 = f1_2 * (long) g5;
	  long f1g6 = f1 * (long) g6;
	  long f1g7_2 = f1_2 * (long) g7;
	  long f1g8 = f1 * (long) g8;
	  long f1g9_38 = f1_2 * (long) g9_19;
	  long f2g0 = f2 * (long) g0;
	  long f2g1 = f2 * (long) g1;
	  long f2g2 = f2 * (long) g2;
	  long f2g3 = f2 * (long) g3;
	  long f2g4 = f2 * (long) g4;
	  long f2g5 = f2 * (long) g5;
	  long f2g6 = f2 * (long) g6;
	  long f2g7 = f2 * (long) g7;
	  long f2g8_19 = f2 * (long) g8_19;
	  long f2g9_19 = f2 * (long) g9_19;
	  long f3g0 = f3 * (long) g0;
	  long f3g1_2 = f3_2 * (long) g1;
	  long f3g2 = f3 * (long) g2;
	  long f3g3_2 = f3_2 * (long) g3;
	  long f3g4 = f3 * (long) g4;
	  long f3g5_2 = f3_2 * (long) g5;
	  long f3g6 = f3 * (long) g6;
	  long f3g7_38 = f3_2 * (long) g7_19;
	  long f3g8_19 = f3 * (long) g8_19;
	  long f3g9_38 = f3_2 * (long) g9_19;
	  long f4g0 = f4 * (long) g0;
	  long f4g1 = f4 * (long) g1;
	  long f4g2 = f4 * (long) g2;
	  long f4g3 = f4 * (long) g3;
	  long f4g4 = f4 * (long) g4;
	  long f4g5 = f4 * (long) g5;
	  long f4g6_19 = f4 * (long) g6_19;
	  long f4g7_19 = f4 * (long) g7_19;
	  long f4g8_19 = f4 * (long) g8_19;
	  long f4g9_19 = f4 * (long) g9_19;
	  long f5g0 = f5 * (long) g0;
	  long f5g1_2 = f5_2 * (long) g1;
	  long f5g2 = f5 * (long) g2;
	  long f5g3_2 = f5_2 * (long) g3;
	  long f5g4 = f5 * (long) g4;
	  long f5g5_38 = f5_2 * (long) g5_19;
	  long f5g6_19 = f5 * (long) g6_19;
	  long f5g7_38 = f5_2 * (long) g7_19;
	  long f5g8_19 = f5 * (long) g8_19;
	  long f5g9_38 = f5_2 * (long) g9_19;
	  long f6g0 = f6 * (long) g0;
	  long f6g1 = f6 * (long) g1;
	  long f6g2 = f6 * (long) g2;
	  long f6g3 = f6 * (long) g3;
	  long f6g4_19 = f6 * (long) g4_19;
	  long f6g5_19 = f6 * (long) g5_19;
	  long f6g6_19 = f6 * (long) g6_19;
	  long f6g7_19 = f6 * (long) g7_19;
	  long f6g8_19 = f6 * (long) g8_19;
	  long f6g9_19 = f6 * (long) g9_19;
	  long f7g0 = f7 * (long) g0;
	  long f7g1_2 = f7_2 * (long) g1;
	  long f7g2 = f7 * (long) g2;
	  long f7g3_38 = f7_2 * (long) g3_19;
	  long f7g4_19 = f7 * (long) g4_19;
	  long f7g5_38 = f7_2 * (long) g5_19;
	  long f7g6_19 = f7 * (long) g6_19;
	  long f7g7_38 = f7_2 * (long) g7_19;
	  long f7g8_19 = f7 * (long) g8_19;
	  long f7g9_38 = f7_2 * (long) g9_19;
	  long f8g0 = f8 * (long) g0;
	  long f8g1 = f8 * (long) g1;
	  long f8g2_19 = f8 * (long) g2_19;
	  long f8g3_19 = f8 * (long) g3_19;
	  long f8g4_19 = f8 * (long) g4_19;
	  long f8g5_19 = f8 * (long) g5_19;
	  long f8g6_19 = f8 * (long) g6_19;
	  long f8g7_19 = f8 * (long) g7_19;
	  long f8g8_19 = f8 * (long) g8_19;
	  long f8g9_19 = f8 * (long) g9_19;
	  long f9g0 = f9 * (long) g0;
	  long f9g1_38 = f9_2 * (long) g1_19;
	  long f9g2_19 = f9 * (long) g2_19;
	  long f9g3_38 = f9_2 * (long) g3_19;
	  long f9g4_19 = f9 * (long) g4_19;
	  long f9g5_38 = f9_2 * (long) g5_19;
	  long f9g6_19 = f9 * (long) g6_19;
	  long f9g7_38 = f9_2 * (long) g7_19;
	  long f9g8_19 = f9 * (long) g8_19;
	  long f9g9_38 = f9_2 * (long) g9_19;
	  long h0 = f0g0 + f1g9_38 + f2g8_19 + f3g7_38 + f4g6_19 + f5g5_38 + f6g4_19 + f7g3_38 + f8g2_19 + f9g1_38;
	  long h1 = f0g1 + f1g0 + f2g9_19 + f3g8_19 + f4g7_19 + f5g6_19 + f6g5_19 + f7g4_19 + f8g3_19 + f9g2_19;
	  long h2 = f0g2 + f1g1_2 + f2g0 + f3g9_38 + f4g8_19 + f5g7_38 + f6g6_19 + f7g5_38 + f8g4_19 + f9g3_38;
	  long h3 = f0g3 + f1g2 + f2g1 + f3g0 + f4g9_19 + f5g8_19 + f6g7_19 + f7g6_19 + f8g5_19 + f9g4_19;
	  long h4 = f0g4 + f1g3_2 + f2g2 + f3g1_2 + f4g0 + f5g9_38 + f6g8_19 + f7g7_38 + f8g6_19 + f9g5_38;
	  long h5 = f0g5 + f1g4 + f2g3 + f3g2 + f4g1 + f5g0 + f6g9_19 + f7g8_19 + f8g7_19 + f9g6_19;
	  long h6 = f0g6 + f1g5_2 + f2g4 + f3g3_2 + f4g2 + f5g1_2 + f6g0 + f7g9_38 + f8g8_19 + f9g7_38;
	  long h7 = f0g7 + f1g6 + f2g5 + f3g4 + f4g3 + f5g2 + f6g1 + f7g0 + f8g9_19 + f9g8_19;
	  long h8 = f0g8 + f1g7_2 + f2g6 + f3g5_2 + f4g4 + f5g3_2 + f6g2 + f7g1_2 + f8g0 + f9g9_38;
	  long h9 = f0g9 + f1g8 + f2g7 + f3g6 + f4g5 + f5g4 + f6g3 + f7g2 + f8g1 + f9g0;
	  long carry0 = new long();
	  long carry1 = new long();
	  long carry2 = new long();
	  long carry3 = new long();
	  long carry4 = new long();
	  long carry5 = new long();
	  long carry6 = new long();
	  long carry7 = new long();
	  long carry8 = new long();
	  long carry9 = new long();

	  /*
	  |h0| <= (1.65*1.65*2^52*(1+19+19+19+19)+1.65*1.65*2^50*(38+38+38+38+38))
	    i.e. |h0| <= 1.4*2^60; narrower ranges for h2, h4, h6, h8
	  |h1| <= (1.65*1.65*2^51*(1+1+19+19+19+19+19+19+19+19))
	    i.e. |h1| <= 1.7*2^59; narrower ranges for h3, h5, h7, h9
	  */

	  carry0 = (h0 + (long)(1 << 25)) >> 26;
	  h1 += carry0;
	  h0 -= carry0 << 26;
	  carry4 = (h4 + (long)(1 << 25)) >> 26;
	  h5 += carry4;
	  h4 -= carry4 << 26;
	  /* |h0| <= 2^25 */
	  /* |h4| <= 2^25 */
	  /* |h1| <= 1.71*2^59 */
	  /* |h5| <= 1.71*2^59 */

	  carry1 = (h1 + (long)(1 << 24)) >> 25;
	  h2 += carry1;
	  h1 -= carry1 << 25;
	  carry5 = (h5 + (long)(1 << 24)) >> 25;
	  h6 += carry5;
	  h5 -= carry5 << 25;
	  /* |h1| <= 2^24; from now on fits into int32 */
	  /* |h5| <= 2^24; from now on fits into int32 */
	  /* |h2| <= 1.41*2^60 */
	  /* |h6| <= 1.41*2^60 */

	  carry2 = (h2 + (long)(1 << 25)) >> 26;
	  h3 += carry2;
	  h2 -= carry2 << 26;
	  carry6 = (h6 + (long)(1 << 25)) >> 26;
	  h7 += carry6;
	  h6 -= carry6 << 26;
	  /* |h2| <= 2^25; from now on fits into int32 unchanged */
	  /* |h6| <= 2^25; from now on fits into int32 unchanged */
	  /* |h3| <= 1.71*2^59 */
	  /* |h7| <= 1.71*2^59 */

	  carry3 = (h3 + (long)(1 << 24)) >> 25;
	  h4 += carry3;
	  h3 -= carry3 << 25;
	  carry7 = (h7 + (long)(1 << 24)) >> 25;
	  h8 += carry7;
	  h7 -= carry7 << 25;
	  /* |h3| <= 2^24; from now on fits into int32 unchanged */
	  /* |h7| <= 2^24; from now on fits into int32 unchanged */
	  /* |h4| <= 1.72*2^34 */
	  /* |h8| <= 1.41*2^60 */

	  carry4 = (h4 + (long)(1 << 25)) >> 26;
	  h5 += carry4;
	  h4 -= carry4 << 26;
	  carry8 = (h8 + (long)(1 << 25)) >> 26;
	  h9 += carry8;
	  h8 -= carry8 << 26;
	  /* |h4| <= 2^25; from now on fits into int32 unchanged */
	  /* |h8| <= 2^25; from now on fits into int32 unchanged */
	  /* |h5| <= 1.01*2^24 */
	  /* |h9| <= 1.71*2^59 */

	  carry9 = (h9 + (long)(1 << 24)) >> 25;
	  h0 += carry9 * 19;
	  h9 -= carry9 << 25;
	  /* |h9| <= 2^24; from now on fits into int32 unchanged */
	  /* |h0| <= 1.1*2^39 */

	  carry0 = (h0 + (long)(1 << 25)) >> 26;
	  h1 += carry0;
	  h0 -= carry0 << 26;
	  /* |h0| <= 2^25; from now on fits into int32 unchanged */
	  /* |h1| <= 1.01*2^24 */

	  h[0] = (int) h0;
	  h[1] = (int) h1;
	  h[2] = (int) h2;
	  h[3] = (int) h3;
	  h[4] = (int) h4;
	  h[5] = (int) h5;
	  h[6] = (int) h6;
	  h[7] = (int) h7;
	  h[8] = (int) h8;
	  h[9] = (int) h9;
	}

/* From fe_sq.c */

/*
h = f * f
Can overlap h with f.

Preconditions:
   |f| bounded by 1.65*2^26,1.65*2^25,1.65*2^26,1.65*2^25,etc.

Postconditions:
   |h| bounded by 1.01*2^25,1.01*2^24,1.01*2^25,1.01*2^24,etc.
*/

/*
See fe_mul.c for discussion of implementation strategy.
*/

	internal static void fe_sq(int[] h, int[] f)
	{
	  int f0 = f[0];
	  int f1 = f[1];
	  int f2 = f[2];
	  int f3 = f[3];
	  int f4 = f[4];
	  int f5 = f[5];
	  int f6 = f[6];
	  int f7 = f[7];
	  int f8 = f[8];
	  int f9 = f[9];
	  int f0_2 = 2 * f0;
	  int f1_2 = 2 * f1;
	  int f2_2 = 2 * f2;
	  int f3_2 = 2 * f3;
	  int f4_2 = 2 * f4;
	  int f5_2 = 2 * f5;
	  int f6_2 = 2 * f6;
	  int f7_2 = 2 * f7;
	  int f5_38 = 38 * f5; // 1.959375*2^30
	  int f6_19 = 19 * f6; // 1.959375*2^30
	  int f7_38 = 38 * f7; // 1.959375*2^30
	  int f8_19 = 19 * f8; // 1.959375*2^30
	  int f9_38 = 38 * f9; // 1.959375*2^30
	  long f0f0 = f0 * (long) f0;
	  long f0f1_2 = f0_2 * (long) f1;
	  long f0f2_2 = f0_2 * (long) f2;
	  long f0f3_2 = f0_2 * (long) f3;
	  long f0f4_2 = f0_2 * (long) f4;
	  long f0f5_2 = f0_2 * (long) f5;
	  long f0f6_2 = f0_2 * (long) f6;
	  long f0f7_2 = f0_2 * (long) f7;
	  long f0f8_2 = f0_2 * (long) f8;
	  long f0f9_2 = f0_2 * (long) f9;
	  long f1f1_2 = f1_2 * (long) f1;
	  long f1f2_2 = f1_2 * (long) f2;
	  long f1f3_4 = f1_2 * (long) f3_2;
	  long f1f4_2 = f1_2 * (long) f4;
	  long f1f5_4 = f1_2 * (long) f5_2;
	  long f1f6_2 = f1_2 * (long) f6;
	  long f1f7_4 = f1_2 * (long) f7_2;
	  long f1f8_2 = f1_2 * (long) f8;
	  long f1f9_76 = f1_2 * (long) f9_38;
	  long f2f2 = f2 * (long) f2;
	  long f2f3_2 = f2_2 * (long) f3;
	  long f2f4_2 = f2_2 * (long) f4;
	  long f2f5_2 = f2_2 * (long) f5;
	  long f2f6_2 = f2_2 * (long) f6;
	  long f2f7_2 = f2_2 * (long) f7;
	  long f2f8_38 = f2_2 * (long) f8_19;
	  long f2f9_38 = f2 * (long) f9_38;
	  long f3f3_2 = f3_2 * (long) f3;
	  long f3f4_2 = f3_2 * (long) f4;
	  long f3f5_4 = f3_2 * (long) f5_2;
	  long f3f6_2 = f3_2 * (long) f6;
	  long f3f7_76 = f3_2 * (long) f7_38;
	  long f3f8_38 = f3_2 * (long) f8_19;
	  long f3f9_76 = f3_2 * (long) f9_38;
	  long f4f4 = f4 * (long) f4;
	  long f4f5_2 = f4_2 * (long) f5;
	  long f4f6_38 = f4_2 * (long) f6_19;
	  long f4f7_38 = f4 * (long) f7_38;
	  long f4f8_38 = f4_2 * (long) f8_19;
	  long f4f9_38 = f4 * (long) f9_38;
	  long f5f5_38 = f5 * (long) f5_38;
	  long f5f6_38 = f5_2 * (long) f6_19;
	  long f5f7_76 = f5_2 * (long) f7_38;
	  long f5f8_38 = f5_2 * (long) f8_19;
	  long f5f9_76 = f5_2 * (long) f9_38;
	  long f6f6_19 = f6 * (long) f6_19;
	  long f6f7_38 = f6 * (long) f7_38;
	  long f6f8_38 = f6_2 * (long) f8_19;
	  long f6f9_38 = f6 * (long) f9_38;
	  long f7f7_38 = f7 * (long) f7_38;
	  long f7f8_38 = f7_2 * (long) f8_19;
	  long f7f9_76 = f7_2 * (long) f9_38;
	  long f8f8_19 = f8 * (long) f8_19;
	  long f8f9_38 = f8 * (long) f9_38;
	  long f9f9_38 = f9 * (long) f9_38;
	  long h0 = f0f0 + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38;
	  long h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38;
	  long h2 = f0f2_2 + f1f1_2 + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19;
	  long h3 = f0f3_2 + f1f2_2 + f4f9_38 + f5f8_38 + f6f7_38;
	  long h4 = f0f4_2 + f1f3_4 + f2f2 + f5f9_76 + f6f8_38 + f7f7_38;
	  long h5 = f0f5_2 + f1f4_2 + f2f3_2 + f6f9_38 + f7f8_38;
	  long h6 = f0f6_2 + f1f5_4 + f2f4_2 + f3f3_2 + f7f9_76 + f8f8_19;
	  long h7 = f0f7_2 + f1f6_2 + f2f5_2 + f3f4_2 + f8f9_38;
	  long h8 = f0f8_2 + f1f7_4 + f2f6_2 + f3f5_4 + f4f4 + f9f9_38;
	  long h9 = f0f9_2 + f1f8_2 + f2f7_2 + f3f6_2 + f4f5_2;
	  long carry0 = new long();
	  long carry1 = new long();
	  long carry2 = new long();
	  long carry3 = new long();
	  long carry4 = new long();
	  long carry5 = new long();
	  long carry6 = new long();
	  long carry7 = new long();
	  long carry8 = new long();
	  long carry9 = new long();

	  carry0 = (h0 + (long)(1 << 25)) >> 26;
	  h1 += carry0;
	  h0 -= carry0 << 26;
	  carry4 = (h4 + (long)(1 << 25)) >> 26;
	  h5 += carry4;
	  h4 -= carry4 << 26;

	  carry1 = (h1 + (long)(1 << 24)) >> 25;
	  h2 += carry1;
	  h1 -= carry1 << 25;
	  carry5 = (h5 + (long)(1 << 24)) >> 25;
	  h6 += carry5;
	  h5 -= carry5 << 25;

	  carry2 = (h2 + (long)(1 << 25)) >> 26;
	  h3 += carry2;
	  h2 -= carry2 << 26;
	  carry6 = (h6 + (long)(1 << 25)) >> 26;
	  h7 += carry6;
	  h6 -= carry6 << 26;

	  carry3 = (h3 + (long)(1 << 24)) >> 25;
	  h4 += carry3;
	  h3 -= carry3 << 25;
	  carry7 = (h7 + (long)(1 << 24)) >> 25;
	  h8 += carry7;
	  h7 -= carry7 << 25;

	  carry4 = (h4 + (long)(1 << 25)) >> 26;
	  h5 += carry4;
	  h4 -= carry4 << 26;
	  carry8 = (h8 + (long)(1 << 25)) >> 26;
	  h9 += carry8;
	  h8 -= carry8 << 26;

	  carry9 = (h9 + (long)(1 << 24)) >> 25;
	  h0 += carry9 * 19;
	  h9 -= carry9 << 25;

	  carry0 = (h0 + (long)(1 << 25)) >> 26;
	  h1 += carry0;
	  h0 -= carry0 << 26;

	  h[0] = (int) h0;
	  h[1] = (int) h1;
	  h[2] = (int) h2;
	  h[3] = (int) h3;
	  h[4] = (int) h4;
	  h[5] = (int) h5;
	  h[6] = (int) h6;
	  h[7] = (int) h7;
	  h[8] = (int) h8;
	  h[9] = (int) h9;
	}

/* From fe_tobytes.c */

/*
Preconditions:
  |h| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.

Write p=2^255-19; q=floor(h/p).
Basic claim: q = floor(2^(-255)(h + 19 2^(-25)h9 + 2^(-1))).

Proof:
  Have |h|<=p so |q|<=1 so |19^2 2^(-255) q|<1/4.
  Also have |h-2^230 h9|<2^231 so |19 2^(-255)(h-2^230 h9)|<1/4.

  Write y=2^(-1)-19^2 2^(-255)q-19 2^(-255)(h-2^230 h9).
  Then 0<y<1.

  Write r=h-pq.
  Have 0<=r<=p-1=2^255-20.
  Thus 0<=r+19(2^-255)r<r+19(2^-255)2^255<=2^255-1.

  Write x=r+19(2^-255)r+y.
  Then 0<x<2^255 so floor(2^(-255)x) = 0 so floor(q+2^(-255)x) = q.

  Have q+2^(-255)x = 2^(-255)(h + 19 2^(-25) h9 + 2^(-1))
  so floor(2^(-255)(h + 19 2^(-25) h9 + 2^(-1))) = q.
*/

	internal static void fe_tobytes(byte[] s, int[] h)
	{
	  int h0 = h[0];
	  int h1 = h[1];
	  int h2 = h[2];
	  int h3 = h[3];
	  int h4 = h[4];
	  int h5 = h[5];
	  int h6 = h[6];
	  int h7 = h[7];
	  int h8 = h[8];
	  int h9 = h[9];
	  int q = new int();
	  int carry0 = new int();
	  int carry1 = new int();
	  int carry2 = new int();
	  int carry3 = new int();
	  int carry4 = new int();
	  int carry5 = new int();
	  int carry6 = new int();
	  int carry7 = new int();
	  int carry8 = new int();
	  int carry9 = new int();

	  q = (19 * h9 + (((int) 1) << 24)) >> 25;
	  q = (h0 + q) >> 26;
	  q = (h1 + q) >> 25;
	  q = (h2 + q) >> 26;
	  q = (h3 + q) >> 25;
	  q = (h4 + q) >> 26;
	  q = (h5 + q) >> 25;
	  q = (h6 + q) >> 26;
	  q = (h7 + q) >> 25;
	  q = (h8 + q) >> 26;
	  q = (h9 + q) >> 25;

	  /* Goal: Output h-(2^255-19)q, which is between 0 and 2^255-20. */
	  h0 += 19 * q;
	  /* Goal: Output h-2^255 q, which is between 0 and 2^255-20. */

	  carry0 = h0 >> 26;
	  h1 += carry0;
	  h0 -= carry0 << 26;
	  carry1 = h1 >> 25;
	  h2 += carry1;
	  h1 -= carry1 << 25;
	  carry2 = h2 >> 26;
	  h3 += carry2;
	  h2 -= carry2 << 26;
	  carry3 = h3 >> 25;
	  h4 += carry3;
	  h3 -= carry3 << 25;
	  carry4 = h4 >> 26;
	  h5 += carry4;
	  h4 -= carry4 << 26;
	  carry5 = h5 >> 25;
	  h6 += carry5;
	  h5 -= carry5 << 25;
	  carry6 = h6 >> 26;
	  h7 += carry6;
	  h6 -= carry6 << 26;
	  carry7 = h7 >> 25;
	  h8 += carry7;
	  h7 -= carry7 << 25;
	  carry8 = h8 >> 26;
	  h9 += carry8;
	  h8 -= carry8 << 26;
	  carry9 = h9 >> 25;
	  h9 -= carry9 << 25;
					  /* h10 = carry9 */

	  /*
	  Goal: Output h0+...+2^255 h10-2^255 q, which is between 0 and 2^255-20.
	  Have h0+...+2^230 h9 between 0 and 2^255-1;
	  evidently 2^255 h10-2^255 q = 0.
	  Goal: Output h0+...+2^230 h9.
	  */

	  s[0] = h0 >> 0;
	  s[1] = h0 >> 8;
	  s[2] = h0 >> 16;
	  s[3] = (h0 >> 24) | (h1 << 2);
	  s[4] = h1 >> 6;
	  s[5] = h1 >> 14;
	  s[6] = (h1 >> 22) | (h2 << 3);
	  s[7] = h2 >> 5;
	  s[8] = h2 >> 13;
	  s[9] = (h2 >> 21) | (h3 << 5);
	  s[10] = h3 >> 3;
	  s[11] = h3 >> 11;
	  s[12] = (h3 >> 19) | (h4 << 6);
	  s[13] = h4 >> 2;
	  s[14] = h4 >> 10;
	  s[15] = h4 >> 18;
	  s[16] = h5 >> 0;
	  s[17] = h5 >> 8;
	  s[18] = h5 >> 16;
	  s[19] = (h5 >> 24) | (h6 << 1);
	  s[20] = h6 >> 7;
	  s[21] = h6 >> 15;
	  s[22] = (h6 >> 23) | (h7 << 3);
	  s[23] = h7 >> 5;
	  s[24] = h7 >> 13;
	  s[25] = (h7 >> 21) | (h8 << 4);
	  s[26] = h8 >> 4;
	  s[27] = h8 >> 12;
	  s[28] = (h8 >> 20) | (h9 << 6);
	  s[29] = h9 >> 2;
	  s[30] = h9 >> 10;
	  s[31] = h9 >> 18;
	}

/* From ge_madd.c */

/*
r = p + q
*/

	internal static void ge_madd(ge_p1p1 r, ge_p3 p, ge_precomp q)
	{
	  int[] t0 = Arrays.InitializeWithDefaultInstances<int>(10);
	  fe_add(r.X, p.Y, p.X);
	  fe_sub(r.Y, p.Y, p.X);
	  fe_mul(r.Z, r.X, q.yplusx);
	  fe_mul(r.Y, r.Y, q.yminusx);
	  fe_mul(r.T, q.xy2d, p.T);
	  fe_add(t0, p.Z, p.Z);
	  fe_sub(r.X, r.Z, r.Y);
	  fe_add(r.Y, r.Z, r.Y);
	  fe_add(r.Z, t0, r.T);
	  fe_sub(r.T, t0, r.T);
	}

/* From ge_msub.c */

/*
r = p - q
*/

	internal static void ge_msub(ge_p1p1 r, ge_p3 p, ge_precomp q)
	{
	  int[] t0 = Arrays.InitializeWithDefaultInstances<int>(10);
	  fe_add(r.X, p.Y, p.X);
	  fe_sub(r.Y, p.Y, p.X);
	  fe_mul(r.Z, r.X, q.yminusx);
	  fe_mul(r.Y, r.Y, q.yplusx);
	  fe_mul(r.T, q.xy2d, p.T);
	  fe_add(t0, p.Z, p.Z);
	  fe_sub(r.X, r.Z, r.Y);
	  fe_add(r.Y, r.Z, r.Y);
	  fe_sub(r.Z, t0, r.T);
	  fe_add(r.T, t0, r.T);
	}

/* From ge_p2_0.c */

	internal static void ge_p2_0(ge_p2 h)
	{
	  fe_0(h.X);
	  fe_1(h.Y);
	  fe_1(h.Z);
	}

/* From ge_p3_dbl.c */

/*
r = 2 * p
*/

	internal static void ge_p3_dbl(ge_p1p1 r, ge_p3 p)
	{
	  ge_p2 q = new ge_p2();
	  ge_p3_to_p2(q, p);
	  ge_p2_dbl(r, q);
	}

/* New code */

	internal static void fe_divpowm1(int[] r, int[] u, int[] v)
	{
	  int[] v3 = Arrays.InitializeWithDefaultInstances<int>(10);
	  int uv7 = new int();
	  int t0 = new int();
	  int t1 = new int();
	  int t2 = new int();
	  int i;

	  fe_sq(v3, v);
	  fe_mul(v3, v3, v); // v3 = v^3
	  fe_sq(new int(uv7), v3);
	  fe_mul(new int(uv7), new int(uv7), v);
	  fe_mul(new int(uv7), new int(uv7), u); // uv7 = uv^7

	  /*fe_pow22523(uv7, uv7);*/

	  /* From fe_pow22523.c */

	  fe_sq(new int(t0), new int(uv7));
	  fe_sq(new int(t1), new int(t0));
	  fe_sq(new int(t1), new int(t1));
	  fe_mul(new int(t1), new int(uv7), new int(t1));
	  fe_mul(new int(t0), new int(t0), new int(t1));
	  fe_sq(new int(t0), new int(t0));
	  fe_mul(new int(t0), new int(t1), new int(t0));
	  fe_sq(new int(t1), new int(t0));
	  for (i = 0; i < 4; ++i)
	  {
		fe_sq(new int(t1), new int(t1));
	  }
	  fe_mul(new int(t0), new int(t1), new int(t0));
	  fe_sq(new int(t1), new int(t0));
	  for (i = 0; i < 9; ++i)
	  {
		fe_sq(new int(t1), new int(t1));
	  }
	  fe_mul(new int(t1), new int(t1), new int(t0));
	  fe_sq(new int(t2), new int(t1));
	  for (i = 0; i < 19; ++i)
	  {
		fe_sq(new int(t2), new int(t2));
	  }
	  fe_mul(new int(t1), new int(t2), new int(t1));
	  for (i = 0; i < 10; ++i)
	  {
		fe_sq(new int(t1), new int(t1));
	  }
	  fe_mul(new int(t0), new int(t1), new int(t0));
	  fe_sq(new int(t1), new int(t0));
	  for (i = 0; i < 49; ++i)
	  {
		fe_sq(new int(t1), new int(t1));
	  }
	  fe_mul(new int(t1), new int(t1), new int(t0));
	  fe_sq(new int(t2), new int(t1));
	  for (i = 0; i < 99; ++i)
	  {
		fe_sq(new int(t2), new int(t2));
	  }
	  fe_mul(new int(t1), new int(t2), new int(t1));
	  for (i = 0; i < 50; ++i)
	  {
		fe_sq(new int(t1), new int(t1));
	  }
	  fe_mul(new int(t0), new int(t1), new int(t0));
	  fe_sq(new int(t0), new int(t0));
	  fe_sq(new int(t0), new int(t0));
	  fe_mul(new int(t0), new int(t0), new int(uv7));

	  /* End fe_pow22523.c */
	  /* t0 = (uv^7)^((q-5)/8) */
	  fe_mul(new int(t0), new int(t0), v3);
	  fe_mul(r, new int(t0), u); // u^(m+1)v^(-(m+1))
	}

	/* Common functions */

	internal static ulong load_3(byte[] in)
	{
	  ulong result = new ulong();
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: result = (ulong) in[0];
	  result.CopyFrom((ulong) in[0]);
	  result |= ((ulong) in[1]) << 8;
	  result |= ((ulong) in[2]) << 16;
	  return result;
	}

	internal static ulong load_4(byte[] in)
	{
	  ulong result = new ulong();
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: result = (ulong) in[0];
	  result.CopyFrom((ulong) in[0]);
	  result |= ((ulong) in[1]) << 8;
	  result |= ((ulong) in[2]) << 16;
	  result |= ((ulong) in[3]) << 24;
	  return result;
	}

	/* From fe_0.c */

	/*
	h = 0
	*/

	internal static void fe_0(int[] h)
	{
	  h[0] = 0;
	  h[1] = 0;
	  h[2] = 0;
	  h[3] = 0;
	  h[4] = 0;
	  h[5] = 0;
	  h[6] = 0;
	  h[7] = 0;
	  h[8] = 0;
	  h[9] = 0;
	}

	/* From fe_1.c */

	/*
	h = 1
	*/

	internal static void fe_1(int[] h)
	{
	  h[0] = 1;
	  h[1] = 0;
	  h[2] = 0;
	  h[3] = 0;
	  h[4] = 0;
	  h[5] = 0;
	  h[6] = 0;
	  h[7] = 0;
	  h[8] = 0;
	  h[9] = 0;
	}

	/* From fe_add.c */

	/*
	h = f + g
	Can overlap h with f or g.
	
	Preconditions:
	   |f| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
	   |g| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
	
	Postconditions:
	   |h| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
	*/

	internal static void fe_add(int[] h, int[] f, int[] g)
	{
	  int f0 = f[0];
	  int f1 = f[1];
	  int f2 = f[2];
	  int f3 = f[3];
	  int f4 = f[4];
	  int f5 = f[5];
	  int f6 = f[6];
	  int f7 = f[7];
	  int f8 = f[8];
	  int f9 = f[9];
	  int g0 = g[0];
	  int g1 = g[1];
	  int g2 = g[2];
	  int g3 = g[3];
	  int g4 = g[4];
	  int g5 = g[5];
	  int g6 = g[6];
	  int g7 = g[7];
	  int g8 = g[8];
	  int g9 = g[9];
	  int h0 = f0 + g0;
	  int h1 = f1 + g1;
	  int h2 = f2 + g2;
	  int h3 = f3 + g3;
	  int h4 = f4 + g4;
	  int h5 = f5 + g5;
	  int h6 = f6 + g6;
	  int h7 = f7 + g7;
	  int h8 = f8 + g8;
	  int h9 = f9 + g9;
	  h[0] = h0;
	  h[1] = h1;
	  h[2] = h2;
	  h[3] = h3;
	  h[4] = h4;
	  h[5] = h5;
	  h[6] = h6;
	  h[7] = h7;
	  h[8] = h8;
	  h[9] = h9;
	}

	/* From fe_cmov.c */

	/*
	Replace (f,g) with (g,g) if b == 1;
	replace (f,g) with (f,g) if b == 0.
	
	Preconditions: b in {0,1}.
	*/

	internal static void fe_cmov(int[] f, int[] g, uint b)
	{
	  int f0 = f[0];
	  int f1 = f[1];
	  int f2 = f[2];
	  int f3 = f[3];
	  int f4 = f[4];
	  int f5 = f[5];
	  int f6 = f[6];
	  int f7 = f[7];
	  int f8 = f[8];
	  int f9 = f[9];
	  int g0 = g[0];
	  int g1 = g[1];
	  int g2 = g[2];
	  int g3 = g[3];
	  int g4 = g[4];
	  int g5 = g[5];
	  int g6 = g[6];
	  int g7 = g[7];
	  int g8 = g[8];
	  int g9 = g[9];
	  int x0 = f0 ^ g0;
	  int x1 = f1 ^ g1;
	  int x2 = f2 ^ g2;
	  int x3 = f3 ^ g3;
	  int x4 = f4 ^ g4;
	  int x5 = f5 ^ g5;
	  int x6 = f6 ^ g6;
	  int x7 = f7 ^ g7;
	  int x8 = f8 ^ g8;
	  int x9 = f9 ^ g9;
	  Debug.Assert((((b - 1) & ~b) | ((b - 2) & ~(b - 1))) == (uint) -1);
	  b = -(int) b;
	  x0 &= b;
	  x1 &= b;
	  x2 &= b;
	  x3 &= b;
	  x4 &= b;
	  x5 &= b;
	  x6 &= b;
	  x7 &= b;
	  x8 &= b;
	  x9 &= b;
	  f[0] = f0 ^ x0;
	  f[1] = f1 ^ x1;
	  f[2] = f2 ^ x2;
	  f[3] = f3 ^ x3;
	  f[4] = f4 ^ x4;
	  f[5] = f5 ^ x5;
	  f[6] = f6 ^ x6;
	  f[7] = f7 ^ x7;
	  f[8] = f8 ^ x8;
	  f[9] = f9 ^ x9;
	}

	/* From fe_copy.c */

	/*
	h = f
	*/

	internal static void fe_copy(int[] h, int[] f)
	{
	  int f0 = f[0];
	  int f1 = f[1];
	  int f2 = f[2];
	  int f3 = f[3];
	  int f4 = f[4];
	  int f5 = f[5];
	  int f6 = f[6];
	  int f7 = f[7];
	  int f8 = f[8];
	  int f9 = f[9];
	  h[0] = f0;
	  h[1] = f1;
	  h[2] = f2;
	  h[3] = f3;
	  h[4] = f4;
	  h[5] = f5;
	  h[6] = f6;
	  h[7] = f7;
	  h[8] = f8;
	  h[9] = f9;
	}

	/* From fe_invert.c */

	internal static void fe_invert(int[] @out, int[] z)
	{
	  int[] t0 = Arrays.InitializeWithDefaultInstances<int>(10);
	  int[] t1 = Arrays.InitializeWithDefaultInstances<int>(10);
	  int[] t2 = Arrays.InitializeWithDefaultInstances<int>(10);
	  int[] t3 = Arrays.InitializeWithDefaultInstances<int>(10);
	  int i;

	  fe_sq(t0, z);
	  fe_sq(t1, t0);
	  fe_sq(t1, t1);
	  fe_mul(t1, z, t1);
	  fe_mul(t0, t0, t1);
	  fe_sq(t2, t0);
	  fe_mul(t1, t1, t2);
	  fe_sq(t2, t1);
	  for (i = 0; i < 4; ++i)
	  {
		fe_sq(t2, t2);
	  }
	  fe_mul(t1, t2, t1);
	  fe_sq(t2, t1);
	  for (i = 0; i < 9; ++i)
	  {
		fe_sq(t2, t2);
	  }
	  fe_mul(t2, t2, t1);
	  fe_sq(t3, t2);
	  for (i = 0; i < 19; ++i)
	  {
		fe_sq(t3, t3);
	  }
	  fe_mul(t2, t3, t2);
	  fe_sq(t2, t2);
	  for (i = 0; i < 9; ++i)
	  {
		fe_sq(t2, t2);
	  }
	  fe_mul(t1, t2, t1);
	  fe_sq(t2, t1);
	  for (i = 0; i < 49; ++i)
	  {
		fe_sq(t2, t2);
	  }
	  fe_mul(t2, t2, t1);
	  fe_sq(t3, t2);
	  for (i = 0; i < 99; ++i)
	  {
		fe_sq(t3, t3);
	  }
	  fe_mul(t2, t3, t2);
	  fe_sq(t2, t2);
	  for (i = 0; i < 49; ++i)
	  {
		fe_sq(t2, t2);
	  }
	  fe_mul(t1, t2, t1);
	  fe_sq(t1, t1);
	  for (i = 0; i < 4; ++i)
	  {
		fe_sq(t1, t1);
	  }
	  fe_mul(@out, t1, t0);

	  return;
	}

	/* From fe_isnegative.c */

	/*
	return 1 if f is in {1,3,5,...,q-2}
	return 0 if f is in {0,2,4,...,q-1}
	
	Preconditions:
	   |f| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
	*/

	internal static int fe_isnegative(int[] f)
	{
	  byte[] s = new byte[32];
	  fe_tobytes(s, f);
	  return s[0] & 1;
	}

	/* From fe_isnonzero.c, modified */

	internal static int fe_isnonzero(int[] f)
	{
	  byte[] s = new byte[32];
	  fe_tobytes(s, f);
	  return (((int)(s[0] | s[1] | s[2] | s[3] | s[4] | s[5] | s[6] | s[7] | s[8] | s[9] | s[10] | s[11] | s[12] | s[13] | s[14] | s[15] | s[16] | s[17] | s[18] | s[19] | s[20] | s[21] | s[22] | s[23] | s[24] | s[25] | s[26] | s[27] | s[28] | s[29] | s[30] | s[31]) - 1) >> 8) + 1;
	}

	/* From fe_neg.c */

	/*
	h = -f
	
	Preconditions:
	   |f| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
	
	Postconditions:
	   |h| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
	*/

	internal static void fe_neg(int[] h, int[] f)
	{
	  int f0 = f[0];
	  int f1 = f[1];
	  int f2 = f[2];
	  int f3 = f[3];
	  int f4 = f[4];
	  int f5 = f[5];
	  int f6 = f[6];
	  int f7 = f[7];
	  int f8 = f[8];
	  int f9 = f[9];
	  int h0 = -f0;
	  int h1 = -f1;
	  int h2 = -f2;
	  int h3 = -f3;
	  int h4 = -f4;
	  int h5 = -f5;
	  int h6 = -f6;
	  int h7 = -f7;
	  int h8 = -f8;
	  int h9 = -f9;
	  h[0] = h0;
	  h[1] = h1;
	  h[2] = h2;
	  h[3] = h3;
	  h[4] = h4;
	  h[5] = h5;
	  h[6] = h6;
	  h[7] = h7;
	  h[8] = h8;
	  h[9] = h9;
	}

	/* From fe_sq2.c */

	/*
	h = 2 * f * f
	Can overlap h with f.
	
	Preconditions:
	   |f| bounded by 1.65*2^26,1.65*2^25,1.65*2^26,1.65*2^25,etc.
	
	Postconditions:
	   |h| bounded by 1.01*2^25,1.01*2^24,1.01*2^25,1.01*2^24,etc.
	*/

	/*
	See fe_mul.c for discussion of implementation strategy.
	*/

	internal static void fe_sq2(int[] h, int[] f)
	{
	  int f0 = f[0];
	  int f1 = f[1];
	  int f2 = f[2];
	  int f3 = f[3];
	  int f4 = f[4];
	  int f5 = f[5];
	  int f6 = f[6];
	  int f7 = f[7];
	  int f8 = f[8];
	  int f9 = f[9];
	  int f0_2 = 2 * f0;
	  int f1_2 = 2 * f1;
	  int f2_2 = 2 * f2;
	  int f3_2 = 2 * f3;
	  int f4_2 = 2 * f4;
	  int f5_2 = 2 * f5;
	  int f6_2 = 2 * f6;
	  int f7_2 = 2 * f7;
	  int f5_38 = 38 * f5; // 1.959375*2^30
	  int f6_19 = 19 * f6; // 1.959375*2^30
	  int f7_38 = 38 * f7; // 1.959375*2^30
	  int f8_19 = 19 * f8; // 1.959375*2^30
	  int f9_38 = 38 * f9; // 1.959375*2^30
	  long f0f0 = f0 * (long) f0;
	  long f0f1_2 = f0_2 * (long) f1;
	  long f0f2_2 = f0_2 * (long) f2;
	  long f0f3_2 = f0_2 * (long) f3;
	  long f0f4_2 = f0_2 * (long) f4;
	  long f0f5_2 = f0_2 * (long) f5;
	  long f0f6_2 = f0_2 * (long) f6;
	  long f0f7_2 = f0_2 * (long) f7;
	  long f0f8_2 = f0_2 * (long) f8;
	  long f0f9_2 = f0_2 * (long) f9;
	  long f1f1_2 = f1_2 * (long) f1;
	  long f1f2_2 = f1_2 * (long) f2;
	  long f1f3_4 = f1_2 * (long) f3_2;
	  long f1f4_2 = f1_2 * (long) f4;
	  long f1f5_4 = f1_2 * (long) f5_2;
	  long f1f6_2 = f1_2 * (long) f6;
	  long f1f7_4 = f1_2 * (long) f7_2;
	  long f1f8_2 = f1_2 * (long) f8;
	  long f1f9_76 = f1_2 * (long) f9_38;
	  long f2f2 = f2 * (long) f2;
	  long f2f3_2 = f2_2 * (long) f3;
	  long f2f4_2 = f2_2 * (long) f4;
	  long f2f5_2 = f2_2 * (long) f5;
	  long f2f6_2 = f2_2 * (long) f6;
	  long f2f7_2 = f2_2 * (long) f7;
	  long f2f8_38 = f2_2 * (long) f8_19;
	  long f2f9_38 = f2 * (long) f9_38;
	  long f3f3_2 = f3_2 * (long) f3;
	  long f3f4_2 = f3_2 * (long) f4;
	  long f3f5_4 = f3_2 * (long) f5_2;
	  long f3f6_2 = f3_2 * (long) f6;
	  long f3f7_76 = f3_2 * (long) f7_38;
	  long f3f8_38 = f3_2 * (long) f8_19;
	  long f3f9_76 = f3_2 * (long) f9_38;
	  long f4f4 = f4 * (long) f4;
	  long f4f5_2 = f4_2 * (long) f5;
	  long f4f6_38 = f4_2 * (long) f6_19;
	  long f4f7_38 = f4 * (long) f7_38;
	  long f4f8_38 = f4_2 * (long) f8_19;
	  long f4f9_38 = f4 * (long) f9_38;
	  long f5f5_38 = f5 * (long) f5_38;
	  long f5f6_38 = f5_2 * (long) f6_19;
	  long f5f7_76 = f5_2 * (long) f7_38;
	  long f5f8_38 = f5_2 * (long) f8_19;
	  long f5f9_76 = f5_2 * (long) f9_38;
	  long f6f6_19 = f6 * (long) f6_19;
	  long f6f7_38 = f6 * (long) f7_38;
	  long f6f8_38 = f6_2 * (long) f8_19;
	  long f6f9_38 = f6 * (long) f9_38;
	  long f7f7_38 = f7 * (long) f7_38;
	  long f7f8_38 = f7_2 * (long) f8_19;
	  long f7f9_76 = f7_2 * (long) f9_38;
	  long f8f8_19 = f8 * (long) f8_19;
	  long f8f9_38 = f8 * (long) f9_38;
	  long f9f9_38 = f9 * (long) f9_38;
	  long h0 = f0f0 + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38;
	  long h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38;
	  long h2 = f0f2_2 + f1f1_2 + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19;
	  long h3 = f0f3_2 + f1f2_2 + f4f9_38 + f5f8_38 + f6f7_38;
	  long h4 = f0f4_2 + f1f3_4 + f2f2 + f5f9_76 + f6f8_38 + f7f7_38;
	  long h5 = f0f5_2 + f1f4_2 + f2f3_2 + f6f9_38 + f7f8_38;
	  long h6 = f0f6_2 + f1f5_4 + f2f4_2 + f3f3_2 + f7f9_76 + f8f8_19;
	  long h7 = f0f7_2 + f1f6_2 + f2f5_2 + f3f4_2 + f8f9_38;
	  long h8 = f0f8_2 + f1f7_4 + f2f6_2 + f3f5_4 + f4f4 + f9f9_38;
	  long h9 = f0f9_2 + f1f8_2 + f2f7_2 + f3f6_2 + f4f5_2;
	  long carry0 = new long();
	  long carry1 = new long();
	  long carry2 = new long();
	  long carry3 = new long();
	  long carry4 = new long();
	  long carry5 = new long();
	  long carry6 = new long();
	  long carry7 = new long();
	  long carry8 = new long();
	  long carry9 = new long();

	  h0 += h0;
	  h1 += h1;
	  h2 += h2;
	  h3 += h3;
	  h4 += h4;
	  h5 += h5;
	  h6 += h6;
	  h7 += h7;
	  h8 += h8;
	  h9 += h9;

	  carry0 = (h0 + (long)(1 << 25)) >> 26;
	  h1 += carry0;
	  h0 -= carry0 << 26;
	  carry4 = (h4 + (long)(1 << 25)) >> 26;
	  h5 += carry4;
	  h4 -= carry4 << 26;

	  carry1 = (h1 + (long)(1 << 24)) >> 25;
	  h2 += carry1;
	  h1 -= carry1 << 25;
	  carry5 = (h5 + (long)(1 << 24)) >> 25;
	  h6 += carry5;
	  h5 -= carry5 << 25;

	  carry2 = (h2 + (long)(1 << 25)) >> 26;
	  h3 += carry2;
	  h2 -= carry2 << 26;
	  carry6 = (h6 + (long)(1 << 25)) >> 26;
	  h7 += carry6;
	  h6 -= carry6 << 26;

	  carry3 = (h3 + (long)(1 << 24)) >> 25;
	  h4 += carry3;
	  h3 -= carry3 << 25;
	  carry7 = (h7 + (long)(1 << 24)) >> 25;
	  h8 += carry7;
	  h7 -= carry7 << 25;

	  carry4 = (h4 + (long)(1 << 25)) >> 26;
	  h5 += carry4;
	  h4 -= carry4 << 26;
	  carry8 = (h8 + (long)(1 << 25)) >> 26;
	  h9 += carry8;
	  h8 -= carry8 << 26;

	  carry9 = (h9 + (long)(1 << 24)) >> 25;
	  h0 += carry9 * 19;
	  h9 -= carry9 << 25;

	  carry0 = (h0 + (long)(1 << 25)) >> 26;
	  h1 += carry0;
	  h0 -= carry0 << 26;

	  h[0] = (int) h0;
	  h[1] = (int) h1;
	  h[2] = (int) h2;
	  h[3] = (int) h3;
	  h[4] = (int) h4;
	  h[5] = (int) h5;
	  h[6] = (int) h6;
	  h[7] = (int) h7;
	  h[8] = (int) h8;
	  h[9] = (int) h9;
	}

	/* From fe_sub.c */

	/*
	h = f - g
	Can overlap h with f or g.
	
	Preconditions:
	   |f| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
	   |g| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
	
	Postconditions:
	   |h| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
	*/

	internal static void fe_sub(int[] h, int[] f, int[] g)
	{
	  int f0 = f[0];
	  int f1 = f[1];
	  int f2 = f[2];
	  int f3 = f[3];
	  int f4 = f[4];
	  int f5 = f[5];
	  int f6 = f[6];
	  int f7 = f[7];
	  int f8 = f[8];
	  int f9 = f[9];
	  int g0 = g[0];
	  int g1 = g[1];
	  int g2 = g[2];
	  int g3 = g[3];
	  int g4 = g[4];
	  int g5 = g[5];
	  int g6 = g[6];
	  int g7 = g[7];
	  int g8 = g[8];
	  int g9 = g[9];
	  int h0 = f0 - g0;
	  int h1 = f1 - g1;
	  int h2 = f2 - g2;
	  int h3 = f3 - g3;
	  int h4 = f4 - g4;
	  int h5 = f5 - g5;
	  int h6 = f6 - g6;
	  int h7 = f7 - g7;
	  int h8 = f8 - g8;
	  int h9 = f9 - g9;
	  h[0] = h0;
	  h[1] = h1;
	  h[2] = h2;
	  h[3] = h3;
	  h[4] = h4;
	  h[5] = h5;
	  h[6] = h6;
	  h[7] = h7;
	  h[8] = h8;
	  h[9] = h9;
	}

	/* From ge_double_scalarmult.c, modified */

	internal static void slide(ref string r, byte[] a)
	{
	  int i;
	  int b;
	  int k;

	  for (i = 0; i < 256; ++i)
	  {
		r[i] = 1 & (a[i >> 3] >> (i & 7));
	  }

	  for (i = 0; i < 256; ++i)
	  {
		if (r[i])
		{
		  for (b = 1; b <= 6 && i + b < 256; ++b)
		  {
			if (r[i + b])
			{
			  if (r[i] + (r[i + b] << b) <= 15)
			  {
				r[i] += r[i + b] << b;
				r = r.Substring(0, i + b);
			  }
			  else if (r[i] - (r[i + b] << b) >= -15)
			  {
				r[i] -= r[i + b] << b;
				for (k = i + b; k < 256; ++k)
				{
				  if (!r[k])
				  {
					r[k] = 1;
					break;
				  }
				  r = r.Substring(0, k);
				}
			  }
			  else
			  {
				break;
			  }
			}
		  }
		}
	  }
	}

	/* From ge_p3_0.c */

	internal static void ge_p3_0(ge_p3 h)
	{
	  fe_0(h.X);
	  fe_1(h.Y);
	  fe_1(h.Z);
	  fe_0(h.T);
	}

	/* From ge_precomp_0.c */

	internal static void ge_precomp_0(ge_precomp h)
	{
	  fe_1(h.yplusx);
	  fe_1(h.yminusx);
	  fe_0(h.xy2d);
	}

	/* From ge_scalarmult_base.c */

	internal static byte equal(char b, char c)
	{
	  byte ub = b;
	  byte uc = c;
	  byte x = ub ^ uc; // 0: yes; 1..255: no
	  uint y = x; // 0: yes; 1..255: no
	  y -= 1; // 4294967295: yes; 0..254: no
	  y >>= 31; // 1: yes; 0: no
	  return y;
	}

	internal static byte negative(char b)
	{
	  ulong x = b; // 18446744073709551361..18446744073709551615: yes; 0..255: no
	  x >>= 63; // 1: yes; 0: no
	  return (byte) x;
	}

	internal static void ge_precomp_cmov(ge_precomp t, ge_precomp u, byte b)
	{
	  fe_cmov(t.yplusx, u.yplusx, b);
	  fe_cmov(t.yminusx, u.yminusx, b);
	  fe_cmov(t.xy2d, u.xy2d, b);
	}

	internal static void select(ge_precomp t, int pos, char b)
	{
	  ge_precomp minust = new ge_precomp();
	  byte bnegative = negative(b);
	  byte babs = b - (((-bnegative) & b) << 1);

	  ge_precomp_0(t);
	  ge_precomp_cmov(t, ge_base[pos][0], equal(babs, 1));
	  ge_precomp_cmov(t, ge_base[pos][1], equal(babs, 2));
	  ge_precomp_cmov(t, ge_base[pos][2], equal(babs, 3));
	  ge_precomp_cmov(t, ge_base[pos][3], equal(babs, 4));
	  ge_precomp_cmov(t, ge_base[pos][4], equal(babs, 5));
	  ge_precomp_cmov(t, ge_base[pos][5], equal(babs, 6));
	  ge_precomp_cmov(t, ge_base[pos][6], equal(babs, 7));
	  ge_precomp_cmov(t, ge_base[pos][7], equal(babs, 8));
	  fe_copy(minust.yplusx, t.yminusx);
	  fe_copy(minust.yminusx, t.yplusx);
	  fe_neg(minust.xy2d, t.xy2d);
	  ge_precomp_cmov(t, minust, bnegative);
	}

	internal static void ge_cached_0(ge_cached r)
	{
	  fe_1(r.YplusX);
	  fe_1(r.YminusX);
	  fe_1(r.Z);
	  fe_0(r.T2d);
	}

	internal static void ge_cached_cmov(ge_cached t, ge_cached u, byte b)
	{
	  fe_cmov(t.YplusX, u.YplusX, b);
	  fe_cmov(t.YminusX, u.YminusX, b);
	  fe_cmov(t.Z, u.Z, b);
	  fe_cmov(t.T2d, u.T2d, b);
	}

	/* Assumes that a != INT64_MIN */
	internal static long signum(long a)
	{
	  return (a >> 63) - ((-a) >> 63);
	}

	// Copyright (c) 2012-2017, The CryptoNote developers, The Bytecoin developers
	//
	// This file is part of Bytecoin.
	//
	// Bytecoin is free software: you can redistribute it and/or modify
	// it under the terms of the GNU Lesser General Public License as published by
	// the Free Software Foundation, either version 3 of the License, or
	// (at your option) any later version.
	//
	// Bytecoin is distributed in the hope that it will be useful,
	// but WITHOUT ANY WARRANTY; without even the implied warranty of
	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	// GNU Lesser General Public License for more details.
	//
	// You should have received a copy of the GNU Lesser General Public License
	// along with Bytecoin.  If not, see <http://www.gnu.org/licenses/>.



	/* sqrt(x) is such an integer y that 0 <= y <= p - 1, y % 2 = 0, and y^2 = x (mod p). */
	/* d = -121665 / 121666 */
	public static readonly int[] fe_d = {-10913610, 13857413, -15372611, 6949391, 114729, -8787816, -6275908, -3247719, -18696448, -12055116}; // d
	public static readonly int[] fe_sqrtm1 = {-32595792, -7943725, 9377950, 3500415, 12389472, -272473, -25146209, -2005654, 326686, 11406482}; // sqrt(-1)
	public static readonly int[] fe_d2 = {-21827239, -5839606, -30745221, 13898782, 229458, 15978800, -12551817, -6495438, 29715968, 9444199}; // 2 * d

	/* base[i][j] = (j+1)*256^i*B */
	public static readonly ge_precomp[,] ge_base =
	{
		{
			{
				{25967493, -14356035, 29566456, 3660896, -12694345, 4014787, 27544626, -11754271, -6079156, 2047605},
				{-12545711, 934262, -2722910, 3049990, -727428, 9406986, 12720692, 5043384, 19500929, -15469378},
				{-8738181, 4489570, 9688441, -14785194, 10184609, -12363380, 29287919, 11864899, -24514362, -4438546}
			},
			{
				{-12815894, -12976347, -21581243, 11784320, -25355658, -2750717, -11717903, -3814571, -358445, -10211303},
				{-21703237, 6903825, 27185491, 6451973, -29577724, -9554005, -15616551, 11189268, -26829678, -5319081},
				{26966642, 11152617, 32442495, 15396054, 14353839, -12752335, -3128826, -9541118, -15472047, -4166697}
			},
			{
				{15636291, -9688557, 24204773, -7912398, 616977, -16685262, 27787600, -14772189, 28944400, -1550024},
				{16568933, 4717097, -11556148, -1102322, 15682896, -11807043, 16354577, -11775962, 7689662, 11199574},
				{30464156, -5976125, -11779434, -15670865, 23220365, 15915852, 7512774, 10017326, -17749093, -9920357}
			},
			{
				{-17036878, 13921892, 10945806, -6033431, 27105052, -16084379, -28926210, 15006023, 3284568, -6276540},
				{23599295, -8306047, -11193664, -7687416, 13236774, 10506355, 7464579, 9656445, 13059162, 10374397},
				{7798556, 16710257, 3033922, 2874086, 28997861, 2835604, 32406664, -3839045, -641708, -101325}
			},
			{
				{10861363, 11473154, 27284546, 1981175, -30064349, 12577861, 32867885, 14515107, -15438304, 10819380},
				{4708026, 6336745, 20377586, 9066809, -11272109, 6594696, -25653668, 12483688, -12668491, 5581306},
				{19563160, 16186464, -29386857, 4097519, 10237984, -4348115, 28542350, 13850243, -23678021, -15815942}
			},
			{
				{-15371964, -12862754, 32573250, 4720197, -26436522, 5875511, -19188627, -15224819, -9818940, -12085777},
				{-8549212, 109983, 15149363, 2178705, 22900618, 4543417, 3044240, -15689887, 1762328, 14866737},
				{-18199695, -15951423, -10473290, 1707278, -17185920, 3916101, -28236412, 3959421, 27914454, 4383652}
			},
			{
				{5153746, 9909285, 1723747, -2777874, 30523605, 5516873, 19480852, 5230134, -23952439, -15175766},
				{-30269007, -3463509, 7665486, 10083793, 28475525, 1649722, 20654025, 16520125, 30598449, 7715701},
				{28881845, 14381568, 9657904, 3680757, -20181635, 7843316, -31400660, 1370708, 29794553, -1409300}
			},
			{
				{14499471, -2729599, -33191113, -4254652, 28494862, 14271267, 30290735, 10876454, -33154098, 2381726},
				{-7195431, -2655363, -14730155, 462251, -27724326, 3941372, -6236617, 3696005, -32300832, 15351955},
				{27431194, 8222322, 16448760, -3907995, -18707002, 11938355, -32961401, -2970515, 29551813, 10109425}
			}
		},
		{
			{
				{-13657040, -13155431, -31283750, 11777098, 21447386, 6519384, -2378284, -1627556, 10092783, -4764171},
				{27939166, 14210322, 4677035, 16277044, -22964462, -12398139, -32508754, 12005538, -17810127, 12803510},
				{17228999, -15661624, -1233527, 300140, -1224870, -11714777, 30364213, -9038194, 18016357, 4397660}
			},
			{
				{-10958843, -7690207, 4776341, -14954238, 27850028, -15602212, -26619106, 14544525, -17477504, 982639},
				{29253598, 15796703, -2863982, -9908884, 10057023, 3163536, 7332899, -4120128, -21047696, 9934963},
				{5793303, 16271923, -24131614, -10116404, 29188560, 1206517, -14747930, 4559895, -30123922, -10897950}
			},
			{
				{-27643952, -11493006, 16282657, -11036493, 28414021, -15012264, 24191034, 4541697, -13338309, 5500568},
				{12650548, -1497113, 9052871, 11355358, -17680037, -8400164, -17430592, 12264343, 10874051, 13524335},
				{25556948, -3045990, 714651, 2510400, 23394682, -10415330, 33119038, 5080568, -22528059, 5376628}
			},
			{
				{-26088264, -4011052, -17013699, -3537628, -6726793, 1920897, -22321305, -9447443, 4535768, 1569007},
				{-2255422, 14606630, -21692440, -8039818, 28430649, 8775819, -30494562, 3044290, 31848280, 12543772},
				{-22028579, 2943893, -31857513, 6777306, 13784462, -4292203, -27377195, -2062731, 7718482, 14474653}
			},
			{
				{2385315, 2454213, -22631320, 46603, -4437935, -15680415, 656965, -7236665, 24316168, -5253567},
				{13741529, 10911568, -33233417, -8603737, -20177830, -1033297, 33040651, -13424532, -20729456, 8321686},
				{21060490, -2212744, 15712757, -4336099, 1639040, 10656336, 23845965, -11874838, -9984458, 608372}
			},
			{
				{-13672732, -15087586, -10889693, -7557059, -6036909, 11305547, 1123968, -6780577, 27229399, 23887},
				{-23244140, -294205, -11744728, 14712571, -29465699, -2029617, 12797024, -6440308, -1633405, 16678954},
				{-29500620, 4770662, -16054387, 14001338, 7830047, 9564805, -1508144, -4795045, -17169265, 4904953}
			},
			{
				{24059557, 14617003, 19037157, -15039908, 19766093, -14906429, 5169211, 16191880, 2128236, -4326833},
				{-16981152, 4124966, -8540610, -10653797, 30336522, -14105247, -29806336, 916033, -6882542, -2986532},
				{-22630907, 12419372, -7134229, -7473371, -16478904, 16739175, 285431, 2763829, 15736322, 4143876}
			},
			{
				{2379352, 11839345, -4110402, -5988665, 11274298, 794957, 212801, -14594663, 23527084, -16458268},
				{33431127, -11130478, -17838966, -15626900, 8909499, 8376530, -32625340, 4087881, -15188911, -14416214},
				{1767683, 7197987, -13205226, -2022635, -13091350, 448826, 5799055, 4357868, -4774191, -16323038}
			}
		},
		{
			{
				{6721966, 13833823, -23523388, -1551314, 26354293, -11863321, 23365147, -3949732, 7390890, 2759800},
				{4409041, 2052381, 23373853, 10530217, 7676779, -12885954, 21302353, -4264057, 1244380, -12919645},
				{-4421239, 7169619, 4982368, -2957590, 30256825, -2777540, 14086413, 9208236, 15886429, 16489664}
			},
			{
				{1996075, 10375649, 14346367, 13311202, -6874135, -16438411, -13693198, 398369, -30606455, -712933},
				{-25307465, 9795880, -2777414, 14878809, -33531835, 14780363, 13348553, 12076947, -30836462, 5113182},
				{-17770784, 11797796, 31950843, 13929123, -25888302, 12288344, -30341101, -7336386, 13847711, 5387222}
			},
			{
				{-18582163, -3416217, 17824843, -2340966, 22744343, -10442611, 8763061, 3617786, -19600662, 10370991},
				{20246567, -14369378, 22358229, -543712, 18507283, -10413996, 14554437, -8746092, 32232924, 16763880},
				{9648505, 10094563, 26416693, 14745928, -30374318, -6472621, 11094161, 15689506, 3140038, -16510092}
			},
			{
				{-16160072, 5472695, 31895588, 4744994, 8823515, 10365685, -27224800, 9448613, -28774454, 366295},
				{19153450, 11523972, -11096490, -6503142, -24647631, 5420647, 28344573, 8041113, 719605, 11671788},
				{8678025, 2694440, -6808014, 2517372, 4964326, 11152271, -15432916, -15266516, 27000813, -10195553}
			},
			{
				{-15157904, 7134312, 8639287, -2814877, -7235688, 10421742, 564065, 5336097, 6750977, -14521026},
				{11836410, -3979488, 26297894, 16080799, 23455045, 15735944, 1695823, -8819122, 8169720, 16220347},
				{-18115838, 8653647, 17578566, -6092619, -8025777, -16012763, -11144307, -2627664, -5990708, -14166033}
			},
			{
				{-23308498, -10968312, 15213228, -10081214, -30853605, -11050004, 27884329, 2847284, 2655861, 1738395},
				{-27537433, -14253021, -25336301, -8002780, -9370762, 8129821, 21651608, -3239336, -19087449, -11005278},
				{1533110, 3437855, 23735889, 459276, 29970501, 11335377, 26030092, 5821408, 10478196, 8544890}
			},
			{
				{32173121, -16129311, 24896207, 3921497, 22579056, -3410854, 19270449, 12217473, 17789017, -3395995},
				{-30552961, -2228401, -15578829, -10147201, 13243889, 517024, 15479401, -3853233, 30460520, 1052596},
				{-11614875, 13323618, 32618793, 8175907, -15230173, 12596687, 27491595, -4612359, 3179268, -9478891}
			},
			{
				{31947069, -14366651, -4640583, -15339921, -15125977, -6039709, -14756777, -16411740, 19072640, -9511060},
				{11685058, 11822410, 3158003, -13952594, 33402194, -4165066, 5977896, -5215017, 473099, 5040608},
				{-20290863, 8198642, -27410132, 11602123, 1290375, -2799760, 28326862, 1721092, -19558642, -3131606}
			}
		},
		{
			{
				{7881532, 10687937, 7578723, 7738378, -18951012, -2553952, 21820786, 8076149, -27868496, 11538389},
				{-19935666, 3899861, 18283497, -6801568, -15728660, -11249211, 8754525, 7446702, -5676054, 5797016},
				{-11295600, -3793569, -15782110, -7964573, 12708869, -8456199, 2014099, -9050574, -2369172, -5877341}
			},
			{
				{-22472376, -11568741, -27682020, 1146375, 18956691, 16640559, 1192730, -3714199, 15123619, 10811505},
				{14352098, -3419715, -18942044, 10822655, 32750596, 4699007, -70363, 15776356, -28886779, -11974553},
				{-28241164, -8072475, -4978962, -5315317, 29416931, 1847569, -20654173, -16484855, 4714547, -9600655}
			},
			{
				{15200332, 8368572, 19679101, 15970074, -31872674, 1959451, 24611599, -4543832, -11745876, 12340220},
				{12876937, -10480056, 33134381, 6590940, -6307776, 14872440, 9613953, 8241152, 15370987, 9608631},
				{-4143277, -12014408, 8446281, -391603, 4407738, 13629032, -7724868, 15866074, -28210621, -8814099}
			},
			{
				{26660628, -15677655, 8393734, 358047, -7401291, 992988, -23904233, 858697, 20571223, 8420556},
				{14620715, 13067227, -15447274, 8264467, 14106269, 15080814, 33531827, 12516406, -21574435, -12476749},
				{236881, 10476226, 57258, -14677024, 6472998, 2466984, 17258519, 7256740, 8791136, 15069930}
			},
			{
				{1276410, -9371918, 22949635, -16322807, -23493039, -5702186, 14711875, 4874229, -30663140, -2331391},
				{5855666, 4990204, -13711848, 7294284, -7804282, 1924647, -1423175, -7912378, -33069337, 9234253},
				{20590503, -9018988, 31529744, -7352666, -2706834, 10650548, 31559055, -11609587, 18979186, 13396066}
			},
			{
				{24474287, 4968103, 22267082, 4407354, 24063882, -8325180, -18816887, 13594782, 33514650, 7021958},
				{-11566906, -6565505, -21365085, 15928892, -26158305, 4315421, -25948728, -3916677, -21480480, 12868082},
				{-28635013, 13504661, 19988037, -2132761, 21078225, 6443208, -21446107, 2244500, -12455797, -8089383}
			},
			{
				{-30595528, 13793479, -5852820, 319136, -25723172, -6263899, 33086546, 8957937, -15233648, 5540521},
				{-11630176, -11503902, -8119500, -7643073, 2620056, 1022908, -23710744, -1568984, -16128528, -14962807},
				{23152971, 775386, 27395463, 14006635, -9701118, 4649512, 1689819, 892185, -11513277, -15205948}
			},
			{
				{9770129, 9586738, 26496094, 4324120, 1556511, -3550024, 27453819, 4763127, -19179614, 5867134},
				{-32765025, 1927590, 31726409, -4753295, 23962434, -16019500, 27846559, 5931263, -29749703, -16108455},
				{27461885, -2977536, 22380810, 1815854, -23033753, -3031938, 7283490, -15148073, -19526700, 7734629}
			}
		},
		{
			{
				{-8010264, -9590817, -11120403, 6196038, 29344158, -13430885, 7585295, -3176626, 18549497, 15302069},
				{-32658337, -6171222, -7672793, -11051681, 6258878, 13504381, 10458790, -6418461, -8872242, 8424746},
				{24687205, 8613276, -30667046, -3233545, 1863892, -1830544, 19206234, 7134917, -11284482, -828919}
			},
			{
				{11334899, -9218022, 8025293, 12707519, 17523892, -10476071, 10243738, -14685461, -5066034, 16498837},
				{8911542, 6887158, -9584260, -6958590, 11145641, -9543680, 17303925, -14124238, 6536641, 10543906},
				{-28946384, 15479763, -17466835, 568876, -1497683, 11223454, -2669190, -16625574, -27235709, 8876771}
			},
			{
				{-25742899, -12566864, -15649966, -846607, -33026686, -796288, -33481822, 15824474, -604426, -9039817},
				{10330056, 70051, 7957388, -9002667, 9764902, 15609756, 27698697, -4890037, 1657394, 3084098},
				{10477963, -7470260, 12119566, -13250805, 29016247, -5365589, 31280319, 14396151, -30233575, 15272409}
			},
			{
				{-12288309, 3169463, 28813183, 16658753, 25116432, -5630466, -25173957, -12636138, -25014757, 1950504},
				{-26180358, 9489187, 11053416, -14746161, -31053720, 5825630, -8384306, -8767532, 15341279, 8373727},
				{28685821, 7759505, -14378516, -12002860, -31971820, 4079242, 298136, -10232602, -2878207, 15190420}
			},
			{
				{-32932876, 13806336, -14337485, -15794431, -24004620, 10940928, 8669718, 2742393, -26033313, -6875003},
				{-1580388, -11729417, -25979658, -11445023, -17411874, -10912854, 9291594, -16247779, -12154742, 6048605},
				{-30305315, 14843444, 1539301, 11864366, 20201677, 1900163, 13934231, 5128323, 11213262, 9168384}
			},
			{
				{-26280513, 11007847, 19408960, -940758, -18592965, -4328580, -5088060, -11105150, 20470157, -16398701},
				{-23136053, 9282192, 14855179, -15390078, -7362815, -14408560, -22783952, 14461608, 14042978, 5230683},
				{29969567, -2741594, -16711867, -8552442, 9175486, -2468974, 21556951, 3506042, -5933891, -12449708}
			},
			{
				{-3144746, 8744661, 19704003, 4581278, -20430686, 6830683, -21284170, 8971513, -28539189, 15326563},
				{-19464629, 10110288, -17262528, -3503892, -23500387, 1355669, -15523050, 15300988, -20514118, 9168260},
				{-5353335, 4488613, -23803248, 16314347, 7780487, -15638939, -28948358, 9601605, 33087103, -9011387}
			},
			{
				{-19443170, -15512900, -20797467, -12445323, -29824447, 10229461, -27444329, -15000531, -5996870, 15664672},
				{23294591, -16632613, -22650781, -8470978, 27844204, 11461195, 13099750, -2460356, 18151676, 13417686},
				{-24722913, -4176517, -31150679, 5988919, -26858785, 6685065, 1661597, -12551441, 15271676, -15452665}
			}
		},
		{
			{
				{11433042, -13228665, 8239631, -5279517, -1985436, -725718, -18698764, 2167544, -6921301, -13440182},
				{-31436171, 15575146, 30436815, 12192228, -22463353, 9395379, -9917708, -8638997, 12215110, 12028277},
				{14098400, 6555944, 23007258, 5757252, -15427832, -12950502, 30123440, 4617780, -16900089, -655628}
			},
			{
				{-4026201, -15240835, 11893168, 13718664, -14809462, 1847385, -15819999, 10154009, 23973261, -12684474},
				{-26531820, -3695990, -1908898, 2534301, -31870557, -16550355, 18341390, -11419951, 32013174, -10103539},
				{-25479301, 10876443, -11771086, -14625140, -12369567, 1838104, 21911214, 6354752, 4425632, -837822}
			},
			{
				{-10433389, -14612966, 22229858, -3091047, -13191166, 776729, -17415375, -12020462, 4725005, 14044970},
				{19268650, -7304421, 1555349, 8692754, -21474059, -9910664, 6347390, -1411784, -19522291, -16109756},
				{-24864089, 12986008, -10898878, -5558584, -11312371, -148526, 19541418, 8180106, 9282262, 10282508}
			},
			{
				{-26205082, 4428547, -8661196, -13194263, 4098402, -14165257, 15522535, 8372215, 5542595, -10702683},
				{-10562541, 14895633, 26814552, -16673850, -17480754, -2489360, -2781891, 6993761, -18093885, 10114655},
				{-20107055, -929418, 31422704, 10427861, -7110749, 6150669, -29091755, -11529146, 25953725, -106158}
			},
			{
				{-4234397, -8039292, -9119125, 3046000, 2101609, -12607294, 19390020, 6094296, -3315279, 12831125},
				{-15998678, 7578152, 5310217, 14408357, -33548620, -224739, 31575954, 6326196, 7381791, -2421839},
				{-20902779, 3296811, 24736065, -16328389, 18374254, 7318640, 6295303, 8082724, -15362489, 12339664}
			},
			{
				{27724736, 2291157, 6088201, -14184798, 1792727, 5857634, 13848414, 15768922, 25091167, 14856294},
				{-18866652, 8331043, 24373479, 8541013, -701998, -9269457, 12927300, -12695493, -22182473, -9012899},
				{-11423429, -5421590, 11632845, 3405020, 30536730, -11674039, -27260765, 13866390, 30146206, 9142070}
			},
			{
				{3924129, -15307516, -13817122, -10054960, 12291820, -668366, -27702774, 9326384, -8237858, 4171294},
				{-15921940, 16037937, 6713787, 16606682, -21612135, 2790944, 26396185, 3731949, 345228, -5462949},
				{-21327538, 13448259, 25284571, 1143661, 20614966, -8849387, 2031539, -12391231, -16253183, -13582083}
			},
			{
				{31016211, -16722429, 26371392, -14451233, -5027349, 14854137, 17477601, 3842657, 28012650, -16405420},
				{-5075835, 9368966, -8562079, -4600902, -15249953, 6970560, -9189873, 16292057, -8867157, 3507940},
				{29439664, 3537914, 23333589, 6997794, -17555561, -11018068, -15209202, -15051267, -9164929, 6580396}
			}
		},
		{
			{
				{-12185861, -7679788, 16438269, 10826160, -8696817, -6235611, 17860444, -9273846, -2095802, 9304567},
				{20714564, -4336911, 29088195, 7406487, 11426967, -5095705, 14792667, -14608617, 5289421, -477127},
				{-16665533, -10650790, -6160345, -13305760, 9192020, -1802462, 17271490, 12349094, 26939669, -3752294}
			},
			{
				{-12889898, 9373458, 31595848, 16374215, 21471720, 13221525, -27283495, -12348559, -3698806, 117887},
				{22263325, -6560050, 3984570, -11174646, -15114008, -566785, 28311253, 5358056, -23319780, 541964},
				{16259219, 3261970, 2309254, -15534474, -16885711, -4581916, 24134070, -16705829, -13337066, -13552195}
			},
			{
				{9378160, -13140186, -22845982, -12745264, 28198281, -7244098, -2399684, -717351, 690426, 14876244},
				{24977353, -314384, -8223969, -13465086, 28432343, -1176353, -13068804, -12297348, -22380984, 6618999},
				{-1538174, 11685646, 12944378, 13682314, -24389511, -14413193, 8044829, -13817328, 32239829, -5652762}
			},
			{
				{-18603066, 4762990, -926250, 8885304, -28412480, -3187315, 9781647, -10350059, 32779359, 5095274},
				{-33008130, -5214506, -32264887, -3685216, 9460461, -9327423, -24601656, 14506724, 21639561, -2630236},
				{-16400943, -13112215, 25239338, 15531969, 3987758, -4499318, -1289502, -6863535, 17874574, 558605}
			},
			{
				{-13600129, 10240081, 9171883, 16131053, -20869254, 9599700, 33499487, 5080151, 2085892, 5119761},
				{-22205145, -2519528, -16381601, 414691, -25019550, 2170430, 30634760, -8363614, -31999993, -5759884},
				{-6845704, 15791202, 8550074, -1312654, 29928809, -12092256, 27534430, -7192145, -22351378, 12961482}
			},
			{
				{-24492060, -9570771, 10368194, 11582341, -23397293, -2245287, 16533930, 8206996, -30194652, -5159638},
				{-11121496, -3382234, 2307366, 6362031, -135455, 8868177, -16835630, 7031275, 7589640, 8945490},
				{-32152748, 8917967, 6661220, -11677616, -1192060, -15793393, 7251489, -11182180, 24099109, -14456170}
			},
			{
				{5019558, -7907470, 4244127, -14714356, -26933272, 6453165, -19118182, -13289025, -6231896, -10280736},
				{10853594, 10721687, 26480089, 5861829, -22995819, 1972175, -1866647, -10557898, -3363451, -6441124},
				{-17002408, 5906790, 221599, -6563147, 7828208, -13248918, 24362661, -2008168, -13866408, 7421392}
			},
			{
				{8139927, -6546497, 32257646, -5890546, 30375719, 1886181, -21175108, 15441252, 28826358, -4123029},
				{6267086, 9695052, 7709135, -16603597, -32869068, -1886135, 14795160, -7840124, 13746021, -1742048},
				{28584902, 7787108, -6732942, -15050729, 22846041, -7571236, -3181936, -363524, 4771362, -8419958}
			}
		},
		{
			{
				{24949256, 6376279, -27466481, -8174608, -18646154, -9930606, 33543569, -12141695, 3569627, 11342593},
				{26514989, 4740088, 27912651, 3697550, 19331575, -11472339, 6809886, 4608608, 7325975, -14801071},
				{-11618399, -14554430, -24321212, 7655128, -1369274, 5214312, -27400540, 10258390, -17646694, -8186692}
			},
			{
				{11431204, 15823007, 26570245, 14329124, 18029990, 4796082, -31446179, 15580664, 9280358, -3973687},
				{-160783, -10326257, -22855316, -4304997, -20861367, -13621002, -32810901, -11181622, -15545091, 4387441},
				{-20799378, 12194512, 3937617, -5805892, -27154820, 9340370, -24513992, 8548137, 20617071, -7482001}
			},
			{
				{-938825, -3930586, -8714311, 16124718, 24603125, -6225393, -13775352, -11875822, 24345683, 10325460},
				{-19855277, -1568885, -22202708, 8714034, 14007766, 6928528, 16318175, -1010689, 4766743, 3552007},
				{-21751364, -16730916, 1351763, -803421, -4009670, 3950935, 3217514, 14481909, 10988822, -3994762}
			},
			{
				{15564307, -14311570, 3101243, 5684148, 30446780, -8051356, 12677127, -6505343, -8295852, 13296005},
				{-9442290, 6624296, -30298964, -11913677, -4670981, -2057379, 31521204, 9614054, -30000824, 12074674},
				{4771191, -135239, 14290749, -13089852, 27992298, 14998318, -1413936, -1556716, 29832613, -16391035}
			},
			{
				{7064884, -7541174, -19161962, -5067537, -18891269, -2912736, 25825242, 5293297, -27122660, 13101590},
				{-2298563, 2439670, -7466610, 1719965, -27267541, -16328445, 32512469, -5317593, -30356070, -4190957},
				{-30006540, 10162316, -33180176, 3981723, -16482138, -13070044, 14413974, 9515896, 19568978, 9628812}
			},
			{
				{33053803, 199357, 15894591, 1583059, 27380243, -4580435, -17838894, -6106839, -6291786, 3437740},
				{-18978877, 3884493, 19469877, 12726490, 15913552, 13614290, -22961733, 70104, 7463304, 4176122},
				{-27124001, 10659917, 11482427, -16070381, 12771467, -6635117, -32719404, -5322751, 24216882, 5944158}
			},
			{
				{8894125, 7450974, -2664149, -9765752, -28080517, -12389115, 19345746, 14680796, 11632993, 5847885},
				{26942781, -2315317, 9129564, -4906607, 26024105, 11769399, -11518837, 6367194, -9727230, 4782140},
				{19916461, -4828410, -22910704, -11414391, 25606324, -5972441, 33253853, 8220911, 6358847, -1873857}
			},
			{
				{801428, -2081702, 16569428, 11065167, 29875704, 96627, 7908388, -4480480, -13538503, 1387155},
				{19646058, 5720633, -11416706, 12814209, 11607948, 12749789, 14147075, 15156355, -21866831, 11835260},
				{19299512, 1155910, 28703737, 14890794, 2925026, 7269399, 26121523, 15467869, -26560550, 5052483}
			}
		},
		{
			{
				{-3017432, 10058206, 1980837, 3964243, 22160966, 12322533, -6431123, -12618185, 12228557, -7003677},
				{32944382, 14922211, -22844894, 5188528, 21913450, -8719943, 4001465, 13238564, -6114803, 8653815},
				{22865569, -4652735, 27603668, -12545395, 14348958, 8234005, 24808405, 5719875, 28483275, 2841751}
			},
			{
				{-16420968, -1113305, -327719, -12107856, 21886282, -15552774, -1887966, -315658, 19932058, -12739203},
				{-11656086, 10087521, -8864888, -5536143, -19278573, -3055912, 3999228, 13239134, -4777469, -13910208},
				{1382174, -11694719, 17266790, 9194690, -13324356, 9720081, 20403944, 11284705, -14013818, 3093230}
			},
			{
				{16650921, -11037932, -1064178, 1570629, -8329746, 7352753, -302424, 16271225, -24049421, -6691850},
				{-21911077, -5927941, -4611316, -5560156, -31744103, -10785293, 24123614, 15193618, -21652117, -16739389},
				{-9935934, -4289447, -25279823, 4372842, 2087473, 10399484, 31870908, 14690798, 17361620, 11864968}
			},
			{
				{-11307610, 6210372, 13206574, 5806320, -29017692, -13967200, -12331205, -7486601, -25578460, -16240689},
				{14668462, -12270235, 26039039, 15305210, 25515617, 4542480, 10453892, 6577524, 9145645, -6443880},
				{5974874, 3053895, -9433049, -10385191, -31865124, 3225009, -7972642, 3936128, -5652273, -3050304}
			},
			{
				{30625386, -4729400, -25555961, -12792866, -20484575, 7695099, 17097188, -16303496, -27999779, 1803632},
				{-3553091, 9865099, -5228566, 4272701, -5673832, -16689700, 14911344, 12196514, -21405489, 7047412},
				{20093277, 9920966, -11138194, -5343857, 13161587, 12044805, -32856851, 4124601, -32343828, -10257566}
			},
			{
				{-20788824, 14084654, -13531713, 7842147, 19119038, -13822605, 4752377, -8714640, -21679658, 2288038},
				{-26819236, -3283715, 29965059, 3039786, -14473765, 2540457, 29457502, 14625692, -24819617, 12570232},
				{-1063558, -11551823, 16920318, 12494842, 1278292, -5869109, -21159943, -3498680, -11974704, 4724943}
			},
			{
				{17960970, -11775534, -4140968, -9702530, -8876562, -1410617, -12907383, -8659932, -29576300, 1903856},
				{23134274, -14279132, -10681997, -1611936, 20684485, 15770816, -12989750, 3190296, 26955097, 14109738},
				{15308788, 5320727, -30113809, -14318877, 22902008, 7767164, 29425325, -11277562, 31960942, 11934971}
			},
			{
				{-27395711, 8435796, 4109644, 12222639, -24627868, 14818669, 20638173, 4875028, 10491392, 1379718},
				{-13159415, 9197841, 3875503, -8936108, -1383712, -5879801, 33518459, 16176658, 21432314, 12180697},
				{-11787308, 11500838, 13787581, -13832590, -22430679, 10140205, 1465425, 12689540, -10301319, -13872883}
			}
		},
		{
			{
				{5414091, -15386041, -21007664, 9643570, 12834970, 1186149, -2622916, -1342231, 26128231, 6032912},
				{-26337395, -13766162, 32496025, -13653919, 17847801, -12669156, 3604025, 8316894, -25875034, -10437358},
				{3296484, 6223048, 24680646, -12246460, -23052020, 5903205, -8862297, -4639164, 12376617, 3188849}
			},
			{
				{29190488, -14659046, 27549113, -1183516, 3520066, -10697301, 32049515, -7309113, -16109234, -9852307},
				{-14744486, -9309156, 735818, -598978, -20407687, -5057904, 25246078, -15795669, 18640741, -960977},
				{-6928835, -16430795, 10361374, 5642961, 4910474, 12345252, -31638386, -494430, 10530747, 1053335}
			},
			{
				{-29265967, -14186805, -13538216, -12117373, -19457059, -10655384, -31462369, -2948985, 24018831, 15026644},
				{-22592535, -3145277, -2289276, 5953843, -13440189, 9425631, 25310643, 13003497, -2314791, -15145616},
				{-27419985, -603321, -8043984, -1669117, -26092265, 13987819, -27297622, 187899, -23166419, -2531735}
			},
			{
				{-21744398, -13810475, 1844840, 5021428, -10434399, -15911473, 9716667, 16266922, -5070217, 726099},
				{29370922, -6053998, 7334071, -15342259, 9385287, 2247707, -13661962, -4839461, 30007388, -15823341},
				{-936379, 16086691, 23751945, -543318, -1167538, -5189036, 9137109, 730663, 9835848, 4555336}
			},
			{
				{-23376435, 1410446, -22253753, -12899614, 30867635, 15826977, 17693930, 544696, -11985298, 12422646},
				{31117226, -12215734, -13502838, 6561947, -9876867, -12757670, -5118685, -4096706, 29120153, 13924425},
				{-17400879, -14233209, 19675799, -2734756, -11006962, -5858820, -9383939, -11317700, 7240931, -237388}
			},
			{
				{-31361739, -11346780, -15007447, -5856218, -22453340, -12152771, 1222336, 4389483, 3293637, -15551743},
				{-16684801, -14444245, 11038544, 11054958, -13801175, -3338533, -24319580, 7733547, 12796905, -6335822},
				{-8759414, -10817836, -25418864, 10783769, -30615557, -9746811, -28253339, 3647836, 3222231, -11160462}
			},
			{
				{18606113, 1693100, -25448386, -15170272, 4112353, 10045021, 23603893, -2048234, -7550776, 2484985},
				{9255317, -3131197, -12156162, -1004256, 13098013, -9214866, 16377220, -2102812, -19802075, -3034702},
				{-22729289, 7496160, -5742199, 11329249, 19991973, -3347502, -31718148, 9936966, -30097688, -10618797}
			},
			{
				{21878590, -5001297, 4338336, 13643897, -3036865, 13160960, 19708896, 5415497, -7360503, -4109293},
				{27736861, 10103576, 12500508, 8502413, -3413016, -9633558, 10436918, -1550276, -23659143, -8132100},
				{19492550, -12104365, -29681976, -852630, -3208171, 12403437, 30066266, 8367329, 13243957, 8709688}
			}
		},
		{
			{
				{12015105, 2801261, 28198131, 10151021, 24818120, -4743133, -11194191, -5645734, 5150968, 7274186},
				{2831366, -12492146, 1478975, 6122054, 23825128, -12733586, 31097299, 6083058, 31021603, -9793610},
				{-2529932, -2229646, 445613, 10720828, -13849527, -11505937, -23507731, 16354465, 15067285, -14147707}
			},
			{
				{7840942, 14037873, -33364863, 15934016, -728213, -3642706, 21403988, 1057586, -19379462, -12403220},
				{915865, -16469274, 15608285, -8789130, -24357026, 6060030, -17371319, 8410997, -7220461, 16527025},
				{32922597, -556987, 20336074, -16184568, 10903705, -5384487, 16957574, 52992, 23834301, 6588044}
			},
			{
				{32752030, 11232950, 3381995, -8714866, 22652988, -10744103, 17159699, 16689107, -20314580, -1305992},
				{-4689649, 9166776, -25710296, -10847306, 11576752, 12733943, 7924251, -2752281, 1976123, -7249027},
				{21251222, 16309901, -2983015, -6783122, 30810597, 12967303, 156041, -3371252, 12331345, -8237197}
			},
			{
				{8651614, -4477032, -16085636, -4996994, 13002507, 2950805, 29054427, -5106970, 10008136, -4667901},
				{31486080, 15114593, -14261250, 12951354, 14369431, -7387845, 16347321, -13662089, 8684155, -10532952},
				{19443825, 11385320, 24468943, -9659068, -23919258, 2187569, -26263207, -6086921, 31316348, 14219878}
			},
			{
				{-28594490, 1193785, 32245219, 11392485, 31092169, 15722801, 27146014, 6992409, 29126555, 9207390},
				{32382935, 1110093, 18477781, 11028262, -27411763, -7548111, -4980517, 10843782, -7957600, -14435730},
				{2814918, 7836403, 27519878, -7868156, -20894015, -11553689, -21494559, 8550130, 28346258, 1994730}
			},
			{
				{-19578299, 8085545, -14000519, -3948622, 2785838, -16231307, -19516951, 7174894, 22628102, 8115180},
				{-30405132, 955511, -11133838, -15078069, -32447087, -13278079, -25651578, 3317160, -9943017, 930272},
				{-15303681, -6833769, 28856490, 1357446, 23421993, 1057177, 24091212, -1388970, -22765376, -10650715}
			},
			{
				{-22751231, -5303997, -12907607, -12768866, -15811511, -7797053, -14839018, -16554220, -1867018, 8398970},
				{-31969310, 2106403, -4736360, 1362501, 12813763, 16200670, 22981545, -6291273, 18009408, -15772772},
				{-17220923, -9545221, -27784654, 14166835, 29815394, 7444469, 29551787, -3727419, 19288549, 1325865}
			},
			{
				{15100157, -15835752, -23923978, -1005098, -26450192, 15509408, 12376730, -3479146, 33166107, -8042750},
				{20909231, 13023121, -9209752, 16251778, -5778415, -8094914, 12412151, 10018715, 2213263, -13878373},
				{32529814, -11074689, 30361439, -16689753, -9135940, 1513226, 22922121, 6382134, -5766928, 8371348}
			}
		},
		{
			{
				{9923462, 11271500, 12616794, 3544722, -29998368, -1721626, 12891687, -8193132, -26442943, 10486144},
				{-22597207, -7012665, 8587003, -8257861, 4084309, -12970062, 361726, 2610596, -23921530, -11455195},
				{5408411, -1136691, -4969122, 10561668, 24145918, 14240566, 31319731, -4235541, 19985175, -3436086}
			},
			{
				{-13994457, 16616821, 14549246, 3341099, 32155958, 13648976, -17577068, 8849297, 65030, 8370684},
				{-8320926, -12049626, 31204563, 5839400, -20627288, -1057277, -19442942, 6922164, 12743482, -9800518},
				{-2361371, 12678785, 28815050, 4759974, -23893047, 4884717, 23783145, 11038569, 18800704, 255233}
			},
			{
				{-5269658, -1773886, 13957886, 7990715, 23132995, 728773, 13393847, 9066957, 19258688, -14753793},
				{-2936654, -10827535, -10432089, 14516793, -3640786, 4372541, -31934921, 2209390, -1524053, 2055794},
				{580882, 16705327, 5468415, -2683018, -30926419, -14696000, -7203346, -8994389, -30021019, 7394435}
			},
			{
				{23838809, 1822728, -15738443, 15242727, 8318092, -3733104, -21672180, -3492205, -4821741, 14799921},
				{13345610, 9759151, 3371034, -16137791, 16353039, 8577942, 31129804, 13496856, -9056018, 7402518},
				{2286874, -4435931, -20042458, -2008336, -13696227, 5038122, 11006906, -15760352, 8205061, 1607563}
			},
			{
				{14414086, -8002132, 3331830, -3208217, 22249151, -5594188, 18364661, -2906958, 30019587, -9029278},
				{-27688051, 1585953, -10775053, 931069, -29120221, -11002319, -14410829, 12029093, 9944378, 8024},
				{4368715, -3709630, 29874200, -15022983, -20230386, -11410704, -16114594, -999085, -8142388, 5640030}
			},
			{
				{10299610, 13746483, 11661824, 16234854, 7630238, 5998374, 9809887, -16694564, 15219798, -14327783},
				{27425505, -5719081, 3055006, 10660664, 23458024, 595578, -15398605, -1173195, -18342183, 9742717},
				{6744077, 2427284, 26042789, 2720740, -847906, 1118974, 32324614, 7406442, 12420155, 1994844}
			},
			{
				{14012521, -5024720, -18384453, -9578469, -26485342, -3936439, -13033478, -10909803, 24319929, -6446333},
				{16412690, -4507367, 10772641, 15929391, -17068788, -4658621, 10555945, -10484049, -30102368, -4739048},
				{22397382, -7767684, -9293161, -12792868, 17166287, -9755136, -27333065, 6199366, 21880021, -12250760}
			},
			{
				{-4283307, 5368523, -31117018, 8163389, -30323063, 3209128, 16557151, 8890729, 8840445, 4957760},
				{-15447727, 709327, -6919446, -10870178, -29777922, 6522332, -21720181, 12130072, -14796503, 5005757},
				{-2114751, -14308128, 23019042, 15765735, -25269683, 6002752, 10183197, -13239326, -16395286, -2176112}
			}
		},
		{
			{
				{-19025756, 1632005, 13466291, -7995100, -23640451, 16573537, -32013908, -3057104, 22208662, 2000468},
				{3065073, -1412761, -25598674, -361432, -17683065, -5703415, -8164212, 11248527, -3691214, -7414184},
				{10379208, -6045554, 8877319, 1473647, -29291284, -12507580, 16690915, 2553332, -3132688, 16400289}
			},
			{
				{15716668, 1254266, -18472690, 7446274, -8448918, 6344164, -22097271, -7285580, 26894937, 9132066},
				{24158887, 12938817, 11085297, -8177598, -28063478, -4457083, -30576463, 64452, -6817084, -2692882},
				{13488534, 7794716, 22236231, 5989356, 25426474, -12578208, 2350710, -3418511, -4688006, 2364226}
			},
			{
				{16335052, 9132434, 25640582, 6678888, 1725628, 8517937, -11807024, -11697457, 15445875, -7798101},
				{29004207, -7867081, 28661402, -640412, -12794003, -7943086, 31863255, -4135540, -278050, -15759279},
				{-6122061, -14866665, -28614905, 14569919, -10857999, -3591829, 10343412, -6976290, -29828287, -10815811}
			},
			{
				{27081650, 3463984, 14099042, -4517604, 1616303, -6205604, 29542636, 15372179, 17293797, 960709},
				{20263915, 11434237, -5765435, 11236810, 13505955, -10857102, -16111345, 6493122, -19384511, 7639714},
				{-2830798, -14839232, 25403038, -8215196, -8317012, -16173699, 18006287, -16043750, 29994677, -15808121}
			},
			{
				{9769828, 5202651, -24157398, -13631392, -28051003, -11561624, -24613141, -13860782, -31184575, 709464},
				{12286395, 13076066, -21775189, -1176622, -25003198, 4057652, -32018128, -8890874, 16102007, 13205847},
				{13733362, 5599946, 10557076, 3195751, -5557991, 8536970, -25540170, 8525972, 10151379, 10394400}
			},
			{
				{4024660, -16137551, 22436262, 12276534, -9099015, -2686099, 19698229, 11743039, -33302334, 8934414},
				{-15879800, -4525240, -8580747, -2934061, 14634845, -698278, -9449077, 3137094, -11536886, 11721158},
				{17555939, -5013938, 8268606, 2331751, -22738815, 9761013, 9319229, 8835153, -9205489, -1280045}
			},
			{
				{-461409, -7830014, 20614118, 16688288, -7514766, -4807119, 22300304, 505429, 6108462, -6183415},
				{-5070281, 12367917, -30663534, 3234473, 32617080, -8422642, 29880583, -13483331, -26898490, -7867459},
				{-31975283, 5726539, 26934134, 10237677, -3173717, -605053, 24199304, 3795095, 7592688, -14992079}
			},
			{
				{21594432, -14964228, 17466408, -4077222, 32537084, 2739898, 6407723, 12018833, -28256052, 4298412},
				{-20650503, -11961496, -27236275, 570498, 3767144, -1717540, 13891942, -1569194, 13717174, 10805743},
				{-14676630, -15644296, 15287174, 11927123, 24177847, -8175568, -796431, 14860609, -26938930, -5863836}
			}
		},
		{
			{
				{12962541, 5311799, -10060768, 11658280, 18855286, -7954201, 13286263, -12808704, -4381056, 9882022},
				{18512079, 11319350, -20123124, 15090309, 18818594, 5271736, -22727904, 3666879, -23967430, -3299429},
				{-6789020, -3146043, 16192429, 13241070, 15898607, -14206114, -10084880, -6661110, -2403099, 5276065}
			},
			{
				{30169808, -5317648, 26306206, -11750859, 27814964, 7069267, 7152851, 3684982, 1449224, 13082861},
				{10342826, 3098505, 2119311, 193222, 25702612, 12233820, 23697382, 15056736, -21016438, -8202000},
				{-33150110, 3261608, 22745853, 7948688, 19370557, -15177665, -26171976, 6482814, -10300080, -11060101}
			},
			{
				{32869458, -5408545, 25609743, 15678670, -10687769, -15471071, 26112421, 2521008, -22664288, 6904815},
				{29506923, 4457497, 3377935, -9796444, -30510046, 12935080, 1561737, 3841096, -29003639, -6657642},
				{10340844, -6630377, -18656632, -2278430, 12621151, -13339055, 30878497, -11824370, -25584551, 5181966}
			},
			{
				{25940115, -12658025, 17324188, -10307374, -8671468, 15029094, 24396252, -16450922, -2322852, -12388574},
				{-21765684, 9916823, -1300409, 4079498, -1028346, 11909559, 1782390, 12641087, 20603771, -6561742},
				{-18882287, -11673380, 24849422, 11501709, 13161720, -4768874, 1925523, 11914390, 4662781, 7820689}
			},
			{
				{12241050, -425982, 8132691, 9393934, 32846760, -1599620, 29749456, 12172924, 16136752, 15264020},
				{-10349955, -14680563, -8211979, 2330220, -17662549, -14545780, 10658213, 6671822, 19012087, 3772772},
				{3753511, -3421066, 10617074, 2028709, 14841030, -6721664, 28718732, -15762884, 20527771, 12988982}
			},
			{
				{-14822485, -5797269, -3707987, 12689773, -898983, -10914866, -24183046, -10564943, 3299665, -12424953},
				{-16777703, -15253301, -9642417, 4978983, 3308785, 8755439, 6943197, 6461331, -25583147, 8991218},
				{-17226263, 1816362, -1673288, -6086439, 31783888, -8175991, -32948145, 7417950, -30242287, 1507265}
			},
			{
				{29692663, 6829891, -10498800, 4334896, 20945975, -11906496, -28887608, 8209391, 14606362, -10647073},
				{-3481570, 8707081, 32188102, 5672294, 22096700, 1711240, -33020695, 9761487, 4170404, -2085325},
				{-11587470, 14855945, -4127778, -1531857, -26649089, 15084046, 22186522, 16002000, -14276837, -8400798}
			},
			{
				{-4811456, 13761029, -31703877, -2483919, -3312471, 7869047, -7113572, -9620092, 13240845, 10965870},
				{-7742563, -8256762, -14768334, -13656260, -23232383, 12387166, 4498947, 14147411, 29514390, 4302863},
				{-13413405, -12407859, 20757302, -13801832, 14785143, 8976368, -5061276, -2144373, 17846988, -13971927}
			}
		},
		{
			{
				{-2244452, -754728, -4597030, -1066309, -6247172, 1455299, -21647728, -9214789, -5222701, 12650267},
				{-9906797, -16070310, 21134160, 12198166, -27064575, 708126, 387813, 13770293, -19134326, 10958663},
				{22470984, 12369526, 23446014, -5441109, -21520802, -9698723, -11772496, -11574455, -25083830, 4271862}
			},
			{
				{-25169565, -10053642, -19909332, 15361595, -5984358, 2159192, 75375, -4278529, -32526221, 8469673},
				{15854970, 4148314, -8893890, 7259002, 11666551, 13824734, -30531198, 2697372, 24154791, -9460943},
				{15446137, -15806644, 29759747, 14019369, 30811221, -9610191, -31582008, 12840104, 24913809, 9815020}
			},
			{
				{-4709286, -5614269, -31841498, -12288893, -14443537, 10799414, -9103676, 13438769, 18735128, 9466238},
				{11933045, 9281483, 5081055, -5183824, -2628162, -4905629, -7727821, -10896103, -22728655, 16199064},
				{14576810, 379472, -26786533, -8317236, -29426508, -10812974, -102766, 1876699, 30801119, 2164795}
			},
			{
				{15995086, 3199873, 13672555, 13712240, -19378835, -4647646, -13081610, -15496269, -13492807, 1268052},
				{-10290614, -3659039, -3286592, 10948818, 23037027, 3794475, -3470338, -12600221, -17055369, 3565904},
				{29210088, -9419337, -5919792, -4952785, 10834811, -13327726, -16512102, -10820713, -27162222, -14030531}
			},
			{
				{-13161890, 15508588, 16663704, -8156150, -28349942, 9019123, -29183421, -3769423, 2244111, -14001979},
				{-5152875, -3800936, -9306475, -6071583, 16243069, 14684434, -25673088, -16180800, 13491506, 4641841},
				{10813417, 643330, -19188515, -728916, 30292062, -16600078, 27548447, -7721242, 14476989, -12767431}
			},
			{
				{10292079, 9984945, 6481436, 8279905, -7251514, 7032743, 27282937, -1644259, -27912810, 12651324},
				{-31185513, -813383, 22271204, 11835308, 10201545, 15351028, 17099662, 3988035, 21721536, -3148940},
				{10202177, -6545839, -31373232, -9574638, -32150642, -8119683, -12906320, 3852694, 13216206, 14842320}
			},
			{
				{-15815640, -10601066, -6538952, -7258995, -6984659, -6581778, -31500847, 13765824, -27434397, 9900184},
				{14465505, -13833331, -32133984, -14738873, -27443187, 12990492, 33046193, 15796406, -7051866, -8040114},
				{30924417, -8279620, 6359016, -12816335, 16508377, 9071735, -25488601, 15413635, 9524356, -7018878}
			},
			{
				{12274201, -13175547, 32627641, -1785326, 6736625, 13267305, 5237659, -5109483, 15663516, 4035784},
				{-2951309, 8903985, 17349946, 601635, -16432815, -4612556, -13732739, -15889334, -22258478, 4659091},
				{-16916263, -4952973, -30393711, -15158821, 20774812, 15897498, 5736189, 15026997, -2178256, -13455585}
			}
		},
		{
			{
				{-8858980, -2219056, 28571666, -10155518, -474467, -10105698, -3801496, 278095, 23440562, -290208},
				{10226241, -5928702, 15139956, 120818, -14867693, 5218603, 32937275, 11551483, -16571960, -7442864},
				{17932739, -12437276, -24039557, 10749060, 11316803, 7535897, 22503767, 5561594, -3646624, 3898661}
			},
			{
				{7749907, -969567, -16339731, -16464, -25018111, 15122143, -1573531, 7152530, 21831162, 1245233},
				{26958459, -14658026, 4314586, 8346991, -5677764, 11960072, -32589295, -620035, -30402091, -16716212},
				{-12165896, 9166947, 33491384, 13673479, 29787085, 13096535, 6280834, 14587357, -22338025, 13987525}
			},
			{
				{-24349909, 7778775, 21116000, 15572597, -4833266, -5357778, -4300898, -5124639, -7469781, -2858068},
				{9681908, -6737123, -31951644, 13591838, -6883821, 386950, 31622781, 6439245, -14581012, 4091397},
				{-8426427, 1470727, -28109679, -1596990, 3978627, -5123623, -19622683, 12092163, 29077877, -14741988}
			},
			{
				{5269168, -6859726, -13230211, -8020715, 25932563, 1763552, -5606110, -5505881, -20017847, 2357889},
				{32264008, -15407652, -5387735, -1160093, -2091322, -3946900, 23104804, -12869908, 5727338, 189038},
				{14609123, -8954470, -6000566, -16622781, -14577387, -7743898, -26745169, 10942115, -25888931, -14884697}
			},
			{
				{20513500, 5557931, -15604613, 7829531, 26413943, -2019404, -21378968, 7471781, 13913677, -5137875},
				{-25574376, 11967826, 29233242, 12948236, -6754465, 4713227, -8940970, 14059180, 12878652, 8511905},
				{-25656801, 3393631, -2955415, -7075526, -2250709, 9366908, -30223418, 6812974, 5568676, -3127656}
			},
			{
				{11630004, 12144454, 2116339, 13606037, 27378885, 15676917, -17408753, -13504373, -14395196, 8070818},
				{27117696, -10007378, -31282771, -5570088, 1127282, 12772488, -29845906, 10483306, -11552749, -1028714},
				{10637467, -5688064, 5674781, 1072708, -26343588, -6982302, -1683975, 9177853, -27493162, 15431203}
			},
			{
				{20525145, 10892566, -12742472, 12779443, -29493034, 16150075, -28240519, 14943142, -15056790, -7935931},
				{-30024462, 5626926, -551567, -9981087, 753598, 11981191, 25244767, -3239766, -3356550, 9594024},
				{-23752644, 2636870, -5163910, -10103818, 585134, 7877383, 11345683, -6492290, 13352335, -10977084}
			},
			{
				{-1931799, -5407458, 3304649, -12884869, 17015806, -4877091, -29783850, -7752482, -13215537, -319204},
				{20239939, 6607058, 6203985, 3483793, -18386976, -779229, -20723742, 15077870, -22750759, 14523817},
				{27406042, -6041657, 27423596, -4497394, 4996214, 10002360, -28842031, -4545494, -30172742, -4805667}
			}
		},
		{
			{
				{11374242, 12660715, 17861383, -12540833, 10935568, 1099227, -13886076, -9091740, -27727044, 11358504},
				{-12730809, 10311867, 1510375, 10778093, -2119455, -9145702, 32676003, 11149336, -26123651, 4985768},
				{-19096303, 341147, -6197485, -239033, 15756973, -8796662, -983043, 13794114, -19414307, -15621255}
			},
			{
				{6490081, 11940286, 25495923, -7726360, 8668373, -8751316, 3367603, 6970005, -1691065, -9004790},
				{1656497, 13457317, 15370807, 6364910, 13605745, 8362338, -19174622, -5475723, -16796596, -5031438},
				{-22273315, -13524424, -64685, -4334223, -18605636, -10921968, -20571065, -7007978, -99853, -10237333}
			},
			{
				{17747465, 10039260, 19368299, -4050591, -20630635, -16041286, 31992683, -15857976, -29260363, -5511971},
				{31932027, -4986141, -19612382, 16366580, 22023614, 88450, 11371999, -3744247, 4882242, -10626905},
				{29796507, 37186, 19818052, 10115756, -11829032, 3352736, 18551198, 3272828, -5190932, -4162409}
			},
			{
				{12501286, 4044383, -8612957, -13392385, -32430052, 5136599, -19230378, -3529697, 330070, -3659409},
				{6384877, 2899513, 17807477, 7663917, -2358888, 12363165, 25366522, -8573892, -271295, 12071499},
				{-8365515, -4042521, 25133448, -4517355, -6211027, 2265927, -32769618, 1936675, -5159697, 3829363}
			},
			{
				{28425966, -5835433, -577090, -4697198, -14217555, 6870930, 7921550, -6567787, 26333140, 14267664},
				{-11067219, 11871231, 27385719, -10559544, -4585914, -11189312, 10004786, -8709488, -21761224, 8930324},
				{-21197785, -16396035, 25654216, -1725397, 12282012, 11008919, 1541940, 4757911, -26491501, -16408940}
			},
			{
				{13537262, -7759490, -20604840, 10961927, -5922820, -13218065, -13156584, 6217254, -15943699, 13814990},
				{-17422573, 15157790, 18705543, 29619, 24409717, -260476, 27361681, 9257833, -1956526, -1776914},
				{-25045300, -10191966, 15366585, 15166509, -13105086, 8423556, -29171540, 12361135, -18685978, 4578290}
			},
			{
				{24579768, 3711570, 1342322, -11180126, -27005135, 14124956, -22544529, 14074919, 21964432, 8235257},
				{-6528613, -2411497, 9442966, -5925588, 12025640, -1487420, -2981514, -1669206, 13006806, 2355433},
				{-16304899, -13605259, -6632427, -5142349, 16974359, -10911083, 27202044, 1719366, 1141648, -12796236}
			},
			{
				{-12863944, -13219986, -8318266, -11018091, -6810145, -4843894, 13475066, -3133972, 32674895, 13715045},
				{11423335, -5468059, 32344216, 8962751, 24989809, 9241752, -13265253, 16086212, -28740881, -15642093},
				{-1409668, 12530728, -6368726, 10847387, 19531186, -14132160, -11709148, 7791794, -27245943, 4383347}
			}
		},
		{
			{
				{-28970898, 5271447, -1266009, -9736989, -12455236, 16732599, -4862407, -4906449, 27193557, 6245191},
				{-15193956, 5362278, -1783893, 2695834, 4960227, 12840725, 23061898, 3260492, 22510453, 8577507},
				{-12632451, 11257346, -32692994, 13548177, -721004, 10879011, 31168030, 13952092, -29571492, -3635906}
			},
			{
				{3877321, -9572739, 32416692, 5405324, -11004407, -13656635, 3759769, 11935320, 5611860, 8164018},
				{-16275802, 14667797, 15906460, 12155291, -22111149, -9039718, 32003002, -8832289, 5773085, -8422109},
				{-23788118, -8254300, 1950875, 8937633, 18686727, 16459170, -905725, 12376320, 31632953, 190926}
			},
			{
				{-24593607, -16138885, -8423991, 13378746, 14162407, 6901328, -8288749, 4508564, -25341555, -3627528},
				{8884438, -5884009, 6023974, 10104341, -6881569, -4941533, 18722941, -14786005, -1672488, 827625},
				{-32720583, -16289296, -32503547, 7101210, 13354605, 2659080, -1800575, -14108036, -24878478, 1541286}
			},
			{
				{2901347, -1117687, 3880376, -10059388, -17620940, -3612781, -21802117, -3567481, 20456845, -1885033},
				{27019610, 12299467, -13658288, -1603234, -12861660, -4861471, -19540150, -5016058, 29439641, 15138866},
				{21536104, -6626420, -32447818, -10690208, -22408077, 5175814, -5420040, -16361163, 7779328, 109896}
			},
			{
				{30279744, 14648750, -8044871, 6425558, 13639621, -743509, 28698390, 12180118, 23177719, -554075},
				{26572847, 3405927, -31701700, 12890905, -19265668, 5335866, -6493768, 2378492, 4439158, -13279347},
				{-22716706, 3489070, -9225266, -332753, 18875722, -1140095, 14819434, -12731527, -17717757, -5461437}
			},
			{
				{-5056483, 16566551, 15953661, 3767752, -10436499, 15627060, -820954, 2177225, 8550082, -15114165},
				{-18473302, 16596775, -381660, 15663611, 22860960, 15585581, -27844109, -3582739, -23260460, -8428588},
				{-32480551, 15707275, -8205912, -5652081, 29464558, 2713815, -22725137, 15860482, -21902570, 1494193}
			},
			{
				{-19562091, -14087393, -25583872, -9299552, 13127842, 759709, 21923482, 16529112, 8742704, 12967017},
				{-28464899, 1553205, 32536856, -10473729, -24691605, -406174, -8914625, -2933896, -29903758, 15553883},
				{21877909, 3230008, 9881174, 10539357, -4797115, 2841332, 11543572, 14513274, 19375923, -12647961}
			},
			{
				{8832269, -14495485, 13253511, 5137575, 5037871, 4078777, 24880818, -6222716, 2862653, 9455043},
				{29306751, 5123106, 20245049, -14149889, 9592566, 8447059, -2077124, -2990080, 15511449, 4789663},
				{-20679756, 7004547, 8824831, -9434977, -4045704, -3750736, -5754762, 108893, 23513200, 16652362}
			}
		},
		{
			{
				{-33256173, 4144782, -4476029, -6579123, 10770039, -7155542, -6650416, -12936300, -18319198, 10212860},
				{2756081, 8598110, 7383731, -6859892, 22312759, -1105012, 21179801, 2600940, -9988298, -12506466},
				{-24645692, 13317462, -30449259, -15653928, 21365574, -10869657, 11344424, 864440, -2499677, -16710063}
			},
			{
				{-26432803, 6148329, -17184412, -14474154, 18782929, -275997, -22561534, 211300, 2719757, 4940997},
				{-1323882, 3911313, -6948744, 14759765, -30027150, 7851207, 21690126, 8518463, 26699843, 5276295},
				{-13149873, -6429067, 9396249, 365013, 24703301, -10488939, 1321586, 149635, -15452774, 7159369}
			},
			{
				{9987780, -3404759, 17507962, 9505530, 9731535, -2165514, 22356009, 8312176, 22477218, -8403385},
				{18155857, -16504990, 19744716, 9006923, 15154154, -10538976, 24256460, -4864995, -22548173, 9334109},
				{2986088, -4911893, 10776628, -3473844, 10620590, -7083203, -21413845, 14253545, -22587149, 536906}
			},
			{
				{4377756, 8115836, 24567078, 15495314, 11625074, 13064599, 7390551, 10589625, 10838060, -15420424},
				{-19342404, 867880, 9277171, -3218459, -14431572, -1986443, 19295826, -15796950, 6378260, 699185},
				{7895026, 4057113, -7081772, -13077756, -17886831, -323126, -716039, 15693155, -5045064, -13373962}
			},
			{
				{-7737563, -5869402, -14566319, -7406919, 11385654, 13201616, 31730678, -10962840, -3918636, -9669325},
				{10188286, -15770834, -7336361, 13427543, 22223443, 14896287, 30743455, 7116568, -21786507, 5427593},
				{696102, 13206899, 27047647, -10632082, 15285305, -9853179, 10798490, -4578720, 19236243, 12477404}
			},
			{
				{-11229439, 11243796, -17054270, -8040865, -788228, -8167967, -3897669, 11180504, -23169516, 7733644},
				{17800790, -14036179, -27000429, -11766671, 23887827, 3149671, 23466177, -10538171, 10322027, 15313801},
				{26246234, 11968874, 32263343, -5468728, 6830755, -13323031, -15794704, -101982, -24449242, 10890804}
			},
			{
				{-31365647, 10271363, -12660625, -6267268, 16690207, -13062544, -14982212, 16484931, 25180797, -5334884},
				{-586574, 10376444, -32586414, -11286356, 19801893, 10997610, 2276632, 9482883, 316878, 13820577},
				{-9882808, -4510367, -2115506, 16457136, -11100081, 11674996, 30756178, -7515054, 30696930, -3712849}
			},
			{
				{32988917, -9603412, 12499366, 7910787, -10617257, -11931514, -7342816, -9985397, -32349517, 7392473},
				{-8855661, 15927861, 9866406, -3649411, -2396914, -16655781, -30409476, -9134995, 25112947, -2926644},
				{-2504044, -436966, 25621774, -5678772, 15085042, -5479877, -24884878, -13526194, 5537438, -13914319}
			}
		},
		{
			{
				{-11225584, 2320285, -9584280, 10149187, -33444663, 5808648, -14876251, -1729667, 31234590, 6090599},
				{-9633316, 116426, 26083934, 2897444, -6364437, -2688086, 609721, 15878753, -6970405, -9034768},
				{-27757857, 247744, -15194774, -9002551, 23288161, -10011936, -23869595, 6503646, 20650474, 1804084}
			},
			{
				{-27589786, 15456424, 8972517, 8469608, 15640622, 4439847, 3121995, -10329713, 27842616, -202328},
				{-15306973, 2839644, 22530074, 10026331, 4602058, 5048462, 28248656, 5031932, -11375082, 12714369},
				{20807691, -7270825, 29286141, 11421711, -27876523, -13868230, -21227475, 1035546, -19733229, 12796920}
			},
			{
				{12076899, -14301286, -8785001, -11848922, -25012791, 16400684, -17591495, -12899438, 3480665, -15182815},
				{-32361549, 5457597, 28548107, 7833186, 7303070, -11953545, -24363064, -15921875, -33374054, 2771025},
				{-21389266, 421932, 26597266, 6860826, 22486084, -6737172, -17137485, -4210226, -24552282, 15673397}
			},
			{
				{-20184622, 2338216, 19788685, -9620956, -4001265, -8740893, -20271184, 4733254, 3727144, -12934448},
				{6120119, 814863, -11794402, -622716, 6812205, -15747771, 2019594, 7975683, 31123697, -10958981},
				{30069250, -11435332, 30434654, 2958439, 18399564, -976289, 12296869, 9204260, -16432438, 9648165}
			},
			{
				{32705432, -1550977, 30705658, 7451065, -11805606, 9631813, 3305266, 5248604, -26008332, -11377501},
				{17219865, 2375039, -31570947, -5575615, -19459679, 9219903, 294711, 15298639, 2662509, -16297073},
				{-1172927, -7558695, -4366770, -4287744, -21346413, -8434326, 32087529, -1222777, 32247248, -14389861}
			},
			{
				{14312628, 1221556, 17395390, -8700143, -4945741, -8684635, -28197744, -9637817, -16027623, -13378845},
				{-1428825, -9678990, -9235681, 6549687, -7383069, -468664, 23046502, 9803137, 17597934, 2346211},
				{18510800, 15337574, 26171504, 981392, -22241552, 7827556, -23491134, -11323352, 3059833, -11782870}
			},
			{
				{10141598, 6082907, 17829293, -1947643, 9830092, 13613136, -25556636, -5544586, -33502212, 3592096},
				{33114168, -15889352, -26525686, -13343397, 33076705, 8716171, 1151462, 1521897, -982665, -6837803},
				{-32939165, -4255815, 23947181, -324178, -33072974, -12305637, -16637686, 3891704, 26353178, 693168}
			},
			{
				{30374239, 1595580, -16884039, 13186931, 4600344, 406904, 9585294, -400668, 31375464, 14369965},
				{-14370654, -7772529, 1510301, 6434173, -18784789, -6262728, 32732230, -13108839, 17901441, 16011505},
				{18171223, -11934626, -12500402, 15197122, -11038147, -15230035, -19172240, -16046376, 8764035, 12309598}
			}
		},
		{
			{
				{5975908, -5243188, -19459362, -9681747, -11541277, 14015782, -23665757, 1228319, 17544096, -10593782},
				{5811932, -1715293, 3442887, -2269310, -18367348, -8359541, -18044043, -15410127, -5565381, 12348900},
				{-31399660, 11407555, 25755363, 6891399, -3256938, 14872274, -24849353, 8141295, -10632534, -585479}
			},
			{
				{-12675304, 694026, -5076145, 13300344, 14015258, -14451394, -9698672, -11329050, 30944593, 1130208},
				{8247766, -6710942, -26562381, -7709309, -14401939, -14648910, 4652152, 2488540, 23550156, -271232},
				{17294316, -3788438, 7026748, 15626851, 22990044, 113481, 2267737, -5908146, -408818, -137719}
			},
			{
				{16091085, -16253926, 18599252, 7340678, 2137637, -1221657, -3364161, 14550936, 3260525, -7166271},
				{-4910104, -13332887, 18550887, 10864893, -16459325, -7291596, -23028869, -13204905, -12748722, 2701326},
				{-8574695, 16099415, 4629974, -16340524, -20786213, -6005432, -10018363, 9276971, 11329923, 1862132}
			},
			{
				{14763076, -15903608, -30918270, 3689867, 3511892, 10313526, -21951088, 12219231, -9037963, -940300},
				{8894987, -3446094, 6150753, 3013931, 301220, 15693451, -31981216, -2909717, -15438168, 11595570},
				{15214962, 3537601, -26238722, -14058872, 4418657, -15230761, 13947276, 10730794, -13489462, -4363670}
			},
			{
				{-2538306, 7682793, 32759013, 263109, -29984731, -7955452, -22332124, -10188635, 977108, 699994},
				{-12466472, 4195084, -9211532, 550904, -15565337, 12917920, 19118110, -439841, -30534533, -14337913},
				{31788461, -14507657, 4799989, 7372237, 8808585, -14747943, 9408237, -10051775, 12493932, -5409317}
			},
			{
				{-25680606, 5260744, -19235809, -6284470, -3695942, 16566087, 27218280, 2607121, 29375955, 6024730},
				{842132, -2794693, -4763381, -8722815, 26332018, -12405641, 11831880, 6985184, -9940361, 2854096},
				{-4847262, -7969331, 2516242, -5847713, 9695691, -7221186, 16512645, 960770, 12121869, 16648078}
			},
			{
				{-15218652, 14667096, -13336229, 2013717, 30598287, -464137, -31504922, -7882064, 20237806, 2838411},
				{-19288047, 4453152, 15298546, -16178388, 22115043, -15972604, 12544294, -13470457, 1068881, -12499905},
				{-9558883, -16518835, 33238498, 13506958, 30505848, -1114596, -8486907, -2630053, 12521378, 4845654}
			},
			{
				{-28198521, 10744108, -2958380, 10199664, 7759311, -13088600, 3409348, -873400, -6482306, -12885870},
				{-23561822, 6230156, -20382013, 10655314, -24040585, -11621172, 10477734, -1240216, -3113227, 13974498},
				{12966261, 15550616, -32038948, -1615346, 21025980, -629444, 5642325, 7188737, 18895762, 12629579}
			}
		},
		{
			{
				{14741879, -14946887, 22177208, -11721237, 1279741, 8058600, 11758140, 789443, 32195181, 3895677},
				{10758205, 15755439, -4509950, 9243698, -4879422, 6879879, -2204575, -3566119, -8982069, 4429647},
				{-2453894, 15725973, -20436342, -10410672, -5803908, -11040220, -7135870, -11642895, 18047436, -15281743}
			},
			{
				{-25173001, -11307165, 29759956, 11776784, -22262383, -15820455, 10993114, -12850837, -17620701, -9408468},
				{21987233, 700364, -24505048, 14972008, -7774265, -5718395, 32155026, 2581431, -29958985, 8773375},
				{-25568350, 454463, -13211935, 16126715, 25240068, 8594567, 20656846, 12017935, -7874389, -13920155}
			},
			{
				{6028182, 6263078, -31011806, -11301710, -818919, 2461772, -31841174, -5468042, -1721788, -2776725},
				{-12278994, 16624277, 987579, -5922598, 32908203, 1248608, 7719845, -4166698, 28408820, 6816612},
				{-10358094, -8237829, 19549651, -12169222, 22082623, 16147817, 20613181, 13982702, -10339570, 5067943}
			},
			{
				{-30505967, -3821767, 12074681, 13582412, -19877972, 2443951, -19719286, 12746132, 5331210, -10105944},
				{30528811, 3601899, -1957090, 4619785, -27361822, -15436388, 24180793, -12570394, 27679908, -1648928},
				{9402404, -13957065, 32834043, 10838634, -26580150, -13237195, 26653274, -8685565, 22611444, -12715406}
			},
			{
				{22190590, 1118029, 22736441, 15130463, -30460692, -5991321, 19189625, -4648942, 4854859, 6622139},
				{-8310738, -2953450, -8262579, -3388049, -10401731, -271929, 13424426, -3567227, 26404409, 13001963},
				{-31241838, -15415700, -2994250, 8939346, 11562230, -12840670, -26064365, -11621720, -15405155, 11020693}
			},
			{
				{1866042, -7949489, -7898649, -10301010, 12483315, 13477547, 3175636, -12424163, 28761762, 1406734},
				{-448555, -1777666, 13018551, 3194501, -9580420, -11161737, 24760585, -4347088, 25577411, -13378680},
				{-24290378, 4759345, -690653, -1852816, 2066747, 10693769, -29595790, 9884936, -9368926, 4745410}
			},
			{
				{-9141284, 6049714, -19531061, -4341411, -31260798, 9944276, -15462008, -11311852, 10931924, -11931931},
				{-16561513, 14112680, -8012645, 4817318, -8040464, -11414606, -22853429, 10856641, -20470770, 13434654},
				{22759489, -10073434, -16766264, -1871422, 13637442, -10168091, 1765144, -12654326, 28445307, -5364710}
			},
			{
				{29875063, 12493613, 2795536, -3786330, 1710620, 15181182, -10195717, -8788675, 9074234, 1167180},
				{-26205683, 11014233, -9842651, -2635485, -26908120, 7532294, -18716888, -9535498, 3843903, 9367684},
				{-10969595, -6403711, 9591134, 9582310, 11349256, 108879, 16235123, 8601684, -139197, 4242895}
			}
		},
		{
			{
				{22092954, -13191123, -2042793, -11968512, 32186753, -11517388, -6574341, 2470660, -27417366, 16625501},
				{-11057722, 3042016, 13770083, -9257922, 584236, -544855, -7770857, 2602725, -27351616, 14247413},
				{6314175, -10264892, -32772502, 15957557, -10157730, 168750, -8618807, 14290061, 27108877, -1180880}
			},
			{
				{-8586597, -7170966, 13241782, 10960156, -32991015, -13794596, 33547976, -11058889, -27148451, 981874},
				{22833440, 9293594, -32649448, -13618667, -9136966, 14756819, -22928859, -13970780, -10479804, -16197962},
				{-7768587, 3326786, -28111797, 10783824, 19178761, 14905060, 22680049, 13906969, -15933690, 3797899}
			},
			{
				{21721356, -4212746, -12206123, 9310182, -3882239, -13653110, 23740224, -2709232, 20491983, -8042152},
				{9209270, -15135055, -13256557, -6167798, -731016, 15289673, 25947805, 15286587, 30997318, -6703063},
				{7392032, 16618386, 23946583, -8039892, -13265164, -1533858, -14197445, -2321576, 17649998, -250080}
			},
			{
				{-9301088, -14193827, 30609526, -3049543, -25175069, -1283752, -15241566, -9525724, -2233253, 7662146},
				{-17558673, 1763594, -33114336, 15908610, -30040870, -12174295, 7335080, -8472199, -3174674, 3440183},
				{-19889700, -5977008, -24111293, -9688870, 10799743, -16571957, 40450, -4431835, 4862400, 1133}
			},
			{
				{-32856209, -7873957, -5422389, 14860950, -16319031, 7956142, 7258061, 311861, -30594991, -7379421},
				{-3773428, -1565936, 28985340, 7499440, 24445838, 9325937, 29727763, 16527196, 18278453, 15405622},
				{-4381906, 8508652, -19898366, -3674424, -5984453, 15149970, -13313598, 843523, -21875062, 13626197}
			},
			{
				{2281448, -13487055, -10915418, -2609910, 1879358, 16164207, -10783882, 3953792, 13340839, 15928663},
				{31727126, -7179855, -18437503, -8283652, 2875793, -16390330, -25269894, -7014826, -23452306, 5964753},
				{4100420, -5959452, -17179337, 6017714, -18705837, 12227141, -26684835, 11344144, 2538215, -7570755}
			},
			{
				{-9433605, 6123113, 11159803, -2156608, 30016280, 14966241, -20474983, 1485421, -629256, -15958862},
				{-26804558, 4260919, 11851389, 9658551, -32017107, 16367492, -20205425, -13191288, 11659922, -11115118},
				{26180396, 10015009, -30844224, -8581293, 5418197, 9480663, 2231568, -10170080, 33100372, -1306171}
			},
			{
				{15121113, -5201871, -10389905, 15427821, -27509937, -15992507, 21670947, 4486675, -5931810, -14466380},
				{16166486, -9483733, -11104130, 6023908, -31926798, -1364923, 2340060, -16254968, -10735770, -10039824},
				{28042865, -3557089, -12126526, 12259706, -3717498, -6945899, 6766453, -8689599, 18036436, 5803270}
			}
		},
		{
			{
				{-817581, 6763912, 11803561, 1585585, 10958447, -2671165, 23855391, 4598332, -6159431, -14117438},
				{-31031306, -14256194, 17332029, -2383520, 31312682, -5967183, 696309, 50292, -20095739, 11763584},
				{-594563, -2514283, -32234153, 12643980, 12650761, 14811489, 665117, -12613632, -19773211, -10713562}
			},
			{
				{30464590, -11262872, -4127476, -12734478, 19835327, -7105613, -24396175, 2075773, -17020157, 992471},
				{18357185, -6994433, 7766382, 16342475, -29324918, 411174, 14578841, 8080033, -11574335, -10601610},
				{19598397, 10334610, 12555054, 2555664, 18821899, -10339780, 21873263, 16014234, 26224780, 16452269}
			},
			{
				{-30223925, 5145196, 5944548, 16385966, 3976735, 2009897, -11377804, -7618186, -20533829, 3698650},
				{14187449, 3448569, -10636236, -10810935, -22663880, -3433596, 7268410, -10890444, 27394301, 12015369},
				{19695761, 16087646, 28032085, 12999827, 6817792, 11427614, 20244189, -1312777, -13259127, -3402461}
			},
			{
				{30860103, 12735208, -1888245, -4699734, -16974906, 2256940, -8166013, 12298312, -8550524, -10393462},
				{-5719826, -11245325, -1910649, 15569035, 26642876, -7587760, -5789354, -15118654, -4976164, 12651793},
				{-2848395, 9953421, 11531313, -5282879, 26895123, -12697089, -13118820, -16517902, 9768698, -2533218}
			},
			{
				{-24719459, 1894651, -287698, -4704085, 15348719, -8156530, 32767513, 12765450, 4940095, 10678226},
				{18860224, 15980149, -18987240, -1562570, -26233012, -11071856, -7843882, 13944024, -24372348, 16582019},
				{-15504260, 4970268, -29893044, 4175593, -20993212, -2199756, -11704054, 15444560, -11003761, 7989037}
			},
			{
				{31490452, 5568061, -2412803, 2182383, -32336847, 4531686, -32078269, 6200206, -19686113, -14800171},
				{-17308668, -15879940, -31522777, -2831, -32887382, 16375549, 8680158, -16371713, 28550068, -6857132},
				{-28126887, -5688091, 16837845, -1820458, -6850681, 12700016, -30039981, 4364038, 1155602, 5988841}
			},
			{
				{21890435, -13272907, -12624011, 12154349, -7831873, 15300496, 23148983, -4470481, 24618407, 8283181},
				{-33136107, -10512751, 9975416, 6841041, -31559793, 16356536, 3070187, -7025928, 1466169, 10740210},
				{-1509399, -15488185, -13503385, -10655916, 32799044, 909394, -13938903, -5779719, -32164649, -15327040}
			},
			{
				{3960823, -14267803, -28026090, -15918051, -19404858, 13146868, 15567327, 951507, -3260321, -573935},
				{24740841, 5052253, -30094131, 8961361, 25877428, 6165135, -24368180, 14397372, -7380369, -6144105},
				{-28888365, 3510803, -28103278, -1158478, -11238128, -10631454, -15441463, -14453128, -1625486, -6494814}
			}
		},
		{
			{
				{793299, -9230478, 8836302, -6235707, -27360908, -2369593, 33152843, -4885251, -9906200, -621852},
				{5666233, 525582, 20782575, -8038419, -24538499, 14657740, 16099374, 1468826, -6171428, -15186581},
				{-4859255, -3779343, -2917758, -6748019, 7778750, 11688288, -30404353, -9871238, -1558923, -9863646}
			},
			{
				{10896332, -7719704, 824275, 472601, -19460308, 3009587, 25248958, 14783338, -30581476, -15757844},
				{10566929, 12612572, -31944212, 11118703, -12633376, 12362879, 21752402, 8822496, 24003793, 14264025},
				{27713862, -7355973, -11008240, 9227530, 27050101, 2504721, 23886875, -13117525, 13958495, -5732453}
			},
			{
				{-23481610, 4867226, -27247128, 3900521, 29838369, -8212291, -31889399, -10041781, 7340521, -15410068},
				{4646514, -8011124, -22766023, -11532654, 23184553, 8566613, 31366726, -1381061, -15066784, -10375192},
				{-17270517, 12723032, -16993061, 14878794, 21619651, -6197576, 27584817, 3093888, -8843694, 3849921}
			},
			{
				{-9064912, 2103172, 25561640, -15125738, -5239824, 9582958, 32477045, -9017955, 5002294, -15550259},
				{-12057553, -11177906, 21115585, -13365155, 8808712, -12030708, 16489530, 13378448, -25845716, 12741426},
				{-5946367, 10645103, -30911586, 15390284, -3286982, -7118677, 24306472, 15852464, 28834118, -7646072}
			},
			{
				{-17335748, -9107057, -24531279, 9434953, -8472084, -583362, -13090771, 455841, 20461858, 5491305},
				{13669248, -16095482, -12481974, -10203039, -14569770, -11893198, -24995986, 11293807, -28588204, -9421832},
				{28497928, 6272777, -33022994, 14470570, 8906179, -1225630, 18504674, -14165166, 29867745, -8795943}
			},
			{
				{-16207023, 13517196, -27799630, -13697798, 24009064, -6373891, -6367600, -13175392, 22853429, -4012011},
				{24191378, 16712145, -13931797, 15217831, 14542237, 1646131, 18603514, -11037887, 12876623, -2112447},
				{17902668, 4518229, -411702, -2829247, 26878217, 5258055, -12860753, 608397, 16031844, 3723494}
			},
			{
				{-28632773, 12763728, -20446446, 7577504, 33001348, -13017745, 17558842, -7872890, 23896954, -4314245},
				{-20005381, -12011952, 31520464, 605201, 2543521, 5991821, -2945064, 7229064, -9919646, -8826859},
				{28816045, 298879, -28165016, -15920938, 19000928, -1665890, -12680833, -2949325, -18051778, -2082915}
			},
			{
				{16000882, -344896, 3493092, -11447198, -29504595, -13159789, 12577740, 16041268, -19715240, 7847707},
				{10151868, 10572098, 27312476, 7922682, 14825339, 4723128, -32855931, -6519018, -10020567, 3852848},
				{-11430470, 15697596, -21121557, -4420647, 5386314, 15063598, 16514493, -15932110, 29330899, -15076224}
			}
		},
		{
			{
				{-25499735, -4378794, -15222908, -6901211, 16615731, 2051784, 3303702, 15490, -27548796, 12314391},
				{15683520, -6003043, 18109120, -9980648, 15337968, -5997823, -16717435, 15921866, 16103996, -3731215},
				{-23169824, -10781249, 13588192, -1628807, -3798557, -1074929, -19273607, 5402699, -29815713, -9841101}
			},
			{
				{23190676, 2384583, -32714340, 3462154, -29903655, -1529132, -11266856, 8911517, -25205859, 2739713},
				{21374101, -3554250, -33524649, 9874411, 15377179, 11831242, -33529904, 6134907, 4931255, 11987849},
				{-7732, -2978858, -16223486, 7277597, 105524, -322051, -31480539, 13861388, -30076310, 10117930}
			},
			{
				{-29501170, -10744872, -26163768, 13051539, -25625564, 5089643, -6325503, 6704079, 12890019, 15728940},
				{-21972360, -11771379, -951059, -4418840, 14704840, 2695116, 903376, -10428139, 12885167, 8311031},
				{-17516482, 5352194, 10384213, -13811658, 7506451, 13453191, 26423267, 4384730, 1888765, -5435404}
			},
			{
				{-25817338, -3107312, -13494599, -3182506, 30896459, -13921729, -32251644, -12707869, -19464434, -3340243},
				{-23607977, -2665774, -526091, 4651136, 5765089, 4618330, 6092245, 14845197, 17151279, -9854116},
				{-24830458, -12733720, -15165978, 10367250, -29530908, -265356, 22825805, -7087279, -16866484, 16176525}
			},
			{
				{-23583256, 6564961, 20063689, 3798228, -4740178, 7359225, 2006182, -10363426, -28746253, -10197509},
				{-10626600, -4486402, -13320562, -5125317, 3432136, -6393229, 23632037, -1940610, 32808310, 1099883},
				{15030977, 5768825, -27451236, -2887299, -6427378, -15361371, -15277896, -6809350, 2051441, -15225865}
			},
			{
				{-3362323, -7239372, 7517890, 9824992, 23555850, 295369, 5148398, -14154188, -22686354, 16633660},
				{4577086, -16752288, 13249841, -15304328, 19958763, -14537274, 18559670, -10759549, 8402478, -9864273},
				{-28406330, -1051581, -26790155, -907698, -17212414, -11030789, 9453451, -14980072, 17983010, 9967138}
			},
			{
				{-25762494, 6524722, 26585488, 9969270, 24709298, 1220360, -1677990, 7806337, 17507396, 3651560},
				{-10420457, -4118111, 14584639, 15971087, -15768321, 8861010, 26556809, -5574557, -18553322, -11357135},
				{2839101, 14284142, 4029895, 3472686, 14402957, 12689363, -26642121, 8459447, -5605463, -7621941}
			},
			{
				{-4839289, -3535444, 9744961, 2871048, 25113978, 3187018, -25110813, -849066, 17258084, -7977739},
				{18164541, -10595176, -17154882, -1542417, 19237078, -9745295, 23357533, -15217008, 26908270, 12150756},
				{-30264870, -7647865, 5112249, -7036672, -1499807, -6974257, 43168, -5537701, -32302074, 16215819}
			}
		},
		{
			{
				{-6898905, 9824394, -12304779, -4401089, -31397141, -6276835, 32574489, 12532905, -7503072, -8675347},
				{-27343522, -16515468, -27151524, -10722951, 946346, 16291093, 254968, 7168080, 21676107, -1943028},
				{21260961, -8424752, -16831886, -11920822, -23677961, 3968121, -3651949, -6215466, -3556191, -7913075}
			},
			{
				{16544754, 13250366, -16804428, 15546242, -4583003, 12757258, -2462308, -8680336, -18907032, -9662799},
				{-2415239, -15577728, 18312303, 4964443, -15272530, -12653564, 26820651, 16690659, 25459437, -4564609},
				{-25144690, 11425020, 28423002, -11020557, -6144921, -15826224, 9142795, -2391602, -6432418, -1644817}
			},
			{
				{-23104652, 6253476, 16964147, -3768872, -25113972, -12296437, -27457225, -16344658, 6335692, 7249989},
				{-30333227, 13979675, 7503222, -12368314, -11956721, -4621693, -30272269, 2682242, 25993170, -12478523},
				{4364628, 5930691, 32304656, -10044554, -8054781, 15091131, 22857016, -10598955, 31820368, 15075278}
			},
			{
				{31879134, -8918693, 17258761, 90626, -8041836, -4917709, 24162788, -9650886, -17970238, 12833045},
				{19073683, 14851414, -24403169, -11860168, 7625278, 11091125, -19619190, 2074449, -9413939, 14905377},
				{24483667, -11935567, -2518866, -11547418, -1553130, 15355506, -25282080, 9253129, 27628530, -7555480}
			},
			{
				{17597607, 8340603, 19355617, 552187, 26198470, -3176583, 4593324, -9157582, -14110875, 15297016},
				{510886, 14337390, -31785257, 16638632, 6328095, 2713355, -20217417, -11864220, 8683221, 2921426},
				{18606791, 11874196, 27155355, -5281482, -24031742, 6265446, -25178240, -1278924, 4674690, 13890525}
			},
			{
				{13609624, 13069022, -27372361, -13055908, 24360586, 9592974, 14977157, 9835105, 4389687, 288396},
				{9922506, -519394, 13613107, 5883594, -18758345, -434263, -12304062, 8317628, 23388070, 16052080},
				{12720016, 11937594, -31970060, -5028689, 26900120, 8561328, -20155687, -11632979, -14754271, -10812892}
			},
			{
				{15961858, 14150409, 26716931, -665832, -22794328, 13603569, 11829573, 7467844, -28822128, 929275},
				{11038231, -11582396, -27310482, -7316562, -10498527, -16307831, -23479533, -9371869, -21393143, 2465074},
				{20017163, -4323226, 27915242, 1529148, 12396362, 15675764, 13817261, -9658066, 2463391, -4622140}
			},
			{
				{-16358878, -12663911, -12065183, 4996454, -1256422, 1073572, 9583558, 12851107, 4003896, 12673717},
				{-1731589, -15155870, -3262930, 16143082, 19294135, 13385325, 14741514, -9103726, 7903886, 2348101},
				{24536016, -16515207, 12715592, -3862155, 1511293, 10047386, -3842346, -7129159, -28377538, 10048127}
			}
		},
		{
			{
				{-12622226, -6204820, 30718825, 2591312, -10617028, 12192840, 18873298, -7297090, -32297756, 15221632},
				{-26478122, -11103864, 11546244, -1852483, 9180880, 7656409, -21343950, 2095755, 29769758, 6593415},
				{-31994208, -2907461, 4176912, 3264766, 12538965, -868111, 26312345, -6118678, 30958054, 8292160}
			},
			{
				{31429822, -13959116, 29173532, 15632448, 12174511, -2760094, 32808831, 3977186, 26143136, -3148876},
				{22648901, 1402143, -22799984, 13746059, 7936347, 365344, -8668633, -1674433, -3758243, -2304625},
				{-15491917, 8012313, -2514730, -12702462, -23965846, -10254029, -1612713, -1535569, -16664475, 8194478}
			},
			{
				{27338066, -7507420, -7414224, 10140405, -19026427, -6589889, 27277191, 8855376, 28572286, 3005164},
				{26287124, 4821776, 25476601, -4145903, -3764513, -15788984, -18008582, 1182479, -26094821, -13079595},
				{-7171154, 3178080, 23970071, 6201893, -17195577, -4489192, -21876275, -13982627, 32208683, -1198248}
			},
			{
				{-16657702, 2817643, -10286362, 14811298, 6024667, 13349505, -27315504, -10497842, -27672585, -11539858},
				{15941029, -9405932, -21367050, 8062055, 31876073, -238629, -15278393, -1444429, 15397331, -4130193},
				{8934485, -13485467, -23286397, -13423241, -32446090, 14047986, 31170398, -1441021, -27505566, 15087184}
			},
			{
				{-18357243, -2156491, 24524913, -16677868, 15520427, -6360776, -15502406, 11461896, 16788528, -5868942},
				{-1947386, 16013773, 21750665, 3714552, -17401782, -16055433, -3770287, -10323320, 31322514, -11615635},
				{21426655, -5650218, -13648287, -5347537, -28812189, -4920970, -18275391, -14621414, 13040862, -12112948}
			},
			{
				{11293895, 12478086, -27136401, 15083750, -29307421, 14748872, 14555558, -13417103, 1613711, 4896935},
				{-25894883, 15323294, -8489791, -8057900, 25967126, -13425460, 2825960, -4897045, -23971776, -11267415},
				{-15924766, -5229880, -17443532, 6410664, 3622847, 10243618, 20615400, 12405433, -23753030, -8436416}
			},
			{
				{-7091295, 12556208, -20191352, 9025187, -17072479, 4333801, 4378436, 2432030, 23097949, -566018},
				{4565804, -16025654, 20084412, -7842817, 1724999, 189254, 24767264, 10103221, -18512313, 2424778},
				{366633, -11976806, 8173090, -6890119, 30788634, 5745705, -7168678, 1344109, -3642553, 12412659}
			},
			{
				{-24001791, 7690286, 14929416, -168257, -32210835, -13412986, 24162697, -15326504, -3141501, 11179385},
				{18289522, -14724954, 8056945, 16430056, -21729724, 7842514, -6001441, -1486897, -18684645, -11443503},
				{476239, 6601091, -6152790, -9723375, 17503545, -4863900, 27672959, 13403813, 11052904, 5219329}
			}
		},
		{
			{
				{20678546, -8375738, -32671898, 8849123, -5009758, 14574752, 31186971, -3973730, 9014762, -8579056},
				{-13644050, -10350239, -15962508, 5075808, -1514661, -11534600, -33102500, 9160280, 8473550, -3256838},
				{24900749, 14435722, 17209120, -15292541, -22592275, 9878983, -7689309, -16335821, -24568481, 11788948}
			},
			{
				{-3118155, -11395194, -13802089, 14797441, 9652448, -6845904, -20037437, 10410733, -24568470, -1458691},
				{-15659161, 16736706, -22467150, 10215878, -9097177, 7563911, 11871841, -12505194, -18513325, 8464118},
				{-23400612, 8348507, -14585951, -861714, -3950205, -6373419, 14325289, 8628612, 33313881, -8370517}
			},
			{
				{-20186973, -4967935, 22367356, 5271547, -1097117, -4788838, -24805667, -10236854, -8940735, -5818269},
				{-6948785, -1795212, -32625683, -16021179, 32635414, -7374245, 15989197, -12838188, 28358192, -4253904},
				{-23561781, -2799059, -32351682, -1661963, -9147719, 10429267, -16637684, 4072016, -5351664, 5596589}
			},
			{
				{-28236598, -3390048, 12312896, 6213178, 3117142, 16078565, 29266239, 2557221, 1768301, 15373193},
				{-7243358, -3246960, -4593467, -7553353, -127927, -912245, -1090902, -4504991, -24660491, 3442910},
				{-30210571, 5124043, 14181784, 8197961, 18964734, -11939093, 22597931, 7176455, -18585478, 13365930}
			},
			{
				{-7877390, -1499958, 8324673, 4690079, 6261860, 890446, 24538107, -8570186, -9689599, -3031667},
				{25008904, -10771599, -4305031, -9638010, 16265036, 15721635, 683793, -11823784, 15723479, -15163481},
				{-9660625, 12374379, -27006999, -7026148, -7724114, -12314514, 11879682, 5400171, 519526, -1235876}
			},
			{
				{22258397, -16332233, -7869817, 14613016, -22520255, -2950923, -20353881, 7315967, 16648397, 7605640},
				{-8081308, -8464597, -8223311, 9719710, 19259459, -15348212, 23994942, -5281555, -9468848, 4763278},
				{-21699244, 9220969, -15730624, 1084137, -25476107, -2852390, 31088447, -7764523, -11356529, 728112}
			},
			{
				{26047220, -11751471, -6900323, -16521798, 24092068, 9158119, -4273545, -12555558, -29365436, -5498272},
				{17510331, -322857, 5854289, 8403524, 17133918, -3112612, -28111007, 12327945, 10750447, 10014012},
				{-10312768, 3936952, 9156313, -8897683, 16498692, -994647, -27481051, -666732, 3424691, 7540221}
			},
			{
				{30322361, -6964110, 11361005, -4143317, 7433304, 4989748, -7071422, -16317219, -9244265, 15258046},
				{13054562, -2779497, 19155474, 469045, -12482797, 4566042, 5631406, 2711395, 1062915, -5136345},
				{-19240248, -11254599, -29509029, -7499965, -5835763, 13005411, -6066489, 12194497, 32960380, 1459310}
			}
		},
		{
			{
				{19852034, 7027924, 23669353, 10020366, 8586503, -6657907, 394197, -6101885, 18638003, -11174937},
				{31395534, 15098109, 26581030, 8030562, -16527914, -5007134, 9012486, -7584354, -6643087, -5442636},
				{-9192165, -2347377, -1997099, 4529534, 25766844, 607986, -13222, 9677543, -32294889, -6456008}
			},
			{
				{-2444496, -149937, 29348902, 8186665, 1873760, 12489863, -30934579, -7839692, -7852844, -8138429},
				{-15236356, -15433509, 7766470, 746860, 26346930, -10221762, -27333451, 10754588, -9431476, 5203576},
				{31834314, 14135496, -770007, 5159118, 20917671, -16768096, -7467973, -7337524, 31809243, 7347066}
			},
			{
				{-9606723, -11874240, 20414459, 13033986, 13716524, -11691881, 19797970, -12211255, 15192876, -2087490},
				{-12663563, -2181719, 1168162, -3804809, 26747877, -14138091, 10609330, 12694420, 33473243, -13382104},
				{33184999, 11180355, 15832085, -11385430, -1633671, 225884, 15089336, -11023903, -6135662, 14480053}
			},
			{
				{31308717, -5619998, 31030840, -1897099, 15674547, -6582883, 5496208, 13685227, 27595050, 8737275},
				{-20318852, -15150239, 10933843, -16178022, 8335352, -7546022, -31008351, -12610604, 26498114, 66511},
				{22644454, -8761729, -16671776, 4884562, -3105614, -13559366, 30540766, -4286747, -13327787, -7515095}
			},
			{
				{-28017847, 9834845, 18617207, -2681312, -3401956, -13307506, 8205540, 13585437, -17127465, 15115439},
				{23711543, -672915, 31206561, -8362711, 6164647, -9709987, -33535882, -1426096, 8236921, 16492939},
				{-23910559, -13515526, -26299483, -4503841, 25005590, -7687270, 19574902, 10071562, 6708380, -6222424}
			},
			{
				{2101391, -4930054, 19702731, 2367575, -15427167, 1047675, 5301017, 9328700, 29955601, -11678310},
				{3096359, 9271816, -21620864, -15521844, -14847996, -7592937, -25892142, -12635595, -9917575, 6216608},
				{-32615849, 338663, -25195611, 2510422, -29213566, -13820213, 24822830, -6146567, -26767480, 7525079}
			},
			{
				{-23066649, -13985623, 16133487, -7896178, -3389565, 778788, -910336, -2782495, -19386633, 11994101},
				{21691500, -13624626, -641331, -14367021, 3285881, -3483596, -25064666, 9718258, -7477437, 13381418},
				{18445390, -4202236, 14979846, 11622458, -1727110, -3582980, 23111648, -6375247, 28535282, 15779576}
			},
			{
				{30098053, 3089662, -9234387, 16662135, -21306940, 11308411, -14068454, 12021730, 9955285, -16303356},
				{9734894, -14576830, -7473633, -9138735, 2060392, 11313496, -18426029, 9924399, 20194861, 13380996},
				{-26378102, -7965207, -22167821, 15789297, -18055342, -6168792, -1984914, 15707771, 26342023, 10146099}
			}
		},
		{
			{
				{-26016874, -219943, 21339191, -41388, 19745256, -2878700, -29637280, 2227040, 21612326, -545728},
				{-13077387, 1184228, 23562814, -5970442, -20351244, -6348714, 25764461, 12243797, -20856566, 11649658},
				{-10031494, 11262626, 27384172, 2271902, 26947504, -15997771, 39944, 6114064, 33514190, 2333242}
			},
			{
				{-21433588, -12421821, 8119782, 7219913, -21830522, -9016134, -6679750, -12670638, 24350578, -13450001},
				{-4116307, -11271533, -23886186, 4843615, -30088339, 690623, -31536088, -10406836, 8317860, 12352766},
				{18200138, -14475911, -33087759, -2696619, -23702521, -9102511, -23552096, -2287550, 20712163, 6719373}
			},
			{
				{26656208, 6075253, -7858556, 1886072, -28344043, 4262326, 11117530, -3763210, 26224235, -3297458},
				{-17168938, -14854097, -3395676, -16369877, -19954045, 14050420, 21728352, 9493610, 18620611, -16428628},
				{-13323321, 13325349, 11432106, 5964811, 18609221, 6062965, -5269471, -9725556, -30701573, -16479657}
			},
			{
				{-23860538, -11233159, 26961357, 1640861, -32413112, -16737940, 12248509, -5240639, 13735342, 1934062},
				{25089769, 6742589, 17081145, -13406266, 21909293, -16067981, -15136294, -3765346, -21277997, 5473616},
				{31883677, -7961101, 1083432, -11572403, 22828471, 13290673, -7125085, 12469656, 29111212, -5451014}
			},
			{
				{24244947, -15050407, -26262976, 2791540, -14997599, 16666678, 24367466, 6388839, -10295587, 452383},
				{-25640782, -3417841, 5217916, 16224624, 19987036, -4082269, -24236251, -5915248, 15766062, 8407814},
				{-20406999, 13990231, 15495425, 16395525, 5377168, 15166495, -8917023, -4388953, -8067909, 2276718}
			},
			{
				{30157918, 12924066, -17712050, 9245753, 19895028, 3368142, -23827587, 5096219, 22740376, -7303417},
				{2041139, -14256350, 7783687, 13876377, -25946985, -13352459, 24051124, 13742383, -15637599, 13295222},
				{33338237, -8505733, 12532113, 7977527, 9106186, -1715251, -17720195, -4612972, -4451357, -14669444}
			},
			{
				{-20045281, 5454097, -14346548, 6447146, 28862071, 1883651, -2469266, -4141880, 7770569, 9620597},
				{23208068, 7979712, 33071466, 8149229, 1758231, -10834995, 30945528, -1694323, -33502340, -14767970},
				{1439958, -16270480, -1079989, -793782, 4625402, 10647766, -5043801, 1220118, 30494170, -11440799}
			},
			{
				{-5037580, -13028295, -2970559, -3061767, 15640974, -6701666, -26739026, 926050, -1684339, -13333647},
				{13908495, -3549272, 30919928, -6273825, -21521863, 7989039, 9021034, 9078865, 3353509, 4033511},
				{-29663431, -15113610, 32259991, -344482, 24295849, -12912123, 23161163, 8839127, 27485041, 7356032}
			}
		},
		{
			{
				{9661027, 705443, 11980065, -5370154, -1628543, 14661173, -6346142, 2625015, 28431036, -16771834},
				{-23839233, -8311415, -25945511, 7480958, -17681669, -8354183, -22545972, 14150565, 15970762, 4099461},
				{29262576, 16756590, 26350592, -8793563, 8529671, -11208050, 13617293, -9937143, 11465739, 8317062}
			},
			{
				{-25493081, -6962928, 32500200, -9419051, -23038724, -2302222, 14898637, 3848455, 20969334, -5157516},
				{-20384450, -14347713, -18336405, 13884722, -33039454, 2842114, -21610826, -3649888, 11177095, 14989547},
				{-24496721, -11716016, 16959896, 2278463, 12066309, 10137771, 13515641, 2581286, -28487508, 9930240}
			},
			{
				{-17751622, -2097826, 16544300, -13009300, -15914807, -14949081, 18345767, -13403753, 16291481, -5314038},
				{-33229194, 2553288, 32678213, 9875984, 8534129, 6889387, -9676774, 6957617, 4368891, 9788741},
				{16660756, 7281060, -10830758, 12911820, 20108584, -8101676, -21722536, -8613148, 16250552, -11111103}
			},
			{
				{-19765507, 2390526, -16551031, 14161980, 1905286, 6414907, 4689584, 10604807, -30190403, 4782747},
				{-1354539, 14736941, -7367442, -13292886, 7710542, -14155590, -9981571, 4383045, 22546403, 437323},
				{31665577, -12180464, -16186830, 1491339, -18368625, 3294682, 27343084, 2786261, -30633590, -14097016}
			},
			{
				{-14467279, -683715, -33374107, 7448552, 19294360, 14334329, -19690631, 2355319, -19284671, -6114373},
				{15121312, -15796162, 6377020, -6031361, -10798111, -12957845, 18952177, 15496498, -29380133, 11754228},
				{-2637277, -13483075, 8488727, -14303896, 12728761, -1622493, 7141596, 11724556, 22761615, -10134141}
			},
			{
				{16918416, 11729663, -18083579, 3022987, -31015732, -13339659, -28741185, -12227393, 32851222, 11717399},
				{11166634, 7338049, -6722523, 4531520, -29468672, -7302055, 31474879, 3483633, -1193175, -4030831},
				{-185635, 9921305, 31456609, -13536438, -12013818, 13348923, 33142652, 6546660, -19985279, -3948376}
			},
			{
				{-32460596, 11266712, -11197107, -7899103, 31703694, 3855903, -8537131, -12833048, -30772034, -15486313},
				{-18006477, 12709068, 3991746, -6479188, -21491523, -10550425, -31135347, -16049879, 10928917, 3011958},
				{-6957757, -15594337, 31696059, 334240, 29576716, 14796075, -30831056, -12805180, 18008031, 10258577}
			},
			{
				{-22448644, 15655569, 7018479, -4410003, -30314266, -1201591, -1853465, 1367120, 25127874, 6671743},
				{29701166, -14373934, -10878120, 9279288, -17568, 13127210, 21382910, 11042292, 25838796, 4642684},
				{-20430234, 14955537, -24126347, 8124619, -5369288, -5990470, 30468147, -13900640, 18423289, 4177476}
			}
		}
	};

	public static readonly ge_precomp[] ge_Bi =
	{
		{
			{25967493, -14356035, 29566456, 3660896, -12694345, 4014787, 27544626, -11754271, -6079156, 2047605},
			{-12545711, 934262, -2722910, 3049990, -727428, 9406986, 12720692, 5043384, 19500929, -15469378},
			{-8738181, 4489570, 9688441, -14785194, 10184609, -12363380, 29287919, 11864899, -24514362, -4438546}
		},
		{
			{15636291, -9688557, 24204773, -7912398, 616977, -16685262, 27787600, -14772189, 28944400, -1550024},
			{16568933, 4717097, -11556148, -1102322, 15682896, -11807043, 16354577, -11775962, 7689662, 11199574},
			{30464156, -5976125, -11779434, -15670865, 23220365, 15915852, 7512774, 10017326, -17749093, -9920357}
		},
		{
			{10861363, 11473154, 27284546, 1981175, -30064349, 12577861, 32867885, 14515107, -15438304, 10819380},
			{4708026, 6336745, 20377586, 9066809, -11272109, 6594696, -25653668, 12483688, -12668491, 5581306},
			{19563160, 16186464, -29386857, 4097519, 10237984, -4348115, 28542350, 13850243, -23678021, -15815942}
		},
		{
			{5153746, 9909285, 1723747, -2777874, 30523605, 5516873, 19480852, 5230134, -23952439, -15175766},
			{-30269007, -3463509, 7665486, 10083793, 28475525, 1649722, 20654025, 16520125, 30598449, 7715701},
			{28881845, 14381568, 9657904, 3680757, -20181635, 7843316, -31400660, 1370708, 29794553, -1409300}
		},
		{
			{-22518993, -6692182, 14201702, -8745502, -23510406, 8844726, 18474211, -1361450, -13062696, 13821877},
			{-6455177, -7839871, 3374702, -4740862, -27098617, -10571707, 31655028, -7212327, 18853322, -14220951},
			{4566830, -12963868, -28974889, -12240689, -7602672, -2830569, -8514358, -10431137, 2207753, -3209784}
		},
		{
			{-25154831, -4185821, 29681144, 7868801, -6854661, -9423865, -12437364, -663000, -31111463, -16132436},
			{25576264, -2703214, 7349804, -11814844, 16472782, 9300885, 3844789, 15725684, 171356, 6466918},
			{23103977, 13316479, 9739013, -16149481, 817875, -15038942, 8965339, -14088058, -30714912, 16193877}
		},
		{
			{-33521811, 3180713, -2394130, 14003687, -16903474, -16270840, 17238398, 4729455, -18074513, 9256800},
			{-25182317, -4174131, 32336398, 5036987, -21236817, 11360617, 22616405, 9761698, -19827198, 630305},
			{-13720693, 2639453, -24237460, -7406481, 9494427, -5774029, -6554551, -15960994, -2449256, -14291300}
		},
		{
			{-3151181, -5046075, 9282714, 6866145, -31907062, -863023, -18940575, 15033784, 25105118, -7894876},
			{-24326370, 15950226, -31801215, -14592823, -11662737, -5090925, 1573892, -2625887, 2198790, -15804619},
			{-3099351, 10324967, -2241613, 7453183, -5446979, -2735503, -13812022, -16236442, -32461234, -12290683}
		}
	};

	/* A = 2 * (1 - d) / (1 + d) = 486662 */
	public static readonly int[] fe_ma2 = {-12721188, -3529, 0, 0, 0, 0, 0, 0, 0, 0}; // -A^2
	public static readonly int[] fe_ma = {-486662, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // -A
	public static readonly int[] fe_fffb1 = {-31702527, -2466483, -26106795, -12203692, -12169197, -321052, 14850977, -10296299, -16929438, -407568}; // sqrt(-2 * A * (A + 2))
	public static readonly int[] fe_fffb2 = {8166131, -6741800, -17040804, 3154616, 21461005, 1466302, -30876704, -6368709, 10503587, -13363080}; // sqrt(2 * A * (A + 2))
	public static readonly int[] fe_fffb3 = {-13620103, 14639558, 4532995, 7679154, 16815101, -15883539, -22863840, -14813421, 13716513, -6477756}; // sqrt(-sqrt(-1) * A * (A + 2))
	public static readonly int[] fe_fffb4 = {-21786234, -12173074, 21573800, 4524538, -4645904, 16204591, 8012863, -8444712, 3212926, 6885324}; // sqrt(sqrt(-1) * A * (A + 2))


/* hash bit sequence */

	/*void Init(hashState*);
	void Update(hashState*, const BitSequence*, DataLength);
	void Final(hashState*, BitSequence*); */
	public static void groestl(byte data, ulong databitlen, ref byte hashval)
	{

	  hashState context = new hashState();

	  /* initialise */
		Init(context);


	  /* process message */
	  Update(context, data, databitlen);

	  /* finalise */
	  Final(context, hashval);
	}
	/* NIST API end   */

	/*
	int crypto_hash(unsigned char *out,
			const unsigned char *in,
			unsigned long long len);
	*/




	public static readonly ushort[,] shift_Values =
	{
		{0, 1, 2, 3, 4, 5, 6, 7},
		{1, 3, 5, 7, 0, 2, 4, 6}
	};

	public static readonly ushort[] indices_cyclic = {0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6};


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ROTATE_COLUMN_DOWN(v1, v2, amount_bytes, temp_var) {temp_var = (v1<<(8*amount_bytes))|(v2>>(8*(4-amount_bytes))); v2 = (v2<<(8*amount_bytes))|(v1>>(8*(4-amount_bytes))); v1 = temp_var;}


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define COLUMN(x,y,i,c0,c1,c2,c3,c4,c5,c6,c7,tv1,tv2,tu,tl,t) tu = T[2*(uint)x[4*c0+0]]; tl = T[2*(uint)x[4*c0+0]+1]; tv1 = T[2*(uint)x[4*c1+1]]; tv2 = T[2*(uint)x[4*c1+1]+1]; ROTATE_COLUMN_DOWN(tv1,tv2,1,t) tu ^= tv1; tl ^= tv2; tv1 = T[2*(uint)x[4*c2+2]]; tv2 = T[2*(uint)x[4*c2+2]+1]; ROTATE_COLUMN_DOWN(tv1,tv2,2,t) tu ^= tv1; tl ^= tv2; tv1 = T[2*(uint)x[4*c3+3]]; tv2 = T[2*(uint)x[4*c3+3]+1]; ROTATE_COLUMN_DOWN(tv1,tv2,3,t) tu ^= tv1; tl ^= tv2; tl ^= T[2*(uint)x[4*c4+0]]; tu ^= T[2*(uint)x[4*c4+0]+1]; tv1 = T[2*(uint)x[4*c5+1]]; tv2 = T[2*(uint)x[4*c5+1]+1]; ROTATE_COLUMN_DOWN(tv1,tv2,1,t) tl ^= tv1; tu ^= tv2; tv1 = T[2*(uint)x[4*c6+2]]; tv2 = T[2*(uint)x[4*c6+2]+1]; ROTATE_COLUMN_DOWN(tv1,tv2,2,t) tl ^= tv1; tu ^= tv2; tv1 = T[2*(uint)x[4*c7+3]]; tv2 = T[2*(uint)x[4*c7+3]+1]; ROTATE_COLUMN_DOWN(tv1,tv2,3,t) tl ^= tv1; tu ^= tv2; y[i] = tu; y[i+1] = tl;


	/* compute one round of P (short variants) */
	internal static void RND512P(ushort[] x, uint[] y, uint r)
	{
	  uint temp_v1 = new uint();
	  uint temp_v2 = new uint();
	  uint temp_upper_value = new uint();
	  uint temp_lower_value = new uint();
	  uint temp = new uint();
	  uint[] x32 = (uint)x;
	  x32[0] ^= 0x00000000 ^ r;
	  x32[2] ^= 0x00000010 ^ r;
	  x32[4] ^= 0x00000020 ^ r;
	  x32[6] ^= 0x00000030 ^ r;
	  x32[8] ^= 0x00000040 ^ r;
	  x32[10] ^= 0x00000050 ^ r;
	  x32[12] ^= 0x00000060 ^ r;
	  x32[14] ^= 0x00000070 ^ r;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *0+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 0 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *0+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 0 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *2+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 2 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *2+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 2 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *4+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 4 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *4+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 4 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *6+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 6 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *6+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 6 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 9 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 9 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *11+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 11 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *11+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 11 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *13+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 13 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *13+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 13 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *15+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 15 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *15+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 15 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[0] = temp_upper_value;
	  y[0 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *2+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 2 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *2+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 2 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *4+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 4 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *4+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 4 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *6+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 6 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *6+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 6 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *8+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 8 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *8+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 8 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 11 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 11 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *13+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 13 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *13+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 13 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *15+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 15 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *15+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 15 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *1+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 1 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *1+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 1 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[2] = temp_upper_value;
	  y[2 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *4+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 4 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *4+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 4 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *6+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 6 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *6+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 6 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *8+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 8 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *8+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 8 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *10+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 10 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *10+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 10 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 13 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 13 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *15+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 15 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *15+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 15 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *1+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 1 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *1+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 1 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *3+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 3 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *3+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 3 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[4] = temp_upper_value;
	  y[4 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *6+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 6 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *6+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 6 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *8+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 8 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *8+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 8 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *10+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 10 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *10+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 10 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *12+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 12 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *12+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 12 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 15 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 15 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *1+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 1 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *1+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 1 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *3+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 3 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *3+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 3 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *5+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 5 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *5+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 5 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[6] = temp_upper_value;
	  y[6 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *8+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 8 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *8+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 8 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *10+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 10 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *10+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 10 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *12+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 12 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *12+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 12 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *14+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 14 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *14+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 14 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 1 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 1 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *3+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 3 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *3+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 3 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *5+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 5 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *5+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 5 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *7+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 7 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *7+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 7 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[8] = temp_upper_value;
	  y[8 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *10+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 10 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *10+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 10 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *12+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 12 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *12+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 12 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *14+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 14 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *14+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 14 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *0+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 0 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *0+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 0 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 3 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 3 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *5+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 5 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *5+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 5 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *7+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 7 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *7+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 7 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *9+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 9 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *9+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 9 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[10] = temp_upper_value;
	  y[10 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *12+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 12 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *12+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 12 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *14+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 14 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *14+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 14 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *0+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 0 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *0+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 0 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *2+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 2 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *2+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 2 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 5 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 5 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *7+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 7 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *7+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 7 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *9+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 9 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *9+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 9 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *11+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 11 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *11+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 11 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[12] = temp_upper_value;
	  y[12 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *14+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 14 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *14+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 14 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *0+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 0 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *0+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 0 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *2+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 2 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *2+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 2 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *4+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 4 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *4+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 4 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 7 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 7 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *9+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 9 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *9+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 9 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *11+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 11 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *11+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 11 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *13+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 13 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *13+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 13 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[14] = temp_upper_value;
	  y[14 + 1] = temp_lower_value;
	}

	/* compute one round of Q (short variants) */
	internal static void RND512Q(ushort[] x, uint[] y, uint r)
	{
	  uint temp_v1 = new uint();
	  uint temp_v2 = new uint();
	  uint temp_upper_value = new uint();
	  uint temp_lower_value = new uint();
	  uint temp = new uint();
	  uint[] x32 = (uint)x;
	  x32[0] = ~x32[0];
	  x32[1] ^= 0xffffffff ^ r;
	  x32[2] = ~x32[2];
	  x32[3] ^= 0xefffffff ^ r;
	  x32[4] = ~x32[4];
	  x32[5] ^= 0xdfffffff ^ r;
	  x32[6] = ~x32[6];
	  x32[7] ^= 0xcfffffff ^ r;
	  x32[8] = ~x32[8];
	  x32[9] ^= 0xbfffffff ^ r;
	  x32[10] = ~x32[10];
	  x32[11] ^= 0xafffffff ^ r;
	  x32[12] = ~x32[12];
	  x32[13] ^= 0x9fffffff ^ r;
	  x32[14] = ~x32[14];
	  x32[15] ^= 0x8fffffff ^ r;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *2+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 2 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *2+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 2 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *6+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 6 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *6+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 6 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *10+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 10 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *10+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 10 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *14+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 14 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *14+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 14 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 1 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 1 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *5+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 5 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *5+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 5 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *9+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 9 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *9+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 9 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *13+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 13 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *13+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 13 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[0] = temp_upper_value;
	  y[0 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *4+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 4 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *4+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 4 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *8+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 8 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *8+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 8 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *12+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 12 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *12+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 12 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *0+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 0 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *0+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 0 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 3 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 3 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *7+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 7 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *7+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 7 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *11+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 11 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *11+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 11 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *15+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 15 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *15+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 15 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[2] = temp_upper_value;
	  y[2 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *6+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 6 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *6+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 6 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *10+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 10 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *10+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 10 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *14+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 14 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *14+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 14 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *2+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 2 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *2+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 2 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 5 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 5 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *9+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 9 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *9+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 9 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *13+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 13 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *13+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 13 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *1+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 1 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *1+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 1 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[4] = temp_upper_value;
	  y[4 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *8+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 8 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *8+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 8 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *12+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 12 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *12+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 12 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *0+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 0 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *0+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 0 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *4+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 4 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *4+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 4 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 7 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 7 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *11+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 11 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *11+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 11 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *15+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 15 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *15+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 15 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *3+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 3 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *3+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 3 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[6] = temp_upper_value;
	  y[6 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *10+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 10 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *10+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 10 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *14+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 14 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *14+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 14 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *2+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 2 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *2+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 2 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *6+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 6 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *6+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 6 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 9 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 9 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *13+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 13 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *13+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 13 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *1+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 1 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *1+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 1 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *5+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 5 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *5+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 5 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[8] = temp_upper_value;
	  y[8 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *12+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 12 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *12+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 12 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *0+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 0 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *0+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 0 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *4+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 4 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *4+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 4 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *8+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 8 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *8+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 8 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 11 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 11 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *15+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 15 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *15+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 15 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *3+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 3 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *3+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 3 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *7+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 7 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *7+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 7 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[10] = temp_upper_value;
	  y[10 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *14+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 14 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *14+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 14 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *2+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 2 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *2+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 2 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *6+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 6 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *6+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 6 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *10+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 10 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *10+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 10 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 13 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 13 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *1+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 1 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *1+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 1 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *5+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 5 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *5+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 5 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *9+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 9 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *9+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 9 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[12] = temp_upper_value;
	  y[12 + 1] = temp_lower_value;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_upper_value = T[2*(uint)x[4 *0+0]];
	  temp_upper_value.CopyFrom(T[2 * (uint)x[4 * 0 + 0]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_lower_value = T[2*(uint)x[4 *0+0]+1];
	  temp_lower_value.CopyFrom(T[2 * (uint)x[4 * 0 + 0] + 1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *4+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 4 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *4+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 4 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *8+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 8 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *8+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 8 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *12+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 12 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *12+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 12 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_upper_value ^= temp_v1;
	  temp_lower_value ^= temp_v2;
	  temp_lower_value ^= T[2 * (uint)x[4 * 15 + 0]];
	  temp_upper_value ^= T[2 * (uint)x[4 * 15 + 0] + 1];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *3+1]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 3 + 1]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *3+1]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 3 + 1] + 1]);
	  {
		  temp = (temp_v1 << (8 * 1)) | (temp_v2>>(8 * (4 - 1)));
		  temp_v2 = (temp_v2 << (8 * 1)) | (temp_v1>>(8 * (4 - 1)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *7+2]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 7 + 2]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *7+2]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 7 + 2] + 1]);
	  {
		  temp = (temp_v1 << (8 * 2)) | (temp_v2>>(8 * (4 - 2)));
		  temp_v2 = (temp_v2 << (8 * 2)) | (temp_v1>>(8 * (4 - 2)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = T[2*(uint)x[4 *11+3]];
	  temp_v1.CopyFrom(T[2 * (uint)x[4 * 11 + 3]]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v2 = T[2*(uint)x[4 *11+3]+1];
	  temp_v2.CopyFrom(T[2 * (uint)x[4 * 11 + 3] + 1]);
	  {
		  temp = (temp_v1 << (8 * 3)) | (temp_v2>>(8 * (4 - 3)));
		  temp_v2 = (temp_v2 << (8 * 3)) | (temp_v1>>(8 * (4 - 3)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: temp_v1 = temp;
		  temp_v1.CopyFrom(temp);
	  }
	  temp_lower_value ^= temp_v1;
	  temp_upper_value ^= temp_v2;
	  y[14] = temp_upper_value;
	  y[14 + 1] = temp_lower_value;
	}

	/* compute compression function (short variants) */
	internal static void F512(uint[] h, uint[] m)
	{
	  int i;
	  uint[] Ptmp = Arrays.InitializeWithDefaultInstances<uint>(2 * DefineConstants.COLS512);
	  uint[] Qtmp = Arrays.InitializeWithDefaultInstances<uint>(2 * DefineConstants.COLS512);
	  uint[] y = Arrays.InitializeWithDefaultInstances<uint>(2 * DefineConstants.COLS512);
	  uint[] z = Arrays.InitializeWithDefaultInstances<uint>(2 * DefineConstants.COLS512);

	  for (i = 0; i < 2 * DefineConstants.COLS512; i++)
	  {
		z[i] = m[i];
		Ptmp[i] = h[i] ^ m[i];
	  }

	  /* compute Q(m) */
	  RND512Q((ushort)z, y, 0x00000000);
	  RND512Q((ushort)y, z, 0x01000000);
	  RND512Q((ushort)z, y, 0x02000000);
	  RND512Q((ushort)y, z, 0x03000000);
	  RND512Q((ushort)z, y, 0x04000000);
	  RND512Q((ushort)y, z, 0x05000000);
	  RND512Q((ushort)z, y, 0x06000000);
	  RND512Q((ushort)y, z, 0x07000000);
	  RND512Q((ushort)z, y, 0x08000000);
	  RND512Q((ushort)y, Qtmp, 0x09000000);

	  /* compute P(h+m) */
	  RND512P((ushort)Ptmp, y, 0x00000000);
	  RND512P((ushort)y, z, 0x00000001);
	  RND512P((ushort)z, y, 0x00000002);
	  RND512P((ushort)y, z, 0x00000003);
	  RND512P((ushort)z, y, 0x00000004);
	  RND512P((ushort)y, z, 0x00000005);
	  RND512P((ushort)z, y, 0x00000006);
	  RND512P((ushort)y, z, 0x00000007);
	  RND512P((ushort)z, y, 0x00000008);
	  RND512P((ushort)y, Ptmp, 0x00000009);

	  /* compute P(h+m) + Q(m) + h */
	  for (i = 0; i < 2 * DefineConstants.COLS512; i++)
	  {
		h[i] ^= Ptmp[i] ^ Qtmp[i];
	  }
	}


	/* digest up to msglen bytes of input (full blocks only) */
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'input', so pointers on this parameter are left unchanged:
	internal static void Transform(hashState ctx, ushort * input, int msglen)
	{

	  /* digest message, one block at a time */
	  for (; msglen >= (DefineConstants.ROWS * DefineConstants.COLS512); msglen -= (DefineConstants.ROWS * DefineConstants.COLS512), input += (DefineConstants.ROWS * DefineConstants.COLS512))
	  {
		F512(ctx.chaining, (uint)input);

		/* increment block counter */
		ctx.block_counter1++;
		if (ctx.block_counter1 == 0)
		{
			ctx.block_counter2++;
		}
	  }
	}

	/* given state h, do h <- P(h)+h */
	internal static void OutputTransformation(hashState ctx)
	{
	  int j;
	  uint[] temp = Arrays.InitializeWithDefaultInstances<uint>(2 * DefineConstants.COLS512);
	  uint[] y = Arrays.InitializeWithDefaultInstances<uint>(2 * DefineConstants.COLS512);
	  uint[] z = Arrays.InitializeWithDefaultInstances<uint>(2 * DefineConstants.COLS512);



		for (j = 0; j < 2 * DefineConstants.COLS512; j++)
		{
		  temp[j] = ctx.chaining[j];
		}
		RND512P((ushort)temp, y, 0x00000000);
		RND512P((ushort)y, z, 0x00000001);
		RND512P((ushort)z, y, 0x00000002);
		RND512P((ushort)y, z, 0x00000003);
		RND512P((ushort)z, y, 0x00000004);
		RND512P((ushort)y, z, 0x00000005);
		RND512P((ushort)z, y, 0x00000006);
		RND512P((ushort)y, z, 0x00000007);
		RND512P((ushort)z, y, 0x00000008);
		RND512P((ushort)y, temp, 0x00000009);
		for (j = 0; j < 2 * DefineConstants.COLS512; j++)
		{
		  ctx.chaining[j] ^= temp[j];
		}
	}

	/* initialise context */
	internal static void Init(hashState ctx)
	{
	  uint i = 0;
	  /* allocate memory for state and data buffer */

	  for (;i < ((DefineConstants.ROWS * DefineConstants.COLS512) / sizeof(uint));i++)
	  {
		ctx.chaining[i] = 0;
	  }

	  /* set initial value */
	  ctx.chaining[2 * DefineConstants.COLS512 - 1] = (((((((uint)DefineConstants.HASH_BIT_LEN) << (8)) | (((uint)DefineConstants.HASH_BIT_LEN)>>(32 - (8)))) & 0xffffffffu) & 0x0x0FF00FFu) | ((((((uint)DefineConstants.HASH_BIT_LEN) << (24)) | (((uint)DefineConstants.HASH_BIT_LEN)>>(32 - (24)))) & 0xffffffffu) & 0xFF00FF00u));

	  /* set other variables */
	  ctx.buf_ptr = 0;
	  ctx.block_counter1 = 0;
	  ctx.block_counter2 = 0;
	  ctx.bits_in_last_byte = 0;
	}

	/* update state with databitlen bits of input */
	internal static void Update(hashState ctx, byte[] input, ulong databitlen)
	{
	  int index = 0;
	  int msglen = (int)(databitlen / 8);
	  int rem = (int)(databitlen % 8);

	  /* if the buffer contains data that has not yet been digested, first
	     add data to buffer until full */
	  if (ctx.buf_ptr != 0)
	  {
		while (ctx.buf_ptr < (DefineConstants.ROWS * DefineConstants.COLS512) && index < msglen)
		{
		  ctx.buffer[(int)ctx.buf_ptr++] = input[index++];
		}
		if (ctx.buf_ptr < (DefineConstants.ROWS * DefineConstants.COLS512))
		{
		  /* buffer still not full, return */
		  if (rem != 0)
		  {
		ctx.bits_in_last_byte = rem;
		ctx.buffer[(int)ctx.buf_ptr++] = input[index];
		  }
		  return;
		}

		/* digest buffer */
		ctx.buf_ptr = 0;
		Transform(ctx, ctx.buffer, (DefineConstants.ROWS * DefineConstants.COLS512));
	  }

	  /* digest bulk of message */
	  Transform(ctx, input + index, msglen - index);
	  index += ((msglen - index) / (DefineConstants.ROWS * DefineConstants.COLS512)) * (DefineConstants.ROWS * DefineConstants.COLS512);

	  /* store remaining data in buffer */
	  while (index < msglen)
	  {
		ctx.buffer[(int)ctx.buf_ptr++] = input[index++];
	  }

	  /* if non-integral number of bytes have been supplied, store
	     remaining bits in last byte, together with information about
	     number of bits */
	  if (rem != 0)
	  {
		ctx.bits_in_last_byte = rem;
		ctx.buffer[(int)ctx.buf_ptr++] = input[index];
	  }
	}

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BILB ctx->bits_in_last_byte

	/* finalise: process remaining data (including padding), perform
	   output transformation, and write hash result to 'output' */
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'ctx', so pointers on this parameter are left unchanged:
	internal static void Final(hashState * ctx, byte[] output)
	{
	  int i;
	  int j = 0;
	  int hashbytelen = DefineConstants.HASH_BIT_LEN / 8;
	  ushort s = (byte)ctx.chaining;

	  /* pad with '1'-bit and first few '0'-bits */
	  if (ctx.bits_in_last_byte != 0)
	  {
		ctx.buffer[(int)ctx.buf_ptr - 1] &= ((1 << ctx.bits_in_last_byte) - 1) << (8 - ctx.bits_in_last_byte);
		ctx.buffer[(int)ctx.buf_ptr - 1] ^= 0x1 << (7 - ctx.bits_in_last_byte);
		ctx.bits_in_last_byte = 0;
	  }
	  else
	  {
		  ctx.buffer[(int)ctx.buf_ptr++] = 0x80;
	  }

	  /* pad with '0'-bits */
	  if (ctx.buf_ptr > (DefineConstants.ROWS * DefineConstants.COLS512) - DefineConstants.ROWS)
	  {
		/* padding requires two blocks */
		while (ctx.buf_ptr < (DefineConstants.ROWS * DefineConstants.COLS512))
		{
		  ctx.buffer[(int)ctx.buf_ptr++] = 0;
		}
		/* digest first padding block */
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Transform(ctx, ctx->buffer, (DefineConstants.ROWS *DefineConstants.COLS512));
		Transform(new hashState(ctx), ctx.buffer, (DefineConstants.ROWS * DefineConstants.COLS512));
		ctx.buf_ptr = 0;
	  }
	  while (ctx.buf_ptr < (DefineConstants.ROWS * DefineConstants.COLS512) - DefineConstants.ROWS)
	  {
		ctx.buffer[(int)ctx.buf_ptr++] = 0;
	  }

	  /* length padding */
	  ctx.block_counter1++;
	  if (ctx.block_counter1 == 0)
	  {
		  ctx.block_counter2++;
	  }
	  ctx.buf_ptr = (DefineConstants.ROWS * DefineConstants.COLS512);

	  while (ctx.buf_ptr > (DefineConstants.ROWS * DefineConstants.COLS512) - (int)sizeof(uint))
	  {
		ctx.buffer[(int)--ctx.buf_ptr] = (ushort)ctx.block_counter1;
		ctx.block_counter1 >>= 8;
	  }
	  while (ctx.buf_ptr > (DefineConstants.ROWS * DefineConstants.COLS512) - DefineConstants.ROWS)
	  {
		ctx.buffer[(int)--ctx.buf_ptr] = (ushort)ctx.block_counter2;
		ctx.block_counter2 >>= 8;
	  }
	  /* digest final padding block */
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Transform(ctx, ctx->buffer, (DefineConstants.ROWS *DefineConstants.COLS512));
	  Transform(new hashState(ctx), ctx.buffer, (DefineConstants.ROWS * DefineConstants.COLS512));
	  /* perform output transformation */
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: OutputTransformation(ctx);
	  OutputTransformation(new hashState(ctx));

	  /* store hash result in output */
	  for (i = (DefineConstants.ROWS * DefineConstants.COLS512) - hashbytelen; i < (DefineConstants.ROWS * DefineConstants.COLS512); i++,j++)
	  {
		output[j] = s[i];
	  }

	  /* zeroise relevant variables and deallocate memory */
	  for (i = 0; i < DefineConstants.COLS512; i++)
	  {
		ctx.chaining[i] = 0;
	  }
	  for (i = 0; i < (DefineConstants.ROWS * DefineConstants.COLS512); i++)
	  {
		ctx.buffer[i] = 0;
	  }
	}
	/*
	static int crypto_hash(unsigned char *out,
			const unsigned char *in,
			unsigned long long len)
	{
	  groestl(in, 8*len, out);
	  return 0;
	}
	
	*/
	// Copyright (c) 2012-2017, The CryptoNote developers, The Bytecoin developers
	//
	// This file is part of Bytecoin.
	//
	// Bytecoin is free software: you can redistribute it and/or modify
	// it under the terms of the GNU Lesser General Public License as published by
	// the Free Software Foundation, either version 3 of the License, or
	// (at your option) any later version.
	//
	// Bytecoin is distributed in the hope that it will be useful,
	// but WITHOUT ANY WARRANTY; without even the implied warranty of
	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	// GNU Lesser General Public License for more details.
	//
	// You should have received a copy of the GNU Lesser General Public License
	// along with Bytecoin.  If not, see <http://www.gnu.org/licenses/>.


	// Copyright (c) 2012-2017, The CryptoNote developers, The Bytecoin developers
	//
	// This file is part of Bytecoin.
	//
	// Bytecoin is free software: you can redistribute it and/or modify
	// it under the terms of the GNU Lesser General Public License as published by
	// the Free Software Foundation, either version 3 of the License, or
	// (at your option) any later version.
	//
	// Bytecoin is distributed in the hope that it will be useful,
	// but WITHOUT ANY WARRANTY; without even the implied warranty of
	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	// GNU Lesser General Public License for more details.
	//
	// You should have received a copy of the GNU Lesser General Public License
	// along with Bytecoin.  If not, see <http://www.gnu.org/licenses/>.


	#if !__cplusplus


	// Copyright (c) 2012-2017, The CryptoNote developers, The Bytecoin developers
	//
	// This file is part of Bytecoin.
	//
	// Bytecoin is free software: you can redistribute it and/or modify
	// it under the terms of the GNU Lesser General Public License as published by
	// the Free Software Foundation, either version 3 of the License, or
	// (at your option) any later version.
	//
	// Bytecoin is distributed in the hope that it will be useful,
	// but WITHOUT ANY WARRANTY; without even the implied warranty of
	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	// GNU Lesser General Public License for more details.
	//
	// You should have received a copy of the GNU Lesser General Public License
	// along with Bytecoin.  If not, see <http://www.gnu.org/licenses/>.



	#if _MSC_VER

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define inline __inline
	#define inline

	internal static uint rol32(uint x, int r)
	{
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//  static_assert(sizeof(uint) == sizeof(uint), "this code assumes 32-bit integers");
	  return _rotl(x, r);
	}

	internal static ulong rol64(ulong x, int r)
	{
	  return _rotl64(x, r);
	}

	#else

	internal static uint rol32(uint x, int r)
	{
	  return (x << (r & 31)) | (x >> (-r & 31));
	}

	internal static ulong rol64(ulong x, int r)
	{
	  return (x << (r & 63)) | (x >> (-r & 63));
	}

	#endif

	internal static ulong hi_dword(ulong val)
	{
	  return val >> 32;
	}

	internal static ulong lo_dword(ulong val)
	{
	  return val & 0xFFFFFFFF;
	}

	internal static ulong mul128(ulong multiplier, ulong multiplicand, ulong product_hi)
	{
	  // multiplier   = ab = a * 2^32 + b
	  // multiplicand = cd = c * 2^32 + d
	  // ab * cd = a * c * 2^64 + (a * d + b * c) * 2^32 + b * d
	  ulong a = hi_dword(new ulong(multiplier));
	  ulong b = lo_dword(new ulong(multiplier));
	  ulong c = hi_dword(new ulong(multiplicand));
	  ulong d = lo_dword(new ulong(multiplicand));

	  ulong ac = a * c;
	  ulong ad = a * d;
	  ulong bc = b * c;
	  ulong bd = b * d;

	  ulong adbc = ad + bc;
	  ulong adbc_carry = adbc < ad != null ? 1 : 0;

	  // multiplier * multiplicand = product_hi * 2^64 + product_lo
	  ulong product_lo = bd + (adbc << 32);
	  ulong product_lo_carry = product_lo < bd != null ? 1 : 0;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: *product_hi = ac + (adbc >> 32) + (adbc_carry << 32) + product_lo_carry;
	  product_hi.CopyFrom(ac + (adbc >> 32) + (adbc_carry << 32) + product_lo_carry);
	  Debug.Assert(ac <= product_hi);

	  return product_lo;
	}

	internal static ulong div_with_reminder(ulong dividend, uint divisor, uint remainder)
	{
	  dividend |= ((ulong) remainder) << 32;
	  remainder = dividend % divisor;
	  return dividend / divisor;
	}

	// Long division with 2^32 base
	internal static uint div128_32(ulong dividend_hi, ulong dividend_lo, uint divisor, ulong quotient_hi, ulong quotient_lo)
	{
	  ulong[] dividend_dwords = Arrays.InitializeWithDefaultInstances<ulong>(4);
	  uint remainder = 0;

	  dividend_dwords[3] = hi_dword(new ulong(dividend_hi));
	  dividend_dwords[2] = lo_dword(new ulong(dividend_hi));
	  dividend_dwords[1] = hi_dword(new ulong(dividend_lo));
	  dividend_dwords[0] = lo_dword(new ulong(dividend_lo));

	  quotient_hi = div_with_reminder(dividend_dwords[3], new uint(divisor), remainder) << 32;
	  quotient_hi |= div_with_reminder(dividend_dwords[2], new uint(divisor), remainder);
	  quotient_lo = div_with_reminder(dividend_dwords[1], new uint(divisor), remainder) << 32;
	  quotient_lo |= div_with_reminder(dividend_dwords[0], new uint(divisor), remainder);

	  return remainder;
	}

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IDENT32(x) ((uint) (x))
	#define IDENT32
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IDENT64(x) ((ulong) (x))
	#define IDENT64

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32(x) ((((uint) (x) & 0x000000ff) << 24) | (((uint) (x) & 0x0000ff00) << 8) | (((uint) (x) & 0x00ff0000) >> 8) | (((uint) (x) & 0xff000000) >> 24))
	#define SWAP32
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64(x) ((((ulong) (x) & 0x00000000000000ff) << 56) | (((ulong) (x) & 0x000000000000ff00) << 40) | (((ulong) (x) & 0x0000000000ff0000) << 24) | (((ulong) (x) & 0x00000000ff000000) << 8) | (((ulong) (x) & 0x000000ff00000000) >> 8) | (((ulong) (x) & 0x0000ff0000000000) >> 24) | (((ulong) (x) & 0x00ff000000000000) >> 40) | (((ulong) (x) & 0xff00000000000000) >> 56))
	#define SWAP64

	internal static uint ident32(uint x)
	{
		return x;
	}
	internal static ulong ident64(ulong x)
	{
		return x;
	}

	internal static uint swap32(uint x)
	{
	  x = ((x & 0x00ff00ff) << 8) | ((x & 0xff00ff00) >> 8);
	  return (x << 16) | (x >> 16);
	}
	internal static ulong swap64(ulong x)
	{
	  x = ((x & 0x00ff00ff00ff00ff) << 8) | ((x & 0xff00ff00ff00ff00) >> 8);
	  x = ((x & 0x0000ffff0000ffff) << 16) | ((x & 0xffff0000ffff0000) >> 16);
	  return (x << 32) | (x >> 32);
	}

	#if __GNUC__
	#define UNUSED
	#else
	#define UNUSED
	#endif
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'UNUSED' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	internal static void mem_inplace_ident(object * mem UNUSED, ulong n UNUSED)
	{
	}
	#undef UNUSED

	internal static void mem_inplace_swap32(object mem, ulong n)
	{
	  ulong i = new ulong();
	  for (i = 0; i < n; i++)
	  {
		((uint) mem)[i] = swap32(((uint) mem)[i]);
	  }
	}
	internal static void mem_inplace_swap64(object mem, ulong n)
	{
	  ulong i = new ulong();
	  for (i = 0; i < n; i++)
	  {
		((ulong) mem)[i] = swap64(((ulong) mem)[i]);
	  }
	}

	internal static void memcpy_ident32(object dst, object src, ulong n)
	{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(dst, src, 4 * n);
	}
	internal static void memcpy_ident64(object dst, object src, ulong n)
	{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(dst, src, 8 * n);
	}

	internal static void memcpy_swap32(object dst, object src, ulong n)
	{
	  ulong i = new ulong();
	  for (i = 0; i < n; i++)
	  {
		((uint) dst)[i] = swap32(((uint) src)[i]);
	  }
	}
	internal static void memcpy_swap64(object dst, object src, ulong n)
	{
	  ulong i = new ulong();
	  for (i = 0; i < n; i++)
	  {
		((ulong) dst)[i] = swap64(((ulong) src)[i]);
	  }
	}

	#if !BYTE_ORDER || !LITTLE_ENDIAN || !BIG_ENDIAN
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//static_assert(false, "BYTE_ORDER is undefined. Perhaps, GNU extensions are not enabled");
	#endif

	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	#if BYTE_ORDER == LITTLE_ENDIAN
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32LE IDENT32
	#define SWAP32LE
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32BE SWAP32
	#define SWAP32BE
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32le ident32
	#define swap32le
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32be swap32
	#define swap32be
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32le mem_inplace_ident
	#define mem_inplace_swap32le
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32be mem_inplace_swap32
	#define mem_inplace_swap32be
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32le memcpy_ident32
	#define memcpy_swap32le
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32be memcpy_swap32
	#define memcpy_swap32be
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64LE IDENT64
	#define SWAP64LE
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64BE SWAP64
	#define SWAP64BE
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64le ident64
	#define swap64le
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64be swap64
	#define swap64be
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64le mem_inplace_ident
	#define mem_inplace_swap64le
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64be mem_inplace_swap64
	#define mem_inplace_swap64be
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64le memcpy_ident64
	#define memcpy_swap64le
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64be memcpy_swap64
	#define memcpy_swap64be
	#endif

	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	#if BYTE_ORDER == BIG_ENDIAN
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32BE IDENT32
	#define SWAP32BE
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32LE SWAP32
	#define SWAP32LE
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32be ident32
	#define swap32be
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32le swap32
	#define swap32le
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32be mem_inplace_ident
	#define mem_inplace_swap32be
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32le mem_inplace_swap32
	#define mem_inplace_swap32le
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32be memcpy_ident32
	#define memcpy_swap32be
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32le memcpy_swap32
	#define memcpy_swap32le
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64BE IDENT64
	#define SWAP64BE
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64LE SWAP64
	#define SWAP64LE
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64be ident64
	#define swap64be
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64le swap64
	#define swap64le
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64be mem_inplace_ident
	#define mem_inplace_swap64be
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64le mem_inplace_swap64
	#define mem_inplace_swap64le
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64be memcpy_ident64
	#define memcpy_swap64be
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64le memcpy_swap64
	#define memcpy_swap64le
	#endif


	internal static object padd(object p, size_t i)
	{
	  return (string) p + i;
	}

	internal static object cpadd(object p, size_t i)
	{
	  return (string) p + i;
	}

	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//static_assert(sizeof(size_t) == 4 || sizeof(size_t) == 8, "size_t must be 4 or 8 bytes long");
	internal static void place_length(ushort buffer, size_t bufsize, size_t length)
	{
	  if (sizeof(size_t) == 4)
	  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'swap32be' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		(uint) padd(buffer, bufsize - 4) = swap32be((uint) length);
	  }
	  else
	  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'swap64be' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		(ulong) padd(buffer, bufsize - 8) = swap64be(length);
	  }
	}
	//{
	//  ushort b[200];
	//  ulong w[25];
	//};
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent to most C++ 'pragma' directives in C#:
	//#pragma pack(pop)
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//static_assert(sizeof(union hash_state) == 200, "Invalid structure size");

	public static void hash_permutation(hash_state state)
	{
	  keccakf((ulong)state, 24);
	}
	public static void hash_process(hash_state state, ushort buf, size_t count)
	{
	  keccak1600(buf, (int)count, (ushort)state);
	}

	#endif

	public static void cn_fast_hash(object data, size_t length, ref string hash)
	{
	  hash_state state = new hash_state();
	  hash_process(state, data, new size_t(length));
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(hash, state, AnonymousEnum.HASH_SIZE);
	}
	//void cn_slow_hash(object data, size_t length, ref string hash, int light, int variant, int prehashed, uint page_size, uint scratchpad, uint iterations);Tangible Method Implementation Not Found-cn_slow_hash

	//void hash_extra_blake(object data, size_t length, ref string hash);Tangible Method Implementation Not Found-hash_extra_blake
	//void hash_extra_groestl(object data, size_t length, ref string hash);Tangible Method Implementation Not Found-hash_extra_groestl
	//void hash_extra_jh(object data, size_t length, ref string hash);Tangible Method Implementation Not Found-hash_extra_jh
	//void hash_extra_skein(object data, size_t length, ref string hash);Tangible Method Implementation Not Found-hash_extra_skein

	//void tree_hash(char(*hashes)[HASH_SIZE] UnnamedParameter, size_t count, ref string root_hash);Tangible Method Implementation Not Found-tree_hash
	//size_t tree_depth(size_t count);Tangible Method Implementation Not Found-tree_depth
	//void tree_branch(char(*hashes)[HASH_SIZE] UnnamedParameter, size_t count, string branch);Tangible Method Implementation Not Found-tree_branch
	//void tree_hash_from_branch(char(*branch)[HASH_SIZE] UnnamedParameter, size_t depth, string leaf, object path, ref string root_hash);Tangible Method Implementation Not Found-tree_hash_from_branch

	// keccak.h
	// 19-Nov-11  Markku-Juhani O. Saarinen <mjos@iki.fi>




	#if ! ROTL64
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ROTL64(x, y) (((x) << (y)) | ((x) >> (64 - (y))))
	#define ROTL64
	#endif

	// compute a keccak hash (md) of given byte length from "in"
	//int keccak(ushort in, int inlen, ushort md, int mdlen);Tangible Method Implementation Not Found-keccak

	// update the state
	//void keccakf(ulong[] st, int norounds);Tangible Method Implementation Not Found-keccakf

	//void keccak1600(ushort in, int inlen, ushort md);Tangible Method Implementation Not Found-keccak1600

	// Copyright (c) 2012-2017, The CryptoNote developers, The Bytecoin developers
	//
	// This file is part of Bytecoin.
	//
	// Bytecoin is free software: you can redistribute it and/or modify
	// it under the terms of the GNU Lesser General Public License as published by
	// the Free Software Foundation, either version 3 of the License, or
	// (at your option) any later version.
	//
	// Bytecoin is distributed in the hope that it will be useful,
	// but WITHOUT ANY WARRANTY; without even the implied warranty of
	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	// GNU Lesser General Public License for more details.
	//
	// You should have received a copy of the GNU Lesser General Public License
	// along with Bytecoin.  If not, see <http://www.gnu.org/licenses/>.



	public static void hash_extra_blake(object data, size_t length, ref string hash)
	{
	  blake256_hash((ushort)hash, data, new size_t(length));
	}

	// Copyright (c) 2012-2017, The CryptoNote developers, The Bytecoin developers
	//
	// This file is part of Bytecoin.
	//
	// Bytecoin is free software: you can redistribute it and/or modify
	// it under the terms of the GNU Lesser General Public License as published by
	// the Free Software Foundation, either version 3 of the License, or
	// (at your option) any later version.
	//
	// Bytecoin is distributed in the hope that it will be useful,
	// but WITHOUT ANY WARRANTY; without even the implied warranty of
	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	// GNU Lesser General Public License for more details.
	//
	// You should have received a copy of the GNU Lesser General Public License
	// along with Bytecoin.  If not, see <http://www.gnu.org/licenses/>.


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LENGTHFIELDLEN ROWS
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SIZE512 (ROWS*COLS512)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ROTL32(v, n) ((((v)<<(n))|((v)>>(32-(n))))&li_32(ffffffff))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define li_32(h) 0x##h##u
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define EXT_BYTE(var,n) ((ushort)((uint)(var) >> (8*n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define u32BIG(a) ((ROTL32(a,8) & li_32(00FF00FF)) | (ROTL32(a,24) & li_32(FF00FF00)))

	public static void hash_extra_groestl(object data, size_t length, ref string hash)
	{
	  groestl(data, length * 8, ref (ushort)hash);
	}


	//HashReturn jh_hash(int hashbitlen, byte data, ulong databitlen, ref byte hashval);Tangible Method Implementation Not Found-jh_hash

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define inline __inline
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IDENT32(x) ((uint) (x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IDENT64(x) ((ulong) (x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32(x) ((((uint) (x) & 0x000000ff) << 24) | (((uint) (x) & 0x0000ff00) << 8) | (((uint) (x) & 0x00ff0000) >> 8) | (((uint) (x) & 0xff000000) >> 24))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64(x) ((((ulong) (x) & 0x00000000000000ff) << 56) | (((ulong) (x) & 0x000000000000ff00) << 40) | (((ulong) (x) & 0x0000000000ff0000) << 24) | (((ulong) (x) & 0x00000000ff000000) << 8) | (((ulong) (x) & 0x000000ff00000000) >> 8) | (((ulong) (x) & 0x0000ff0000000000) >> 24) | (((ulong) (x) & 0x00ff000000000000) >> 40) | (((ulong) (x) & 0xff00000000000000) >> 56))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32LE IDENT32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32BE SWAP32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32le ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32be swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32le mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32be mem_inplace_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32le memcpy_ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32be memcpy_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64LE IDENT64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64BE SWAP64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64le ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64be swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64le mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64be mem_inplace_swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64le memcpy_ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64be memcpy_swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32BE IDENT32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32LE SWAP32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32be ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32le swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32be mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32le mem_inplace_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32be memcpy_ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32le memcpy_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64BE IDENT64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64LE SWAP64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64be ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64le swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64be mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64le mem_inplace_swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64be memcpy_ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64le memcpy_swap64

	public static void hash_extra_jh(object data, size_t length, ref string hash)
	{
	  int r = (int)jh_hash(AnonymousEnum.HASH_SIZE * 8, data, 8 * length, ref (ushort)hash);
	  if (r != 0)
	  {
	  }
	  Debug.Assert((int)HashReturn.SUCCESS == r);
	}



	#if ! Skein_Put64_LSB_First
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	public static void memcpy(ushort[] dst, ulong[] src, size_t bCnt)
	#if SKEIN_PORT_CODE
	{ // this version is fully portable (big-endian or little-endian), but slow
		size_t n = new size_t();

		for (n = 0;n < bCnt;n++)
		{
			dst[n] = (ushort)(src[n >> 3] >> (8 * (n & 7)));
		}
	}
	#else
		; // output only the function prototype
	#endif
	#endif


	#if ! Skein_Get64_LSB_First
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	void memcpy(ulong * dst,const ushort * src,8 * (size_t wCnt))
	#if SKEIN_PORT_CODE
	{ // this version is fully portable (big-endian or little-endian), but slow
		size_t n = new size_t();

		for (n = 0;n < 8 * wCnt;n += 8)
		{
			dst[n / 8] = (((ulong) src[n])) + (((ulong) src[n + 1]) << 8) + (((ulong) src[n + 2]) << 16) + (((ulong) src[n + 3]) << 24) + (((ulong) src[n + 4]) << 32) + (((ulong) src[n + 5]) << 40) + (((ulong) src[n + 6]) << 48) + (((ulong) src[n + 7]) << 56);
		}
	}
	#else
		; // output only the function prototype
	#endif
	#endif



//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//enum HashReturn
	//{
	//  SKEIN_SUCCESS = 0, // return codes from Skein calls
	//  SKEIN_FAIL = 1,
	//  SKEIN_BAD_HASHLEN = 2
	//};


	/* "all-in-one" call */
	HashReturn skein_hash = new HashReturn(int hashbitlen, const ushort * data, size_t databitlen, ushort * hashval);



	void hash_extra_skein(const object * data, size_t length, char * hash)
	{
	  int r = (int)skein_hash(8 * AnonymousEnum.HASH_SIZE, data, 8 * length, (ushort)hash);
	  if (r != 0)
	  {
	  }
	  Debug.Assert((int)HashReturn.SKEIN_SUCCESS == r);
	}


/* hash a message,
   three inputs: message digest size in bits (hashbitlen); message (data); message length in bits (databitlen)
   one output:   message digest (hashval)
*/

	public static HashReturn jh_hash(int hashbitlen, byte data, ulong databitlen, ref byte hashval)
	{
		  hashState state = new hashState();

		  if (hashbitlen == 224 || hashbitlen == 256 || hashbitlen == 384 || hashbitlen == 512)
		  {
				Init(state, hashbitlen);
				Update(state, data, databitlen);
				Final(state, ref hashval);
				return HashReturn.SUCCESS;
		  }
		  else
		  {
				return (HashReturn.BAD_HASHLEN);
		  }
	}



	/*typedef unsigned long long uint64;*/

	/*define data alignment for different C compilers*/
	#if __GNUC__
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define DATA_ALIGN16(x) x
		  #define DATA_ALIGN16
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define DATA_ALIGN16(x) __declspec(align(16)) x
		  #define DATA_ALIGN16
	#endif


	/*The initial hash value H(0)*/
	public static readonly byte[] JH224_H0 = {0x2d, 0xfe, 0xdd, 0x62, 0xf9, 0x9a, 0x98, 0xac, 0xae, 0x7c, 0xac, 0xd6, 0x19, 0xd6, 0x34, 0xe7, 0xa4, 0x83, 0x10, 0x5, 0xbc, 0x30, 0x12, 0x16, 0xb8, 0x60, 0x38, 0xc6, 0xc9, 0x66, 0x14, 0x94, 0x66, 0xd9, 0x89, 0x9f, 0x25, 0x80, 0x70, 0x6f, 0xce, 0x9e, 0xa3, 0x1b, 0x1d, 0x9b, 0x1a, 0xdc, 0x11, 0xe8, 0x32, 0x5f, 0x7b, 0x36, 0x6e, 0x10, 0xf9, 0x94, 0x85, 0x7f, 0x2, 0xfa, 0x6, 0xc1, 0x1b, 0x4f, 0x1b, 0x5c, 0xd8, 0xc8, 0x40, 0xb3, 0x97, 0xf6, 0xa1, 0x7f, 0x6e, 0x73, 0x80, 0x99, 0xdc, 0xdf, 0x93, 0xa5, 0xad, 0xea, 0xa3, 0xd3, 0xa4, 0x31, 0xe8, 0xde, 0xc9, 0x53, 0x9a, 0x68, 0x22, 0xb4, 0xa9, 0x8a, 0xec, 0x86, 0xa1, 0xe4, 0xd5, 0x74, 0xac, 0x95, 0x9c, 0xe5, 0x6c, 0xf0, 0x15, 0x96, 0xd, 0xea, 0xb5, 0xab, 0x2b, 0xbf, 0x96, 0x11, 0xdc, 0xf0, 0xdd, 0x64, 0xea, 0x6e};
	public static readonly byte[] JH256_H0 = {0xeb, 0x98, 0xa3, 0x41, 0x2c, 0x20, 0xd3, 0xeb, 0x92, 0xcd, 0xbe, 0x7b, 0x9c, 0xb2, 0x45, 0xc1, 0x1c, 0x93, 0x51, 0x91, 0x60, 0xd4, 0xc7, 0xfa, 0x26, 0x0, 0x82, 0xd6, 0x7e, 0x50, 0x8a, 0x3, 0xa4, 0x23, 0x9e, 0x26, 0x77, 0x26, 0xb9, 0x45, 0xe0, 0xfb, 0x1a, 0x48, 0xd4, 0x1a, 0x94, 0x77, 0xcd, 0xb5, 0xab, 0x26, 0x2, 0x6b, 0x17, 0x7a, 0x56, 0xf0, 0x24, 0x42, 0xf, 0xff, 0x2f, 0xa8, 0x71, 0xa3, 0x96, 0x89, 0x7f, 0x2e, 0x4d, 0x75, 0x1d, 0x14, 0x49, 0x8, 0xf7, 0x7d, 0xe2, 0x62, 0x27, 0x76, 0x95, 0xf7, 0x76, 0x24, 0x8f, 0x94, 0x87, 0xd5, 0xb6, 0x57, 0x47, 0x80, 0x29, 0x6c, 0x5c, 0x5e, 0x27, 0x2d, 0xac, 0x8e, 0xd, 0x6c, 0x51, 0x84, 0x50, 0xc6, 0x57, 0x5, 0x7a, 0xf, 0x7b, 0xe4, 0xd3, 0x67, 0x70, 0x24, 0x12, 0xea, 0x89, 0xe3, 0xab, 0x13, 0xd3, 0x1c, 0xd7, 0x69};
	public static readonly byte[] JH384_H0 = {0x48, 0x1e, 0x3b, 0xc6, 0xd8, 0x13, 0x39, 0x8a, 0x6d, 0x3b, 0x5e, 0x89, 0x4a, 0xde, 0x87, 0x9b, 0x63, 0xfa, 0xea, 0x68, 0xd4, 0x80, 0xad, 0x2e, 0x33, 0x2c, 0xcb, 0x21, 0x48, 0xf, 0x82, 0x67, 0x98, 0xae, 0xc8, 0x4d, 0x90, 0x82, 0xb9, 0x28, 0xd4, 0x55, 0xea, 0x30, 0x41, 0x11, 0x42, 0x49, 0x36, 0xf5, 0x55, 0xb2, 0x92, 0x48, 0x47, 0xec, 0xc7, 0x25, 0xa, 0x93, 0xba, 0xf4, 0x3c, 0xe1, 0x56, 0x9b, 0x7f, 0x8a, 0x27, 0xdb, 0x45, 0x4c, 0x9e, 0xfc, 0xbd, 0x49, 0x63, 0x97, 0xaf, 0xe, 0x58, 0x9f, 0xc2, 0x7d, 0x26, 0xaa, 0x80, 0xcd, 0x80, 0xc0, 0x8b, 0x8c, 0x9d, 0xeb, 0x2e, 0xda, 0x8a, 0x79, 0x81, 0xe8, 0xf8, 0xd5, 0x37, 0x3a, 0xf4, 0x39, 0x67, 0xad, 0xdd, 0xd1, 0x7a, 0x71, 0xa9, 0xb4, 0xd3, 0xbd, 0xa4, 0x75, 0xd3, 0x94, 0x97, 0x6c, 0x3f, 0xba, 0x98, 0x42, 0x73, 0x7f};
	public static readonly byte[] JH512_H0 = {0x6f, 0xd1, 0x4b, 0x96, 0x3e, 0x0, 0xaa, 0x17, 0x63, 0x6a, 0x2e, 0x5, 0x7a, 0x15, 0xd5, 0x43, 0x8a, 0x22, 0x5e, 0x8d, 0xc, 0x97, 0xef, 0xb, 0xe9, 0x34, 0x12, 0x59, 0xf2, 0xb3, 0xc3, 0x61, 0x89, 0x1d, 0xa0, 0xc1, 0x53, 0x6f, 0x80, 0x1e, 0x2a, 0xa9, 0x5, 0x6b, 0xea, 0x2b, 0x6d, 0x80, 0x58, 0x8e, 0xcc, 0xdb, 0x20, 0x75, 0xba, 0xa6, 0xa9, 0xf, 0x3a, 0x76, 0xba, 0xf8, 0x3b, 0xf7, 0x1, 0x69, 0xe6, 0x5, 0x41, 0xe3, 0x4a, 0x69, 0x46, 0xb5, 0x8a, 0x8e, 0x2e, 0x6f, 0xe6, 0x5a, 0x10, 0x47, 0xa7, 0xd0, 0xc1, 0x84, 0x3c, 0x24, 0x3b, 0x6e, 0x71, 0xb1, 0x2d, 0x5a, 0xc1, 0x99, 0xcf, 0x57, 0xf6, 0xec, 0x9d, 0xb1, 0xf8, 0x56, 0xa7, 0x6, 0x88, 0x7c, 0x57, 0x16, 0xb1, 0x56, 0xe3, 0xc2, 0xfc, 0xdf, 0xe6, 0x85, 0x17, 0xfb, 0x54, 0x5a, 0x46, 0x78, 0xcc, 0x8c, 0xdd, 0x4b};

	/*42 round constants, each round constant is 32-byte (256-bit)*/
	public static readonly byte[,] E8_bitslice_roundconstant =
	{
		{0x72, 0xd5, 0xde, 0xa2, 0xdf, 0x15, 0xf8, 0x67, 0x7b, 0x84, 0x15, 0xa, 0xb7, 0x23, 0x15, 0x57, 0x81, 0xab, 0xd6, 0x90, 0x4d, 0x5a, 0x87, 0xf6, 0x4e, 0x9f, 0x4f, 0xc5, 0xc3, 0xd1, 0x2b, 0x40},
		{0xea, 0x98, 0x3a, 0xe0, 0x5c, 0x45, 0xfa, 0x9c, 0x3, 0xc5, 0xd2, 0x99, 0x66, 0xb2, 0x99, 0x9a, 0x66, 0x2, 0x96, 0xb4, 0xf2, 0xbb, 0x53, 0x8a, 0xb5, 0x56, 0x14, 0x1a, 0x88, 0xdb, 0xa2, 0x31},
		{0x3, 0xa3, 0x5a, 0x5c, 0x9a, 0x19, 0xe, 0xdb, 0x40, 0x3f, 0xb2, 0xa, 0x87, 0xc1, 0x44, 0x10, 0x1c, 0x5, 0x19, 0x80, 0x84, 0x9e, 0x95, 0x1d, 0x6f, 0x33, 0xeb, 0xad, 0x5e, 0xe7, 0xcd, 0xdc},
		{0x10, 0xba, 0x13, 0x92, 0x2, 0xbf, 0x6b, 0x41, 0xdc, 0x78, 0x65, 0x15, 0xf7, 0xbb, 0x27, 0xd0, 0xa, 0x2c, 0x81, 0x39, 0x37, 0xaa, 0x78, 0x50, 0x3f, 0x1a, 0xbf, 0xd2, 0x41, 0x0, 0x91, 0xd3},
		{0x42, 0x2d, 0x5a, 0xd, 0xf6, 0xcc, 0x7e, 0x90, 0xdd, 0x62, 0x9f, 0x9c, 0x92, 0xc0, 0x97, 0xce, 0x18, 0x5c, 0xa7, 0xb, 0xc7, 0x2b, 0x44, 0xac, 0xd1, 0xdf, 0x65, 0xd6, 0x63, 0xc6, 0xfc, 0x23},
		{0x97, 0x6e, 0x6c, 0x3, 0x9e, 0xe0, 0xb8, 0x1a, 0x21, 0x5, 0x45, 0x7e, 0x44, 0x6c, 0xec, 0xa8, 0xee, 0xf1, 0x3, 0xbb, 0x5d, 0x8e, 0x61, 0xfa, 0xfd, 0x96, 0x97, 0xb2, 0x94, 0x83, 0x81, 0x97},
		{0x4a, 0x8e, 0x85, 0x37, 0xdb, 0x3, 0x30, 0x2f, 0x2a, 0x67, 0x8d, 0x2d, 0xfb, 0x9f, 0x6a, 0x95, 0x8a, 0xfe, 0x73, 0x81, 0xf8, 0xb8, 0x69, 0x6c, 0x8a, 0xc7, 0x72, 0x46, 0xc0, 0x7f, 0x42, 0x14},
		{0xc5, 0xf4, 0x15, 0x8f, 0xbd, 0xc7, 0x5e, 0xc4, 0x75, 0x44, 0x6f, 0xa7, 0x8f, 0x11, 0xbb, 0x80, 0x52, 0xde, 0x75, 0xb7, 0xae, 0xe4, 0x88, 0xbc, 0x82, 0xb8, 0x0, 0x1e, 0x98, 0xa6, 0xa3, 0xf4},
		{0x8e, 0xf4, 0x8f, 0x33, 0xa9, 0xa3, 0x63, 0x15, 0xaa, 0x5f, 0x56, 0x24, 0xd5, 0xb7, 0xf9, 0x89, 0xb6, 0xf1, 0xed, 0x20, 0x7c, 0x5a, 0xe0, 0xfd, 0x36, 0xca, 0xe9, 0x5a, 0x6, 0x42, 0x2c, 0x36},
		{0xce, 0x29, 0x35, 0x43, 0x4e, 0xfe, 0x98, 0x3d, 0x53, 0x3a, 0xf9, 0x74, 0x73, 0x9a, 0x4b, 0xa7, 0xd0, 0xf5, 0x1f, 0x59, 0x6f, 0x4e, 0x81, 0x86, 0xe, 0x9d, 0xad, 0x81, 0xaf, 0xd8, 0x5a, 0x9f},
		{0xa7, 0x5, 0x6, 0x67, 0xee, 0x34, 0x62, 0x6a, 0x8b, 0xb, 0x28, 0xbe, 0x6e, 0xb9, 0x17, 0x27, 0x47, 0x74, 0x7, 0x26, 0xc6, 0x80, 0x10, 0x3f, 0xe0, 0xa0, 0x7e, 0x6f, 0xc6, 0x7e, 0x48, 0x7b},
		{0xd, 0x55, 0xa, 0xa5, 0x4a, 0xf8, 0xa4, 0xc0, 0x91, 0xe3, 0xe7, 0x9f, 0x97, 0x8e, 0xf1, 0x9e, 0x86, 0x76, 0x72, 0x81, 0x50, 0x60, 0x8d, 0xd4, 0x7e, 0x9e, 0x5a, 0x41, 0xf3, 0xe5, 0xb0, 0x62},
		{0xfc, 0x9f, 0x1f, 0xec, 0x40, 0x54, 0x20, 0x7a, 0xe3, 0xe4, 0x1a, 0x0, 0xce, 0xf4, 0xc9, 0x84, 0x4f, 0xd7, 0x94, 0xf5, 0x9d, 0xfa, 0x95, 0xd8, 0x55, 0x2e, 0x7e, 0x11, 0x24, 0xc3, 0x54, 0xa5},
		{0x5b, 0xdf, 0x72, 0x28, 0xbd, 0xfe, 0x6e, 0x28, 0x78, 0xf5, 0x7f, 0xe2, 0xf, 0xa5, 0xc4, 0xb2, 0x5, 0x89, 0x7c, 0xef, 0xee, 0x49, 0xd3, 0x2e, 0x44, 0x7e, 0x93, 0x85, 0xeb, 0x28, 0x59, 0x7f},
		{0x70, 0x5f, 0x69, 0x37, 0xb3, 0x24, 0x31, 0x4a, 0x5e, 0x86, 0x28, 0xf1, 0x1d, 0xd6, 0xe4, 0x65, 0xc7, 0x1b, 0x77, 0x4, 0x51, 0xb9, 0x20, 0xe7, 0x74, 0xfe, 0x43, 0xe8, 0x23, 0xd4, 0x87, 0x8a},
		{0x7d, 0x29, 0xe8, 0xa3, 0x92, 0x76, 0x94, 0xf2, 0xdd, 0xcb, 0x7a, 0x9, 0x9b, 0x30, 0xd9, 0xc1, 0x1d, 0x1b, 0x30, 0xfb, 0x5b, 0xdc, 0x1b, 0xe0, 0xda, 0x24, 0x49, 0x4f, 0xf2, 0x9c, 0x82, 0xbf},
		{0xa4, 0xe7, 0xba, 0x31, 0xb4, 0x70, 0xbf, 0xff, 0xd, 0x32, 0x44, 0x5, 0xde, 0xf8, 0xbc, 0x48, 0x3b, 0xae, 0xfc, 0x32, 0x53, 0xbb, 0xd3, 0x39, 0x45, 0x9f, 0xc3, 0xc1, 0xe0, 0x29, 0x8b, 0xa0},
		{0xe5, 0xc9, 0x5, 0xfd, 0xf7, 0xae, 0x9, 0xf, 0x94, 0x70, 0x34, 0x12, 0x42, 0x90, 0xf1, 0x34, 0xa2, 0x71, 0xb7, 0x1, 0xe3, 0x44, 0xed, 0x95, 0xe9, 0x3b, 0x8e, 0x36, 0x4f, 0x2f, 0x98, 0x4a},
		{0x88, 0x40, 0x1d, 0x63, 0xa0, 0x6c, 0xf6, 0x15, 0x47, 0xc1, 0x44, 0x4b, 0x87, 0x52, 0xaf, 0xff, 0x7e, 0xbb, 0x4a, 0xf1, 0xe2, 0xa, 0xc6, 0x30, 0x46, 0x70, 0xb6, 0xc5, 0xcc, 0x6e, 0x8c, 0xe6},
		{0xa4, 0xd5, 0xa4, 0x56, 0xbd, 0x4f, 0xca, 0x0, 0xda, 0x9d, 0x84, 0x4b, 0xc8, 0x3e, 0x18, 0xae, 0x73, 0x57, 0xce, 0x45, 0x30, 0x64, 0xd1, 0xad, 0xe8, 0xa6, 0xce, 0x68, 0x14, 0x5c, 0x25, 0x67},
		{0xa3, 0xda, 0x8c, 0xf2, 0xcb, 0xe, 0xe1, 0x16, 0x33, 0xe9, 0x6, 0x58, 0x9a, 0x94, 0x99, 0x9a, 0x1f, 0x60, 0xb2, 0x20, 0xc2, 0x6f, 0x84, 0x7b, 0xd1, 0xce, 0xac, 0x7f, 0xa0, 0xd1, 0x85, 0x18},
		{0x32, 0x59, 0x5b, 0xa1, 0x8d, 0xdd, 0x19, 0xd3, 0x50, 0x9a, 0x1c, 0xc0, 0xaa, 0xa5, 0xb4, 0x46, 0x9f, 0x3d, 0x63, 0x67, 0xe4, 0x4, 0x6b, 0xba, 0xf6, 0xca, 0x19, 0xab, 0xb, 0x56, 0xee, 0x7e},
		{0x1f, 0xb1, 0x79, 0xea, 0xa9, 0x28, 0x21, 0x74, 0xe9, 0xbd, 0xf7, 0x35, 0x3b, 0x36, 0x51, 0xee, 0x1d, 0x57, 0xac, 0x5a, 0x75, 0x50, 0xd3, 0x76, 0x3a, 0x46, 0xc2, 0xfe, 0xa3, 0x7d, 0x70, 0x1},
		{0xf7, 0x35, 0xc1, 0xaf, 0x98, 0xa4, 0xd8, 0x42, 0x78, 0xed, 0xec, 0x20, 0x9e, 0x6b, 0x67, 0x79, 0x41, 0x83, 0x63, 0x15, 0xea, 0x3a, 0xdb, 0xa8, 0xfa, 0xc3, 0x3b, 0x4d, 0x32, 0x83, 0x2c, 0x83},
		{0xa7, 0x40, 0x3b, 0x1f, 0x1c, 0x27, 0x47, 0xf3, 0x59, 0x40, 0xf0, 0x34, 0xb7, 0x2d, 0x76, 0x9a, 0xe7, 0x3e, 0x4e, 0x6c, 0xd2, 0x21, 0x4f, 0xfd, 0xb8, 0xfd, 0x8d, 0x39, 0xdc, 0x57, 0x59, 0xef},
		{0x8d, 0x9b, 0xc, 0x49, 0x2b, 0x49, 0xeb, 0xda, 0x5b, 0xa2, 0xd7, 0x49, 0x68, 0xf3, 0x70, 0xd, 0x7d, 0x3b, 0xae, 0xd0, 0x7a, 0x8d, 0x55, 0x84, 0xf5, 0xa5, 0xe9, 0xf0, 0xe4, 0xf8, 0x8e, 0x65},
		{0xa0, 0xb8, 0xa2, 0xf4, 0x36, 0x10, 0x3b, 0x53, 0xc, 0xa8, 0x7, 0x9e, 0x75, 0x3e, 0xec, 0x5a, 0x91, 0x68, 0x94, 0x92, 0x56, 0xe8, 0x88, 0x4f, 0x5b, 0xb0, 0x5c, 0x55, 0xf8, 0xba, 0xbc, 0x4c},
		{0xe3, 0xbb, 0x3b, 0x99, 0xf3, 0x87, 0x94, 0x7b, 0x75, 0xda, 0xf4, 0xd6, 0x72, 0x6b, 0x1c, 0x5d, 0x64, 0xae, 0xac, 0x28, 0xdc, 0x34, 0xb3, 0x6d, 0x6c, 0x34, 0xa5, 0x50, 0xb8, 0x28, 0xdb, 0x71},
		{0xf8, 0x61, 0xe2, 0xf2, 0x10, 0x8d, 0x51, 0x2a, 0xe3, 0xdb, 0x64, 0x33, 0x59, 0xdd, 0x75, 0xfc, 0x1c, 0xac, 0xbc, 0xf1, 0x43, 0xce, 0x3f, 0xa2, 0x67, 0xbb, 0xd1, 0x3c, 0x2, 0xe8, 0x43, 0xb0},
		{0x33, 0xa, 0x5b, 0xca, 0x88, 0x29, 0xa1, 0x75, 0x7f, 0x34, 0x19, 0x4d, 0xb4, 0x16, 0x53, 0x5c, 0x92, 0x3b, 0x94, 0xc3, 0xe, 0x79, 0x4d, 0x1e, 0x79, 0x74, 0x75, 0xd7, 0xb6, 0xee, 0xaf, 0x3f},
		{0xea, 0xa8, 0xd4, 0xf7, 0xbe, 0x1a, 0x39, 0x21, 0x5c, 0xf4, 0x7e, 0x9, 0x4c, 0x23, 0x27, 0x51, 0x26, 0xa3, 0x24, 0x53, 0xba, 0x32, 0x3c, 0xd2, 0x44, 0xa3, 0x17, 0x4a, 0x6d, 0xa6, 0xd5, 0xad},
		{0xb5, 0x1d, 0x3e, 0xa6, 0xaf, 0xf2, 0xc9, 0x8, 0x83, 0x59, 0x3d, 0x98, 0x91, 0x6b, 0x3c, 0x56, 0x4c, 0xf8, 0x7c, 0xa1, 0x72, 0x86, 0x60, 0x4d, 0x46, 0xe2, 0x3e, 0xcc, 0x8, 0x6e, 0xc7, 0xf6},
		{0x2f, 0x98, 0x33, 0xb3, 0xb1, 0xbc, 0x76, 0x5e, 0x2b, 0xd6, 0x66, 0xa5, 0xef, 0xc4, 0xe6, 0x2a, 0x6, 0xf4, 0xb6, 0xe8, 0xbe, 0xc1, 0xd4, 0x36, 0x74, 0xee, 0x82, 0x15, 0xbc, 0xef, 0x21, 0x63},
		{0xfd, 0xc1, 0x4e, 0xd, 0xf4, 0x53, 0xc9, 0x69, 0xa7, 0x7d, 0x5a, 0xc4, 0x6, 0x58, 0x58, 0x26, 0x7e, 0xc1, 0x14, 0x16, 0x6, 0xe0, 0xfa, 0x16, 0x7e, 0x90, 0xaf, 0x3d, 0x28, 0x63, 0x9d, 0x3f},
		{0xd2, 0xc9, 0xf2, 0xe3, 0x0, 0x9b, 0xd2, 0xc, 0x5f, 0xaa, 0xce, 0x30, 0xb7, 0xd4, 0xc, 0x30, 0x74, 0x2a, 0x51, 0x16, 0xf2, 0xe0, 0x32, 0x98, 0xd, 0xeb, 0x30, 0xd8, 0xe3, 0xce, 0xf8, 0x9a},
		{0x4b, 0xc5, 0x9e, 0x7b, 0xb5, 0xf1, 0x79, 0x92, 0xff, 0x51, 0xe6, 0x6e, 0x4, 0x86, 0x68, 0xd3, 0x9b, 0x23, 0x4d, 0x57, 0xe6, 0x96, 0x67, 0x31, 0xcc, 0xe6, 0xa6, 0xf3, 0x17, 0xa, 0x75, 0x5},
		{0xb1, 0x76, 0x81, 0xd9, 0x13, 0x32, 0x6c, 0xce, 0x3c, 0x17, 0x52, 0x84, 0xf8, 0x5, 0xa2, 0x62, 0xf4, 0x2b, 0xcb, 0xb3, 0x78, 0x47, 0x15, 0x47, 0xff, 0x46, 0x54, 0x82, 0x23, 0x93, 0x6a, 0x48},
		{0x38, 0xdf, 0x58, 0x7, 0x4e, 0x5e, 0x65, 0x65, 0xf2, 0xfc, 0x7c, 0x89, 0xfc, 0x86, 0x50, 0x8e, 0x31, 0x70, 0x2e, 0x44, 0xd0, 0xb, 0xca, 0x86, 0xf0, 0x40, 0x9, 0xa2, 0x30, 0x78, 0x47, 0x4e},
		{0x65, 0xa0, 0xee, 0x39, 0xd1, 0xf7, 0x38, 0x83, 0xf7, 0x5e, 0xe9, 0x37, 0xe4, 0x2c, 0x3a, 0xbd, 0x21, 0x97, 0xb2, 0x26, 0x1, 0x13, 0xf8, 0x6f, 0xa3, 0x44, 0xed, 0xd1, 0xef, 0x9f, 0xde, 0xe7},
		{0x8b, 0xa0, 0xdf, 0x15, 0x76, 0x25, 0x92, 0xd9, 0x3c, 0x85, 0xf7, 0xf6, 0x12, 0xdc, 0x42, 0xbe, 0xd8, 0xa7, 0xec, 0x7c, 0xab, 0x27, 0xb0, 0x7e, 0x53, 0x8d, 0x7d, 0xda, 0xaa, 0x3e, 0xa8, 0xde},
		{0xaa, 0x25, 0xce, 0x93, 0xbd, 0x2, 0x69, 0xd8, 0x5a, 0xf6, 0x43, 0xfd, 0x1a, 0x73, 0x8, 0xf9, 0xc0, 0x5f, 0xef, 0xda, 0x17, 0x4a, 0x19, 0xa5, 0x97, 0x4d, 0x66, 0x33, 0x4c, 0xfd, 0x21, 0x6a},
		{0x35, 0xb4, 0x98, 0x31, 0xdb, 0x41, 0x15, 0x70, 0xea, 0x1e, 0xf, 0xbb, 0xed, 0xcd, 0x54, 0x9b, 0x9a, 0xd0, 0x63, 0xa1, 0x51, 0x97, 0x40, 0x72, 0xf6, 0x75, 0x9d, 0xbf, 0x91, 0x47, 0x6f, 0xe2}
	};

/*The bijective function E8, in bitslice form*/


	internal static void E8(hashState state)
	{
		  ulong i = new ulong();
		  ulong roundnumber = new ulong();
		  ulong temp0 = new ulong();
		  ulong temp1 = new ulong();

		  for (roundnumber = 0; roundnumber < 42; roundnumber = roundnumber + 7)
		  {
				/*round 7*roundnumber+0: Sbox, MDS and Swapping layers*/
				for (i = 0; i < 2; i++)
				{
					  state.x[6][i] = ~(state.x[6][i]);
					  state.x[7][i] = ~(state.x[7][i]);
					  state.x[0][i] ^= ((~(state.x[4][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 0])[i]));
					  state.x[1][i] ^= ((~(state.x[5][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 0])[i + 2]));
					  temp0 = (((ulong)E8_bitslice_roundconstant[roundnumber + 0])[i]) ^ ((state.x[0][i]) & (state.x[2][i]));
					  temp1 = (((ulong)E8_bitslice_roundconstant[roundnumber + 0])[i + 2]) ^ ((state.x[1][i]) & (state.x[3][i]));
					  state.x[0][i] ^= ((state.x[4][i]) & (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[5][i]) & (state.x[7][i]));
					  state.x[6][i] ^= ((~(state.x[2][i])) & (state.x[4][i]));
					  state.x[7][i] ^= ((~(state.x[3][i])) & (state.x[5][i]));
					  state.x[2][i] ^= ((state.x[0][i]) & (state.x[4][i]));
					  state.x[3][i] ^= ((state.x[1][i]) & (state.x[5][i]));
					  state.x[4][i] ^= ((state.x[0][i]) & (~(state.x[6][i])));
					  state.x[5][i] ^= ((state.x[1][i]) & (~(state.x[7][i])));
					  state.x[0][i] ^= ((state.x[2][i]) | (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[3][i]) | (state.x[7][i]));
					  state.x[6][i] ^= ((state.x[2][i]) & (state.x[4][i]));
					  state.x[7][i] ^= ((state.x[3][i]) & (state.x[5][i]));
					  state.x[2][i] ^= (temp0 & (state.x[0][i]));
					  state.x[3][i] ^= (temp1 & (state.x[1][i]));
					  state.x[4][i] ^= temp0;
					  state.x[5][i] ^= temp1;
					  (state.x[1][i]) ^= (state.x[2][i]);
					  (state.x[3][i]) ^= (state.x[4][i]);
					  (state.x[5][i]) ^= (state.x[0][i]) ^ (state.x[6][i]);
					  (state.x[7][i]) ^= (state.x[0][i]);
					  (state.x[0][i]) ^= (state.x[3][i]);
					  (state.x[2][i]) ^= (state.x[5][i]);
					  (state.x[4][i]) ^= (state.x[1][i]) ^ (state.x[7][i]);
					  (state.x[6][i]) ^= (state.x[1][i]);
					  (state.x[1][i]) = ((((state.x[1][i]) & 0x5555555555555555UL) << 1) | (((state.x[1][i]) & 0xaaaaaaaaaaaaaaaaUL) >> 1));
					  ;
					  (state.x[3][i]) = ((((state.x[3][i]) & 0x5555555555555555UL) << 1) | (((state.x[3][i]) & 0xaaaaaaaaaaaaaaaaUL) >> 1));
					  ;
					  (state.x[5][i]) = ((((state.x[5][i]) & 0x5555555555555555UL) << 1) | (((state.x[5][i]) & 0xaaaaaaaaaaaaaaaaUL) >> 1));
					  ;
					  (state.x[7][i]) = ((((state.x[7][i]) & 0x5555555555555555UL) << 1) | (((state.x[7][i]) & 0xaaaaaaaaaaaaaaaaUL) >> 1));
				}

				/*round 7*roundnumber+1: Sbox, MDS and Swapping layers*/
				for (i = 0; i < 2; i++)
				{
					  state.x[6][i] = ~(state.x[6][i]);
					  state.x[7][i] = ~(state.x[7][i]);
					  state.x[0][i] ^= ((~(state.x[4][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 1])[i]));
					  state.x[1][i] ^= ((~(state.x[5][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 1])[i + 2]));
					  temp0 = (((ulong)E8_bitslice_roundconstant[roundnumber + 1])[i]) ^ ((state.x[0][i]) & (state.x[2][i]));
					  temp1 = (((ulong)E8_bitslice_roundconstant[roundnumber + 1])[i + 2]) ^ ((state.x[1][i]) & (state.x[3][i]));
					  state.x[0][i] ^= ((state.x[4][i]) & (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[5][i]) & (state.x[7][i]));
					  state.x[6][i] ^= ((~(state.x[2][i])) & (state.x[4][i]));
					  state.x[7][i] ^= ((~(state.x[3][i])) & (state.x[5][i]));
					  state.x[2][i] ^= ((state.x[0][i]) & (state.x[4][i]));
					  state.x[3][i] ^= ((state.x[1][i]) & (state.x[5][i]));
					  state.x[4][i] ^= ((state.x[0][i]) & (~(state.x[6][i])));
					  state.x[5][i] ^= ((state.x[1][i]) & (~(state.x[7][i])));
					  state.x[0][i] ^= ((state.x[2][i]) | (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[3][i]) | (state.x[7][i]));
					  state.x[6][i] ^= ((state.x[2][i]) & (state.x[4][i]));
					  state.x[7][i] ^= ((state.x[3][i]) & (state.x[5][i]));
					  state.x[2][i] ^= (temp0 & (state.x[0][i]));
					  state.x[3][i] ^= (temp1 & (state.x[1][i]));
					  state.x[4][i] ^= temp0;
					  state.x[5][i] ^= temp1;
					  (state.x[1][i]) ^= (state.x[2][i]);
					  (state.x[3][i]) ^= (state.x[4][i]);
					  (state.x[5][i]) ^= (state.x[0][i]) ^ (state.x[6][i]);
					  (state.x[7][i]) ^= (state.x[0][i]);
					  (state.x[0][i]) ^= (state.x[3][i]);
					  (state.x[2][i]) ^= (state.x[5][i]);
					  (state.x[4][i]) ^= (state.x[1][i]) ^ (state.x[7][i]);
					  (state.x[6][i]) ^= (state.x[1][i]);
					  (state.x[1][i]) = ((((state.x[1][i]) & 0x3333333333333333UL) << 2) | (((state.x[1][i]) & 0xccccccccccccccccUL) >> 2));
					  ;
					  (state.x[3][i]) = ((((state.x[3][i]) & 0x3333333333333333UL) << 2) | (((state.x[3][i]) & 0xccccccccccccccccUL) >> 2));
					  ;
					  (state.x[5][i]) = ((((state.x[5][i]) & 0x3333333333333333UL) << 2) | (((state.x[5][i]) & 0xccccccccccccccccUL) >> 2));
					  ;
					  (state.x[7][i]) = ((((state.x[7][i]) & 0x3333333333333333UL) << 2) | (((state.x[7][i]) & 0xccccccccccccccccUL) >> 2));
				}

				/*round 7*roundnumber+2: Sbox, MDS and Swapping layers*/
				for (i = 0; i < 2; i++)
				{
					  state.x[6][i] = ~(state.x[6][i]);
					  state.x[7][i] = ~(state.x[7][i]);
					  state.x[0][i] ^= ((~(state.x[4][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 2])[i]));
					  state.x[1][i] ^= ((~(state.x[5][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 2])[i + 2]));
					  temp0 = (((ulong)E8_bitslice_roundconstant[roundnumber + 2])[i]) ^ ((state.x[0][i]) & (state.x[2][i]));
					  temp1 = (((ulong)E8_bitslice_roundconstant[roundnumber + 2])[i + 2]) ^ ((state.x[1][i]) & (state.x[3][i]));
					  state.x[0][i] ^= ((state.x[4][i]) & (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[5][i]) & (state.x[7][i]));
					  state.x[6][i] ^= ((~(state.x[2][i])) & (state.x[4][i]));
					  state.x[7][i] ^= ((~(state.x[3][i])) & (state.x[5][i]));
					  state.x[2][i] ^= ((state.x[0][i]) & (state.x[4][i]));
					  state.x[3][i] ^= ((state.x[1][i]) & (state.x[5][i]));
					  state.x[4][i] ^= ((state.x[0][i]) & (~(state.x[6][i])));
					  state.x[5][i] ^= ((state.x[1][i]) & (~(state.x[7][i])));
					  state.x[0][i] ^= ((state.x[2][i]) | (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[3][i]) | (state.x[7][i]));
					  state.x[6][i] ^= ((state.x[2][i]) & (state.x[4][i]));
					  state.x[7][i] ^= ((state.x[3][i]) & (state.x[5][i]));
					  state.x[2][i] ^= (temp0 & (state.x[0][i]));
					  state.x[3][i] ^= (temp1 & (state.x[1][i]));
					  state.x[4][i] ^= temp0;
					  state.x[5][i] ^= temp1;
					  (state.x[1][i]) ^= (state.x[2][i]);
					  (state.x[3][i]) ^= (state.x[4][i]);
					  (state.x[5][i]) ^= (state.x[0][i]) ^ (state.x[6][i]);
					  (state.x[7][i]) ^= (state.x[0][i]);
					  (state.x[0][i]) ^= (state.x[3][i]);
					  (state.x[2][i]) ^= (state.x[5][i]);
					  (state.x[4][i]) ^= (state.x[1][i]) ^ (state.x[7][i]);
					  (state.x[6][i]) ^= (state.x[1][i]);
					  (state.x[1][i]) = ((((state.x[1][i]) & 0x0f0f0f0f0f0f0f0fUL) << 4) | (((state.x[1][i]) & 0xf0f0f0f0f0f0f0f0UL) >> 4));
					  ;
					  (state.x[3][i]) = ((((state.x[3][i]) & 0x0f0f0f0f0f0f0f0fUL) << 4) | (((state.x[3][i]) & 0xf0f0f0f0f0f0f0f0UL) >> 4));
					  ;
					  (state.x[5][i]) = ((((state.x[5][i]) & 0x0f0f0f0f0f0f0f0fUL) << 4) | (((state.x[5][i]) & 0xf0f0f0f0f0f0f0f0UL) >> 4));
					  ;
					  (state.x[7][i]) = ((((state.x[7][i]) & 0x0f0f0f0f0f0f0f0fUL) << 4) | (((state.x[7][i]) & 0xf0f0f0f0f0f0f0f0UL) >> 4));
				}

				/*round 7*roundnumber+3: Sbox, MDS and Swapping layers*/
				for (i = 0; i < 2; i++)
				{
					  state.x[6][i] = ~(state.x[6][i]);
					  state.x[7][i] = ~(state.x[7][i]);
					  state.x[0][i] ^= ((~(state.x[4][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 3])[i]));
					  state.x[1][i] ^= ((~(state.x[5][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 3])[i + 2]));
					  temp0 = (((ulong)E8_bitslice_roundconstant[roundnumber + 3])[i]) ^ ((state.x[0][i]) & (state.x[2][i]));
					  temp1 = (((ulong)E8_bitslice_roundconstant[roundnumber + 3])[i + 2]) ^ ((state.x[1][i]) & (state.x[3][i]));
					  state.x[0][i] ^= ((state.x[4][i]) & (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[5][i]) & (state.x[7][i]));
					  state.x[6][i] ^= ((~(state.x[2][i])) & (state.x[4][i]));
					  state.x[7][i] ^= ((~(state.x[3][i])) & (state.x[5][i]));
					  state.x[2][i] ^= ((state.x[0][i]) & (state.x[4][i]));
					  state.x[3][i] ^= ((state.x[1][i]) & (state.x[5][i]));
					  state.x[4][i] ^= ((state.x[0][i]) & (~(state.x[6][i])));
					  state.x[5][i] ^= ((state.x[1][i]) & (~(state.x[7][i])));
					  state.x[0][i] ^= ((state.x[2][i]) | (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[3][i]) | (state.x[7][i]));
					  state.x[6][i] ^= ((state.x[2][i]) & (state.x[4][i]));
					  state.x[7][i] ^= ((state.x[3][i]) & (state.x[5][i]));
					  state.x[2][i] ^= (temp0 & (state.x[0][i]));
					  state.x[3][i] ^= (temp1 & (state.x[1][i]));
					  state.x[4][i] ^= temp0;
					  state.x[5][i] ^= temp1;
					  (state.x[1][i]) ^= (state.x[2][i]);
					  (state.x[3][i]) ^= (state.x[4][i]);
					  (state.x[5][i]) ^= (state.x[0][i]) ^ (state.x[6][i]);
					  (state.x[7][i]) ^= (state.x[0][i]);
					  (state.x[0][i]) ^= (state.x[3][i]);
					  (state.x[2][i]) ^= (state.x[5][i]);
					  (state.x[4][i]) ^= (state.x[1][i]) ^ (state.x[7][i]);
					  (state.x[6][i]) ^= (state.x[1][i]);
					  (state.x[1][i]) = ((((state.x[1][i]) & 0x00ff00ff00ff00ffUL) << 8) | (((state.x[1][i]) & 0xff00ff00ff00ff00UL) >> 8));
					  ;
					  (state.x[3][i]) = ((((state.x[3][i]) & 0x00ff00ff00ff00ffUL) << 8) | (((state.x[3][i]) & 0xff00ff00ff00ff00UL) >> 8));
					  ;
					  (state.x[5][i]) = ((((state.x[5][i]) & 0x00ff00ff00ff00ffUL) << 8) | (((state.x[5][i]) & 0xff00ff00ff00ff00UL) >> 8));
					  ;
					  (state.x[7][i]) = ((((state.x[7][i]) & 0x00ff00ff00ff00ffUL) << 8) | (((state.x[7][i]) & 0xff00ff00ff00ff00UL) >> 8));
				}

				/*round 7*roundnumber+4: Sbox, MDS and Swapping layers*/
				for (i = 0; i < 2; i++)
				{
					  state.x[6][i] = ~(state.x[6][i]);
					  state.x[7][i] = ~(state.x[7][i]);
					  state.x[0][i] ^= ((~(state.x[4][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 4])[i]));
					  state.x[1][i] ^= ((~(state.x[5][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 4])[i + 2]));
					  temp0 = (((ulong)E8_bitslice_roundconstant[roundnumber + 4])[i]) ^ ((state.x[0][i]) & (state.x[2][i]));
					  temp1 = (((ulong)E8_bitslice_roundconstant[roundnumber + 4])[i + 2]) ^ ((state.x[1][i]) & (state.x[3][i]));
					  state.x[0][i] ^= ((state.x[4][i]) & (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[5][i]) & (state.x[7][i]));
					  state.x[6][i] ^= ((~(state.x[2][i])) & (state.x[4][i]));
					  state.x[7][i] ^= ((~(state.x[3][i])) & (state.x[5][i]));
					  state.x[2][i] ^= ((state.x[0][i]) & (state.x[4][i]));
					  state.x[3][i] ^= ((state.x[1][i]) & (state.x[5][i]));
					  state.x[4][i] ^= ((state.x[0][i]) & (~(state.x[6][i])));
					  state.x[5][i] ^= ((state.x[1][i]) & (~(state.x[7][i])));
					  state.x[0][i] ^= ((state.x[2][i]) | (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[3][i]) | (state.x[7][i]));
					  state.x[6][i] ^= ((state.x[2][i]) & (state.x[4][i]));
					  state.x[7][i] ^= ((state.x[3][i]) & (state.x[5][i]));
					  state.x[2][i] ^= (temp0 & (state.x[0][i]));
					  state.x[3][i] ^= (temp1 & (state.x[1][i]));
					  state.x[4][i] ^= temp0;
					  state.x[5][i] ^= temp1;
					  (state.x[1][i]) ^= (state.x[2][i]);
					  (state.x[3][i]) ^= (state.x[4][i]);
					  (state.x[5][i]) ^= (state.x[0][i]) ^ (state.x[6][i]);
					  (state.x[7][i]) ^= (state.x[0][i]);
					  (state.x[0][i]) ^= (state.x[3][i]);
					  (state.x[2][i]) ^= (state.x[5][i]);
					  (state.x[4][i]) ^= (state.x[1][i]) ^ (state.x[7][i]);
					  (state.x[6][i]) ^= (state.x[1][i]);
					  (state.x[1][i]) = ((((state.x[1][i]) & 0x0000ffff0000ffffUL) << 16) | (((state.x[1][i]) & 0xffff0000ffff0000UL) >> 16));
					  ;
					  (state.x[3][i]) = ((((state.x[3][i]) & 0x0000ffff0000ffffUL) << 16) | (((state.x[3][i]) & 0xffff0000ffff0000UL) >> 16));
					  ;
					  (state.x[5][i]) = ((((state.x[5][i]) & 0x0000ffff0000ffffUL) << 16) | (((state.x[5][i]) & 0xffff0000ffff0000UL) >> 16));
					  ;
					  (state.x[7][i]) = ((((state.x[7][i]) & 0x0000ffff0000ffffUL) << 16) | (((state.x[7][i]) & 0xffff0000ffff0000UL) >> 16));
				}

				/*round 7*roundnumber+5: Sbox, MDS and Swapping layers*/
				for (i = 0; i < 2; i++)
				{
					  state.x[6][i] = ~(state.x[6][i]);
					  state.x[7][i] = ~(state.x[7][i]);
					  state.x[0][i] ^= ((~(state.x[4][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 5])[i]));
					  state.x[1][i] ^= ((~(state.x[5][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 5])[i + 2]));
					  temp0 = (((ulong)E8_bitslice_roundconstant[roundnumber + 5])[i]) ^ ((state.x[0][i]) & (state.x[2][i]));
					  temp1 = (((ulong)E8_bitslice_roundconstant[roundnumber + 5])[i + 2]) ^ ((state.x[1][i]) & (state.x[3][i]));
					  state.x[0][i] ^= ((state.x[4][i]) & (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[5][i]) & (state.x[7][i]));
					  state.x[6][i] ^= ((~(state.x[2][i])) & (state.x[4][i]));
					  state.x[7][i] ^= ((~(state.x[3][i])) & (state.x[5][i]));
					  state.x[2][i] ^= ((state.x[0][i]) & (state.x[4][i]));
					  state.x[3][i] ^= ((state.x[1][i]) & (state.x[5][i]));
					  state.x[4][i] ^= ((state.x[0][i]) & (~(state.x[6][i])));
					  state.x[5][i] ^= ((state.x[1][i]) & (~(state.x[7][i])));
					  state.x[0][i] ^= ((state.x[2][i]) | (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[3][i]) | (state.x[7][i]));
					  state.x[6][i] ^= ((state.x[2][i]) & (state.x[4][i]));
					  state.x[7][i] ^= ((state.x[3][i]) & (state.x[5][i]));
					  state.x[2][i] ^= (temp0 & (state.x[0][i]));
					  state.x[3][i] ^= (temp1 & (state.x[1][i]));
					  state.x[4][i] ^= temp0;
					  state.x[5][i] ^= temp1;
					  (state.x[1][i]) ^= (state.x[2][i]);
					  (state.x[3][i]) ^= (state.x[4][i]);
					  (state.x[5][i]) ^= (state.x[0][i]) ^ (state.x[6][i]);
					  (state.x[7][i]) ^= (state.x[0][i]);
					  (state.x[0][i]) ^= (state.x[3][i]);
					  (state.x[2][i]) ^= (state.x[5][i]);
					  (state.x[4][i]) ^= (state.x[1][i]) ^ (state.x[7][i]);
					  (state.x[6][i]) ^= (state.x[1][i]);
					  (state.x[1][i]) = (((state.x[1][i]) << 32) | ((state.x[1][i]) >> 32));
					  ;
					  (state.x[3][i]) = (((state.x[3][i]) << 32) | ((state.x[3][i]) >> 32));
					  ;
					  (state.x[5][i]) = (((state.x[5][i]) << 32) | ((state.x[5][i]) >> 32));
					  ;
					  (state.x[7][i]) = (((state.x[7][i]) << 32) | ((state.x[7][i]) >> 32));
				}

				/*round 7*roundnumber+6: Sbox and MDS layers*/
				for (i = 0; i < 2; i++)
				{
					  state.x[6][i] = ~(state.x[6][i]);
					  state.x[7][i] = ~(state.x[7][i]);
					  state.x[0][i] ^= ((~(state.x[4][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 6])[i]));
					  state.x[1][i] ^= ((~(state.x[5][i])) & (((ulong)E8_bitslice_roundconstant[roundnumber + 6])[i + 2]));
					  temp0 = (((ulong)E8_bitslice_roundconstant[roundnumber + 6])[i]) ^ ((state.x[0][i]) & (state.x[2][i]));
					  temp1 = (((ulong)E8_bitslice_roundconstant[roundnumber + 6])[i + 2]) ^ ((state.x[1][i]) & (state.x[3][i]));
					  state.x[0][i] ^= ((state.x[4][i]) & (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[5][i]) & (state.x[7][i]));
					  state.x[6][i] ^= ((~(state.x[2][i])) & (state.x[4][i]));
					  state.x[7][i] ^= ((~(state.x[3][i])) & (state.x[5][i]));
					  state.x[2][i] ^= ((state.x[0][i]) & (state.x[4][i]));
					  state.x[3][i] ^= ((state.x[1][i]) & (state.x[5][i]));
					  state.x[4][i] ^= ((state.x[0][i]) & (~(state.x[6][i])));
					  state.x[5][i] ^= ((state.x[1][i]) & (~(state.x[7][i])));
					  state.x[0][i] ^= ((state.x[2][i]) | (state.x[6][i]));
					  state.x[1][i] ^= ((state.x[3][i]) | (state.x[7][i]));
					  state.x[6][i] ^= ((state.x[2][i]) & (state.x[4][i]));
					  state.x[7][i] ^= ((state.x[3][i]) & (state.x[5][i]));
					  state.x[2][i] ^= (temp0 & (state.x[0][i]));
					  state.x[3][i] ^= (temp1 & (state.x[1][i]));
					  state.x[4][i] ^= temp0;
					  state.x[5][i] ^= temp1;
					  (state.x[1][i]) ^= (state.x[2][i]);
					  (state.x[3][i]) ^= (state.x[4][i]);
					  (state.x[5][i]) ^= (state.x[0][i]) ^ (state.x[6][i]);
					  (state.x[7][i]) ^= (state.x[0][i]);
					  (state.x[0][i]) ^= (state.x[3][i]);
					  (state.x[2][i]) ^= (state.x[5][i]);
					  (state.x[4][i]) ^= (state.x[1][i]) ^ (state.x[7][i]);
					  (state.x[6][i]) ^= (state.x[1][i]);
				}
				/*round 7*roundnumber+6: swapping layer*/
				for (i = 1; i < 8; i = i + 2)
				{
					  temp0 = state.x[i][0];
					  state.x[i][0] = state.x[i][1];
					  state.x[i][1] = temp0;
				}
		  }

	}

/*The compression function F8 */
	internal static void F8(hashState state)
	{
		  ulong i = new ulong();

		  /*xor the 512-bit message with the fist half of the 1024-bit hash state*/
		  for (i = 0; i < 8; i++)
		  {
			  state.x[i >> 1][i & 1] ^= ((ulong)state.buffer)[i];
		  }

		  /*the bijective function E8 */
		  E8(state);

		  /*xor the 512-bit message with the second half of the 1024-bit hash state*/
		  for (i = 0; i < 8; i++)
		  {
			  state.x[(8 + i) >> 1][(8 + i) & 1] ^= ((ulong)state.buffer)[i];
		  }
	}

/*before hashing a message, initialize the hash state as H0 */

	/*The API functions*/
	internal static HashReturn Init(hashState state, int hashbitlen)
	{
		  state.databitlen = 0;
		  state.datasize_in_buffer = 0;

		  /*initialize the initial hash value of JH*/
		  state.hashbitlen = hashbitlen;

		  /*load the intital hash value into state*/
		  switch (hashbitlen)
		  {
				case 224:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(state.x,JH224_H0,128);
					break;
				case 256:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(state.x,JH256_H0,128);
					break;
				case 384:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(state.x,JH384_H0,128);
					break;
				case 512:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(state.x,JH512_H0,128);
					break;
		  }

		  return (HashReturn.SUCCESS);
	}

/*hash each 512-bit message block, except the last partial block*/
	internal static HashReturn Update(hashState state, byte data, ulong databitlen)
	{
		  ulong index; //the starting address of the data to be compressed

		  state.databitlen += databitlen;
		  index = 0;

		  /*if there is remaining data in the buffer, fill it to a full message block first*/
		  /*we assume that the size of the data in the buffer is the multiple of 8 bits if it is not at the end of a message*/

		  /*There is data in the buffer, but the incoming data is insufficient for a full block*/
		  if ((state.datasize_in_buffer > 0) && ((state.datasize_in_buffer + databitlen) < 512))
		  {
				if ((databitlen & 7) == 0)
				{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					 memcpy(state.buffer + (state.datasize_in_buffer >> 3), data, 64 - (state.datasize_in_buffer >> 3));
				}
				else
				{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(state.buffer + (state.datasize_in_buffer >> 3), data, 64 - (state.datasize_in_buffer >> 3) + 1);
				}
				state.datasize_in_buffer += databitlen;
				databitlen = 0;
		  }

		  /*There is data in the buffer, and the incoming data is sufficient for a full block*/
		  if ((state.datasize_in_buffer > 0) && ((state.datasize_in_buffer + databitlen) >= 512))
		  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(state.buffer + (state.datasize_in_buffer >> 3), data, 64 - (state.datasize_in_buffer >> 3));
				index = 64 - (state.datasize_in_buffer >> 3);
				databitlen = databitlen - (512 - state.datasize_in_buffer);
				F8(state);
				state.datasize_in_buffer = 0;
		  }

		  /*hash the remaining full message blocks*/
		  for (; databitlen >= 512; index = index + 64, databitlen = databitlen - 512)
		  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(state.buffer, data + index, 64);
				F8(state);
		  }

		  /*store the partial block into buffer, assume that -- if part of the last byte is not part of the message, then that part consists of 0 bits*/
		  if (databitlen > 0)
		  {
				if ((databitlen & 7) == 0)
				{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					  memcpy(state.buffer, data + index, (databitlen & 0x1ff) >> 3);
				}
				else
				{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					  memcpy(state.buffer, data + index, ((databitlen & 0x1ff) >> 3) + 1);
				}
				state.datasize_in_buffer = databitlen;
		  }

		  return (HashReturn.SUCCESS);
	}

/*pad the message, process the padded block(s), truncate the hash value H to obtain the message digest*/
	internal static HashReturn Final(hashState state, ref byte hashval)
	{
		  uint i;

		  if ((state.databitlen & 0x1ff) == 0)
		  {
				/*pad the message when databitlen is multiple of 512 bits, then process the padded block*/
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
				memset(state.buffer, 0, 64);
				state.buffer[0] = 0x80;
				state.buffer[63] = state.databitlen & 0xff;
				state.buffer[62] = (state.databitlen >> 8) & 0xff;
				state.buffer[61] = (state.databitlen >> 16) & 0xff;
				state.buffer[60] = (state.databitlen >> 24) & 0xff;
				state.buffer[59] = (state.databitlen >> 32) & 0xff;
				state.buffer[58] = (state.databitlen >> 40) & 0xff;
				state.buffer[57] = (state.databitlen >> 48) & 0xff;
				state.buffer[56] = (state.databitlen >> 56) & 0xff;
				F8(state);
		  }
		  else
		  {
				/*set the rest of the bytes in the buffer to 0*/
				if ((state.datasize_in_buffer & 7) == 0)
				{
					  for (i = (state.databitlen & 0x1ff) >> 3; i < 64; i++)
					  {
						  state.buffer[i] = 0;
					  }
				}
				else
				{
					  for (i = ((state.databitlen & 0x1ff) >> 3) + 1; i < 64; i++)
					  {
						  state.buffer[i] = 0;
					  }
				}

				/*pad and process the partial block when databitlen is not multiple of 512 bits, then hash the padded blocks*/
				state.buffer[((state.databitlen & 0x1ff) >> 3)] |= 1 << (7 - (state.databitlen & 7));

				F8(state);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
				memset(state.buffer, 0, 64);
				state.buffer[63] = state.databitlen & 0xff;
				state.buffer[62] = (state.databitlen >> 8) & 0xff;
				state.buffer[61] = (state.databitlen >> 16) & 0xff;
				state.buffer[60] = (state.databitlen >> 24) & 0xff;
				state.buffer[59] = (state.databitlen >> 32) & 0xff;
				state.buffer[58] = (state.databitlen >> 40) & 0xff;
				state.buffer[57] = (state.databitlen >> 48) & 0xff;
				state.buffer[56] = (state.databitlen >> 56) & 0xff;
				F8(state);
		  }

		  /*truncating the final hash value to generate the message digest*/
		  switch (state.hashbitlen)
		  {
				case 224:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(hashval,(byte)state.x + 64 + 36,28);
					break;
				case 256:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(hashval,(byte)state.x + 64 + 32,32);
					break;
				case 384:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(hashval,(byte)state.x + 64 + 16,48);
					break;
				case 512:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(hashval,(byte)state.x + 64,64);
					break;
		  }

		  return (HashReturn.SUCCESS);
	}
	//HashReturn jh_hash(int hashbitlen, byte data, ulong databitlen, ref byte hashval);Tangible Method Implementation Not Found-jh_hash

	/*swapping bit 2i with bit 2i+1 of 64-bit x*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP1(x) (x) = ((((x) & 0x5555555555555555ULL) << 1) | (((x) & 0xaaaaaaaaaaaaaaaaULL) >> 1));
	/*swapping bits 4i||4i+1 with bits 4i+2||4i+3 of 64-bit x*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP2(x) (x) = ((((x) & 0x3333333333333333ULL) << 2) | (((x) & 0xccccccccccccccccULL) >> 2));
	/*swapping bits 8i||8i+1||8i+2||8i+3 with bits 8i+4||8i+5||8i+6||8i+7 of 64-bit x*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP4(x) (x) = ((((x) & 0x0f0f0f0f0f0f0f0fULL) << 4) | (((x) & 0xf0f0f0f0f0f0f0f0ULL) >> 4));
	/*swapping bits 16i||16i+1||......||16i+7  with bits 16i+8||16i+9||......||16i+15 of 64-bit x*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP8(x) (x) = ((((x) & 0x00ff00ff00ff00ffULL) << 8) | (((x) & 0xff00ff00ff00ff00ULL) >> 8));
	/*swapping bits 32i||32i+1||......||32i+15 with bits 32i+16||32i+17||......||32i+31 of 64-bit x*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP16(x) (x) = ((((x) & 0x0000ffff0000ffffULL) << 16) | (((x) & 0xffff0000ffff0000ULL) >> 16));
	/*swapping bits 64i||64i+1||......||64i+31 with bits 64i+32||64i+33||......||64i+63 of 64-bit x*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32(x) (x) = (((x) << 32) | ((x) >> 32));

	/*The MDS transform*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define L(m0,m1,m2,m3,m4,m5,m6,m7) (m4) ^= (m1); (m5) ^= (m2); (m6) ^= (m0) ^ (m3); (m7) ^= (m0); (m0) ^= (m5); (m1) ^= (m6); (m2) ^= (m4) ^ (m7); (m3) ^= (m4);

	/*Two Sboxes are computed in parallel, each Sbox implements S0 and S1, selected by a constant bit*/
	/*The reason to compute two Sboxes in parallel is to try to fully utilize the parallel processing power*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SS(m0,m1,m2,m3,m4,m5,m6,m7,cc0,cc1) m3 = ~(m3); m7 = ~(m7); m0 ^= ((~(m2)) & (cc0)); m4 ^= ((~(m6)) & (cc1)); temp0 = (cc0) ^ ((m0) & (m1)); temp1 = (cc1) ^ ((m4) & (m5)); m0 ^= ((m2) & (m3)); m4 ^= ((m6) & (m7)); m3 ^= ((~(m1)) & (m2)); m7 ^= ((~(m5)) & (m6)); m1 ^= ((m0) & (m2)); m5 ^= ((m4) & (m6)); m2 ^= ((m0) & (~(m3))); m6 ^= ((m4) & (~(m7))); m0 ^= ((m1) | (m3)); m4 ^= ((m5) | (m7)); m3 ^= ((m1) & (m2)); m7 ^= ((m5) & (m6)); m1 ^= (temp0 & (m0)); m5 ^= (temp1 & (m4)); m2 ^= temp0; m6 ^= temp1;


	// compute a keccak hash (md) of given byte length from "in"
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'in', so pointers on this parameter are left unchanged:
	public static int keccak(ushort * in, int inlen, ushort md, int mdlen)
	{
		ulong[] st = Arrays.InitializeWithDefaultInstances<ulong>(25);
		ushort[] temp = Arrays.InitializeWithDefaultInstances<ushort>(144);
		int i;
		int rsiz;
		int rsizw;


		/* for some reason the enum from hash-ops.h is not valid here when
		   compiling - is this a C vs C++ thing? Anyhow, lets just redefine it for
		   now. */

		const int HASH_DATA_AREA = 136;

		rsiz = sizeof(ulong[25]) == mdlen != 0 ? HASH_DATA_AREA : 200 - 2 * mdlen;
		rsizw = rsiz / 8;

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(st, 0, sizeof(ulong));

		for (; inlen >= rsiz; inlen -= rsiz, in += rsiz)
		{
			for (i = 0; i < rsizw; i++)
			{
				st[i] ^= ((ulong) in)[i];
			}
			keccakf(st, DefineConstants.KECCAK_ROUNDS);
		}

		// last block and padding
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(temp, in, inlen);
		temp[inlen++] = 1;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(temp + inlen, 0, rsiz - inlen);
		temp[rsiz - 1] |= 0x80;

		for (i = 0; i < rsizw; i++)
		{
			st[i] ^= ((ulong) temp)[i];
		}

		keccakf(st, DefineConstants.KECCAK_ROUNDS);

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(md, st, mdlen);

		return 0;
	}

// update the state with given number of rounds


	// update the state
	public static void keccakf(ulong[] st, int rounds)
	{
		int i;
		int j;
		int round;
		ulong t = new ulong();
		ulong[] bc = Arrays.InitializeWithDefaultInstances<ulong>(5);

		for (round = 0; round < rounds; round++)
		{

			// Theta
			for (i = 0; i < 5; i++)
			{
				bc[i] = st[i] ^ st[i + 5] ^ st[i + 10] ^ st[i + 15] ^ st[i + 20];
			}

			for (i = 0; i < 5; i++)
			{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: t = bc[(i + 4) % 5] ^ (((bc[(i + 1) % 5]) << (1)) | ((bc[(i + 1) % 5]) >> (64 - (1))));
				t.CopyFrom(bc[(i + 4) % 5] ^ (((bc[(i + 1) % 5]) << (1)) | ((bc[(i + 1) % 5]) >> (64 - (1)))));
				for (j = 0; j < 25; j += 5)
				{
					st[j + i] ^= t;
				}
			}

			// Rho Pi
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: t = st[1];
			t.CopyFrom(st[1]);
			for (i = 0; i < 24; i++)
			{
				j = keccakf_piln[i];
				bc[0] = st[j];
				st[j] = (((t) << (keccakf_rotc[i])) | ((t) >> (64 - (keccakf_rotc[i]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: t = bc[0];
				t.CopyFrom(bc[0]);
			}

			//  Chi
			for (j = 0; j < 25; j += 5)
			{
				for (i = 0; i < 5; i++)
				{
					bc[i] = st[j + i];
				}
				for (i = 0; i < 5; i++)
				{
					st[j + i] ^= (~bc[(i + 1) % 5]) & bc[(i + 2) % 5];
				}
			}

			//  Iota
			st[0] ^= keccakf_rndc[round];
		}
	}

	public static void keccak1600(ushort in, int inlen, ushort md)
	{
		keccak(in, inlen, md, sizeof(ulong[25]));
	}



	public static readonly ulong[] keccakf_rndc = {0x0000000000000001, 0x0000000000008082, 0x800000000000808a, 0x8000000080008000, 0x000000000000808b, 0x0000000080000001, 0x8000000080008081, 0x8000000000008009, 0x000000000000008a, 0x0000000000000088, 0x0000000080008009, 0x000000008000000a, 0x000000008000808b, 0x800000000000008b, 0x8000000000008089, 0x8000000000008003, 0x8000000000008002, 0x8000000000000080, 0x000000000000800a, 0x800000008000000a, 0x8000000080008081, 0x8000000000008080, 0x0000000080000001, 0x8000000080008008};

	public static readonly int[] keccakf_rotc = {1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44};

	public static readonly int[] keccakf_piln = {10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1};

	// compute a keccak hash (md) of given byte length from "in"

	/*
	 * // usage:
	 * 
	 * OAES_CTX * ctx = oaes_alloc();
	 * .
	 * .
	 * .
	 * {
	 *   oaes_gen_key_xxx( ctx );
	 *   {
	 *     oaes_key_export( ctx, _buf, &_buf_len );
	 *     // or
	 *     oaes_key_export_data( ctx, _buf, &_buf_len );
	 *   }
	 * }
	 * // or
	 * {
	 *   oaes_key_import( ctx, _buf, _buf_len );
	 *   // or
	 *   oaes_key_import_data( ctx, _buf, _buf_len );
	 * }
	 * .
	 * .
	 * .
	 * oaes_encrypt( ctx, m, m_len, c, &c_len );
	 * .
	 * .
	 * .
	 * oaes_decrypt( ctx, c, c_len, m, &m_len );
	 * .
	 * .
	 * .
	 * oaes_free( &ctx );
	 */

	public static OAES_CTX oaes_alloc()
	{
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
		oaes_ctx _ctx = (oaes_ctx) calloc(sizeof(oaes_ctx), 1);

		if (_ctx == null)
		{
			return null;
		}

	#if OAES_HAVE_ISAAC
		{
		  ub4 _i = 0;
			string _seed = new string(new char[RANDSIZ + 1]);

//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
			_ctx.rctx = (randctx) calloc(sizeof(randctx), 1);

			if (_ctx.== null rctx)
			{
				_ctx = null;
				return null;
			}

			oaes_get_seed(_seed);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
			memset(_ctx.rctx.randrsl, 0, RANDSIZ);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(_ctx.rctx.randrsl, _seed, RANDSIZ);
			randinit(_ctx.rctx, 1);
	}
	#else
			RandomNumbers.Seed(oaes_get_seed());
	#endif

		_ctx.key = null;
		oaes_set_option(_ctx, DefineConstants.OAES_OPTION_CBC, null);

	#if OAES_DEBUG
		_ctx.step_cb = null;
		oaes_set_option(_ctx, DefineConstants.OAES_OPTION_STEP_OFF, null);
	#endif

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		return (OAES_CTX) _ctx;
	}

	//OAES_API OAES_RET oaes_free(object[] ctx);Tangible Method Implementation Not Found-oaes_free

	//OAES_API OAES_RET oaes_set_option(object ctx, ushort option, object value);Tangible Method Implementation Not Found-oaes_set_option

	//OAES_API OAES_RET oaes_key_gen_128(object ctx);Tangible Method Implementation Not Found-oaes_key_gen_128

	//OAES_API OAES_RET oaes_key_gen_192(object ctx);Tangible Method Implementation Not Found-oaes_key_gen_192

	//OAES_API OAES_RET oaes_key_gen_256(object ctx);Tangible Method Implementation Not Found-oaes_key_gen_256

	// export key with header information
	// set data == NULL to get the required data_len
	//OAES_API OAES_RET oaes_key_export(object ctx, ushort data, size_t data_len);Tangible Method Implementation Not Found-oaes_key_export

	// directly export the data from key
	// set data == NULL to get the required data_len
	//OAES_API OAES_RET oaes_key_export_data(object ctx, ushort data, size_t data_len);Tangible Method Implementation Not Found-oaes_key_export_data

	// import key with header information
	//OAES_API OAES_RET oaes_key_import(object ctx, ushort data, size_t data_len);Tangible Method Implementation Not Found-oaes_key_import

	// directly import data into key
	//OAES_API OAES_RET oaes_key_import_data(object ctx, ushort data, size_t data_len);Tangible Method Implementation Not Found-oaes_key_import_data

	// set c == NULL to get the required c_len
	//OAES_API OAES_RET oaes_encrypt(object ctx, ushort m, size_t m_len, ushort c, size_t c_len);Tangible Method Implementation Not Found-oaes_encrypt

	// set m == NULL to get the required m_len
	//OAES_API OAES_RET oaes_decrypt(object ctx, ushort c, size_t c_len, ushort m, size_t m_len);Tangible Method Implementation Not Found-oaes_decrypt

	// set buf == NULL to get the required buf_len
	public static OAES_RET oaes_sprintf(ref string buf, size_t buf_len, ushort[] data, size_t data_len)
	{
		size_t _i = new size_t();
		size_t _buf_len_in = new size_t();
		string _temp = new string(new char[4]);

		if (buf_len == null)
		{
			return OAES_RET.OAES_RET_ARG2;
		}

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: _buf_len_in = *buf_len;
		_buf_len_in.CopyFrom(buf_len);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: *buf_len = data_len * 3 + data_len / DefineConstants.OAES_BLOCK_SIZE + 1;
		buf_len.CopyFrom(data_len * 3 + data_len / DefineConstants.OAES_BLOCK_SIZE + 1);

		if (buf == null)
		{
			return OAES_RET.OAES_RET_SUCCESS;
		}

		if (buf_len > _buf_len_in)
		{
			return OAES_RET.OAES_RET_BUF;
		}

		if (data == null)
		{
			return OAES_RET.OAES_RET_ARG3;
		}

		buf = "";

		for (_i = 0; _i < data_len; _i++)
		{
			_temp = string.Format("{0:x2} ", data[_i]);
			buf += _temp;
			if (_i != null && 0 == (_i + 1) % DefineConstants.OAES_BLOCK_SIZE)
			{
				buf += "\n";
			}
		}

		return OAES_RET.OAES_RET_SUCCESS;
	}

	public static OAES_API OAES_RET oaes_encryption_round(ushort[] key, ushort[] c)
	{
	  size_t _i = new size_t();

	  if (key == null)
	  {
		return OAES_RET.OAES_RET_ARG1;
	  }

	  if (c == null)
	  {
		return OAES_RET.OAES_RET_ARG2;
	  }

	  // SubBytes(state)
	  for (_i = 0; _i < DefineConstants.OAES_BLOCK_SIZE; _i++)
	  {
		oaes_sub_byte(c + _i);
	  }

	  // ShiftRows(state)
	  oaes_shift_rows(new ushort(c));

	  // MixColumns(state)
	  oaes_mix_cols(new ushort(c));
	  oaes_mix_cols(c + 4);
	  oaes_mix_cols(c + 8);
	  oaes_mix_cols(c + 12);

	  // AddRoundKey(State, key)
	  for (_i = 0; _i < DefineConstants.OAES_BLOCK_SIZE; _i++)
	  {
		c[_i] ^= key[_i];
	  }

	  return OAES_RET.OAES_RET_SUCCESS;
	}

	//OAES_API OAES_RET oaes_pseudo_encrypt_ecb(object ctx, ushort c);Tangible Method Implementation Not Found-oaes_pseudo_encrypt_ecb

	#if __cplusplus
	#endif



	#if OAES_HAVE_ISAAC
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define FIPS_RAND_SIZE_T size_t
	#define FIPS_RAND_SIZE_T
	#define RAND_F_RAND_GET_RAND_METHOD
	#define RAND_F_RAND_INIT_FIPS
	#define RAND_F_SSLEAY_RAND_BYTES
	#define RAND_R_DUAL_EC_DRBG_DISABLED
	#define RAND_R_ERROR_INITIALISING_DRBG
	#define RAND_R_ERROR_INSTANTIATING_DRBG
	#define RAND_R_NO_FIPS_RANDOM_METHOD_SET
	#define RAND_R_PRNG_NOT_SEEDED
	#endif


	// the block is padded

	#if ! min
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define min(a,b) (((a)<(b)) ? (a) : (b))
	#define min
	#endif

	// "OAES<8-bit header version><8-bit type><16-bit options><8-bit flags><56-bit reserved>"
	internal static ushort[] oaes_header = {0x4f, 0x41, 0x45, 0x53, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	internal static ushort[] oaes_gf_8 = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36};

	internal static ushort[,] oaes_sub_byte_value =
	{
		{0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76},
		{0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0},
		{0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15},
		{0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75},
		{0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84},
		{0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf},
		{0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8},
		{0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2},
		{0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73},
		{0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb},
		{0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79},
		{0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08},
		{0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a},
		{0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e},
		{0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf},
		{0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16}
	};

	internal static ushort[,] oaes_inv_sub_byte_value =
	{
		{0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb},
		{0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb},
		{0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e},
		{0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25},
		{0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92},
		{0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84},
		{0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06},
		{0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b},
		{0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73},
		{0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e},
		{0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b},
		{0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4},
		{0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f},
		{0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef},
		{0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61},
		{0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d}
	};

	internal static ushort[,] oaes_gf_mul_2 =
	{
		{0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e},
		{0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e},
		{0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e},
		{0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e},
		{0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e},
		{0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe},
		{0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde},
		{0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe},
		{0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05},
		{0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25},
		{0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45},
		{0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65},
		{0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85},
		{0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5},
		{0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5},
		{0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5}
	};

	internal static ushort[,] oaes_gf_mul_3 =
	{
		{0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11},
		{0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21},
		{0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71},
		{0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41},
		{0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1},
		{0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1},
		{0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1},
		{0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81},
		{0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a},
		{0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba},
		{0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea},
		{0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda},
		{0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a},
		{0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a},
		{0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a},
		{0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a}
	};

	internal static ushort[,] oaes_gf_mul_9 =
	{
		{0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77},
		{0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7},
		{0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c},
		{0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc},
		{0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01},
		{0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91},
		{0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a},
		{0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa},
		{0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b},
		{0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b},
		{0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0},
		{0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30},
		{0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed},
		{0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d},
		{0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6},
		{0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46}
	};

	internal static ushort[,] oaes_gf_mul_b =
	{
		{0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69},
		{0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9},
		{0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12},
		{0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2},
		{0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f},
		{0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f},
		{0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4},
		{0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54},
		{0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e},
		{0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e},
		{0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5},
		{0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55},
		{0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68},
		{0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8},
		{0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13},
		{0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3}
	};

	internal static ushort[,] oaes_gf_mul_d =
	{
		{0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b},
		{0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b},
		{0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0},
		{0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20},
		{0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26},
		{0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6},
		{0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d},
		{0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d},
		{0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91},
		{0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41},
		{0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a},
		{0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa},
		{0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc},
		{0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c},
		{0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47},
		{0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97}
	};

	internal static ushort[,] oaes_gf_mul_e =
	{
		{0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a},
		{0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba},
		{0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81},
		{0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61},
		{0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7},
		{0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17},
		{0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c},
		{0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc},
		{0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b},
		{0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb},
		{0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0},
		{0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20},
		{0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6},
		{0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56},
		{0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d},
		{0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d}
	};

	internal static OAES_RET oaes_sub_byte(ushort @byte)
	{
		size_t _x = new size_t();
		size_t _y = new size_t();

		if (@byte == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		_x = _y = @byte;
		_x &= 0x0f;
		_y &= 0xf0;
		_y >>= 4;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: *byte = oaes_sub_byte_value[_y][_x];
		@byte.CopyFrom(oaes_sub_byte_value[_y, _x]);

		return OAES_RET.OAES_RET_SUCCESS;
	}

	internal static OAES_RET oaes_inv_sub_byte(ushort @byte)
	{
		size_t _x = new size_t();
		size_t _y = new size_t();

		if (@byte == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		_x = _y = @byte;
		_x &= 0x0f;
		_y &= 0xf0;
		_y >>= 4;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: *byte = oaes_inv_sub_byte_value[_y][_x];
		@byte.CopyFrom(oaes_inv_sub_byte_value[_y, _x]);

		return OAES_RET.OAES_RET_SUCCESS;
	}
	/*
	static OAES_RET oaes_word_rot_right( ushort word[OAES_COL_LEN] )
	{
		ushort _temp[OAES_COL_LEN];
		
		if( NULL == word )
			return OAES_RET_ARG1;
	
		memcpy( _temp + 1, word, OAES_COL_LEN - 1 );
		_temp[0] = word[OAES_COL_LEN - 1];
		memcpy( word, _temp, OAES_COL_LEN );
		
		return OAES_RET_SUCCESS;
	}
	*/
	internal static OAES_RET oaes_word_rot_left(ushort[] word)
	{
		ushort[] _temp = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.OAES_COL_LEN);

		if (word == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(_temp, word + 1, DefineConstants.OAES_COL_LEN - 1);
		_temp[DefineConstants.OAES_COL_LEN - 1] = word[0];
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(word, _temp, DefineConstants.OAES_COL_LEN);

		return OAES_RET.OAES_RET_SUCCESS;
	}

	internal static OAES_RET oaes_shift_rows(ushort[] block)
	{
		ushort[] _temp = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.OAES_BLOCK_SIZE);

		if (block == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		_temp[0x00] = block[0x00];
		_temp[0x01] = block[0x05];
		_temp[0x02] = block[0x0a];
		_temp[0x03] = block[0x0f];
		_temp[0x04] = block[0x04];
		_temp[0x05] = block[0x09];
		_temp[0x06] = block[0x0e];
		_temp[0x07] = block[0x03];
		_temp[0x08] = block[0x08];
		_temp[0x09] = block[0x0d];
		_temp[0x0a] = block[0x02];
		_temp[0x0b] = block[0x07];
		_temp[0x0c] = block[0x0c];
		_temp[0x0d] = block[0x01];
		_temp[0x0e] = block[0x06];
		_temp[0x0f] = block[0x0b];
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(block, _temp, DefineConstants.OAES_BLOCK_SIZE);

		return OAES_RET.OAES_RET_SUCCESS;
	}

	internal static OAES_RET oaes_inv_shift_rows(ushort[] block)
	{
		ushort[] _temp = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.OAES_BLOCK_SIZE);

		if (block == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		_temp[0x00] = block[0x00];
		_temp[0x01] = block[0x0d];
		_temp[0x02] = block[0x0a];
		_temp[0x03] = block[0x07];
		_temp[0x04] = block[0x04];
		_temp[0x05] = block[0x01];
		_temp[0x06] = block[0x0e];
		_temp[0x07] = block[0x0b];
		_temp[0x08] = block[0x08];
		_temp[0x09] = block[0x05];
		_temp[0x0a] = block[0x02];
		_temp[0x0b] = block[0x0f];
		_temp[0x0c] = block[0x0c];
		_temp[0x0d] = block[0x09];
		_temp[0x0e] = block[0x06];
		_temp[0x0f] = block[0x03];
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(block, _temp, DefineConstants.OAES_BLOCK_SIZE);

		return OAES_RET.OAES_RET_SUCCESS;
	}

	internal static ushort oaes_gf_mul(ushort left, ushort right)
	{
		size_t _x = new size_t();
		size_t _y = new size_t();

		_x = _y = left;
		_x &= 0x0f;
		_y &= 0xf0;
		_y >>= 4;

		switch (right)
		{
			case 0x02:
				return oaes_gf_mul_2[_y, _x];
				break;
			case 0x03:
				return oaes_gf_mul_3[_y, _x];
				break;
			case 0x09:
				return oaes_gf_mul_9[_y, _x];
				break;
			case 0x0b:
				return oaes_gf_mul_b[_y, _x];
				break;
			case 0x0d:
				return oaes_gf_mul_d[_y, _x];
				break;
			case 0x0e:
				return oaes_gf_mul_e[_y, _x];
				break;
			default:
				return left;
				break;
		}
	}

	internal static OAES_RET oaes_mix_cols(ushort[] word)
	{
		ushort[] _temp = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.OAES_COL_LEN);

		if (word == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		_temp[0] = oaes_gf_mul(word[0], 0x02) ^ oaes_gf_mul(word[1], 0x03) ^ word[2] ^ word[3];
		_temp[1] = word[0] ^ oaes_gf_mul(word[1], 0x02) ^ oaes_gf_mul(word[2], 0x03) ^ word[3];
		_temp[2] = word[0] ^ word[1] ^ oaes_gf_mul(word[2], 0x02) ^ oaes_gf_mul(word[3], 0x03);
		_temp[3] = oaes_gf_mul(word[0], 0x03) ^ word[1] ^ word[2] ^ oaes_gf_mul(word[3], 0x02);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(word, _temp, DefineConstants.OAES_COL_LEN);

		return OAES_RET.OAES_RET_SUCCESS;
	}

	internal static OAES_RET oaes_inv_mix_cols(ushort[] word)
	{
		ushort[] _temp = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.OAES_COL_LEN);

		if (word == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		_temp[0] = oaes_gf_mul(word[0], 0x0e) ^ oaes_gf_mul(word[1], 0x0b) ^ oaes_gf_mul(word[2], 0x0d) ^ oaes_gf_mul(word[3], 0x09);
		_temp[1] = oaes_gf_mul(word[0], 0x09) ^ oaes_gf_mul(word[1], 0x0e) ^ oaes_gf_mul(word[2], 0x0b) ^ oaes_gf_mul(word[3], 0x0d);
		_temp[2] = oaes_gf_mul(word[0], 0x0d) ^ oaes_gf_mul(word[1], 0x09) ^ oaes_gf_mul(word[2], 0x0e) ^ oaes_gf_mul(word[3], 0x0b);
		_temp[3] = oaes_gf_mul(word[0], 0x0b) ^ oaes_gf_mul(word[1], 0x0d) ^ oaes_gf_mul(word[2], 0x09) ^ oaes_gf_mul(word[3], 0x0e);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(word, _temp, DefineConstants.OAES_COL_LEN);

		return OAES_RET.OAES_RET_SUCCESS;
	}

	#if OAES_HAVE_ISAAC
	internal static void oaes_get_seed(string buf)
	{
			#if !__FreeBSD__ && !__OpenBSD__
		timeb timer = new timeb();
		tm gmTimer;
		string _test = null;

		ftime(timer);
		gmTimer = gmtime(timer.time);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
		_test = (string) calloc(sizeof(char), timer.millitm);
//C++ TO C# CONVERTER TODO TASK: The following line has a C format specifier which cannot be directly translated to C#:
//ORIGINAL LINE: sprintf(buf, "%04d%02d%02d%02d%02d%02d%03d%p%d", gmTimer->tm_year + 1900, gmTimer->tm_mon + 1, gmTimer->tm_mday, gmTimer->tm_hour, gmTimer->tm_min, gmTimer->tm_sec, timer.millitm, _test + timer.millitm, getpid());
		buf = string.Format("{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}{6:D3}%p{8:D}", gmTimer.tm_year + 1900, gmTimer.tm_mon + 1, gmTimer.tm_mday, gmTimer.tm_hour, gmTimer.tm_min, gmTimer.tm_sec, timer.millitm, _test + timer.millitm, getpid());
		#else
		timeval timer = new timeval();
		tm gmTimer;
		string _test = null;

		gettimeofday(timer, null);
		gmTimer = gmtime(timer.tv_sec);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
		_test = (string) calloc(sizeof(char), timer.tv_usec / 1000);
//C++ TO C# CONVERTER TODO TASK: The following line has a C format specifier which cannot be directly translated to C#:
//ORIGINAL LINE: sprintf(buf, "%04d%02d%02d%02d%02d%02d%03d%p%d", gmTimer->tm_year + 1900, gmTimer->tm_mon + 1, gmTimer->tm_mday, gmTimer->tm_hour, gmTimer->tm_min, gmTimer->tm_sec, timer.tv_usec/1000, _test + timer.tv_usec/1000, getpid());
		buf = string.Format("{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}{6:D3}%p{8:D}", gmTimer.tm_year + 1900, gmTimer.tm_mon + 1, gmTimer.tm_mday, gmTimer.tm_hour, gmTimer.tm_min, gmTimer.tm_sec, timer.tv_usec / 1000, _test + timer.tv_usec / 1000, getpid());
		#endif

		if (_test != null)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'free' has no equivalent in C#:
			free(_test);
		}
	}
	#else
	internal static uint oaes_get_seed()
	{
			#if !__FreeBSD__ && !__OpenBSD__ && !__ANDROID__
		timeb timer = new timeb();
		tm gmTimer;
		string _test = null;
		uint _ret = 0;

		ftime(timer);
		gmTimer = gmtime(timer.time);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
		_test = (string) calloc(sizeof(char), timer.millitm);
		_ret = gmTimer.tm_year + 1900 + gmTimer.tm_mon + 1 + gmTimer.tm_mday + gmTimer.tm_hour + gmTimer.tm_min + gmTimer.tm_sec + timer.millitm + (uintptr_t)(_test + timer.millitm) + getpid();
		#else
		timeval timer = new timeval();
		tm gmTimer;
		string _test = null;
		uint _ret = 0;

		gettimeofday(timer, null);
		gmTimer = gmtime(timer.tv_sec);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
		_test = (string) calloc(sizeof(char), timer.tv_usec / 1000);
		_ret = gmTimer.tm_year + 1900 + gmTimer.tm_mon + 1 + gmTimer.tm_mday + gmTimer.tm_hour + gmTimer.tm_min + gmTimer.tm_sec + timer.tv_usec / 1000 + (uintptr_t)(_test + timer.tv_usec / 1000) + getpid();
		#endif

		if (_test != null)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'free' has no equivalent in C#:
			free(_test);
		}

		return _ret;
	}
	#endif

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	internal static OAES_RET oaes_key_destroy(oaes_key[] key)
	{
		if (== null = key[0])
		{
			return OAES_RET.OAES_RET_SUCCESS;
		}

		if (key.data)
		{
			key.data = null;
			key.data = null;
		}

		if (key.exp_data)
		{
			key.exp_data = null;
			key.exp_data = null;
		}

		key.data_len = 0;
		key.exp_data_len = 0;
		key.num_keys = 0;
		key.key_base = 0;
		freekey;
		key[0] = null;

		return OAES_RET.OAES_RET_SUCCESS;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	internal static OAES_RET oaes_key_expand(OAES_CTX ctx)
	{
		size_t _i = new size_t();
		size_t _j = new size_t();
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_ctx _ctx = (oaes_ctx) ctx;

		if (_ctx == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		if (_ctx.== null key)
		{
			return OAES_RET.OAES_RET_NOKEY;
		}

		_ctx.key.key_base = _ctx.key.data_len / DefineConstants.OAES_RKEY_LEN;
		_ctx.key.num_keys = _ctx.key.key_base + DefineConstants.OAES_ROUND_BASE;

		_ctx.key.exp_data_len = _ctx.key.num_keys * DefineConstants.OAES_RKEY_LEN * DefineConstants.OAES_COL_LEN;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
		_ctx.key.exp_data = (ushort) calloc(_ctx.key.exp_data_len, sizeof(ushort));

		if (_ctx.== null key.exp_data)
		{
			return OAES_RET.OAES_RET_MEM;
		}

		// the first _ctx->key->data_len are a direct copy
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(_ctx.key.exp_data, _ctx.key.data, _ctx.key.data_len);

		// apply ExpandKey algorithm for remainder
		for (_i = _ctx.key.key_base; _i < _ctx.key.num_keys * DefineConstants.OAES_RKEY_LEN; _i++)
		{
			ushort[] _temp = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.OAES_COL_LEN);

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(_temp, _ctx.key.exp_data + (_i - 1) * DefineConstants.OAES_RKEY_LEN, DefineConstants.OAES_COL_LEN);

			// transform key column
			if (0 == _i % _ctx.key.key_base)
			{
				oaes_word_rot_left(_temp);

				for (_j = 0; _j < DefineConstants.OAES_COL_LEN; _j++)
				{
					oaes_sub_byte(_temp + _j);
				}

				_temp[0] = _temp[0] ^ oaes_gf_8[_i / _ctx.key.key_base - 1];
			}
			else if (_ctx.key.key_base > 6 && 4 == _i % _ctx.key.key_base)
			{
				for (_j = 0; _j < DefineConstants.OAES_COL_LEN; _j++)
				{
					oaes_sub_byte(_temp + _j);
				}
			}

			for (_j = 0; _j < DefineConstants.OAES_COL_LEN; _j++)
			{
				_ctx.key.exp_data[_i * DefineConstants.OAES_RKEY_LEN + _j] = _ctx.key.exp_data[(_i - _ctx.key.key_base) * DefineConstants.OAES_RKEY_LEN + _j] ^ _temp[_j];
			}
		}

		return OAES_RET.OAES_RET_SUCCESS;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	internal static OAES_RET oaes_key_gen(OAES_CTX ctx, size_t key_size)
	{
		size_t _i = new size_t();
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_key _key = null;
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_ctx _ctx = (oaes_ctx) ctx;
		OAES_RET _rc = OAES_RET.OAES_RET_SUCCESS;

		if (_ctx == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
		_key = (oaes_key) calloc(sizeof(oaes_key), 1);

		if (_key == null)
		{
			return OAES_RET.OAES_RET_MEM;
		}

		if (_ctx.key)
		{
			oaes_key_destroy((_ctx.key));
		}

		_key.data_len = key_size;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
		_key.data = (ushort) calloc(key_size, sizeof(ushort));

		if (_key.== null data)
		{
			_key = null;
			return OAES_RET.OAES_RET_MEM;
		}

		for (_i = 0; _i < key_size; _i++)
		{
	#if OAES_HAVE_ISAAC
			_key.data[_i] = (ushort) rand(_ctx.rctx);
		}
	#else
			_key.data[_i] = (ushort) RandomNumbers.NextNumber();
	#endif

		_ctx.key = _key;
		_rc = ((int)_rc) != 0 || ((int)oaes_key_expand(ctx)) != 0;

		if (_rc != OAES_RET.OAES_RET_SUCCESS)
		{
			oaes_key_destroy((_ctx.key));
			return _rc;
		}

		return OAES_RET.OAES_RET_SUCCESS;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	OAES_RET oaes_key_gen_128(OAES_CTX * ctx)
	{
		return oaes_key_gen(ctx, 16);
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	OAES_RET oaes_key_gen_192(OAES_CTX * ctx)
	{
		return oaes_key_gen(ctx, 24);
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	OAES_RET oaes_key_gen_256(OAES_CTX * ctx)
	{
		return oaes_key_gen(ctx, 32);
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	OAES_RET oaes_key_export(OAES_CTX * ctx, ushort * data, size_t * data_len)
	{
		size_t _data_len_in = new size_t();
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_ctx _ctx = (oaes_ctx) ctx;

		if (_ctx == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		if (_ctx.== null key)
		{
			return OAES_RET.OAES_RET_NOKEY;
		}

		if (data_len == null)
		{
			return OAES_RET.OAES_RET_ARG3;
		}

		_data_len_in = data_len;
		// data + header
		*data_len = _ctx.key.data_len + DefineConstants.OAES_BLOCK_SIZE;

		if (data == null)
		{
			return OAES_RET.OAES_RET_SUCCESS;
		}

		if (_data_len_in < *data_len)
		{
			return OAES_RET.OAES_RET_BUF;
		}

		// header
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(data, oaes_header, DefineConstants.OAES_BLOCK_SIZE);
		data[5] = 0x01;
		data[7] = _ctx.key.data_len;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(data + DefineConstants.OAES_BLOCK_SIZE, _ctx.key.data, _ctx.key.data_len);

		return OAES_RET.OAES_RET_SUCCESS;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	OAES_RET oaes_key_export_data(OAES_CTX * ctx, ushort * data, size_t * data_len)
	{
		size_t _data_len_in = new size_t();
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_ctx _ctx = (oaes_ctx) ctx;

		if (_ctx == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		if (_ctx.== null key)
		{
			return OAES_RET.OAES_RET_NOKEY;
		}

		if (data_len == null)
		{
			return OAES_RET.OAES_RET_ARG3;
		}

		_data_len_in = data_len;
		*data_len = _ctx.key.data_len;

		if (data == null)
		{
			return OAES_RET.OAES_RET_SUCCESS;
		}

		if (_data_len_in < *data_len)
		{
			return OAES_RET.OAES_RET_BUF;
		}

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(data, _ctx.key.data, *data_len);

		return OAES_RET.OAES_RET_SUCCESS;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	OAES_RET oaes_key_import(OAES_CTX * ctx, const ushort * data, size_t data_len)
	{
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_ctx _ctx = (oaes_ctx) ctx;
		OAES_RET _rc = OAES_RET.OAES_RET_SUCCESS;
		int _key_length;

		if (_ctx == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		if (data == null)
		{
			return OAES_RET.OAES_RET_ARG2;
		}

		switch (data_len)
		{
			case 16 + DefineConstants.OAES_BLOCK_SIZE:
			case 24 + DefineConstants.OAES_BLOCK_SIZE:
			case 32 + DefineConstants.OAES_BLOCK_SIZE:
				break;
			default:
				return OAES_RET.OAES_RET_ARG3;
		}

		// header
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
		if (0 != memcmp(data, oaes_header, 4))
		{
			return OAES_RET.OAES_RET_HEADER;
		}

		// header version
		switch (data[4])
		{
			case 0x01:
				break;
			default:
				return OAES_RET.OAES_RET_HEADER;
		}

		// header type
		switch (data[5])
		{
			case 0x01:
				break;
			default:
				return OAES_RET.OAES_RET_HEADER;
		}

		// options
		_key_length = data[7];
		switch (_key_length)
		{
			case 16:
			case 24:
			case 32:
				break;
			default:
				return OAES_RET.OAES_RET_HEADER;
		}

		if ((int)data_len != _key_length + DefineConstants.OAES_BLOCK_SIZE)
		{
				return OAES_RET.OAES_RET_ARG3;
		}

		if (_ctx.key)
		{
			oaes_key_destroy((_ctx.key));
		}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
		_ctx.key = (oaes_key) calloc(sizeof(oaes_key), 1);

		if (_ctx.== null key)
		{
			return OAES_RET.OAES_RET_MEM;
		}

		_ctx.key.data_len = _key_length;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
		_ctx.key.data = (ushort) calloc(_key_length, sizeof(ushort));

		if (_ctx.== null key.data)
		{
			oaes_key_destroy((_ctx.key));
			return OAES_RET.OAES_RET_MEM;
		}

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(_ctx.key.data, data + DefineConstants.OAES_BLOCK_SIZE, _key_length);
		_rc = ((int)_rc) != 0 || ((int)oaes_key_expand(ctx)) != 0;

		if (_rc != OAES_RET.OAES_RET_SUCCESS)
		{
			oaes_key_destroy((_ctx.key));
			return _rc;
		}

		return OAES_RET.OAES_RET_SUCCESS;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	OAES_RET oaes_key_import_data(OAES_CTX * ctx, const ushort * data, size_t data_len)
	{
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_ctx _ctx = (oaes_ctx) ctx;
		OAES_RET _rc = OAES_RET.OAES_RET_SUCCESS;

		if (_ctx == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		if (data == null)
		{
			return OAES_RET.OAES_RET_ARG2;
		}

		switch (data_len)
		{
			case 16:
			case 24:
			case 32:
				break;
			default:
				return OAES_RET.OAES_RET_ARG3;
		}

		if (_ctx.key)
		{
			oaes_key_destroy((_ctx.key));
		}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
		_ctx.key = (oaes_key) calloc(sizeof(oaes_key), 1);

		if (_ctx.== null key)
		{
			return OAES_RET.OAES_RET_MEM;
		}

		_ctx.key.data_len = data_len;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'calloc' has no equivalent in C#:
		_ctx.key.data = (ushort) calloc(data_len, sizeof(ushort));

		if (_ctx.== null key.data)
		{
			oaes_key_destroy((_ctx.key));
			return OAES_RET.OAES_RET_MEM;
		}

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(_ctx.key.data, data, data_len);
		_rc = ((int)_rc) != 0 || ((int)oaes_key_expand(ctx)) != 0;

		if (_rc != OAES_RET.OAES_RET_SUCCESS)
		{
			oaes_key_destroy((_ctx.key));
			return _rc;
		}

		return OAES_RET.OAES_RET_SUCCESS;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	OAES_RET oaes_free(OAES_CTX * ctx)
	{
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_ctx[] _ctx = (oaes_ctx) ctx;

		if (_ctx == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		if (== null = _ctx[0])
		{
			return OAES_RET.OAES_RET_SUCCESS;
		}

		if (_ctx.key)
		{
			oaes_key_destroy((_ctx.key));
		}

	#if OAES_HAVE_ISAAC
		if (_ctx.rctx)
		{
			_ctx.rctx = null;
			_ctx.rctx = null;
		}
	#endif

		free_ctx;
		_ctx[0] = null;

		return OAES_RET.OAES_RET_SUCCESS;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	OAES_RET oaes_set_option(OAES_CTX * ctx, OAES_OPTION option, const object * value)
	{
		size_t _i = new size_t();
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_ctx _ctx = (oaes_ctx) ctx;

		if (_ctx == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		switch (option)
		{
			case DefineConstants.OAES_OPTION_ECB:
				_ctx.options &= ~DefineConstants.OAES_OPTION_CBC;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
				memset(_ctx.iv, 0, DefineConstants.OAES_BLOCK_SIZE);
				break;

			case DefineConstants.OAES_OPTION_CBC:
				_ctx.options &= ~DefineConstants.OAES_OPTION_ECB;
				if (value)
				{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(_ctx.iv, value, DefineConstants.OAES_BLOCK_SIZE);
				}
				else
				{
					for (_i = 0; _i < DefineConstants.OAES_BLOCK_SIZE; _i++)
					{
	#if OAES_HAVE_ISAAC
						_ctx.iv[_i] = (ushort) rand(_ctx.rctx);
					}
	#else
						_ctx.iv[_i] = (ushort) RandomNumbers.NextNumber();
	#endif
				}
				break;

	#if OAES_DEBUG

//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			case DefineConstants.OAES_OPTION_STEP_ON:
				if (value)
				{
					_ctx.options &= ~DefineConstants.OAES_OPTION_STEP_OFF;
					_ctx.step_cb = value;
				}
				else
				{
					_ctx.options &= ~DefineConstants.OAES_OPTION_STEP_ON;
					_ctx.options |= DefineConstants.OAES_OPTION_STEP_OFF;
					_ctx.step_cb = null;
					return OAES_RET.OAES_RET_ARG3;
				}
				break;

			case DefineConstants.OAES_OPTION_STEP_OFF:
				_ctx.options &= ~DefineConstants.OAES_OPTION_STEP_ON;
				_ctx.step_cb = null;
				break;

	#endif

//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			default:
				return OAES_RET.OAES_RET_ARG2;
		}

		_ctx.options |= option;

		return OAES_RET.OAES_RET_SUCCESS;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	static OAES_RET oaes_encrypt_block(OAES_CTX * ctx, ushort * c, size_t c_len)
	{
		size_t _i = new size_t();
		size_t _j = new size_t();
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_ctx _ctx = (oaes_ctx) ctx;

		if (_ctx == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		if (c == null)
		{
			return OAES_RET.OAES_RET_ARG2;
		}

		if (c_len != DefineConstants.OAES_BLOCK_SIZE)
		{
			return OAES_RET.OAES_RET_ARG3;
		}

		if (_ctx.== null key)
		{
			return OAES_RET.OAES_RET_NOKEY;
		}

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(c, "input", 1, null);
		}
	#endif

		// AddRoundKey(State, K0)
		for (_i = 0; _i < c_len; _i++)
		{
			c[_i] = c[_i] ^ _ctx.key.exp_data[_i];
		}

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(_ctx.key.exp_data, "k_sch", 1, null);
			_ctx.step_cb(c, "k_add", 1, null);
		}
	#endif

		// for round = 1 step 1 to Nr–1
		for (_i = 1; _i < _ctx.key.num_keys - 1; _i++)
		{
			// SubBytes(state)
			for (_j = 0; _j < c_len; _j++)
			{
				oaes_sub_byte(c + _j);
			}

	#if OAES_DEBUG
			if (_ctx.step_cb)
			{
				_ctx.step_cb(c, "s_box", _i, null);
			}
	#endif

			// ShiftRows(state)
			oaes_shift_rows(c);

	#if OAES_DEBUG
			if (_ctx.step_cb)
			{
				_ctx.step_cb(c, "s_row", _i, null);
			}
	#endif

			// MixColumns(state)
			oaes_mix_cols(c);
			oaes_mix_cols(c + 4);
			oaes_mix_cols(c + 8);
			oaes_mix_cols(c + 12);

	#if OAES_DEBUG
			if (_ctx.step_cb)
			{
				_ctx.step_cb(c, "m_col", _i, null);
			}
	#endif

			// AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
			for (_j = 0; _j < c_len; _j++)
			{
				c[_j] = c[_j] ^ _ctx.key.exp_data[_i * DefineConstants.OAES_RKEY_LEN * DefineConstants.OAES_COL_LEN + _j];
			}

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(_ctx.key.exp_data + _i * DefineConstants.OAES_RKEY_LEN * DefineConstants.OAES_COL_LEN, "k_sch", _i, null);
			_ctx.step_cb(c, "k_add", _i, null);
		}
	#endif

		}

		// SubBytes(state)
		for (_i = 0; _i < c_len; _i++)
		{
			oaes_sub_byte(c + _i);
		}

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(c, "s_box", _ctx.key.num_keys - 1, null);
		}
	#endif

		// ShiftRows(state)
		oaes_shift_rows(c);

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(c, "s_row", _ctx.key.num_keys - 1, null);
		}
	#endif

		// AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
		for (_i = 0; _i < c_len; _i++)
		{
			c[_i] = c[_i] ^ _ctx.key.exp_data[(_ctx.key.num_keys - 1) * DefineConstants.OAES_RKEY_LEN * DefineConstants.OAES_COL_LEN + _i];
		}

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(_ctx.key.exp_data + (_ctx.key.num_keys - 1) * DefineConstants.OAES_RKEY_LEN * DefineConstants.OAES_COL_LEN, "k_sch", _ctx.key.num_keys - 1, null);
			_ctx.step_cb(c, "output", _ctx.key.num_keys - 1, null);
		}
	#endif

		return OAES_RET.OAES_RET_SUCCESS;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	static OAES_RET oaes_decrypt_block(OAES_CTX * ctx, ushort * c, size_t c_len)
	{
		size_t _i = new size_t();
		size_t _j = new size_t();
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_ctx _ctx = (oaes_ctx) ctx;

		if (_ctx == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		if (c == null)
		{
			return OAES_RET.OAES_RET_ARG2;
		}

		if (c_len != DefineConstants.OAES_BLOCK_SIZE)
		{
			return OAES_RET.OAES_RET_ARG3;
		}

		if (_ctx.== null key)
		{
			return OAES_RET.OAES_RET_NOKEY;
		}

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(c, "iinput", _ctx.key.num_keys - 1, null);
		}
	#endif

		// AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
		for (_i = 0; _i < c_len; _i++)
		{
			c[_i] = c[_i] ^ _ctx.key.exp_data[(_ctx.key.num_keys - 1) * DefineConstants.OAES_RKEY_LEN * DefineConstants.OAES_COL_LEN + _i];
		}

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(_ctx.key.exp_data + (_ctx.key.num_keys - 1) * DefineConstants.OAES_RKEY_LEN * DefineConstants.OAES_COL_LEN, "ik_sch", _ctx.key.num_keys - 1, null);
			_ctx.step_cb(c, "ik_add", _ctx.key.num_keys - 1, null);
		}
	#endif

		for (_i = _ctx.key.num_keys - 2; _i > 0; _i--)
		{
			// InvShiftRows(state)
			oaes_inv_shift_rows(c);

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(c, "is_row", _i, null);
		}
	#endif

			// InvSubBytes(state)
			for (_j = 0; _j < c_len; _j++)
			{
				oaes_inv_sub_byte(c + _j);
			}

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(c, "is_box", _i, null);
		}
	#endif

			// AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
			for (_j = 0; _j < c_len; _j++)
			{
				c[_j] = c[_j] ^ _ctx.key.exp_data[_i * DefineConstants.OAES_RKEY_LEN * DefineConstants.OAES_COL_LEN + _j];
			}

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(_ctx.key.exp_data + _i * DefineConstants.OAES_RKEY_LEN * DefineConstants.OAES_COL_LEN, "ik_sch", _i, null);
			_ctx.step_cb(c, "ik_add", _i, null);
		}
	#endif

			// InvMixColums(state)
			oaes_inv_mix_cols(c);
			oaes_inv_mix_cols(c + 4);
			oaes_inv_mix_cols(c + 8);
			oaes_inv_mix_cols(c + 12);

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(c, "im_col", _i, null);
		}
	#endif

		}

		// InvShiftRows(state)
		oaes_inv_shift_rows(c);

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(c, "is_row", 1, null);
		}
	#endif

		// InvSubBytes(state)
		for (_i = 0; _i < c_len; _i++)
		{
			oaes_inv_sub_byte(c + _i);
		}

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(c, "is_box", 1, null);
		}
	#endif

		// AddRoundKey(state, w[0, Nb-1])
		for (_i = 0; _i < c_len; _i++)
		{
			c[_i] = c[_i] ^ _ctx.key.exp_data[_i];
		}

	#if OAES_DEBUG
		if (_ctx.step_cb)
		{
			_ctx.step_cb(_ctx.key.exp_data, "ik_sch", 1, null);
			_ctx.step_cb(c, "ioutput", 1, null);
		}
	#endif

		return OAES_RET.OAES_RET_SUCCESS;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	OAES_RET oaes_encrypt(OAES_CTX * ctx, const ushort * m, size_t m_len, ushort * c, size_t * c_len)
	{
		size_t _i = new size_t();
		size_t _j = new size_t();
		size_t _c_len_in = new size_t();
		size_t _c_data_len = new size_t();
		size_t _pad_len = m_len % DefineConstants.OAES_BLOCK_SIZE == 0 ? 0 : DefineConstants.OAES_BLOCK_SIZE - m_len % DefineConstants.OAES_BLOCK_SIZE;
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_ctx _ctx = (oaes_ctx) ctx;
		OAES_RET _rc = OAES_RET.OAES_RET_SUCCESS;
		ushort _flags = _pad_len != null ? DefineConstants.OAES_FLAG_PAD : 0;

		if (_ctx == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		if (m == null)
		{
			return OAES_RET.OAES_RET_ARG2;
		}

		if (c_len == null)
		{
			return OAES_RET.OAES_RET_ARG5;
		}

		_c_len_in = c_len;
		// data + pad
		_c_data_len = m_len + _pad_len;
		// header + iv + data + pad
		*c_len = 2 * DefineConstants.OAES_BLOCK_SIZE + m_len + _pad_len;

		if (c == null)
		{
			return OAES_RET.OAES_RET_SUCCESS;
		}

		if (_c_len_in < *c_len)
		{
			return OAES_RET.OAES_RET_BUF;
		}

		if (_ctx.== null key)
		{
			return OAES_RET.OAES_RET_NOKEY;
		}

		// header
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(c, oaes_header, DefineConstants.OAES_BLOCK_SIZE);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(c + 6, _ctx.options, sizeof(_ctx.options));
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(c + 8, _flags, sizeof(ushort));
		// iv
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(c + DefineConstants.OAES_BLOCK_SIZE, _ctx.iv, DefineConstants.OAES_BLOCK_SIZE);
		// data
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(c + 2 * DefineConstants.OAES_BLOCK_SIZE, m, m_len);

		for (_i = 0; _i < _c_data_len; _i += DefineConstants.OAES_BLOCK_SIZE)
		{
			ushort[] _block = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.OAES_BLOCK_SIZE);
			size_t _block_size = (((m_len - _i) < (DefineConstants.OAES_BLOCK_SIZE)) ? (m_len - _i) : (DefineConstants.OAES_BLOCK_SIZE));

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(_block, c + 2 * DefineConstants.OAES_BLOCK_SIZE + _i, _block_size);

			// insert pad
			for (_j = 0; _j < DefineConstants.OAES_BLOCK_SIZE - _block_size; _j++)
			{
				_block[_block_size + _j] = _j + 1;
			}

			// CBC
			if ((_ctx.options & DefineConstants.OAES_OPTION_CBC) != 0)
			{
				for (_j = 0; _j < DefineConstants.OAES_BLOCK_SIZE; _j++)
				{
					_block[_j] = _block[_j] ^ _ctx.iv[_j];
				}
			}

			_rc = ((int)_rc) != 0 || ((int)oaes_encrypt_block(ctx, _block, DefineConstants.OAES_BLOCK_SIZE)) != 0;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(c + 2 * DefineConstants.OAES_BLOCK_SIZE + _i, _block, DefineConstants.OAES_BLOCK_SIZE);

			if ((_ctx.options & DefineConstants.OAES_OPTION_CBC) != 0)
			{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(_ctx.iv, _block, DefineConstants.OAES_BLOCK_SIZE);
			}
		}

		return _rc;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	OAES_RET oaes_decrypt(OAES_CTX * ctx, const ushort * c, size_t c_len, ushort * m, size_t * m_len)
	{
		size_t _i = new size_t();
		size_t _j = new size_t();
		size_t _m_len_in = new size_t();
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		oaes_ctx _ctx = (oaes_ctx) ctx;
		OAES_RET _rc = OAES_RET.OAES_RET_SUCCESS;
		ushort[] _iv = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.OAES_BLOCK_SIZE);
		ushort _flags = new ushort();
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		OAES_OPTION _options = new OAES_OPTION();

		if (ctx == null)
		{
			return OAES_RET.OAES_RET_ARG1;
		}

		if (c == null)
		{
			return OAES_RET.OAES_RET_ARG2;
		}

		if (c_len % DefineConstants.OAES_BLOCK_SIZE)
		{
			return OAES_RET.OAES_RET_ARG3;
		}

		if (m_len == null)
		{
			return OAES_RET.OAES_RET_ARG5;
		}

		_m_len_in = m_len;
		*m_len = c_len - 2 * DefineConstants.OAES_BLOCK_SIZE;

		if (m == null)
		{
			return OAES_RET.OAES_RET_SUCCESS;
		}

		if (_m_len_in < *m_len)
		{
			return OAES_RET.OAES_RET_BUF;
		}

		if (_ctx.== null key)
		{
			return OAES_RET.OAES_RET_NOKEY;
		}

		// header
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
		if (0 != memcmp(c, oaes_header, 4))
		{
			return OAES_RET.OAES_RET_HEADER;
		}

		// header version
		switch (c[4])
		{
			case 0x01:
				break;
			default:
				return OAES_RET.OAES_RET_HEADER;
		}

		// header type
		switch (c[5])
		{
			case 0x02:
				break;
			default:
				return OAES_RET.OAES_RET_HEADER;
		}

		// options
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(_options, c + 6, sizeof(OAES_OPTION));
		// validate that all options are valid
	//C++ TO C# CONVERTER TODO TASK: Statements that are interrupted by preprocessor statements are not converted by C++ to C# Converter:
		if (_options & ~(DefineConstants.OAES_OPTION_ECB | DefineConstants.OAES_OPTION_CBC
		{
	#if OAES_DEBUG
	//C++ TO C# CONVERTER TODO TASK: Statements that are interrupted by preprocessor statements are not converted by C++ to C# Converter:
				| DefineConstants.OAES_OPTION_STEP_ON | DefineConstants.OAES_OPTION_STEP_OFF
	#endif
			   )) return OAES_RET.OAES_RET_HEADER;
		}
		if ((_options & DefineConstants.OAES_OPTION_ECB) && (_options & DefineConstants.OAES_OPTION_CBC))
		{
			return OAES_RET.OAES_RET_HEADER;
		}
		if (_options == DefineConstants.OAES_OPTION_NONE)
		{
			return OAES_RET.OAES_RET_HEADER;
		}

		// flags
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(_flags, c + 8, sizeof(ushort));
		// validate that all flags are valid
		if (_flags & ~(DefineConstants.OAES_FLAG_PAD) != null)
		{
			return OAES_RET.OAES_RET_HEADER;
		}

		// iv
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(_iv, c + DefineConstants.OAES_BLOCK_SIZE, DefineConstants.OAES_BLOCK_SIZE);
		// data + pad
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(m, c + 2 * DefineConstants.OAES_BLOCK_SIZE, *m_len);

		for (_i = 0; _i < *m_len; _i += DefineConstants.OAES_BLOCK_SIZE)
		{
			if ((_options & DefineConstants.OAES_OPTION_CBC) && _i > 0)
			{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(_iv, c + DefineConstants.OAES_BLOCK_SIZE + _i, DefineConstants.OAES_BLOCK_SIZE);
			}

			_rc = ((int)_rc) != 0 || ((int)oaes_decrypt_block(ctx, m + _i, (((*m_len - _i) < (DefineConstants.OAES_BLOCK_SIZE)) ? (*m_len - _i) : (DefineConstants.OAES_BLOCK_SIZE)))) != 0;

			// CBC
			if (_options & DefineConstants.OAES_OPTION_CBC != null)
			{
				for (_j = 0; _j < DefineConstants.OAES_BLOCK_SIZE; _j++)
				{
					m[_i + _j] = m[_i + _j] ^ _iv[_j];
				}
			}
		}

		// remove pad
		if (_flags & DefineConstants.OAES_FLAG_PAD != null)
		{
			int _is_pad = 1;
			size_t _temp = (size_t) m[*m_len - 1];

			if (_temp <= 0x00 || _temp > 0x0f)
			{
				return OAES_RET.OAES_RET_HEADER;
			}
			for (_i = 0; _i < _temp; _i++)
			{
				if (m[*m_len - 1 - _i] != _temp - _i)
				{
					_is_pad = 0;
				}
			}
			if (_is_pad != 0)
			{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
				memset(m + *m_len - _temp, 0, _temp);
				*m_len -= _temp;
			}
			else
			{
				return OAES_RET.OAES_RET_HEADER;
			}
		}

		return OAES_RET.OAES_RET_SUCCESS;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	OAES_API OAES_RET oaes_pseudo_encrypt_ecb(OAES_CTX * ctx, ushort * c)
	{
	  size_t _i = new size_t();
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	  oaes_ctx _ctx = (oaes_ctx) ctx;

	  if (_ctx == null)
	  {
		return OAES_RET.OAES_RET_ARG1;
	  }

	  if (c == null)
	  {
		return OAES_RET.OAES_RET_ARG2;
	  }

	  if (_ctx.== null key)
	  {
		return OAES_RET.OAES_RET_NOKEY;
	  }

	  for (_i = 0; _i < 10; ++_i)
	  {
		oaes_encryption_round(_ctx.key.exp_data[_i * DefineConstants.OAES_RKEY_LEN * DefineConstants.OAES_COL_LEN], c);
	  }

	  return OAES_RET.OAES_RET_SUCCESS;
	}


	public static void generate_random_bytes(size_t n, object result)
	{
	#if !NDEBUG
	  Debug.Assert(curstate == 1);
	  curstate = 2;
	#endif
	  if (n == 0)
	  {
	#if !NDEBUG
		Debug.Assert(curstate == 2);
		curstate = 1;
	#endif
		return;
	  }
	  for (;;)
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: hash_permutation(&state);
		hash_permutation(new hash_state(state));
		if (n <= AnonymousEnum.HASH_DATA_AREA)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		  memcpy(result, state, n);
	#if !NDEBUG
		  Debug.Assert(curstate == 2);
		  curstate = 1;
	#endif
		  return;
		}
		else
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		  memcpy(result, state, AnonymousEnum.HASH_DATA_AREA);
		  result = padd(result, AnonymousEnum.HASH_DATA_AREA);
		  n -= AnonymousEnum.HASH_DATA_AREA;
		}
	  }
	}


	#if _WIN32
	internal static void generate_system_random_bytes(size_t n, object result)
	{
	  HCRYPTPROV prov = new HCRYPTPROV();
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define must_succeed(x) do if (!(x)) assert(0); while (0)
	#define must_succeed
	  do
	  {
		  if (!(CryptAcquireContext(prov, null, null, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT)))
		  {
			  Debug.Assert(0);
		  }
	  } while (0 != 0);
	  do
	  {
		  if (!(CryptGenRandom(prov, (uint)n, result)))
		  {
			  Debug.Assert(0);
		  }
	  } while (0 != 0);
	  do
	  {
		  if (!(CryptReleaseContext(prov, 0)))
		  {
			  Debug.Assert(0);
		  }
	  } while (0 != 0);
	#undef must_succeed
	}
	#endif


	#if ! _WIN32


	internal static void generate_system_random_bytes(size_t n, object result)
	{
	  int fd;
	  if ((fd = open("/dev/urandom", O_RDONLY | O_NOCTTY | O_CLOEXEC)) < 0)
	  {
		err(EXIT_FAILURE, "open /dev/urandom");
	  }
	  for (;;)
	  {
		uint res = read(fd, result, n);
		if ((size_t) res == n)
		{
		  break;
		}
		if (res < 0)
		{
		  if (errno != EINTR)
		  {
			err(EXIT_FAILURE, "read /dev/urandom");
		  }
		}
		else if (res == 0)
		{
		  errx(EXIT_FAILURE, "read /dev/urandom: end of file");
		}
		else
		{
		  result = padd(result, (size_t) res);
		  n -= (size_t) res;
		}
	  }
	  if (close(fd) < 0)
	  {
		err(EXIT_FAILURE, "close /dev/urandom");
	  }
	}

	#endif

	internal static hash_state state = new hash_state();

	#if !NDEBUG
//C++ TO C# CONVERTER TODO TASK: 'volatile' has a different meaning in C#:
//ORIGINAL LINE: static volatile int curstate;
	internal static int curstate; // To catch thread safety problems.
	#endif

//C++ TO C# CONVERTER NOTE: __cdecl is not available in C#:
//ORIGINAL LINE: static void __cdecl deinit_random()
	internal static void deinit_random()
	{
	#if !NDEBUG
	  Debug.Assert(curstate == 1);
	  curstate = 0;
	#endif
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
	  memset(state, 0, sizeof(hash_state));
	}

//C++ TO C# CONVERTER NOTE: __cdecl is not available in C#:
//ORIGINAL LINE: static void __cdecl init_random()
	internal static void init_random()
	{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: generate_system_random_bytes(32, &state);
	  generate_system_random_bytes(32, new hash_state(state));
	  do
	  {
		  int _res = atexit(deinit_random);
		  Debug.Assert(_res == 0);
	  } while (0 != 0);
	#if !NDEBUG
	  Debug.Assert(curstate == 0);
	  curstate = 1;
	#endif
	}
	//C++ TO C# CONVERTER WARNING: Most '__declspec' modifiers cannot be converted to C#:
	//ORIGINAL LINE: __declspec(allocate(".CRT$XCT"))void(__cdecl *const _init_random)() = &init_random;
//C++ TO C# CONVERTER TODO TASK: The original C++ function pointer contained an unconverted modifier:
//ORIGINAL LINE: void(__cdecl *const _init_random)() = &init_random;
	public delegate void _init_randomDelegate();
	public static _init_randomDelegate _init_random = init_random;


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* all-in-one hash function */


	/* "all-in-one" call */
	public static HashReturn skein_hash(int hashbitlen, ushort data, size_t databitlen, ushort hashval)
	{
	  hashState state = new hashState();
	  HashReturn r = Init(state, hashbitlen);
	  if (r == HashReturn.SKEIN_SUCCESS)
	  { // these calls do not fail when called properly
		r = Update(state, data, new size_t(databitlen));
		Final(state, hashval);
	  }
	  return r;
	}

	/*   Skein APIs for (incremental) "straight hashing" */
	#if SKEIN_256_NIST_MAX_HASHBITS
	//static int Skein_256_Init(Skein_256_Ctxt_t ctx, size_t hashBitLen);Tangible Method Implementation Not Found-Skein_256_Init
	#endif

/*****************************************************************/
/*     512-bit Skein                                             */
/*****************************************************************/

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* init the context for a straight hashing operation  */
	internal static int Skein_512_Init(Skein_512_Ctxt_t ctx, size_t hashBitLen)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//	union
	//		{
	//		ushort b[(8 *DefineConstants.SKEIN_512_STATE_WORDS)];
	//		ulong w[DefineConstants.SKEIN_512_STATE_WORDS];
	//		}
			cfg; // config block

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_Assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		Skein_Assert(hashBitLen > 0,HashReturn.SKEIN_BAD_HASHLEN);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: ctx->h.hashBitLen = hashBitLen;
		ctx.h.hashBitLen.CopyFrom(hashBitLen); // output hash bit count

		switch (hashBitLen)
		{ // use pre-computed values, where available
	#if ! SKEIN_NO_PRECOMP
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			case 512:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(ctx.X, SKEIN_512_IV_512, sizeof(ulong));
				break;
			case 384:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(ctx.X, SKEIN_512_IV_384, sizeof(ulong));
				break;
			case 256:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(ctx.X, SKEIN_512_IV_256, sizeof(ulong));
				break;
			case 224:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(ctx.X, SKEIN_512_IV_224, sizeof(ulong));
				break;
	#endif
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			default:
				/* here if there is no precomputed IV value available */
				/* build/process the config block, type == CONFIG (could be precomputed) */
			{
					{
						{
							(ctx).h.T[0] = ((0));
					};
					{
							(ctx).h.T[1] = (((((ulong) 1) << ((126) - 64)) | SKEIN_T1_BLK_TYPE_CFG_FINAL));
					};
				};
					(ctx).h.bCnt = 0;
			}; // set tweaks: T0=0; T1=CFG | FINAL

				cfg.w[0] = Skein_Swap64((((0x33414853)) + (((ulong)(DefineConstants.SKEIN_VERSION)) << 32))); // set the schema, version
				cfg.w[1] = Skein_Swap64(hashBitLen); // hash result length in bits
				cfg.w[2] = Skein_Swap64(((((ulong)(0)) << DefineConstants.SKEIN_CFG_TREE_LEAF_SIZE_POS) | (((ulong)(0)) << DefineConstants.SKEIN_CFG_TREE_NODE_SIZE_POS) | (((ulong)(0)) << DefineConstants.SKEIN_CFG_TREE_MAX_LEVEL_POS)));
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
				memset(cfg.w[3], 0, sizeof(cfg) - 3 * sizeof(cfg.w[0])); // zero pad config block

				/* compute the initial chaining values from config block */
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
				memset(ctx.X,0,sizeof(ulong)); // zero the chaining variables
				Skein_512_Process_Block(ctx, cfg.b, 1, DefineConstants.SKEIN_CFG_STR_LEN);
				break;
		}

		/* The chaining vars ctx->X are now initialized for the given hashBitLen. */
		/* Set up to process the data message portion of the hash (default) */
		{
			{
				{
					(ctx).h.T[0] = ((0));
			};
			{
					(ctx).h.T[1] = (((((ulong) 1) << ((126) - 64)) | SKEIN_T1_BLK_TYPE_MSG));
			};
		};
			(ctx).h.bCnt = 0;
	}; // T0=0, T1= MSG type

		return HashReturn.SKEIN_SUCCESS;
	}

/*****************************************************************/
/*    1024-bit Skein                                             */
/*****************************************************************/
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* init the context for a straight hashing operation  */
	internal static int Skein1024_Init(Skein1024_Ctxt_t ctx, size_t hashBitLen)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//	union
	//		{
	//		ushort b[(8 *DefineConstants.SKEIN1024_STATE_WORDS)];
	//		ulong w[DefineConstants.SKEIN1024_STATE_WORDS];
	//		}
			cfg; // config block

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_Assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		Skein_Assert(hashBitLen > 0,HashReturn.SKEIN_BAD_HASHLEN);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: ctx->h.hashBitLen = hashBitLen;
		ctx.h.hashBitLen.CopyFrom(hashBitLen); // output hash bit count

		switch (hashBitLen)
		{ // use pre-computed values, where available
	#if ! SKEIN_NO_PRECOMP
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			case 512:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(ctx.X, SKEIN1024_IV_512, sizeof(ulong));
				break;
			case 384:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(ctx.X, SKEIN1024_IV_384, sizeof(ulong));
				break;
			case 1024:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(ctx.X, SKEIN1024_IV_1024, sizeof(ulong));
				break;
	#endif
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			default:
				/* here if there is no precomputed IV value available */
				/* build/process the config block, type == CONFIG (could be precomputed) */
			{
					{
						{
							(ctx).h.T[0] = ((0));
					};
					{
							(ctx).h.T[1] = (((((ulong) 1) << ((126) - 64)) | SKEIN_T1_BLK_TYPE_CFG_FINAL));
					};
				};
					(ctx).h.bCnt = 0;
			}; // set tweaks: T0=0; T1=CFG | FINAL

				cfg.w[0] = Skein_Swap64((((0x33414853)) + (((ulong)(DefineConstants.SKEIN_VERSION)) << 32))); // set the schema, version
				cfg.w[1] = Skein_Swap64(hashBitLen); // hash result length in bits
				cfg.w[2] = Skein_Swap64(((((ulong)(0)) << DefineConstants.SKEIN_CFG_TREE_LEAF_SIZE_POS) | (((ulong)(0)) << DefineConstants.SKEIN_CFG_TREE_NODE_SIZE_POS) | (((ulong)(0)) << DefineConstants.SKEIN_CFG_TREE_MAX_LEVEL_POS)));
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
				memset(cfg.w[3], 0, sizeof(cfg) - 3 * sizeof(cfg.w[0])); // zero pad config block

				/* compute the initial chaining values from config block */
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
				memset(ctx.X,0,sizeof(ulong)); // zero the chaining variables
				Skein1024_Process_Block(ctx, cfg.b, 1, DefineConstants.SKEIN_CFG_STR_LEN);
				break;
		}

		/* The chaining vars ctx->X are now initialized for the given hashBitLen. */
		/* Set up to process the data message portion of the hash (default) */
		{
			{
				{
					(ctx).h.T[0] = ((0));
			};
			{
					(ctx).h.T[1] = (((((ulong) 1) << ((126) - 64)) | SKEIN_T1_BLK_TYPE_MSG));
			};
		};
			(ctx).h.bCnt = 0;
	}; // T0=0, T1= MSG type

		return HashReturn.SKEIN_SUCCESS;
	}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* process the input bytes */

	#if false
	// /*****************************************************************/
	// /*     256-bit Skein                                             */
	// /*****************************************************************/
	//
	// /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// /* init the context for a straight hashing operation  */
	//static int Skein_256_Init(Skein_256_Ctxt_t *ctx, size_t hashBitLen)
	//    {
	//    union
	//        {
	//        u08b_t  b[SKEIN_256_STATE_BYTES];
	//        u64b_t  w[SKEIN_256_STATE_WORDS];
	//        } cfg;                              // config block 
	//        
	//    Skein_Assert(hashBitLen > 0,SKEIN_BAD_HASHLEN);
	//    ctx->h.hashBitLen = hashBitLen;         // output hash bit count 
	//
	//    switch (hashBitLen)
	//        {             // use pre-computed values, where available 
	//#ifndef SKEIN_NO_PRECOMP
	//        case  256: memcpy(ctx->X,SKEIN_256_IV_256,sizeof(ctx->X));  break;
	//        case  224: memcpy(ctx->X,SKEIN_256_IV_224,sizeof(ctx->X));  break;
	//        case  160: memcpy(ctx->X,SKEIN_256_IV_160,sizeof(ctx->X));  break;
	//        case  128: memcpy(ctx->X,SKEIN_256_IV_128,sizeof(ctx->X));  break;
	//#endif
	//        default:
	// /* here if there is no precomputed IV value available */
	// /* build/process the config block, type == CONFIG (could be precomputed) */
	//            Skein_Start_New_Type(ctx,CFG_FINAL);        // set tweaks: T0=0; T1=CFG | FINAL 
	//
	//            cfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);  // set the schema, version 
	//            cfg.w[1] = Skein_Swap64(hashBitLen);        // hash result length in bits 
	//            cfg.w[2] = Skein_Swap64(SKEIN_CFG_TREE_INFO_SEQUENTIAL);
	//            memset(&cfg.w[3],0,sizeof(cfg) - 3*sizeof(cfg.w[0])); // zero pad config block 
	//
	// /* compute the initial chaining values from config block */
	//            memset(ctx->X,0,sizeof(ctx->X));            // zero the chaining variables 
	//            Skein_256_Process_Block(ctx,cfg.b,1,SKEIN_CFG_STR_LEN);
	//            break;
	//        }
	// /* The chaining vars ctx->X are now initialized for the given hashBitLen. */
	// /* Set up to process the data message portion of the hash (default) */
	//    Skein_Start_New_Type(ctx,MSG);              // T0=0, T1= MSG type 
	//
	//    return SKEIN_SUCCESS;
	//    }
	//
	// /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// /* init the context for a MAC and/or tree hash operation */
	// /* [identical to Skein_256_Init() when keyBytes == 0 && treeInfo == SKEIN_CFG_TREE_INFO_SEQUENTIAL] */
	//static int Skein_256_InitExt(Skein_256_Ctxt_t *ctx,size_t hashBitLen,u64b_t treeInfo, const u08b_t *key, size_t keyBytes)
	//    {
	//    union
	//        {
	//        u08b_t  b[SKEIN_256_STATE_BYTES];
	//        u64b_t  w[SKEIN_256_STATE_WORDS];
	//        } cfg;                              // config block 
	//        
	//    Skein_Assert(hashBitLen > 0,SKEIN_BAD_HASHLEN);
	//    Skein_Assert(keyBytes == 0 || key != NULL,SKEIN_FAIL);
	//
	// /* compute the initial chaining values ctx->X[], based on key */
	//    if (keyBytes == 0)                          // is there a key? 
	//        {                                   
	//        memset(ctx->X,0,sizeof(ctx->X));        // no key: use all zeroes as key for config block 
	//        }
	//    else                                        // here to pre-process a key 
	//        {
	//        Skein_assert(sizeof(cfg.b) >= sizeof(ctx->X));
	// /* do a mini-Init right here */
	//        ctx->h.hashBitLen=8*sizeof(ctx->X);     // set output hash bit count = state size 
	//        Skein_Start_New_Type(ctx,KEY);          // set tweaks: T0 = 0; T1 = KEY type 
	//        memset(ctx->X,0,sizeof(ctx->X));        // zero the initial chaining variables 
	//        Skein_256_Update(ctx,key,keyBytes);     // hash the key 
	//        Skein_256_Final_Pad(ctx,cfg.b);         // put result into cfg.b[] 
	//        memcpy(ctx->X,cfg.b,sizeof(cfg.b));     // copy over into ctx->X[] 
	//#if SKEIN_NEED_SWAP
	//        {
	//        uint_t i;
	//        for (i=0;i<SKEIN_256_STATE_WORDS;i++)   // convert key bytes to context words 
	//            ctx->X[i] = Skein_Swap64(ctx->X[i]);
	//        }
	//#endif
	//        }
	// /* build/process the config block, type == CONFIG (could be precomputed for each key) */
	//    ctx->h.hashBitLen = hashBitLen;             // output hash bit count 
	//    Skein_Start_New_Type(ctx,CFG_FINAL);
	//
	//    memset(&cfg.w,0,sizeof(cfg.w));             // pre-pad cfg.w[] with zeroes 
	//    cfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);
	//    cfg.w[1] = Skein_Swap64(hashBitLen);        // hash result length in bits 
	//    cfg.w[2] = Skein_Swap64(treeInfo);          // tree hash config info (or SKEIN_CFG_TREE_INFO_SEQUENTIAL) 
	//
	//    Skein_Show_Key(256,&ctx->h,key,keyBytes);
	//
	// /* compute the initial chaining values from config block */
	//    Skein_256_Process_Block(ctx,cfg.b,1,SKEIN_CFG_STR_LEN);
	//
	// /* The chaining vars ctx->X are now initialized */
	// /* Set up to process the data message portion of the hash (default) */
	//    ctx->h.bCnt = 0;                            // buffer b[] starts out empty 
	//    Skein_Start_New_Type(ctx,MSG);
	//    
	//    return SKEIN_SUCCESS;
	//    }
	#endif
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'msg', so pointers on this parameter are left unchanged:
	internal static int Skein_256_Update(Skein_256_Ctxt_t ctx, ushort * msg, size_t msgByteCnt)
	{
		size_t n = new size_t();

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_Assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		Skein_Assert(ctx.h.bCnt <= (8 * DefineConstants.SKEIN_256_STATE_WORDS),HashReturn.SKEIN_FAIL); // catch uninitialized context

		/* process full blocks, if any */
		if (msgByteCnt + ctx.h.bCnt > (8 * DefineConstants.SKEIN_256_STATE_WORDS) != null)
		{
			if (ctx.h.bCnt != null) // finish up any buffered message data
			{
				n = (8 * DefineConstants.SKEIN_256_STATE_WORDS) - ctx.h.bCnt; // # bytes free in buffer b[]
				if (n != null)
				{
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					Skein_assert(n < msgByteCnt); // check on our logic here
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(ctx.b[ctx.h.bCnt], new ushort(msg), new size_t(n));
					msgByteCnt -= n;
					msg += n;
					ctx.h.bCnt += n;
				}
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				Skein_assert(ctx.h.bCnt == (8 * DefineConstants.SKEIN_256_STATE_WORDS));
				Skein_256_Process_Block(ctx, ctx.b, 1, (8 * DefineConstants.SKEIN_256_STATE_WORDS));
				ctx.h.bCnt = 0;
			}
			/* now process any remaining full blocks, directly from input message data */
			if (msgByteCnt > (8 * DefineConstants.SKEIN_256_STATE_WORDS))
			{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: n = (msgByteCnt-1) / (8 *DefineConstants.SKEIN_256_STATE_WORDS);
				n.CopyFrom((msgByteCnt - 1) / (8 * DefineConstants.SKEIN_256_STATE_WORDS)); // number of full blocks to process
				Skein_256_Process_Block(ctx, new ushort(msg), new size_t(n), (8 * DefineConstants.SKEIN_256_STATE_WORDS));
				msgByteCnt -= n * (8 * DefineConstants.SKEIN_256_STATE_WORDS);
				msg += n * (8 * DefineConstants.SKEIN_256_STATE_WORDS);
			}
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			Skein_assert(ctx.h.bCnt == 0);
		}

		/* copy any remaining source message data bytes into b[] */
		if (msgByteCnt != null)
		{
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			Skein_assert(msgByteCnt + ctx.h.bCnt <= (8 * DefineConstants.SKEIN_256_STATE_WORDS));
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(ctx.b[ctx.h.bCnt], new ushort(msg), new size_t(msgByteCnt));
			ctx.h.bCnt += msgByteCnt;
		}

		return HashReturn.SKEIN_SUCCESS;
	}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* process the input bytes */
	#if false
	// /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// /* init the context for a MAC and/or tree hash operation */
	// /* [identical to Skein_512_Init() when keyBytes == 0 && treeInfo == SKEIN_CFG_TREE_INFO_SEQUENTIAL] */
	//static int Skein_512_InitExt(Skein_512_Ctxt_t *ctx,size_t hashBitLen,u64b_t treeInfo, const u08b_t *key, size_t keyBytes)
	//    {
	//    union
	//        {
	//        u08b_t  b[SKEIN_512_STATE_BYTES];
	//        u64b_t  w[SKEIN_512_STATE_WORDS];
	//        } cfg;                              // config block 
	//        
	//    Skein_Assert(hashBitLen > 0,SKEIN_BAD_HASHLEN);
	//    Skein_Assert(keyBytes == 0 || key != NULL,SKEIN_FAIL);
	//
	// /* compute the initial chaining values ctx->X[], based on key */
	//    if (keyBytes == 0)                          // is there a key? 
	//        {                                   
	//        memset(ctx->X,0,sizeof(ctx->X));        // no key: use all zeroes as key for config block 
	//        }
	//    else                                        // here to pre-process a key 
	//        {
	//        Skein_assert(sizeof(cfg.b) >= sizeof(ctx->X));
	// /* do a mini-Init right here */
	//        ctx->h.hashBitLen=8*sizeof(ctx->X);     // set output hash bit count = state size 
	//        Skein_Start_New_Type(ctx,KEY);          // set tweaks: T0 = 0; T1 = KEY type 
	//        memset(ctx->X,0,sizeof(ctx->X));        // zero the initial chaining variables 
	//        Skein_512_Update(ctx,key,keyBytes);     // hash the key 
	//        Skein_512_Final_Pad(ctx,cfg.b);         // put result into cfg.b[] 
	//        memcpy(ctx->X,cfg.b,sizeof(cfg.b));     // copy over into ctx->X[] 
	//#if SKEIN_NEED_SWAP
	//        {
	//        uint_t i;
	//        for (i=0;i<SKEIN_512_STATE_WORDS;i++)   // convert key bytes to context words 
	//            ctx->X[i] = Skein_Swap64(ctx->X[i]);
	//        }
	//#endif
	//        }
	// /* build/process the config block, type == CONFIG (could be precomputed for each key) */
	//    ctx->h.hashBitLen = hashBitLen;             // output hash bit count 
	//    Skein_Start_New_Type(ctx,CFG_FINAL);
	//
	//    memset(&cfg.w,0,sizeof(cfg.w));             // pre-pad cfg.w[] with zeroes 
	//    cfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);
	//    cfg.w[1] = Skein_Swap64(hashBitLen);        // hash result length in bits 
	//    cfg.w[2] = Skein_Swap64(treeInfo);          // tree hash config info (or SKEIN_CFG_TREE_INFO_SEQUENTIAL) 
	//
	//    Skein_Show_Key(512,&ctx->h,key,keyBytes);
	//
	// /* compute the initial chaining values from config block */
	//    Skein_512_Process_Block(ctx,cfg.b,1,SKEIN_CFG_STR_LEN);
	//
	// /* The chaining vars ctx->X are now initialized */
	// /* Set up to process the data message portion of the hash (default) */
	//    ctx->h.bCnt = 0;                            // buffer b[] starts out empty 
	//    Skein_Start_New_Type(ctx,MSG);
	//    
	//    return SKEIN_SUCCESS;
	//    }
	#endif
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'msg', so pointers on this parameter are left unchanged:
	internal static int Skein_512_Update(Skein_512_Ctxt_t ctx, ushort * msg, size_t msgByteCnt)
	{
		size_t n = new size_t();

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_Assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		Skein_Assert(ctx.h.bCnt <= (8 * DefineConstants.SKEIN_512_STATE_WORDS),HashReturn.SKEIN_FAIL); // catch uninitialized context

		/* process full blocks, if any */
		if (msgByteCnt + ctx.h.bCnt > (8 * DefineConstants.SKEIN_512_STATE_WORDS) != null)
		{
			if (ctx.h.bCnt != null) // finish up any buffered message data
			{
				n = (8 * DefineConstants.SKEIN_512_STATE_WORDS) - ctx.h.bCnt; // # bytes free in buffer b[]
				if (n != null)
				{
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					Skein_assert(n < msgByteCnt); // check on our logic here
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(ctx.b[ctx.h.bCnt], new ushort(msg), new size_t(n));
					msgByteCnt -= n;
					msg += n;
					ctx.h.bCnt += n;
				}
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				Skein_assert(ctx.h.bCnt == (8 * DefineConstants.SKEIN_512_STATE_WORDS));
				Skein_512_Process_Block(ctx, ctx.b, 1, (8 * DefineConstants.SKEIN_512_STATE_WORDS));
				ctx.h.bCnt = 0;
			}
			/* now process any remaining full blocks, directly from input message data */
			if (msgByteCnt > (8 * DefineConstants.SKEIN_512_STATE_WORDS))
			{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: n = (msgByteCnt-1) / (8 *DefineConstants.SKEIN_512_STATE_WORDS);
				n.CopyFrom((msgByteCnt - 1) / (8 * DefineConstants.SKEIN_512_STATE_WORDS)); // number of full blocks to process
				Skein_512_Process_Block(ctx, new ushort(msg), new size_t(n), (8 * DefineConstants.SKEIN_512_STATE_WORDS));
				msgByteCnt -= n * (8 * DefineConstants.SKEIN_512_STATE_WORDS);
				msg += n * (8 * DefineConstants.SKEIN_512_STATE_WORDS);
			}
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			Skein_assert(ctx.h.bCnt == 0);
		}

		/* copy any remaining source message data bytes into b[] */
		if (msgByteCnt != null)
		{
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			Skein_assert(msgByteCnt + ctx.h.bCnt <= (8 * DefineConstants.SKEIN_512_STATE_WORDS));
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(ctx.b[ctx.h.bCnt], new ushort(msg), new size_t(msgByteCnt));
			ctx.h.bCnt += msgByteCnt;
		}

		return HashReturn.SKEIN_SUCCESS;
	}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* process the input bytes */
	#if false
	// /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// /* init the context for a MAC and/or tree hash operation */
	// /* [identical to Skein1024_Init() when keyBytes == 0 && treeInfo == SKEIN_CFG_TREE_INFO_SEQUENTIAL] */
	//static int Skein1024_InitExt(Skein1024_Ctxt_t *ctx,size_t hashBitLen,u64b_t treeInfo, const u08b_t *key, size_t keyBytes)
	//    {
	//    union
	//        {
	//        u08b_t  b[SKEIN1024_STATE_BYTES];
	//        u64b_t  w[SKEIN1024_STATE_WORDS];
	//        } cfg;                              // config block 
	//        
	//    Skein_Assert(hashBitLen > 0,SKEIN_BAD_HASHLEN);
	//    Skein_Assert(keyBytes == 0 || key != NULL,SKEIN_FAIL);
	//
	// /* compute the initial chaining values ctx->X[], based on key */
	//    if (keyBytes == 0)                          // is there a key? 
	//        {                                   
	//        memset(ctx->X,0,sizeof(ctx->X));        // no key: use all zeroes as key for config block 
	//        }
	//    else                                        // here to pre-process a key 
	//        {
	//        Skein_assert(sizeof(cfg.b) >= sizeof(ctx->X));
	// /* do a mini-Init right here */
	//        ctx->h.hashBitLen=8*sizeof(ctx->X);     // set output hash bit count = state size 
	//        Skein_Start_New_Type(ctx,KEY);          // set tweaks: T0 = 0; T1 = KEY type 
	//        memset(ctx->X,0,sizeof(ctx->X));        // zero the initial chaining variables 
	//        Skein1024_Update(ctx,key,keyBytes);     // hash the key 
	//        Skein1024_Final_Pad(ctx,cfg.b);         // put result into cfg.b[] 
	//        memcpy(ctx->X,cfg.b,sizeof(cfg.b));     // copy over into ctx->X[] 
	//#if SKEIN_NEED_SWAP
	//        {
	//        uint_t i;
	//        for (i=0;i<SKEIN1024_STATE_WORDS;i++)   // convert key bytes to context words 
	//            ctx->X[i] = Skein_Swap64(ctx->X[i]);
	//        }
	//#endif
	//        }
	// /* build/process the config block, type == CONFIG (could be precomputed for each key) */
	//    ctx->h.hashBitLen = hashBitLen;             // output hash bit count 
	//    Skein_Start_New_Type(ctx,CFG_FINAL);
	//
	//    memset(&cfg.w,0,sizeof(cfg.w));             // pre-pad cfg.w[] with zeroes 
	//    cfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);
	//    cfg.w[1] = Skein_Swap64(hashBitLen);        // hash result length in bits 
	//    cfg.w[2] = Skein_Swap64(treeInfo);          // tree hash config info (or SKEIN_CFG_TREE_INFO_SEQUENTIAL) 
	//
	//    Skein_Show_Key(1024,&ctx->h,key,keyBytes);
	//
	// /* compute the initial chaining values from config block */
	//    Skein1024_Process_Block(ctx,cfg.b,1,SKEIN_CFG_STR_LEN);
	//
	// /* The chaining vars ctx->X are now initialized */
	// /* Set up to process the data message portion of the hash (default) */
	//    ctx->h.bCnt = 0;                            // buffer b[] starts out empty 
	//    Skein_Start_New_Type(ctx,MSG);
	//    
	//    return SKEIN_SUCCESS;
	//    }
	#endif
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'msg', so pointers on this parameter are left unchanged:
	internal static int Skein1024_Update(Skein1024_Ctxt_t ctx, ushort * msg, size_t msgByteCnt)
	{
		size_t n = new size_t();

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_Assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		Skein_Assert(ctx.h.bCnt <= (8 * DefineConstants.SKEIN1024_STATE_WORDS),HashReturn.SKEIN_FAIL); // catch uninitialized context

		/* process full blocks, if any */
		if (msgByteCnt + ctx.h.bCnt > (8 * DefineConstants.SKEIN1024_STATE_WORDS) != null)
		{
			if (ctx.h.bCnt != null) // finish up any buffered message data
			{
				n = (8 * DefineConstants.SKEIN1024_STATE_WORDS) - ctx.h.bCnt; // # bytes free in buffer b[]
				if (n != null)
				{
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					Skein_assert(n < msgByteCnt); // check on our logic here
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
					memcpy(ctx.b[ctx.h.bCnt], new ushort(msg), new size_t(n));
					msgByteCnt -= n;
					msg += n;
					ctx.h.bCnt += n;
				}
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				Skein_assert(ctx.h.bCnt == (8 * DefineConstants.SKEIN1024_STATE_WORDS));
				Skein1024_Process_Block(ctx, ctx.b, 1, (8 * DefineConstants.SKEIN1024_STATE_WORDS));
				ctx.h.bCnt = 0;
			}
			/* now process any remaining full blocks, directly from input message data */
			if (msgByteCnt > (8 * DefineConstants.SKEIN1024_STATE_WORDS))
			{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: n = (msgByteCnt-1) / (8 *DefineConstants.SKEIN1024_STATE_WORDS);
				n.CopyFrom((msgByteCnt - 1) / (8 * DefineConstants.SKEIN1024_STATE_WORDS)); // number of full blocks to process
				Skein1024_Process_Block(ctx, new ushort(msg), new size_t(n), (8 * DefineConstants.SKEIN1024_STATE_WORDS));
				msgByteCnt -= n * (8 * DefineConstants.SKEIN1024_STATE_WORDS);
				msg += n * (8 * DefineConstants.SKEIN1024_STATE_WORDS);
			}
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			Skein_assert(ctx.h.bCnt == 0);
		}

		/* copy any remaining source message data bytes into b[] */
		if (msgByteCnt != null)
		{
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			Skein_assert(msgByteCnt + ctx.h.bCnt <= (8 * DefineConstants.SKEIN1024_STATE_WORDS));
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(ctx.b[ctx.h.bCnt], new ushort(msg), new size_t(msgByteCnt));
			ctx.h.bCnt += msgByteCnt;
		}

		return HashReturn.SKEIN_SUCCESS;
	}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* finalize the hash computation and output the result */

	internal static int Skein_256_Final(Skein_256_Ctxt_t ctx, ushort hashVal)
	{
		size_t i = new size_t();
		size_t n = new size_t();
		size_t byteCnt = new size_t();
		ulong[] X = Arrays.InitializeWithDefaultInstances<ulong>(DefineConstants.SKEIN_256_STATE_WORDS);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_Assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		Skein_Assert(ctx.h.bCnt <= (8 * DefineConstants.SKEIN_256_STATE_WORDS),HashReturn.SKEIN_FAIL); // catch uninitialized context

		ctx.h.T[1] |= (((ulong) 1) << ((127) - 64)); // tag as the final block
		if (ctx.h.bCnt < (8 * DefineConstants.SKEIN_256_STATE_WORDS)) // zero pad b[] if necessary
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
			memset(ctx.b[ctx.h.bCnt], 0, (8 * DefineConstants.SKEIN_256_STATE_WORDS) - ctx.h.bCnt);
		}

		Skein_256_Process_Block(ctx, ctx.b, 1, new size_t(ctx.h.bCnt)); // process the final block

		/* now output the result */
		byteCnt = (ctx.h.hashBitLen + 7) >> 3; // total number of output bytes

		/* run Threefish in "counter mode" to generate output */
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(ctx.b,0,sizeof(ctx.b)); // zero out b[], so it can hold the counter
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(X, ctx.X, sizeof(ulong)); // keep a local copy of counter mode "key"
		for (i = 0;i * (8 * DefineConstants.SKEIN_256_STATE_WORDS) < byteCnt;i++)
		{
			((ulong)ctx.b)[0] = Skein_Swap64((ulong) i); // build the counter block
			{
				{
					{
						(ctx).h.T[0] = ((0));
				};
				{
						(ctx).h.T[1] = (((((ulong) 1) << ((126) - 64)) | SKEIN_T1_BLK_TYPE_OUT_FINAL));
				};
			};
				(ctx).h.bCnt = 0;
			};
			Skein_256_Process_Block(ctx, ctx.b, 1, sizeof(ulong)); // run "counter mode"
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: n = byteCnt - i*(8 *DefineConstants.SKEIN_256_STATE_WORDS);
			n.CopyFrom(byteCnt - i * (8 * DefineConstants.SKEIN_256_STATE_WORDS)); // number of output bytes left to go
			if (n >= (8 * DefineConstants.SKEIN_256_STATE_WORDS))
			{
				n = (8 * DefineConstants.SKEIN_256_STATE_WORDS);
			}
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(hashVal + i * (8 * DefineConstants.SKEIN_256_STATE_WORDS), ctx.X, new size_t(n)); // "output" the ctr mode bytes
			;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(ctx.X, X, sizeof(ulong)); // restore the counter mode key for next time
		}
		return HashReturn.SKEIN_SUCCESS;
	}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* finalize the hash computation and output the result */
	internal static int Skein_512_Final(Skein_512_Ctxt_t ctx, ushort hashVal)
	{
		size_t i = new size_t();
		size_t n = new size_t();
		size_t byteCnt = new size_t();
		ulong[] X = Arrays.InitializeWithDefaultInstances<ulong>(DefineConstants.SKEIN_512_STATE_WORDS);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_Assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		Skein_Assert(ctx.h.bCnt <= (8 * DefineConstants.SKEIN_512_STATE_WORDS),HashReturn.SKEIN_FAIL); // catch uninitialized context

		ctx.h.T[1] |= (((ulong) 1) << ((127) - 64)); // tag as the final block
		if (ctx.h.bCnt < (8 * DefineConstants.SKEIN_512_STATE_WORDS)) // zero pad b[] if necessary
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
			memset(ctx.b[ctx.h.bCnt], 0, (8 * DefineConstants.SKEIN_512_STATE_WORDS) - ctx.h.bCnt);
		}

		Skein_512_Process_Block(ctx, ctx.b, 1, new size_t(ctx.h.bCnt)); // process the final block

		/* now output the result */
		byteCnt = (ctx.h.hashBitLen + 7) >> 3; // total number of output bytes

		/* run Threefish in "counter mode" to generate output */
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(ctx.b,0,sizeof(ctx.b)); // zero out b[], so it can hold the counter
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(X, ctx.X, sizeof(ulong)); // keep a local copy of counter mode "key"
		for (i = 0;i * (8 * DefineConstants.SKEIN_512_STATE_WORDS) < byteCnt;i++)
		{
			((ulong)ctx.b)[0] = Skein_Swap64((ulong) i); // build the counter block
			{
				{
					{
						(ctx).h.T[0] = ((0));
				};
				{
						(ctx).h.T[1] = (((((ulong) 1) << ((126) - 64)) | SKEIN_T1_BLK_TYPE_OUT_FINAL));
				};
			};
				(ctx).h.bCnt = 0;
			};
			Skein_512_Process_Block(ctx, ctx.b, 1, sizeof(ulong)); // run "counter mode"
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: n = byteCnt - i*(8 *DefineConstants.SKEIN_512_STATE_WORDS);
			n.CopyFrom(byteCnt - i * (8 * DefineConstants.SKEIN_512_STATE_WORDS)); // number of output bytes left to go
			if (n >= (8 * DefineConstants.SKEIN_512_STATE_WORDS))
			{
				n = (8 * DefineConstants.SKEIN_512_STATE_WORDS);
			}
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(hashVal + i * (8 * DefineConstants.SKEIN_512_STATE_WORDS), ctx.X, new size_t(n)); // "output" the ctr mode bytes
			;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(ctx.X, X, sizeof(ulong)); // restore the counter mode key for next time
		}
		return HashReturn.SKEIN_SUCCESS;
	}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* finalize the hash computation and output the result */
	internal static int Skein1024_Final(Skein1024_Ctxt_t ctx, ushort hashVal)
	{
		size_t i = new size_t();
		size_t n = new size_t();
		size_t byteCnt = new size_t();
		ulong[] X = Arrays.InitializeWithDefaultInstances<ulong>(DefineConstants.SKEIN1024_STATE_WORDS);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_Assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		Skein_Assert(ctx.h.bCnt <= (8 * DefineConstants.SKEIN1024_STATE_WORDS),HashReturn.SKEIN_FAIL); // catch uninitialized context

		ctx.h.T[1] |= (((ulong) 1) << ((127) - 64)); // tag as the final block
		if (ctx.h.bCnt < (8 * DefineConstants.SKEIN1024_STATE_WORDS)) // zero pad b[] if necessary
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
			memset(ctx.b[ctx.h.bCnt], 0, (8 * DefineConstants.SKEIN1024_STATE_WORDS) - ctx.h.bCnt);
		}

		Skein1024_Process_Block(ctx, ctx.b, 1, new size_t(ctx.h.bCnt)); // process the final block

		/* now output the result */
		byteCnt = (ctx.h.hashBitLen + 7) >> 3; // total number of output bytes

		/* run Threefish in "counter mode" to generate output */
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(ctx.b,0,sizeof(ctx.b)); // zero out b[], so it can hold the counter
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(X, ctx.X, sizeof(ulong)); // keep a local copy of counter mode "key"
		for (i = 0;i * (8 * DefineConstants.SKEIN1024_STATE_WORDS) < byteCnt;i++)
		{
			((ulong)ctx.b)[0] = Skein_Swap64((ulong) i); // build the counter block
			{
				{
					{
						(ctx).h.T[0] = ((0));
				};
				{
						(ctx).h.T[1] = (((((ulong) 1) << ((126) - 64)) | SKEIN_T1_BLK_TYPE_OUT_FINAL));
				};
			};
				(ctx).h.bCnt = 0;
			};
			Skein1024_Process_Block(ctx, ctx.b, 1, sizeof(ulong)); // run "counter mode"
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: n = byteCnt - i*(8 *DefineConstants.SKEIN1024_STATE_WORDS);
			n.CopyFrom(byteCnt - i * (8 * DefineConstants.SKEIN1024_STATE_WORDS)); // number of output bytes left to go
			if (n >= (8 * DefineConstants.SKEIN1024_STATE_WORDS))
			{
				n = (8 * DefineConstants.SKEIN1024_STATE_WORDS);
			}
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(hashVal + i * (8 * DefineConstants.SKEIN1024_STATE_WORDS), ctx.X, new size_t(n)); // "output" the ctr mode bytes
			;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(ctx.X, X, sizeof(ulong)); // restore the counter mode key for next time
		}
		return HashReturn.SKEIN_SUCCESS;
	}

	/*
	**   Skein APIs for "extended" initialization: MAC keys, tree hashing.
	**   After an InitExt() call, just use Update/Final calls as with Init().
	**
	**   Notes: Same parameters as _Init() calls, plus treeInfo/key/keyBytes.
	**          When keyBytes == 0 and treeInfo == SKEIN_SEQUENTIAL, 
	**              the results of InitExt() are identical to calling Init().
	**          The function Init() may be called once to "precompute" the IV for
	**              a given hashBitLen value, then by saving a copy of the context
	**              the IV computation may be avoided in later calls.
	**          Similarly, the function InitExt() may be called once per MAC key 
	**              to precompute the MAC IV, then a copy of the context saved and
	**              reused for each new MAC computation.
	**/
	#if false
	//static int  Skein_256_InitExt(Skein_256_Ctxt_t *ctx, size_t hashBitLen, u64b_t treeInfo, const u08b_t *key, size_t keyBytes);
	//static int  Skein_512_InitExt(Skein_512_Ctxt_t *ctx, size_t hashBitLen, u64b_t treeInfo, const u08b_t *key, size_t keyBytes);
	//static int  Skein1024_InitExt(Skein1024_Ctxt_t *ctx, size_t hashBitLen, u64b_t treeInfo, const u08b_t *key, size_t keyBytes);
	#endif

	/*
	**   Skein APIs for MAC and tree hash:
	**      Final_Pad:  pad, do final block, but no OUTPUT type
	**      Output:     do just the output stage
	*/
	#if false
	//static int  Skein_256_Final_Pad(Skein_256_Ctxt_t *ctx, u08b_t * hashVal);
	//static int  Skein_512_Final_Pad(Skein_512_Ctxt_t *ctx, u08b_t * hashVal);
	//static int  Skein1024_Final_Pad(Skein1024_Ctxt_t *ctx, u08b_t * hashVal);
	#endif

	#if false
	//#if  SKEIN_TREE_HASH
	//static int  Skein_256_Output   (Skein_256_Ctxt_t *ctx, u08b_t * hashVal);
	//static int  Skein_512_Output   (Skein_512_Ctxt_t *ctx, u08b_t * hashVal);
	//static int  Skein1024_Output   (Skein1024_Ctxt_t *ctx, u08b_t * hashVal);
	//#endif
	#endif

	/*****************************************************************
	** "Internal" Skein definitions
	**    -- not needed for sequential hashing API, but will be 
	**           helpful for other uses of Skein (e.g., tree hash mode).
	**    -- included here so that they can be shared between
	**           reference and optimized code.
	******************************************************************/

	/* tweak word T[1]: bit field starting positions */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BIT(BIT) ((BIT) - 64)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_POS_TREE_LVL SKEIN_T1_BIT(112)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_POS_BIT_PAD SKEIN_T1_BIT(119)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_POS_BLK_TYPE SKEIN_T1_BIT(120)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_POS_FIRST SKEIN_T1_BIT(126)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_POS_FINAL SKEIN_T1_BIT(127)

	/* tweak word T[1]: flag bit definition(s) */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_FLAG_FIRST (((u64b_t) 1 ) << SKEIN_T1_POS_FIRST)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_FLAG_FINAL (((u64b_t) 1 ) << SKEIN_T1_POS_FINAL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_FLAG_BIT_PAD (((u64b_t) 1 ) << SKEIN_T1_POS_BIT_PAD)

	/* tweak word T[1]: tree level bit field mask */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_TREE_LVL_MASK (((u64b_t)0x7F) << SKEIN_T1_POS_TREE_LVL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_TREE_LEVEL(n) (((u64b_t) (n)) << SKEIN_T1_POS_TREE_LVL)

	/* tweak word T[1]: block type field */

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BLK_TYPE(T) (((u64b_t) (SKEIN_BLK_TYPE_##T)) << SKEIN_T1_POS_BLK_TYPE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BLK_TYPE_KEY SKEIN_T1_BLK_TYPE(KEY)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BLK_TYPE_CFG SKEIN_T1_BLK_TYPE(CFG)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BLK_TYPE_PERS SKEIN_T1_BLK_TYPE(PERS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BLK_TYPE_PK SKEIN_T1_BLK_TYPE(PK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BLK_TYPE_KDF SKEIN_T1_BLK_TYPE(KDF)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BLK_TYPE_NONCE SKEIN_T1_BLK_TYPE(NONCE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BLK_TYPE_MSG SKEIN_T1_BLK_TYPE(MSG)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BLK_TYPE_OUT SKEIN_T1_BLK_TYPE(OUT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BLK_TYPE_MASK SKEIN_T1_BLK_TYPE(MASK)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BLK_TYPE_CFG_FINAL (SKEIN_T1_BLK_TYPE_CFG | SKEIN_T1_FLAG_FINAL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_T1_BLK_TYPE_OUT_FINAL (SKEIN_T1_BLK_TYPE_OUT | SKEIN_T1_FLAG_FINAL)


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_ID_STRING_LE (0x33414853)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_MK_64(hi32,lo32) ((lo32) + (((u64b_t) (hi32)) << 32))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_SCHEMA_VER SKEIN_MK_64(SKEIN_VERSION,SKEIN_ID_STRING_LE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_KS_PARITY SKEIN_MK_64(0x1BD11BDA,0xA9FC1A22)


	/* bit field definitions in config block treeInfo word */

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_CFG_TREE_LEAF_SIZE_MSK (((u64b_t) 0xFF) << SKEIN_CFG_TREE_LEAF_SIZE_POS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_CFG_TREE_NODE_SIZE_MSK (((u64b_t) 0xFF) << SKEIN_CFG_TREE_NODE_SIZE_POS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_CFG_TREE_MAX_LEVEL_MSK (((u64b_t) 0xFF) << SKEIN_CFG_TREE_MAX_LEVEL_POS)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_CFG_TREE_INFO(leaf,node,maxLvl) ( (((u64b_t)(leaf )) << SKEIN_CFG_TREE_LEAF_SIZE_POS) | (((u64b_t)(node )) << SKEIN_CFG_TREE_NODE_SIZE_POS) | (((u64b_t)(maxLvl)) << SKEIN_CFG_TREE_MAX_LEVEL_POS) )

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_CFG_TREE_INFO_SEQUENTIAL SKEIN_CFG_TREE_INFO(0,0,0)

	/*
	**   Skein macros for getting/setting tweak words, etc.
	**   These are useful for partial input bytes, hash tree init/update, etc.
	**/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Get_Tweak(ctxPtr,TWK_NUM) ((ctxPtr)->h.T[TWK_NUM])
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Set_Tweak(ctxPtr,TWK_NUM,tVal) {(ctxPtr)->h.T[TWK_NUM] = (tVal);}

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Get_T0(ctxPtr) Skein_Get_Tweak(ctxPtr,0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Get_T1(ctxPtr) Skein_Get_Tweak(ctxPtr,1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Set_T0(ctxPtr,T0) Skein_Set_Tweak(ctxPtr,0,T0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Set_T1(ctxPtr,T1) Skein_Set_Tweak(ctxPtr,1,T1)

	/* set both tweak words at once */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Set_T0_T1(ctxPtr,T0,T1) { Skein_Set_T0(ctxPtr,(T0)); Skein_Set_T1(ctxPtr,(T1)); }

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Set_Type(ctxPtr,BLK_TYPE) Skein_Set_T1(ctxPtr,SKEIN_T1_BLK_TYPE_##BLK_TYPE)

	/* set up for starting with a new type: h.T[0]=0; h.T[1] = NEW_TYPE; h.bCnt=0; */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Start_New_Type(ctxPtr,BLK_TYPE) { Skein_Set_T0_T1(ctxPtr,0,SKEIN_T1_FLAG_FIRST | SKEIN_T1_BLK_TYPE_##BLK_TYPE); (ctxPtr)->h.bCnt=0; }

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Clear_First_Flag(hdr) { (hdr).T[1] &= ~SKEIN_T1_FLAG_FIRST; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Set_Bit_Pad_Flag(hdr) { (hdr).T[1] |= SKEIN_T1_FLAG_BIT_PAD; }

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Set_Tree_Level(hdr,height) { (hdr).T[1] |= SKEIN_T1_TREE_LEVEL(height);}

	/*****************************************************************
	** "Internal" Skein definitions for debugging and error checking
	******************************************************************/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Show_Block(bits,ctx,X,blkPtr,wPtr,ksEvenPtr,ksOddPtr)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Show_Round(bits,ctx,r,X)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Show_R_Ptr(bits,ctx,r,X_ptr)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Show_Final(bits,ctx,cnt,outPtr)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Show_Key(bits,ctx,key,keyBytes)


	#if ! SKEIN_ERR_CHECK
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Assert(x,retCode)
	#define Skein_Assert
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_assert(x)
	#define Skein_assert
	#elif SKEIN_ASSERT
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Assert(x,retCode) assert(x)
	#define Skein_Assert
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_assert(x) assert(x)
	#define Skein_assert
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_Assert(x,retCode) { if (!(x)) return retCode; }
	#define Skein_Assert
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Skein_assert(x) assert(x)
	#define Skein_assert
	#endif


	/*
	***************** Pre-computed Skein IVs *******************
	**
	** NOTE: these values are not "magic" constants, but
	** are generated using the Threefish block function.
	** They are pre-computed here only for speed; i.e., to
	** avoid the need for a Threefish call during Init().
	**
	** The IV for any fixed hash length may be pre-computed.
	** Only the most common values are included here.
	**
	************************************************************
	**/

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MK_64 SKEIN_MK_64

	/* blkSize =  256 bits. hashSize =  128 bits */
	public static readonly ulong[] SKEIN_256_IV_128 = {((0x964D7260) + (((ulong)(0xE1111906)) << 32)), ((0x7C8D811C) + (((ulong)(0x883DAAA7)) << 32)), ((0x91960F7A) + (((ulong)(0x10080DF4)) << 32)), ((0xB45BC1C2) + (((ulong)(0xCCF7DDE5)) << 32))};

	/* blkSize =  256 bits. hashSize =  160 bits */
	public static readonly ulong[] SKEIN_256_IV_160 = {((0x72825E98) + (((ulong)(0x14202314)) << 32)), ((0x5A77E590) + (((ulong)(0x2AC4E9A2)) << 32)), ((0x8838D63E) + (((ulong)(0xD47A5856)) << 32)), ((0x8586AB7D) + (((ulong)(0x2DD2E496)) << 32))};

	/* blkSize =  256 bits. hashSize =  224 bits */
	public static readonly ulong[] SKEIN_256_IV_224 = {((0x9AE5EA0B) + (((ulong)(0xC6098A8C)) << 32)), ((0x08C5191C) + (((ulong)(0x876D5686)) << 32)), ((0xD7F53884) + (((ulong)(0x99CB88D7)) << 32)), ((0xAEDDB5DE) + (((ulong)(0x384BDDB1)) << 32))};

	/* blkSize =  256 bits. hashSize =  256 bits */
	public static readonly ulong[] SKEIN_256_IV_256 = {((0xD048B449) + (((ulong)(0xFC9DA860)) << 32)), ((0x9FA7D833) + (((ulong)(0x2FCA6647)) << 32)), ((0x6656840F) + (((ulong)(0xB33BC389)) << 32)), ((0xFDE8DA69) + (((ulong)(0x6A54E920)) << 32))};

	/* blkSize =  512 bits. hashSize =  128 bits */
	public static readonly ulong[] SKEIN_512_IV_128 = {((0x6FBF9F52) + (((ulong)(0xA8BC7BF3)) << 32)), ((0xBD1AF0AA) + (((ulong)(0x1E9872CE)) << 32)), ((0xB32190D3) + (((ulong)(0x309B1790)) << 32)), ((0x3F94805C) + (((ulong)(0xBCFBB854)) << 32)), ((0x6E31B11B) + (((ulong)(0x0DA61BCD)) << 32)), ((0xD46A32E3) + (((ulong)(0x1A18EBEA)) << 32)), ((0xCE84AA82) + (((ulong)(0xA2CC5B18)) << 32)), ((0x9D46982D) + (((ulong)(0x6982AB28)) << 32))};

	/* blkSize =  512 bits. hashSize =  160 bits */
	public static readonly ulong[] SKEIN_512_IV_160 = {((0xE013BD91) + (((ulong)(0x28B81A2A)) << 32)), ((0xB5BDF78F) + (((ulong)(0xC2F11668)) << 32)), ((0xF6A56F12) + (((ulong)(0x1760D8F3)) << 32)), ((0x8239904F) + (((ulong)(0x4FB74758)) << 32)), ((0x7EAF5056) + (((ulong)(0x21EDE07F)) << 32)), ((0x63ED70B8) + (((ulong)(0xD908922E)) << 32)), ((0xECCB52FA) + (((ulong)(0xB8EC76FF)) << 32)), ((0xA3F27A6E) + (((ulong)(0x01A47BB8)) << 32))};

	/* blkSize =  512 bits. hashSize =  224 bits */
	public static readonly ulong[] SKEIN_512_IV_224 = {((0x48677224) + (((ulong)(0xCCD06162)) << 32)), ((0xA92339EF) + (((ulong)(0xCBA65CF3)) << 32)), ((0x52FF4B64) + (((ulong)(0x8CCD69D6)) << 32)), ((0x3AB890B4) + (((ulong)(0x398AED7B)) << 32)), ((0x457D2BD0) + (((ulong)(0x0F59D1B1)) << 32)), ((0x75D4EB3D) + (((ulong)(0x6776FE65)) << 32)), ((0x997413E9) + (((ulong)(0x99FBC70E)) << 32)), ((0xE1C41EF7) + (((ulong)(0x9E2CFCCF)) << 32))};

	/* blkSize =  512 bits. hashSize =  256 bits */
	public static readonly ulong[] SKEIN_512_IV_256 = {((0x2FDB3E13) + (((ulong)(0xCCD044A1)) << 32)), ((0x1A79A9EB) + (((ulong)(0xE8359030)) << 32)), ((0x4F816E6F) + (((ulong)(0x55AEA061)) << 32)), ((0xAE9B94DB) + (((ulong)(0x2A2767A4)) << 32)), ((0x74DD7683) + (((ulong)(0xEC06025E)) << 32)), ((0xC4746251) + (((ulong)(0xE7A436CD)) << 32)), ((0x393AD185) + (((ulong)(0xC36FBAF9)) << 32)), ((0x33EDFC13) + (((ulong)(0x3EEDBA18)) << 32))};

	/* blkSize =  512 bits. hashSize =  384 bits */
	public static readonly ulong[] SKEIN_512_IV_384 = {((0x3A75EF5F) + (((ulong)(0xA3F6C6BF)) << 32)), ((0xFD84FAA4) + (((ulong)(0xB0FEF9CC)) << 32)), ((0x3D770CFE) + (((ulong)(0x9D77DD66)) << 32)), ((0xB468FDDA) + (((ulong)(0xD798CBF3)) << 32)), ((0x8A0E4465) + (((ulong)(0x1BC4A666)) << 32)), ((0xE5807407) + (((ulong)(0x7ED7D434)) << 32)), ((0xD4EC44D6) + (((ulong)(0x548FC1AC)) << 32)), ((0x6AA18FF8) + (((ulong)(0x266E1754)) << 32))};

	/* blkSize =  512 bits. hashSize =  512 bits */
	public static readonly ulong[] SKEIN_512_IV_512 = {((0x749C51CE) + (((ulong)(0x4903ADFF)) << 32)), ((0x9746DF03) + (((ulong)(0x0D95DE39)) << 32)), ((0x27C79BCE) + (((ulong)(0x8FD19341)) << 32)), ((0xFF352CB1) + (((ulong)(0x9A255629)) << 32)), ((0xDF6CA7B0) + (((ulong)(0x5DB62599)) << 32)), ((0xA9D5C3F4) + (((ulong)(0xEABE394C)) << 32)), ((0x1A75B523) + (((ulong)(0x991112C7)) << 32)), ((0x660FCC33) + (((ulong)(0xAE18A40B)) << 32))};

	/* blkSize = 1024 bits. hashSize =  384 bits */
	public static readonly ulong[] SKEIN1024_IV_384 = {((0xC1894A35) + (((ulong)(0x5102B6B8)) << 32)), ((0xFE8AF11A) + (((ulong)(0xFEEBC9E3)) << 32)), ((0xE32BED71) + (((ulong)(0x0C807F06)) << 32)), ((0xB41A91F6) + (((ulong)(0x60C13A52)) << 32)), ((0xD4917C38) + (((ulong)(0x9716D35D)) << 32)), ((0x6FD31D3A) + (((ulong)(0xE780DF12)) << 32)), ((0xC898303A) + (((ulong)(0x797846B6)) << 32)), ((0xB3572A3B) + (((ulong)(0xB172C2A8)) << 32)), ((0xA6104A6C) + (((ulong)(0xC9BC8203)) << 32)), ((0xD75624F4) + (((ulong)(0x65909338)) << 32)), ((0x4B3F81A0) + (((ulong)(0x94BCC568)) << 32)), ((0x10ECFD46) + (((ulong)(0x3EBBF51E)) << 32)), ((0xEEB08542) + (((ulong)(0x2DF50F0B)) << 32)), ((0x0DBC6516) + (((ulong)(0x3B5A6530)) << 32)), ((0x167BBCE1) + (((ulong)(0x484B9CD2)) << 32)), ((0xD4CBAFEA) + (((ulong)(0x2D136947)) << 32))};

	/* blkSize = 1024 bits. hashSize =  512 bits */
	public static readonly ulong[] SKEIN1024_IV_512 = {((0x7C1B1B18) + (((ulong)(0xCAEC0E5D)) << 32)), ((0x5F03E802) + (((ulong)(0xA01B0E04)) << 32)), ((0xED912885) + (((ulong)(0x33840451)) << 32)), ((0xEAEC2E1C) + (((ulong)(0x374AFB04)) << 32)), ((0x813581F7) + (((ulong)(0xDF25A0E2)) << 32)), ((0x8B12F9D2) + (((ulong)(0xE4004093)) << 32)), ((0xC2ED39B6) + (((ulong)(0xA662D539)) << 32)), ((0x45D8C75A) + (((ulong)(0xFA8B85CF)) << 32)), ((0x29EDE796) + (((ulong)(0x8316ED8E)) << 32)), ((0x2E9F91B8) + (((ulong)(0x053289C0)) << 32)), ((0x6D518B73) + (((ulong)(0xC3F8EF1D)) << 32)), ((0xD5EF332E) + (((ulong)(0xBDCEC3C4)) << 32)), ((0x22974487) + (((ulong)(0x549A7E52)) << 32)), ((0x5B749816) + (((ulong)(0x67070872)) << 32)), ((0xF0581BD1) + (((ulong)(0xB9CD28FB)) << 32)), ((0x15804974) + (((ulong)(0x0E2940B8)) << 32))};

	/* blkSize = 1024 bits. hashSize = 1024 bits */
	public static readonly ulong[] SKEIN1024_IV_1024 = {((0x41E72355) + (((ulong)(0xD593DA07)) << 32)), ((0xAC73E00C) + (((ulong)(0x15B5E511)) << 32)), ((0xBAF2C4F0) + (((ulong)(0x5180E5AE)) << 32)), ((0xFCBCAFAF) + (((ulong)(0x03BD41D3)) << 32)), ((0x1983A898) + (((ulong)(0x1CAEC6FD)) << 32)), ((0xCDD0589F) + (((ulong)(0x6E510B8B)) << 32)), ((0xC6394ADA) + (((ulong)(0x77E2BDFD)) << 32)), ((0x24DCB0A3) + (((ulong)(0xC11E1DB5)) << 32)), ((0xC6329AB5) + (((ulong)(0xD6D14AF9)) << 32)), ((0x6EB67E0D) + (((ulong)(0x6A9B0BFC)) << 32)), ((0xCCFF1332) + (((ulong)(0x9243C60D)) << 32)), ((0x743F02D4) + (((ulong)(0x1A1F1DDE)) << 32)), ((0x10ED0BB8) + (((ulong)(0x0996753C)) << 32)), ((0xF2B4969A) + (((ulong)(0x6572DD22)) << 32)), ((0xD00A579A) + (((ulong)(0x61FD3062)) << 32)), ((0x8682E539) + (((ulong)(0x1DE0536E)) << 32))};




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BLK_BITS (WCNT*64)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ks (kw + KW_KEY_BASE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ts (kw + KW_TWK_BASE)

	#if SKEIN_DEBUG
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define DebugSaveTweak(ctx) { ctx->h.T[0] = ts[0]; ctx->h.T[1] = ts[1]; }
	#define DebugSaveTweak
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define DebugSaveTweak(ctx)
	#define DebugSaveTweak
	#endif

	/*****************************  Skein_256 ******************************/
	#if !(SKEIN_USE_ASM & 256)
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'blkPtr', so pointers on this parameter are left unchanged:
	internal static void Skein_256_Process_Block(Skein_256_Ctxt_t ctx, ushort * blkPtr, size_t blkCnt, size_t byteCntAdd)
	{ // do it in C
//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//	enum
	//		{
	//		WCNT = DefineConstants.SKEIN_256_STATE_WORDS
	//		};
	#undef RCNT
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RCNT (SKEIN_256_ROUNDS_TOTAL/8)
	#define RCNT

	#if SKEIN_LOOP
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_UNROLL_256 (((SKEIN_LOOP)/100)%10)
	#define SKEIN_UNROLL_256
	#else
	#define SKEIN_UNROLL_256
	#endif

	#if SKEIN_UNROLL_256
	#if (RCNT % SKEIN_UNROLL_256)
	#error "Invalid SKEIN_UNROLL_256"
	#endif
		size_t r = new size_t();
		ulong[] kw = Arrays.InitializeWithDefaultInstances<ulong>(WCNT + 4 + ((8 * ((((SKEIN_ROUNDS / 100) + 5) % 10) + 5)) / 8) * 2); // key schedule words : chaining vars + tweak + "rotation"
	#else
		ulong[] kw = Arrays.InitializeWithDefaultInstances<ulong>(WCNT + 4); // key schedule words : chaining vars + tweak
	#endif
		ulong X0 = new ulong(); // local copy of context vars, for speed
		ulong X1 = new ulong();
		ulong X2 = new ulong();
		ulong X3 = new ulong();
		ulong[] w = Arrays.InitializeWithDefaultInstances<ulong>(WCNT); // local copy of input block
	#if SKEIN_DEBUG
		ulong[] Xptr = Arrays.InitializeWithDefaultInstances<ulong>(4); // use for debugging (help compiler put Xn in registers)
		Xptr[0] = X0;
		Xptr[1] = X1;
		Xptr[2] = X2;
		Xptr[3] = X3;
	#endif
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		Skein_assert(blkCnt != 0); // never call with blkCnt == 0!
		(kw + DefineConstants.KW_TWK_BASE)[0] = ctx.h.T[0];
		(kw + DefineConstants.KW_TWK_BASE)[1] = ctx.h.T[1];
		do
		{
			/* this implementation only supports 2**64 input bytes (no carry out here) */
			(kw + DefineConstants.KW_TWK_BASE)[0] += byteCntAdd; // update processed length

			/* precompute the key schedule for this block */
			(kw + DefineConstants.KW_KEY_BASE)[0] = ctx.X[0];
			(kw + DefineConstants.KW_KEY_BASE)[1] = ctx.X[1];
			(kw + DefineConstants.KW_KEY_BASE)[2] = ctx.X[2];
			(kw + DefineConstants.KW_KEY_BASE)[3] = ctx.X[3];
			(kw + DefineConstants.KW_KEY_BASE)[4] = (kw + DefineConstants.KW_KEY_BASE)[0] ^ (kw + DefineConstants.KW_KEY_BASE)[1] ^ (kw + DefineConstants.KW_KEY_BASE)[2] ^ (kw + DefineConstants.KW_KEY_BASE)[3] ^ ((0xA9FC1A22) + (((ulong)(0x1BD11BDA)) << 32));

			(kw + DefineConstants.KW_TWK_BASE)[2] = (kw + DefineConstants.KW_TWK_BASE)[0] ^ (kw + DefineConstants.KW_TWK_BASE)[1];

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(w, new ushort(blkPtr), 8 * (WCNT)); // get input block in little-endian format
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'DebugSaveTweak' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			DebugSaveTweak(ctx);
			;

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X0 = w[0] + (kw + DefineConstants.KW_KEY_BASE)[0];
			X0.CopyFrom(w[0] + (kw + DefineConstants.KW_KEY_BASE)[0]); // do the first full key injection
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X1 = w[1] + (kw + DefineConstants.KW_KEY_BASE)[1] + (kw + DefineConstants.KW_TWK_BASE)[0];
			X1.CopyFrom(w[1] + (kw + DefineConstants.KW_KEY_BASE)[1] + (kw + DefineConstants.KW_TWK_BASE)[0]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X2 = w[2] + (kw + DefineConstants.KW_KEY_BASE)[2] + (kw + DefineConstants.KW_TWK_BASE)[1];
			X2.CopyFrom(w[2] + (kw + DefineConstants.KW_KEY_BASE)[2] + (kw + DefineConstants.KW_TWK_BASE)[1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X3 = w[3] + (kw + DefineConstants.KW_KEY_BASE)[3];
			X3.CopyFrom(w[3] + (kw + DefineConstants.KW_KEY_BASE)[3]);

			; // show starting state values

			blkPtr += (8 * DefineConstants.SKEIN_256_STATE_WORDS);

			/* run the rounds */

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Round256(p0,p1,p2,p3,ROT,rNum) X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0; X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2;
	#define Round256
	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	#if SKEIN_UNROLL_256 == 0
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R256(p0,p1,p2,p3,ROT,rNum) Round256(p0,p1,p2,p3,ROT,rNum) Skein_Show_R_Ptr(BLK_BITS,&ctx->h,rNum,Xptr);
	#define R256

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define I256(R) X0 += ks[((R)+1) % 5]; X1 += ks[((R)+2) % 5] + ts[((R)+1) % 3]; X2 += ks[((R)+3) % 5] + ts[((R)+2) % 3]; X3 += ks[((R)+4) % 5] + (R)+1; Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);
	#define I256
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R256(p0,p1,p2,p3,ROT,rNum) Round256(p0,p1,p2,p3,ROT,rNum) Skein_Show_R_Ptr(BLK_BITS,&ctx->h,4*(r-1)+rNum,Xptr);
	#define R256

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define I256(R) X0 += ks[r+(R)+0]; X1 += ks[r+(R)+1] + ts[r+(R)+0]; X2 += ks[r+(R)+2] + ts[r+(R)+1]; X3 += ks[r+(R)+3] + r+(R) ; ks[r + (R)+4 ] = ks[r+(R)-1]; ts[r + (R)+2 ] = ts[r+(R)-1]; Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);
	#define I256

		for (r = 1;r < 2 * ((8 * ((((SKEIN_ROUNDS / 100) + 5) % 10) + 5)) / 8);r += 2 * (((DefineConstants.SKEIN_LOOP) / 100) % 10)) // loop thru it
	#endif
		{
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R256_8_rounds(R) R256(0,1,2,3,R_256_0,8*(R) + 1); R256(0,3,2,1,R_256_1,8*(R) + 2); R256(0,1,2,3,R_256_2,8*(R) + 3); R256(0,3,2,1,R_256_3,8*(R) + 4); I256(2*(R)); R256(0,1,2,3,R_256_4,8*(R) + 5); R256(0,3,2,1,R_256_5,8*(R) + 6); R256(0,1,2,3,R_256_6,8*(R) + 7); R256(0,3,2,1,R_256_7,8*(R) + 8); I256(2*(R)+1);
	#define R256_8_rounds

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (0) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (0) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (0) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (0) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (0));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (0) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (0) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (0) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (0) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (0) + 1);

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R256_Unroll_R(NN) ((SKEIN_UNROLL_256 == 0 && SKEIN_256_ROUNDS_TOTAL/8 > (NN)) || (SKEIN_UNROLL_256 > (NN)))
	#define R256_Unroll_R

	  #if R256_Unroll_R( 1)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (1) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (1) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (1) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (1) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (1));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (1) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (1) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (1) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (1) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (1) + 1);
	  #endif
	  #if R256_Unroll_R( 2)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (2) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (2) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (2) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (2) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (2));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (2) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (2) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (2) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (2) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (2) + 1);
	  #endif
	  #if R256_Unroll_R( 3)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (3) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (3) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (3) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (3) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (3));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (3) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (3) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (3) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (3) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (3) + 1);
	  #endif
	  #if R256_Unroll_R( 4)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (4) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (4) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (4) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (4) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (4));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (4) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (4) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (4) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (4) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (4) + 1);
	  #endif
	  #if R256_Unroll_R( 5)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (5) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (5) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (5) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (5) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (5));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (5) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (5) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (5) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (5) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (5) + 1);
	  #endif
	  #if R256_Unroll_R( 6)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (6) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (6) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (6) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (6) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (6));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (6) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (6) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (6) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (6) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (6) + 1);
	  #endif
	  #if R256_Unroll_R( 7)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (7) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (7) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (7) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (7) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (7));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (7) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (7) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (7) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (7) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (7) + 1);
	  #endif
	  #if R256_Unroll_R( 8)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (8) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (8) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (8) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (8) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (8));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (8) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (8) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (8) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (8) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (8) + 1);
	  #endif
	  #if R256_Unroll_R( 9)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (9) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (9) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (9) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (9) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (9));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (9) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (9) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (9) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (9) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (9) + 1);
	  #endif
	  #if R256_Unroll_R(10)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (10) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (10) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (10) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (10) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (10));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (10) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (10) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (10) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (10) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (10) + 1);
	  #endif
	  #if R256_Unroll_R(11)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (11) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (11) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (11) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (11) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (11));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (11) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (11) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (11) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (11) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (11) + 1);
	  #endif
	  #if R256_Unroll_R(12)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (12) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (12) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (12) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (12) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (12));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (12) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (12) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (12) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (12) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (12) + 1);
	  #endif
	  #if R256_Unroll_R(13)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (13) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (13) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (13) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (13) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (13));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (13) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (13) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (13) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (13) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (13) + 1);
	  #endif
	  #if R256_Unroll_R(14)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_0,8 * (14) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_1,8 * (14) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_2,8 * (14) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_3,8 * (14) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (14));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_4,8 * (14) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_5,8 * (14) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,1,2,3,R_256_6,8 * (14) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R256(0,3,2,1,R_256_7,8 * (14) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I256' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I256(2 * (14) + 1);
	  #endif
	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	  #if (SKEIN_UNROLL_256 > 14)
	#error "need more unrolling in Skein_256_Process_Block"
	  #endif
		}
			/* do the final "feedforward" xor, update context chaining vars */
			ctx.X[0] = X0 ^ w[0];
			ctx.X[1] = X1 ^ w[1];
			ctx.X[2] = X2 ^ w[2];
			ctx.X[3] = X3 ^ w[3];

			;

			(kw + DefineConstants.KW_TWK_BASE)[1] &= ~(((ulong) 1) << ((126) - 64));
		} while (--blkCnt != 0);
		ctx.h.T[0] = (kw + DefineConstants.KW_TWK_BASE)[0];
		ctx.h.T[1] = (kw + DefineConstants.KW_TWK_BASE)[1];
	}

	#if SKEIN_CODE_SIZE || SKEIN_PERF
	internal static size_t Skein_256_Process_Block_CodeSize()
	{
		return ((ushort) Skein_256_Process_Block_CodeSize) - ((ushort) Skein_256_Process_Block);
	}
	internal static uint Skein_256_Unroll_Cnt()
	{
		return (((DefineConstants.SKEIN_LOOP) / 100) % 10);
	}
	#endif
	#endif

	/*****************************  Skein_512 ******************************/
	#if !(SKEIN_USE_ASM & 512)
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'blkPtr', so pointers on this parameter are left unchanged:
	internal static void Skein_512_Process_Block(Skein_512_Ctxt_t ctx, ushort * blkPtr, size_t blkCnt, size_t byteCntAdd)
	{ // do it in C
//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//	enum
	//		{
	//		WCNT = DefineConstants.SKEIN_512_STATE_WORDS
	//		};
	#undef RCNT
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RCNT (SKEIN_512_ROUNDS_TOTAL/8)
	#define RCNT

	#if SKEIN_LOOP
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_UNROLL_512 (((SKEIN_LOOP)/10)%10)
	#define SKEIN_UNROLL_512
	#else
	#define SKEIN_UNROLL_512
	#endif

	#if SKEIN_UNROLL_512
	#if (RCNT % SKEIN_UNROLL_512)
	#error "Invalid SKEIN_UNROLL_512"
	#endif
		size_t r = new size_t();
		ulong[] kw = Arrays.InitializeWithDefaultInstances<ulong>(WCNT + 4 + ((8 * ((((SKEIN_ROUNDS / 10) + 5) % 10) + 5)) / 8) * 2); // key schedule words : chaining vars + tweak + "rotation"
	#else
		ulong[] kw = Arrays.InitializeWithDefaultInstances<ulong>(WCNT + 4); // key schedule words : chaining vars + tweak
	#endif
		ulong X0 = new ulong(); // local copy of vars, for speed
		ulong X1 = new ulong();
		ulong X2 = new ulong();
		ulong X3 = new ulong();
		ulong X4 = new ulong();
		ulong X5 = new ulong();
		ulong X6 = new ulong();
		ulong X7 = new ulong();
		ulong[] w = Arrays.InitializeWithDefaultInstances<ulong>(WCNT); // local copy of input block
	#if SKEIN_DEBUG
		ulong[] Xptr = Arrays.InitializeWithDefaultInstances<ulong>(8); // use for debugging (help compiler put Xn in registers)
		Xptr[0] = X0;
		Xptr[1] = X1;
		Xptr[2] = X2;
		Xptr[3] = X3;
		Xptr[4] = X4;
		Xptr[5] = X5;
		Xptr[6] = X6;
		Xptr[7] = X7;
	#endif

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		Skein_assert(blkCnt != 0); // never call with blkCnt == 0!
		(kw + DefineConstants.KW_TWK_BASE)[0] = ctx.h.T[0];
		(kw + DefineConstants.KW_TWK_BASE)[1] = ctx.h.T[1];
		do
		{
			/* this implementation only supports 2**64 input bytes (no carry out here) */
			(kw + DefineConstants.KW_TWK_BASE)[0] += byteCntAdd; // update processed length

			/* precompute the key schedule for this block */
			(kw + DefineConstants.KW_KEY_BASE)[0] = ctx.X[0];
			(kw + DefineConstants.KW_KEY_BASE)[1] = ctx.X[1];
			(kw + DefineConstants.KW_KEY_BASE)[2] = ctx.X[2];
			(kw + DefineConstants.KW_KEY_BASE)[3] = ctx.X[3];
			(kw + DefineConstants.KW_KEY_BASE)[4] = ctx.X[4];
			(kw + DefineConstants.KW_KEY_BASE)[5] = ctx.X[5];
			(kw + DefineConstants.KW_KEY_BASE)[6] = ctx.X[6];
			(kw + DefineConstants.KW_KEY_BASE)[7] = ctx.X[7];
			(kw + DefineConstants.KW_KEY_BASE)[8] = (kw + DefineConstants.KW_KEY_BASE)[0] ^ (kw + DefineConstants.KW_KEY_BASE)[1] ^ (kw + DefineConstants.KW_KEY_BASE)[2] ^ (kw + DefineConstants.KW_KEY_BASE)[3] ^ (kw + DefineConstants.KW_KEY_BASE)[4] ^ (kw + DefineConstants.KW_KEY_BASE)[5] ^ (kw + DefineConstants.KW_KEY_BASE)[6] ^ (kw + DefineConstants.KW_KEY_BASE)[7] ^ ((0xA9FC1A22) + (((ulong)(0x1BD11BDA)) << 32));

			(kw + DefineConstants.KW_TWK_BASE)[2] = (kw + DefineConstants.KW_TWK_BASE)[0] ^ (kw + DefineConstants.KW_TWK_BASE)[1];

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(w, new ushort(blkPtr), 8 * (WCNT)); // get input block in little-endian format
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'DebugSaveTweak' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			DebugSaveTweak(ctx);
			;

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X0 = w[0] + (kw + DefineConstants.KW_KEY_BASE)[0];
			X0.CopyFrom(w[0] + (kw + DefineConstants.KW_KEY_BASE)[0]); // do the first full key injection
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X1 = w[1] + (kw + DefineConstants.KW_KEY_BASE)[1];
			X1.CopyFrom(w[1] + (kw + DefineConstants.KW_KEY_BASE)[1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X2 = w[2] + (kw + DefineConstants.KW_KEY_BASE)[2];
			X2.CopyFrom(w[2] + (kw + DefineConstants.KW_KEY_BASE)[2]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X3 = w[3] + (kw + DefineConstants.KW_KEY_BASE)[3];
			X3.CopyFrom(w[3] + (kw + DefineConstants.KW_KEY_BASE)[3]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X4 = w[4] + (kw + DefineConstants.KW_KEY_BASE)[4];
			X4.CopyFrom(w[4] + (kw + DefineConstants.KW_KEY_BASE)[4]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X5 = w[5] + (kw + DefineConstants.KW_KEY_BASE)[5] + (kw + DefineConstants.KW_TWK_BASE)[0];
			X5.CopyFrom(w[5] + (kw + DefineConstants.KW_KEY_BASE)[5] + (kw + DefineConstants.KW_TWK_BASE)[0]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X6 = w[6] + (kw + DefineConstants.KW_KEY_BASE)[6] + (kw + DefineConstants.KW_TWK_BASE)[1];
			X6.CopyFrom(w[6] + (kw + DefineConstants.KW_KEY_BASE)[6] + (kw + DefineConstants.KW_TWK_BASE)[1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X7 = w[7] + (kw + DefineConstants.KW_KEY_BASE)[7];
			X7.CopyFrom(w[7] + (kw + DefineConstants.KW_KEY_BASE)[7]);

			blkPtr += (8 * DefineConstants.SKEIN_512_STATE_WORDS);

			;
			/* run the rounds */
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum) X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0; X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2; X##p4 += X##p5; X##p5 = RotL_64(X##p5,ROT##_2); X##p5 ^= X##p4; X##p6 += X##p7; X##p7 = RotL_64(X##p7,ROT##_3); X##p7 ^= X##p6;
	#define Round512
	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	#if SKEIN_UNROLL_512 == 0
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum) Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum) Skein_Show_R_Ptr(BLK_BITS,&ctx->h,rNum,Xptr);
	#define R512

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define I512(R) X0 += ks[((R)+1) % 9]; X1 += ks[((R)+2) % 9]; X2 += ks[((R)+3) % 9]; X3 += ks[((R)+4) % 9]; X4 += ks[((R)+5) % 9]; X5 += ks[((R)+6) % 9] + ts[((R)+1) % 3]; X6 += ks[((R)+7) % 9] + ts[((R)+2) % 3]; X7 += ks[((R)+8) % 9] + (R)+1; Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);
	#define I512
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum) Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum) Skein_Show_R_Ptr(BLK_BITS,&ctx->h,4*(r-1)+rNum,Xptr);
	#define R512

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define I512(R) X0 += ks[r+(R)+0]; X1 += ks[r+(R)+1]; X2 += ks[r+(R)+2]; X3 += ks[r+(R)+3]; X4 += ks[r+(R)+4]; X5 += ks[r+(R)+5] + ts[r+(R)+0]; X6 += ks[r+(R)+6] + ts[r+(R)+1]; X7 += ks[r+(R)+7] + r+(R) ; ks[r + (R)+8] = ks[r+(R)-1]; ts[r + (R)+2] = ts[r+(R)-1]; Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);
	#define I512

		for (r = 1;r < 2 * ((8 * ((((SKEIN_ROUNDS / 10) + 5) % 10) + 5)) / 8);r += 2 * (((DefineConstants.SKEIN_LOOP) / 10) % 10)) // loop thru it
	#endif
		{
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R512_8_rounds(R) R512(0,1,2,3,4,5,6,7,R_512_0,8*(R)+ 1); R512(2,1,4,7,6,5,0,3,R_512_1,8*(R)+ 2); R512(4,1,6,3,0,5,2,7,R_512_2,8*(R)+ 3); R512(6,1,0,7,2,5,4,3,R_512_3,8*(R)+ 4); I512(2*(R)); R512(0,1,2,3,4,5,6,7,R_512_4,8*(R)+ 5); R512(2,1,4,7,6,5,0,3,R_512_5,8*(R)+ 6); R512(4,1,6,3,0,5,2,7,R_512_6,8*(R)+ 7); R512(6,1,0,7,2,5,4,3,R_512_7,8*(R)+ 8); I512(2*(R)+1);
	#define R512_8_rounds

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (0) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (0) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (0) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (0) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (0));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (0) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (0) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (0) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (0) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (0) + 1);

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R512_Unroll_R(NN) ((SKEIN_UNROLL_512 == 0 && SKEIN_512_ROUNDS_TOTAL/8 > (NN)) || (SKEIN_UNROLL_512 > (NN)))
	#define R512_Unroll_R

	  #if R512_Unroll_R( 1)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (1) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (1) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (1) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (1) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (1));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (1) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (1) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (1) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (1) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (1) + 1);
	  #endif
	  #if R512_Unroll_R( 2)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (2) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (2) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (2) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (2) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (2));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (2) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (2) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (2) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (2) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (2) + 1);
	  #endif
	  #if R512_Unroll_R( 3)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (3) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (3) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (3) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (3) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (3));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (3) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (3) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (3) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (3) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (3) + 1);
	  #endif
	  #if R512_Unroll_R( 4)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (4) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (4) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (4) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (4) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (4));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (4) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (4) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (4) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (4) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (4) + 1);
	  #endif
	  #if R512_Unroll_R( 5)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (5) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (5) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (5) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (5) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (5));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (5) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (5) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (5) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (5) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (5) + 1);
	  #endif
	  #if R512_Unroll_R( 6)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (6) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (6) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (6) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (6) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (6));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (6) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (6) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (6) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (6) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (6) + 1);
	  #endif
	  #if R512_Unroll_R( 7)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (7) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (7) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (7) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (7) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (7));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (7) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (7) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (7) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (7) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (7) + 1);
	  #endif
	  #if R512_Unroll_R( 8)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (8) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (8) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (8) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (8) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (8));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (8) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (8) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (8) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (8) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (8) + 1);
	  #endif
	  #if R512_Unroll_R( 9)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (9) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (9) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (9) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (9) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (9));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (9) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (9) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (9) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (9) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (9) + 1);
	  #endif
	  #if R512_Unroll_R(10)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (10) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (10) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (10) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (10) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (10));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (10) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (10) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (10) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (10) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (10) + 1);
	  #endif
	  #if R512_Unroll_R(11)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (11) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (11) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (11) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (11) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (11));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (11) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (11) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (11) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (11) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (11) + 1);
	  #endif
	  #if R512_Unroll_R(12)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (12) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (12) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (12) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (12) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (12));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (12) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (12) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (12) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (12) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (12) + 1);
	  #endif
	  #if R512_Unroll_R(13)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (13) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (13) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (13) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (13) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (13));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (13) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (13) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (13) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (13) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (13) + 1);
	  #endif
	  #if R512_Unroll_R(14)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_0,8 * (14) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_1,8 * (14) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_2,8 * (14) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_3,8 * (14) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (14));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(0,1,2,3,4,5,6,7,R_512_4,8 * (14) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(2,1,4,7,6,5,0,3,R_512_5,8 * (14) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(4,1,6,3,0,5,2,7,R_512_6,8 * (14) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R512(6,1,0,7,2,5,4,3,R_512_7,8 * (14) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I512' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I512(2 * (14) + 1);
	  #endif
	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	  #if (SKEIN_UNROLL_512 > 14)
	#error "need more unrolling in Skein_512_Process_Block"
	  #endif
		}

			/* do the final "feedforward" xor, update context chaining vars */
			ctx.X[0] = X0 ^ w[0];
			ctx.X[1] = X1 ^ w[1];
			ctx.X[2] = X2 ^ w[2];
			ctx.X[3] = X3 ^ w[3];
			ctx.X[4] = X4 ^ w[4];
			ctx.X[5] = X5 ^ w[5];
			ctx.X[6] = X6 ^ w[6];
			ctx.X[7] = X7 ^ w[7];
			;

			(kw + DefineConstants.KW_TWK_BASE)[1] &= ~(((ulong) 1) << ((126) - 64));
		} while (--blkCnt != 0);
		ctx.h.T[0] = (kw + DefineConstants.KW_TWK_BASE)[0];
		ctx.h.T[1] = (kw + DefineConstants.KW_TWK_BASE)[1];
	}

	#if SKEIN_CODE_SIZE || SKEIN_PERF
	internal static size_t Skein_512_Process_Block_CodeSize()
	{
		return ((ushort) Skein_512_Process_Block_CodeSize) - ((ushort) Skein_512_Process_Block);
	}
	internal static uint Skein_512_Unroll_Cnt()
	{
		return (((DefineConstants.SKEIN_LOOP) / 10) % 10);
	}
	#endif
	#endif

	/*****************************  Skein1024 ******************************/
	#if !(SKEIN_USE_ASM & 1024)
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'blkPtr', so pointers on this parameter are left unchanged:
	internal static void Skein1024_Process_Block(Skein1024_Ctxt_t ctx, ushort * blkPtr, size_t blkCnt, size_t byteCntAdd)
	{ // do it in C, always looping (unrolled is bigger AND slower!)
//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//	enum
	//		{
	//		WCNT = DefineConstants.SKEIN1024_STATE_WORDS
	//		};
	#undef RCNT
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RCNT (SKEIN1024_ROUNDS_TOTAL/8)
	#define RCNT

	#if SKEIN_LOOP
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SKEIN_UNROLL_1024 ((SKEIN_LOOP)%10)
	#define SKEIN_UNROLL_1024
	#else
	#define SKEIN_UNROLL_1024
	#endif

	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	#if (SKEIN_UNROLL_1024 != 0)
	#if (RCNT % SKEIN_UNROLL_1024)
	#error "Invalid SKEIN_UNROLL_1024"
	#endif
		size_t r = new size_t();
		ulong[] kw = Arrays.InitializeWithDefaultInstances<ulong>(WCNT + 4 + ((8 * ((((SKEIN_ROUNDS) + 5) % 10) + 5)) / 8) * 2); // key schedule words : chaining vars + tweak + "rotation"
	#else
		ulong[] kw = Arrays.InitializeWithDefaultInstances<ulong>(WCNT + 4); // key schedule words : chaining vars + tweak
	#endif

		ulong X00 = new ulong();
		ulong X01 = new ulong();
		ulong X02 = new ulong();
		ulong X03 = new ulong();
		ulong X04 = new ulong();
		ulong X05 = new ulong();
		ulong X06 = new ulong();
		ulong X07 = new ulong();
		ulong X08 = new ulong();
		ulong X09 = new ulong();
		ulong X10 = new ulong();
		ulong X11 = new ulong();
		ulong X12 = new ulong();
		ulong X13 = new ulong();
		ulong X14 = new ulong();
		ulong X15 = new ulong();
		ulong[] w = Arrays.InitializeWithDefaultInstances<ulong>(WCNT); // local copy of input block
	#if SKEIN_DEBUG
		ulong[] Xptr = Arrays.InitializeWithDefaultInstances<ulong>(16); // use for debugging (help compiler put Xn in registers)
		Xptr[0] = X00;
		Xptr[1] = X01;
		Xptr[2] = X02;
		Xptr[3] = X03;
		Xptr[4] = X04;
		Xptr[5] = X05;
		Xptr[6] = X06;
		Xptr[7] = X07;
		Xptr[8] = X08;
		Xptr[9] = X09;
		Xptr[10] = X10;
		Xptr[11] = X11;
		Xptr[12] = X12;
		Xptr[13] = X13;
		Xptr[14] = X14;
		Xptr[15] = X15;
	#endif

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		Skein_assert(blkCnt != 0); // never call with blkCnt == 0!
		(kw + DefineConstants.KW_TWK_BASE)[0] = ctx.h.T[0];
		(kw + DefineConstants.KW_TWK_BASE)[1] = ctx.h.T[1];
		do
		{
			/* this implementation only supports 2**64 input bytes (no carry out here) */
			(kw + DefineConstants.KW_TWK_BASE)[0] += byteCntAdd; // update processed length

			/* precompute the key schedule for this block */
			(kw + DefineConstants.KW_KEY_BASE)[0] = ctx.X[0];
			(kw + DefineConstants.KW_KEY_BASE)[1] = ctx.X[1];
			(kw + DefineConstants.KW_KEY_BASE)[2] = ctx.X[2];
			(kw + DefineConstants.KW_KEY_BASE)[3] = ctx.X[3];
			(kw + DefineConstants.KW_KEY_BASE)[4] = ctx.X[4];
			(kw + DefineConstants.KW_KEY_BASE)[5] = ctx.X[5];
			(kw + DefineConstants.KW_KEY_BASE)[6] = ctx.X[6];
			(kw + DefineConstants.KW_KEY_BASE)[7] = ctx.X[7];
			(kw + DefineConstants.KW_KEY_BASE)[8] = ctx.X[8];
			(kw + DefineConstants.KW_KEY_BASE)[9] = ctx.X[9];
			(kw + DefineConstants.KW_KEY_BASE)[10] = ctx.X[10];
			(kw + DefineConstants.KW_KEY_BASE)[11] = ctx.X[11];
			(kw + DefineConstants.KW_KEY_BASE)[12] = ctx.X[12];
			(kw + DefineConstants.KW_KEY_BASE)[13] = ctx.X[13];
			(kw + DefineConstants.KW_KEY_BASE)[14] = ctx.X[14];
			(kw + DefineConstants.KW_KEY_BASE)[15] = ctx.X[15];
			(kw + DefineConstants.KW_KEY_BASE)[16] = (kw + DefineConstants.KW_KEY_BASE)[0] ^ (kw + DefineConstants.KW_KEY_BASE)[1] ^ (kw + DefineConstants.KW_KEY_BASE)[2] ^ (kw + DefineConstants.KW_KEY_BASE)[3] ^ (kw + DefineConstants.KW_KEY_BASE)[4] ^ (kw + DefineConstants.KW_KEY_BASE)[5] ^ (kw + DefineConstants.KW_KEY_BASE)[6] ^ (kw + DefineConstants.KW_KEY_BASE)[7] ^ (kw + DefineConstants.KW_KEY_BASE)[8] ^ (kw + DefineConstants.KW_KEY_BASE)[9] ^ (kw + DefineConstants.KW_KEY_BASE)[10] ^ (kw + DefineConstants.KW_KEY_BASE)[11] ^ (kw + DefineConstants.KW_KEY_BASE)[12] ^ (kw + DefineConstants.KW_KEY_BASE)[13] ^ (kw + DefineConstants.KW_KEY_BASE)[14] ^ (kw + DefineConstants.KW_KEY_BASE)[15] ^ ((0xA9FC1A22) + (((ulong)(0x1BD11BDA)) << 32));

			(kw + DefineConstants.KW_TWK_BASE)[2] = (kw + DefineConstants.KW_TWK_BASE)[0] ^ (kw + DefineConstants.KW_TWK_BASE)[1];

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(w, new ushort(blkPtr), 8 * (WCNT)); // get input block in little-endian format
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'DebugSaveTweak' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			DebugSaveTweak(ctx);
			;

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X00 = w[0] + (kw + DefineConstants.KW_KEY_BASE)[0];
			X00.CopyFrom(w[0] + (kw + DefineConstants.KW_KEY_BASE)[0]); // do the first full key injection
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X01 = w[1] + (kw + DefineConstants.KW_KEY_BASE)[1];
			X01.CopyFrom(w[1] + (kw + DefineConstants.KW_KEY_BASE)[1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X02 = w[2] + (kw + DefineConstants.KW_KEY_BASE)[2];
			X02.CopyFrom(w[2] + (kw + DefineConstants.KW_KEY_BASE)[2]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X03 = w[3] + (kw + DefineConstants.KW_KEY_BASE)[3];
			X03.CopyFrom(w[3] + (kw + DefineConstants.KW_KEY_BASE)[3]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X04 = w[4] + (kw + DefineConstants.KW_KEY_BASE)[4];
			X04.CopyFrom(w[4] + (kw + DefineConstants.KW_KEY_BASE)[4]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X05 = w[5] + (kw + DefineConstants.KW_KEY_BASE)[5];
			X05.CopyFrom(w[5] + (kw + DefineConstants.KW_KEY_BASE)[5]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X06 = w[6] + (kw + DefineConstants.KW_KEY_BASE)[6];
			X06.CopyFrom(w[6] + (kw + DefineConstants.KW_KEY_BASE)[6]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X07 = w[7] + (kw + DefineConstants.KW_KEY_BASE)[7];
			X07.CopyFrom(w[7] + (kw + DefineConstants.KW_KEY_BASE)[7]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X08 = w[8] + (kw + DefineConstants.KW_KEY_BASE)[8];
			X08.CopyFrom(w[8] + (kw + DefineConstants.KW_KEY_BASE)[8]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X09 = w[9] + (kw + DefineConstants.KW_KEY_BASE)[9];
			X09.CopyFrom(w[9] + (kw + DefineConstants.KW_KEY_BASE)[9]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X10 = w[10] + (kw + DefineConstants.KW_KEY_BASE)[10];
			X10.CopyFrom(w[10] + (kw + DefineConstants.KW_KEY_BASE)[10]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X11 = w[11] + (kw + DefineConstants.KW_KEY_BASE)[11];
			X11.CopyFrom(w[11] + (kw + DefineConstants.KW_KEY_BASE)[11]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X12 = w[12] + (kw + DefineConstants.KW_KEY_BASE)[12];
			X12.CopyFrom(w[12] + (kw + DefineConstants.KW_KEY_BASE)[12]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X13 = w[13] + (kw + DefineConstants.KW_KEY_BASE)[13] + (kw + DefineConstants.KW_TWK_BASE)[0];
			X13.CopyFrom(w[13] + (kw + DefineConstants.KW_KEY_BASE)[13] + (kw + DefineConstants.KW_TWK_BASE)[0]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X14 = w[14] + (kw + DefineConstants.KW_KEY_BASE)[14] + (kw + DefineConstants.KW_TWK_BASE)[1];
			X14.CopyFrom(w[14] + (kw + DefineConstants.KW_KEY_BASE)[14] + (kw + DefineConstants.KW_TWK_BASE)[1]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: X15 = w[15] + (kw + DefineConstants.KW_KEY_BASE)[15];
			X15.CopyFrom(w[15] + (kw + DefineConstants.KW_KEY_BASE)[15]);

			;

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Round1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT,rNum) X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0; X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2; X##p4 += X##p5; X##p5 = RotL_64(X##p5,ROT##_2); X##p5 ^= X##p4; X##p6 += X##p7; X##p7 = RotL_64(X##p7,ROT##_3); X##p7 ^= X##p6; X##p8 += X##p9; X##p9 = RotL_64(X##p9,ROT##_4); X##p9 ^= X##p8; X##pA += X##pB; X##pB = RotL_64(X##pB,ROT##_5); X##pB ^= X##pA; X##pC += X##pD; X##pD = RotL_64(X##pD,ROT##_6); X##pD ^= X##pC; X##pE += X##pF; X##pF = RotL_64(X##pF,ROT##_7); X##pF ^= X##pE;
	#define Round1024
	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	#if SKEIN_UNROLL_1024 == 0
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT,rn) Round1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT,rn) Skein_Show_R_Ptr(BLK_BITS,&ctx->h,rn,Xptr);
	#define R1024

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define I1024(R) X00 += ks[((R)+ 1) % 17]; X01 += ks[((R)+ 2) % 17]; X02 += ks[((R)+ 3) % 17]; X03 += ks[((R)+ 4) % 17]; X04 += ks[((R)+ 5) % 17]; X05 += ks[((R)+ 6) % 17]; X06 += ks[((R)+ 7) % 17]; X07 += ks[((R)+ 8) % 17]; X08 += ks[((R)+ 9) % 17]; X09 += ks[((R)+10) % 17]; X10 += ks[((R)+11) % 17]; X11 += ks[((R)+12) % 17]; X12 += ks[((R)+13) % 17]; X13 += ks[((R)+14) % 17] + ts[((R)+1) % 3]; X14 += ks[((R)+15) % 17] + ts[((R)+2) % 3]; X15 += ks[((R)+16) % 17] + (R)+1; Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);
	#define I1024
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT,rn) Round1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT,rn) Skein_Show_R_Ptr(BLK_BITS,&ctx->h,4*(r-1)+rn,Xptr);
	#define R1024

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define I1024(R) X00 += ks[r+(R)+ 0]; X01 += ks[r+(R)+ 1]; X02 += ks[r+(R)+ 2]; X03 += ks[r+(R)+ 3]; X04 += ks[r+(R)+ 4]; X05 += ks[r+(R)+ 5]; X06 += ks[r+(R)+ 6]; X07 += ks[r+(R)+ 7]; X08 += ks[r+(R)+ 8]; X09 += ks[r+(R)+ 9]; X10 += ks[r+(R)+10]; X11 += ks[r+(R)+11]; X12 += ks[r+(R)+12]; X13 += ks[r+(R)+13] + ts[r+(R)+0]; X14 += ks[r+(R)+14] + ts[r+(R)+1]; X15 += ks[r+(R)+15] + r+(R) ; ks[r + (R)+16] = ks[r+(R)-1]; ts[r + (R)+ 2] = ts[r+(R)-1]; Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);
	#define I1024

		for (r = 1;r <= 2 * ((8 * ((((SKEIN_ROUNDS) + 5) % 10) + 5)) / 8);r += 2 * ((DefineConstants.SKEIN_LOOP) % 10)) // loop thru it
	#endif
		{
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R1024_8_rounds(R) R1024(00,01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,R1024_0,8*(R) + 1); R1024(00,09,02,13,06,11,04,15,10,07,12,03,14,05,08,01,R1024_1,8*(R) + 2); R1024(00,07,02,05,04,03,06,01,12,15,14,13,08,11,10,09,R1024_2,8*(R) + 3); R1024(00,15,02,11,06,13,04,09,14,01,08,05,10,03,12,07,R1024_3,8*(R) + 4); I1024(2*(R)); R1024(00,01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,R1024_4,8*(R) + 5); R1024(00,09,02,13,06,11,04,15,10,07,12,03,14,05,08,01,R1024_5,8*(R) + 6); R1024(00,07,02,05,04,03,06,01,12,15,14,13,08,11,10,09,R1024_6,8*(R) + 7); R1024(00,15,02,11,06,13,04,09,14,01,08,05,10,03,12,07,R1024_7,8*(R) + 8); I1024(2*(R)+1);
	#define R1024_8_rounds

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (0) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (0) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (0) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (0) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (0));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (0) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (0) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (0) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (0) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (0) + 1);

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R1024_Unroll_R(NN) ((SKEIN_UNROLL_1024 == 0 && SKEIN1024_ROUNDS_TOTAL/8 > (NN)) || (SKEIN_UNROLL_1024 > (NN)))
	#define R1024_Unroll_R

	  #if R1024_Unroll_R( 1)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (1) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (1) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (1) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (1) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (1));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (1) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (1) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (1) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (1) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (1) + 1);
	  #endif
	  #if R1024_Unroll_R( 2)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (2) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (2) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (2) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (2) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (2));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (2) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (2) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (2) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (2) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (2) + 1);
	  #endif
	  #if R1024_Unroll_R( 3)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (3) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (3) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (3) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (3) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (3));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (3) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (3) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (3) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (3) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (3) + 1);
	  #endif
	  #if R1024_Unroll_R( 4)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (4) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (4) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (4) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (4) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (4));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (4) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (4) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (4) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (4) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (4) + 1);
	  #endif
	  #if R1024_Unroll_R( 5)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (5) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (5) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (5) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (5) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (5));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (5) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (5) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (5) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (5) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (5) + 1);
	  #endif
	  #if R1024_Unroll_R( 6)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (6) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (6) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (6) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (6) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (6));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (6) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (6) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (6) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (6) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (6) + 1);
	  #endif
	  #if R1024_Unroll_R( 7)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (7) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (7) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (7) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (7) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (7));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (7) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (7) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (7) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (7) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (7) + 1);
	  #endif
	  #if R1024_Unroll_R( 8)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (8) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (8) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (8) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (8) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (8));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (8) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (8) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (8) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (8) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (8) + 1);
	  #endif
	  #if R1024_Unroll_R( 9)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (9) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (9) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (9) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (9) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (9));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (9) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (9) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (9) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (9) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (9) + 1);
	  #endif
	  #if R1024_Unroll_R(10)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (10) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (10) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (10) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (10) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (10));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (10) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (10) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (10) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (10) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (10) + 1);
	  #endif
	  #if R1024_Unroll_R(11)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (11) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (11) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (11) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (11) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (11));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (11) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (11) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (11) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (11) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (11) + 1);
	  #endif
	  #if R1024_Unroll_R(12)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (12) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (12) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (12) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (12) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (12));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (12) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (12) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (12) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (12) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (12) + 1);
	  #endif
	  #if R1024_Unroll_R(13)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (13) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (13) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (13) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (13) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (13));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (13) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (13) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (13) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (13) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (13) + 1);
	  #endif
	  #if R1024_Unroll_R(14)
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_0,8 * (14) + 1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_1,8 * (14) + 2);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_2,8 * (14) + 3);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_3,8 * (14) + 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (14));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,10,11,12,13,14,15,R1024_4,8 * (14) + 5);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x9,0x2,13,0x6,11,0x4,15,10,0x7,12,0x3,14,0x5,0x8,0x1,R1024_5,8 * (14) + 6);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,0x7,0x2,0x5,0x4,0x3,0x6,0x1,12,15,14,13,0x8,11,10,0x9,R1024_6,8 * (14) + 7);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'R1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			R1024(0x0,15,0x2,11,0x6,13,0x4,0x9,14,0x1,0x8,0x5,10,0x3,12,0x7,R1024_7,8 * (14) + 8);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'I1024' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			I1024(2 * (14) + 1);
	  #endif
	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	  #if (SKEIN_UNROLL_1024 > 14)
	#error "need more unrolling in Skein_1024_Process_Block"
	  #endif
		}
			/* do the final "feedforward" xor, update context chaining vars */

			ctx.X[0] = X00 ^ w[0];
			ctx.X[1] = X01 ^ w[1];
			ctx.X[2] = X02 ^ w[2];
			ctx.X[3] = X03 ^ w[3];
			ctx.X[4] = X04 ^ w[4];
			ctx.X[5] = X05 ^ w[5];
			ctx.X[6] = X06 ^ w[6];
			ctx.X[7] = X07 ^ w[7];
			ctx.X[8] = X08 ^ w[8];
			ctx.X[9] = X09 ^ w[9];
			ctx.X[10] = X10 ^ w[10];
			ctx.X[11] = X11 ^ w[11];
			ctx.X[12] = X12 ^ w[12];
			ctx.X[13] = X13 ^ w[13];
			ctx.X[14] = X14 ^ w[14];
			ctx.X[15] = X15 ^ w[15];

			;

			(kw + DefineConstants.KW_TWK_BASE)[1] &= ~(((ulong) 1) << ((126) - 64));
			blkPtr += (8 * DefineConstants.SKEIN1024_STATE_WORDS);
		} while (--blkCnt != 0);
		ctx.h.T[0] = (kw + DefineConstants.KW_TWK_BASE)[0];
		ctx.h.T[1] = (kw + DefineConstants.KW_TWK_BASE)[1];
	}

	#if SKEIN_CODE_SIZE || SKEIN_PERF
	internal static size_t Skein1024_Process_Block_CodeSize()
	{
		return ((ushort) Skein1024_Process_Block_CodeSize) - ((ushort) Skein1024_Process_Block);
	}
	internal static uint Skein1024_Unroll_Cnt()
	{
		return ((DefineConstants.SKEIN_LOOP) % 10);
	}
	#endif
	#endif



	#if SKEIN_CODE_SIZE || SKEIN_PERF
	internal static size_t Skein_256_API_CodeSize()
	{
		return ((ushort) Skein_256_API_CodeSize) - ((ushort) Skein_256_Init);
	}
	#endif


	#if SKEIN_CODE_SIZE || SKEIN_PERF
	internal static size_t Skein_512_API_CodeSize()
	{
		return ((ushort) Skein_512_API_CodeSize) - ((ushort) Skein_512_Init);
	}
	#endif


	#if SKEIN_CODE_SIZE || SKEIN_PERF
	internal static size_t Skein1024_API_CodeSize()
	{
		return ((ushort) Skein1024_API_CodeSize) - ((ushort) Skein1024_Init);
	}
	#endif

	/**************** Functions to support MAC/tree hashing ***************/
	/*   (this code is identical for Optimized and Reference versions)    */

	#if false
	// /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// /* finalize the hash computation and output the block, no OUTPUT stage */
	//static int Skein_256_Final_Pad(Skein_256_Ctxt_t *ctx, u08b_t *hashVal)
	//    {
	//    Skein_Assert(ctx->h.bCnt <= SKEIN_256_BLOCK_BYTES,SKEIN_FAIL);    // catch uninitialized context 
	//
	//    ctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;        // tag as the final block 
	//    if (ctx->h.bCnt < SKEIN_256_BLOCK_BYTES)   // zero pad b[] if necessary 
	//        memset(&ctx->b[ctx->h.bCnt],0,SKEIN_256_BLOCK_BYTES - ctx->h.bCnt);
	//    Skein_256_Process_Block(ctx,ctx->b,1,ctx->h.bCnt);    // process the final block 
	//    
	//    Skein_Put64_LSB_First(hashVal,ctx->X,SKEIN_256_BLOCK_BYTES);   // "output" the state bytes 
	//    
	//    return SKEIN_SUCCESS;
	//    }
	//
	// /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// /* finalize the hash computation and output the block, no OUTPUT stage */
	//static int Skein_512_Final_Pad(Skein_512_Ctxt_t *ctx, u08b_t *hashVal)
	//    {
	//    Skein_Assert(ctx->h.bCnt <= SKEIN_512_BLOCK_BYTES,SKEIN_FAIL);    // catch uninitialized context 
	//
	//    ctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;        // tag as the final block 
	//    if (ctx->h.bCnt < SKEIN_512_BLOCK_BYTES)   // zero pad b[] if necessary 
	//        memset(&ctx->b[ctx->h.bCnt],0,SKEIN_512_BLOCK_BYTES - ctx->h.bCnt);
	//    Skein_512_Process_Block(ctx,ctx->b,1,ctx->h.bCnt);    // process the final block 
	//    
	//    Skein_Put64_LSB_First(hashVal,ctx->X,SKEIN_512_BLOCK_BYTES);   // "output" the state bytes 
	//    
	//    return SKEIN_SUCCESS;
	//    }
	//
	// /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// /* finalize the hash computation and output the block, no OUTPUT stage */
	//static int Skein1024_Final_Pad(Skein1024_Ctxt_t *ctx, u08b_t *hashVal)
	//    {
	//    Skein_Assert(ctx->h.bCnt <= SKEIN1024_BLOCK_BYTES,SKEIN_FAIL);    // catch uninitialized context 
	//
	//    ctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;        // tag as the final block 
	//    if (ctx->h.bCnt < SKEIN1024_BLOCK_BYTES)   // zero pad b[] if necessary 
	//        memset(&ctx->b[ctx->h.bCnt],0,SKEIN1024_BLOCK_BYTES - ctx->h.bCnt);
	//    Skein1024_Process_Block(ctx,ctx->b,1,ctx->h.bCnt);    // process the final block 
	//    
	//    Skein_Put64_LSB_First(hashVal,ctx->X,SKEIN1024_BLOCK_BYTES);   // "output" the state bytes 
	//    
	//    return SKEIN_SUCCESS;
	//    }
	//
	//
	//#if SKEIN_TREE_HASH
	// /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// /* just do the OUTPUT stage                                       */
	//static int Skein_256_Output(Skein_256_Ctxt_t *ctx, u08b_t *hashVal)
	//    {
	//    size_t i,n,byteCnt;
	//    u64b_t X[SKEIN_256_STATE_WORDS];
	//    Skein_Assert(ctx->h.bCnt <= SKEIN_256_BLOCK_BYTES,SKEIN_FAIL);    // catch uninitialized context 
	//
	// /* now output the result */
	//    byteCnt = (ctx->h.hashBitLen + 7) >> 3;    // total number of output bytes 
	//
	// /* run Threefish in "counter mode" to generate output */
	//    memset(ctx->b,0,sizeof(ctx->b));  // zero out b[], so it can hold the counter 
	//    memcpy(X,ctx->X,sizeof(X));       // keep a local copy of counter mode "key" 
	//    for (i=0;i*SKEIN_256_BLOCK_BYTES < byteCnt;i++)
	//        {
	//        ((u64b_t *)ctx->b)[0]= Skein_Swap64((u64b_t) i); // build the counter block 
	//        Skein_Start_New_Type(ctx,OUT_FINAL);
	//        Skein_256_Process_Block(ctx,ctx->b,1,sizeof(u64b_t)); // run "counter mode" 
	//        n = byteCnt - i*SKEIN_256_BLOCK_BYTES;   // number of output bytes left to go 
	//        if (n >= SKEIN_256_BLOCK_BYTES)
	//            n  = SKEIN_256_BLOCK_BYTES;
	//        Skein_Put64_LSB_First(hashVal+i*SKEIN_256_BLOCK_BYTES,ctx->X,n);   // "output" the ctr mode bytes 
	//        Skein_Show_Final(256,&ctx->h,n,hashVal+i*SKEIN_256_BLOCK_BYTES);
	//        memcpy(ctx->X,X,sizeof(X));   // restore the counter mode key for next time 
	//        }
	//    return SKEIN_SUCCESS;
	//    }
	//
	// /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// /* just do the OUTPUT stage                                       */
	//static int Skein_512_Output(Skein_512_Ctxt_t *ctx, u08b_t *hashVal)
	//    {
	//    size_t i,n,byteCnt;
	//    u64b_t X[SKEIN_512_STATE_WORDS];
	//    Skein_Assert(ctx->h.bCnt <= SKEIN_512_BLOCK_BYTES,SKEIN_FAIL);    // catch uninitialized context 
	//
	// /* now output the result */
	//    byteCnt = (ctx->h.hashBitLen + 7) >> 3;    // total number of output bytes 
	//
	// /* run Threefish in "counter mode" to generate output */
	//    memset(ctx->b,0,sizeof(ctx->b));  // zero out b[], so it can hold the counter 
	//    memcpy(X,ctx->X,sizeof(X));       // keep a local copy of counter mode "key" 
	//    for (i=0;i*SKEIN_512_BLOCK_BYTES < byteCnt;i++)
	//        {
	//        ((u64b_t *)ctx->b)[0]= Skein_Swap64((u64b_t) i); // build the counter block 
	//        Skein_Start_New_Type(ctx,OUT_FINAL);
	//        Skein_512_Process_Block(ctx,ctx->b,1,sizeof(u64b_t)); // run "counter mode" 
	//        n = byteCnt - i*SKEIN_512_BLOCK_BYTES;   // number of output bytes left to go 
	//        if (n >= SKEIN_512_BLOCK_BYTES)
	//            n  = SKEIN_512_BLOCK_BYTES;
	//        Skein_Put64_LSB_First(hashVal+i*SKEIN_512_BLOCK_BYTES,ctx->X,n);   // "output" the ctr mode bytes 
	//        Skein_Show_Final(256,&ctx->h,n,hashVal+i*SKEIN_512_BLOCK_BYTES);
	//        memcpy(ctx->X,X,sizeof(X));   // restore the counter mode key for next time 
	//        }
	//    return SKEIN_SUCCESS;
	//    }
	//
	// /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	// /* just do the OUTPUT stage                                       */
	//static int Skein1024_Output(Skein1024_Ctxt_t *ctx, u08b_t *hashVal)
	//    {
	//    size_t i,n,byteCnt;
	//    u64b_t X[SKEIN1024_STATE_WORDS];
	//    Skein_Assert(ctx->h.bCnt <= SKEIN1024_BLOCK_BYTES,SKEIN_FAIL);    // catch uninitialized context 
	//
	// /* now output the result */
	//    byteCnt = (ctx->h.hashBitLen + 7) >> 3;    // total number of output bytes 
	//
	// /* run Threefish in "counter mode" to generate output */
	//    memset(ctx->b,0,sizeof(ctx->b));  // zero out b[], so it can hold the counter 
	//    memcpy(X,ctx->X,sizeof(X));       // keep a local copy of counter mode "key" 
	//    for (i=0;i*SKEIN1024_BLOCK_BYTES < byteCnt;i++)
	//        {
	//        ((u64b_t *)ctx->b)[0]= Skein_Swap64((u64b_t) i); // build the counter block 
	//        Skein_Start_New_Type(ctx,OUT_FINAL);
	//        Skein1024_Process_Block(ctx,ctx->b,1,sizeof(u64b_t)); // run "counter mode" 
	//        n = byteCnt - i*SKEIN1024_BLOCK_BYTES;   // number of output bytes left to go 
	//        if (n >= SKEIN1024_BLOCK_BYTES)
	//            n  = SKEIN1024_BLOCK_BYTES;
	//        Skein_Put64_LSB_First(hashVal+i*SKEIN1024_BLOCK_BYTES,ctx->X,n);   // "output" the ctr mode bytes 
	//        Skein_Show_Final(256,&ctx->h,n,hashVal+i*SKEIN1024_BLOCK_BYTES);
	//        memcpy(ctx->X,X,sizeof(X));   // restore the counter mode key for next time 
	//        }
	//    return SKEIN_SUCCESS;
	//    }
	//#endif
	#endif

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* select the context size and init the context */

	/* "incremental" hashing API */
	internal static HashReturn Init(hashState state, int hashbitlen)
	{
	#if SKEIN_256_NIST_MAX_HASHBITS
	  if (hashbitlen <= DefineConstants.SKEIN_256_NIST_MAX_HASHBITS)
	  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_Assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		Skein_Assert(hashbitlen > 0,BAD_HASHLEN);
		state.statebits = 64 * DefineConstants.SKEIN_256_STATE_WORDS;
		return Skein_256_Init(state.u.ctx_256, (size_t) hashbitlen);
	  }
	#endif
	  if (hashbitlen <= DefineConstants.SKEIN_512_NIST_MAX_HASHBITS)
	  {
		state.statebits = 64 * DefineConstants.SKEIN_512_STATE_WORDS;
		return Skein_512_Init(state.u.ctx_512, (size_t) hashbitlen);
	  }
	  else
	  {
		state.statebits = 64 * DefineConstants.SKEIN1024_STATE_WORDS;
		return Skein1024_Init(state.u.ctx1024, (size_t) hashbitlen);
	  }
	}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* process data to be hashed */
	internal static HashReturn Update(hashState state, ushort[] data, size_t databitlen)
	{
	  /* only the final Update() call is allowed do partial bytes, else assert an error */
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_Assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  Skein_Assert((state.u.h.T[1] & (((ulong) 1) << ((119) - 64))) == 0 || databitlen == 0, HashReturn.SKEIN_FAIL);

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_Assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  Skein_Assert(state.statebits % 256 == 0 && (state.statebits - 256) < 1024, HashReturn.SKEIN_FAIL);
	  if ((databitlen & 7) == 0) // partial bytes?
	  {
		switch ((state.statebits >> 8) & 3)
		{
		case 2:
			return Skein_512_Update(state.u.ctx_512, new ushort(data), databitlen >> 3);
		case 1:
			return Skein_256_Update(state.u.ctx_256, new ushort(data), databitlen >> 3);
		case 0:
			return Skein1024_Update(state.u.ctx1024, new ushort(data), databitlen >> 3);
		default:
			return HashReturn.SKEIN_FAIL;
		}
	  }
	  else
	  { // handle partial final byte
		size_t bCnt = (databitlen >> 3) + 1; // number of bytes to handle (nonzero here!)
		ushort b = new ushort();
		ushort mask = new ushort();

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: mask = (ushort)(1u << (7 - (databitlen & 7)));
		mask.CopyFrom((ushort)(1u << (7 - (databitlen & 7)))); // partial byte bit mask
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: b = (ushort)((data[bCnt-1] & (0-mask)) | mask);
		b.CopyFrom((ushort)((data[bCnt - 1] & (0 - mask)) | mask)); // apply bit padding on final byte

		switch ((state.statebits >> 8) & 3)
		{
		case 2:
			Skein_512_Update(state.u.ctx_512, new ushort(data), bCnt - 1); // process all but the final byte
		  Skein_512_Update(state.u.ctx_512, b, 1); // process the (masked) partial byte
		  break;
		case 1:
			Skein_256_Update(state.u.ctx_256, new ushort(data), bCnt - 1); // process all but the final byte
		  Skein_256_Update(state.u.ctx_256, b, 1); // process the (masked) partial byte
		  break;
		case 0:
			Skein1024_Update(state.u.ctx1024, new ushort(data), bCnt - 1); // process all but the final byte
		  Skein1024_Update(state.u.ctx1024, b, 1); // process the (masked) partial byte
		  break;
		default:
			return HashReturn.SKEIN_FAIL;
		}
		{
			(state.u.h).T[1] |= (((ulong) 1) << ((119) - 64));
	}; // set tweak flag for the final call

		return HashReturn.SKEIN_SUCCESS;
	  }
	}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/* finalize hash computation and output the result (hashbitlen bits) */
	internal static HashReturn Final(hashState state, ushort hashval)
	{
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'Skein_Assert' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  Skein_Assert(state.statebits % 256 == 0 && (state.statebits - 256) < 1024, FAIL);
	  switch ((state.statebits >> 8) & 3)
	  {
	  case 2:
		  return Skein_512_Final(state.u.ctx_512, hashval);
	  case 1:
		  return Skein_256_Final(state.u.ctx_256, hashval);
	  case 0:
		  return Skein1024_Final(state.u.ctx1024, hashval);
	  default:
		  return HashReturn.SKEIN_FAIL;
	  }
	}

	// Parts of this file are originally copyright (c) 2012-2013 The Cryptonote developers
	// Copyright (c) 2014-2018, The Monero Project
	// Copyright (c) 2014-2018, The Aeon Project
	// Copyright (c) 2018, The TurtleCoin Developers
	//
	// Please see the included LICENSE file for more information.


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define inline __inline
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IDENT32(x) ((uint) (x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IDENT64(x) ((ulong) (x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32(x) ((((uint) (x) & 0x000000ff) << 24) | (((uint) (x) & 0x0000ff00) << 8) | (((uint) (x) & 0x00ff0000) >> 8) | (((uint) (x) & 0xff000000) >> 24))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64(x) ((((ulong) (x) & 0x00000000000000ff) << 56) | (((ulong) (x) & 0x000000000000ff00) << 40) | (((ulong) (x) & 0x0000000000ff0000) << 24) | (((ulong) (x) & 0x00000000ff000000) << 8) | (((ulong) (x) & 0x000000ff00000000) >> 8) | (((ulong) (x) & 0x0000ff0000000000) >> 24) | (((ulong) (x) & 0x00ff000000000000) >> 40) | (((ulong) (x) & 0xff00000000000000) >> 56))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32LE IDENT32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32BE SWAP32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32le ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32be swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32le mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32be mem_inplace_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32le memcpy_ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32be memcpy_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64LE IDENT64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64BE SWAP64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64le ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64be swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64le mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64be mem_inplace_swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64le memcpy_ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64be memcpy_swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32BE IDENT32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32LE SWAP32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32be ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32le swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32be mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32le mem_inplace_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32be memcpy_ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32le memcpy_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64BE IDENT64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64LE SWAP64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64be ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64le swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64be mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64le mem_inplace_swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64be memcpy_ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64le memcpy_swap64
	// Copyright (c) 2014-2018, The Monero Project
	// Copyright (c) 2018, The TurtleCoin Developers
	//
	// Please see the included LICENSE file for more information.



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_INTEGER_MATH_SQRT_STEP_SSE2() do { const __m128i exp_double_bias = _mm_set_epi64x(0, 1023ULL << 52); __m128d x = _mm_castsi128_pd(_mm_add_epi64(_mm_cvtsi64_si128(sqrt_input >> 12), exp_double_bias)); x = _mm_sqrt_sd(_mm_setzero_pd(), x); sqrt_result = (ulong)(_mm_cvtsi128_si64(_mm_sub_epi64(_mm_castpd_si128(x), exp_double_bias))) >> 19; } while(0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_INTEGER_MATH_SQRT_STEP_FP64() do { sqrt_result = sqrt(sqrt_input + 18446744073709551616.0) * 2.0 - 8589934592.0; } while(0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_INTEGER_MATH_SQRT_STEP_REF() sqrt_result = integer_square_root_v2(sqrt_input)

	// Reference implementation of the integer square root for Cryptonight variant 2
	// Computes integer part of "sqrt(2^64 + n) * 2 - 2^33"
	//
	// In other words, given 64-bit unsigned integer n:
	// 1) Write it as x = 1.NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN000... in binary (1 <= x < 2, all 64 bits of n are used)
	// 2) Calculate sqrt(x) = 1.0RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR... (1 <= sqrt(x) < sqrt(2), so it will always start with "1.0" in binary)
	// 3) Take 32 bits that come after "1.0" and return them as a 32-bit unsigned integer, discard all remaining bits
	//
	// Some sample inputs and outputs:
	//
	// Input            | Output     | Exact value of "sqrt(2^64 + n) * 2 - 2^33"
	// -----------------|------------|-------------------------------------------
	// 0                | 0          | 0
	// 2^32             | 0          | 0.99999999994179233909330885695244...
	// 2^32 + 1         | 1          | 1.0000000001746229827200734316305...
	// 2^50             | 262140     | 262140.00012206565608606978175873...
	// 2^55 + 20963331  | 8384515    | 8384515.9999999997673963974959744...
	// 2^55 + 20963332  | 8384516    | 8384516
	// 2^62 + 26599786  | 1013904242 | 1013904242.9999999999479374853545...
	// 2^62 + 26599787  | 1013904243 | 1013904243.0000000001561875439364...
	// 2^64 - 1         | 3558067407 | 3558067407.9041987696409179931096...

	// The reference implementation as it is now uses only unsigned int64 arithmetic, so it can't have undefined behavior
	// It was tested once for all edge cases and confirmed correct
	internal static uint integer_square_root_v2(ulong n)
	{
	  ulong r = 1UL << 63;

	  for (ulong bit = 1UL << 60; bit != null; bit >>= 2)
	  {
		bool b = (n < r + bit);
		ulong n_next = n - (r + bit);
		ulong r_next = r + bit * 2;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: n = b ? n : n_next;
		n.CopyFrom(b ? n : n_next);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: r = b ? r : r_next;
		r.CopyFrom(b ? r : r_next);
		r >>= 1;
	  }

	  return r * 2 + ((n > r) ? 1 : 0);
	}

	/*
	VARIANT2_INTEGER_MATH_SQRT_FIXUP checks that "r" is an integer part of "sqrt(2^64 + sqrt_input) * 2 - 2^33" and adds or subtracts 1 if needed
	It's hard to understand how it works, so here is a full calculation of formulas used in VARIANT2_INTEGER_MATH_SQRT_FIXUP
	
	The following inequalities must hold for r if it's an integer part of "sqrt(2^64 + sqrt_input) * 2 - 2^33":
	1) r <= sqrt(2^64 + sqrt_input) * 2 - 2^33
	2) r + 1 > sqrt(2^64 + sqrt_input) * 2 - 2^33
	
	We need to check them using only unsigned integer arithmetic to avoid rounding errors and undefined behavior
	
	First inequality: r <= sqrt(2^64 + sqrt_input) * 2 - 2^33
	-----------------------------------------------------------------------------------
	r <= sqrt(2^64 + sqrt_input) * 2 - 2^33
	r + 2^33 <= sqrt(2^64 + sqrt_input) * 2
	r/2 + 2^32 <= sqrt(2^64 + sqrt_input)
	(r/2 + 2^32)^2 <= 2^64 + sqrt_input
	
	Rewrite r as r = s * 2 + b (s = trunc(r/2), b is 0 or 1)
	
	((s*2+b)/2 + 2^32)^2 <= 2^64 + sqrt_input
	(s*2+b)^2/4 + 2*2^32*(s*2+b)/2 + 2^64 <= 2^64 + sqrt_input
	(s*2+b)^2/4 + 2*2^32*(s*2+b)/2 <= sqrt_input
	(s*2+b)^2/4 + 2^32*r <= sqrt_input
	(s^2*4+2*s*2*b+b^2)/4 + 2^32*r <= sqrt_input
	s^2+s*b+b^2/4 + 2^32*r <= sqrt_input
	s*(s+b) + b^2/4 + 2^32*r <= sqrt_input
	
	Let r2 = s*(s+b) + r*2^32
	r2 + b^2/4 <= sqrt_input
	
	If this inequality doesn't hold, then we must decrement r: IF "r2 + b^2/4 > sqrt_input" THEN r = r - 1
	
	b can be 0 or 1
	If b is 0 then we need to compare "r2 > sqrt_input"
	If b is 1 then b^2/4 = 0.25, so we need to compare "r2 + 0.25 > sqrt_input"
	Since both r2 and sqrt_input are integers, we can safely replace it with "r2 + 1 > sqrt_input"
	-----------------------------------------------------------------------------------
	Both cases can be merged to a single expression "r2 + b > sqrt_input"
	-----------------------------------------------------------------------------------
	There will be no overflow when calculating "r2 + b", so it's safe to compare with sqrt_input:
	r2 + b = s*(s+b) + r*2^32 + b
	The largest value s, b and r can have is s = 1779033703, b = 1, r = 3558067407 when sqrt_input = 2^64 - 1
	r2 + b <= 1779033703*1779033704 + 3558067407*2^32 + 1 = 18446744068217447385 < 2^64
	
	Second inequality: r + 1 > sqrt(2^64 + sqrt_input) * 2 - 2^33
	-----------------------------------------------------------------------------------
	r + 1 > sqrt(2^64 + sqrt_input) * 2 - 2^33
	r + 1 + 2^33 > sqrt(2^64 + sqrt_input) * 2
	((r+1)/2 + 2^32)^2 > 2^64 + sqrt_input
	
	Rewrite r as r = s * 2 + b (s = trunc(r/2), b is 0 or 1)
	
	((s*2+b+1)/2 + 2^32)^2 > 2^64 + sqrt_input
	(s*2+b+1)^2/4 + 2*(s*2+b+1)/2*2^32 + 2^64 > 2^64 + sqrt_input
	(s*2+b+1)^2/4 + (s*2+b+1)*2^32 > sqrt_input
	(s*2+b+1)^2/4 + (r+1)*2^32 > sqrt_input
	(s*2+(b+1))^2/4 + r*2^32 + 2^32 > sqrt_input
	(s^2*4+2*s*2*(b+1)+(b+1)^2)/4 + r*2^32 + 2^32 > sqrt_input
	s^2+s*(b+1)+(b+1)^2/4 + r*2^32 + 2^32 > sqrt_input
	s*(s+b) + s + (b+1)^2/4 + r*2^32 + 2^32 > sqrt_input
	
	Let r2 = s*(s+b) + r*2^32
	
	r2 + s + (b+1)^2/4 + 2^32 > sqrt_input
	r2 + 2^32 + (b+1)^2/4 > sqrt_input - s
	
	If this inequality doesn't hold, then we must decrement r: IF "r2 + 2^32 + (b+1)^2/4 <= sqrt_input - s" THEN r = r - 1
	b can be 0 or 1
	If b is 0 then we need to compare "r2 + 2^32 + 1/4 <= sqrt_input - s" which is equal to "r2 + 2^32 < sqrt_input - s" because all numbers here are integers
	If b is 1 then (b+1)^2/4 = 1, so we need to compare "r2 + 2^32 + 1 <= sqrt_input - s" which is also equal to "r2 + 2^32 < sqrt_input - s"
	-----------------------------------------------------------------------------------
	Both cases can be merged to a single expression "r2 + 2^32 < sqrt_input - s"
	-----------------------------------------------------------------------------------
	There will be no overflow when calculating "r2 + 2^32":
	r2 + 2^32 = s*(s+b) + r*2^32 + 2^32 = s*(s+b) + (r+1)*2^32
	The largest value s, b and r can have is s = 1779033703, b = 1, r = 3558067407 when sqrt_input = 2^64 - 1
	r2 + b <= 1779033703*1779033704 + 3558067408*2^32 = 18446744072512414680 < 2^64
	
	There will be no integer overflow when calculating "sqrt_input - s", i.e. "sqrt_input >= s" at all times:
	s = trunc(r/2) = trunc(sqrt(2^64 + sqrt_input) - 2^32) < sqrt(2^64 + sqrt_input) - 2^32 + 1
	sqrt_input > sqrt(2^64 + sqrt_input) - 2^32 + 1
	sqrt_input + 2^32 - 1 > sqrt(2^64 + sqrt_input)
	(sqrt_input + 2^32 - 1)^2 > sqrt_input + 2^64
	sqrt_input^2 + 2*sqrt_input*(2^32 - 1) + (2^32-1)^2 > sqrt_input + 2^64
	sqrt_input^2 + sqrt_input*(2^33 - 2) + (2^32-1)^2 > sqrt_input + 2^64
	sqrt_input^2 + sqrt_input*(2^33 - 3) + (2^32-1)^2 > 2^64
	sqrt_input^2 + sqrt_input*(2^33 - 3) + 2^64-2^33+1 > 2^64
	sqrt_input^2 + sqrt_input*(2^33 - 3) - 2^33 + 1 > 0
	This inequality is true if sqrt_input > 1 and it's easy to check that s = 0 if sqrt_input is 0 or 1, so there will be no integer overflow
	*/

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_INTEGER_MATH_SQRT_FIXUP(r) do { const ulong s = r >> 1; const ulong b = r & 1; const ulong r2 = (ulong)(s) * (s + b) + (r << 32); r += ((r2 + b > sqrt_input) ? -1 : 0) + ((r2 + (1ULL << 32) < sqrt_input - s) ? 1 : 0); } while(0)


	// Standard Crypto Definitions
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define INIT_SIZE_BYTE (INIT_SIZE_BLK * AES_BLOCK_SIZE)

	//int aesb_single_round(ushort in, ushort @out, ushort expandedKey);Tangible Method Implementation Not Found-aesb_single_round
	//int aesb_pseudo_round(ushort in, ushort @out, ushort expandedKey);Tangible Method Implementation Not Found-aesb_pseudo_round

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT1_1(p) do if (variant == 1) { const ushort tmp = ((const ushort*)(p))[11]; static const uint table = 0x75310; const ushort index = (((tmp >> 3) & 6) | (tmp & 1)) << 1; ((ushort*)(p))[11] = tmp ^ ((table >> index) & 0x30); } while(0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT1_2(p) do if (variant == 1) { xor64(p, tweak1_2); } while(0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT1_CHECK() do if (length < 43) { fprintf(stderr, "Cryptonight variant 1 need at least 43 bytes of data"); abort(); } while(0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NONCE_POINTER (((const ushort*)data)+35)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT1_PORTABLE_INIT() ushort tweak1_2[8]; do if (variant == 1) { VARIANT1_CHECK(); memcpy(&tweak1_2, &state.hs.b[192], sizeof(tweak1_2)); xor64(tweak1_2, NONCE_POINTER); } while(0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT1_INIT64() if (variant == 1) { VARIANT1_CHECK(); } const ulong tweak1_2 = (variant == 1) ? (state.hs.w[24] ^ (*((const ulong*)NONCE_POINTER))) : 0

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_INIT64() ulong division_result = 0; ulong sqrt_result = 0; do if (variant == 2) { U64(b)[2] = state.hs.w[8] ^ state.hs.w[10]; U64(b)[3] = state.hs.w[9] ^ state.hs.w[11]; division_result = state.hs.w[12]; sqrt_result = state.hs.w[13]; } while (0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_PORTABLE_INIT() ulong division_result = 0; ulong sqrt_result = 0; do if (variant == 2) { memcpy(b + AES_BLOCK_SIZE, state.hs.b + 64, AES_BLOCK_SIZE); xor64(b + AES_BLOCK_SIZE, state.hs.b + 80); xor64(b + AES_BLOCK_SIZE + 8, state.hs.b + 88); division_result = state.hs.w[12]; sqrt_result = state.hs.w[13]; } while (0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_SHUFFLE_ADD_SSE2(base_ptr, offset) do if (variant == 2) { const __m128i chunk1 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10))); const __m128i chunk2 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20))); const __m128i chunk3 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30))); _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10)), _mm_add_epi64(chunk3, _b1)); _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20)), _mm_add_epi64(chunk1, _b)); _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30)), _mm_add_epi64(chunk2, _a)); } while (0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_SHUFFLE_ADD_NEON(base_ptr, offset) do if (variant == 2) { const uint64x2_t chunk1 = vld1q_u64(U64((base_ptr) + ((offset) ^ 0x10))); const uint64x2_t chunk2 = vld1q_u64(U64((base_ptr) + ((offset) ^ 0x20))); const uint64x2_t chunk3 = vld1q_u64(U64((base_ptr) + ((offset) ^ 0x30))); vst1q_u64(U64((base_ptr) + ((offset) ^ 0x10)), vaddq_u64(chunk3, vreinterpretq_u64_u8(_b1))); vst1q_u64(U64((base_ptr) + ((offset) ^ 0x20)), vaddq_u64(chunk1, vreinterpretq_u64_u8(_b))); vst1q_u64(U64((base_ptr) + ((offset) ^ 0x30)), vaddq_u64(chunk2, vreinterpretq_u64_u8(_a))); } while (0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_PORTABLE_SHUFFLE_ADD(base_ptr, offset) do if (variant == 2) { ulong* chunk1 = U64((base_ptr) + ((offset) ^ 0x10)); ulong* chunk2 = U64((base_ptr) + ((offset) ^ 0x20)); ulong* chunk3 = U64((base_ptr) + ((offset) ^ 0x30)); const ulong chunk1_old[2] = { chunk1[0], chunk1[1] }; ulong b1[2]; memcpy(b1, b + 16, 16); chunk1[0] = chunk3[0] + b1[0]; chunk1[1] = chunk3[1] + b1[1]; ulong a0[2]; memcpy(a0, a, 16); chunk3[0] = chunk2[0] + a0[0]; chunk3[1] = chunk2[1] + a0[1]; ulong b0[2]; memcpy(b0, b, 16); chunk2[0] = chunk1_old[0] + b0[0]; chunk2[1] = chunk1_old[1] + b0[1]; } while (0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_INTEGER_MATH_DIVISION_STEP(b, ptr) ((ulong*)(b))[0] ^= division_result ^ (sqrt_result << 32); { const ulong dividend = ((ulong*)(ptr))[1]; const uint divisor = (((ulong*)(ptr))[0] + (uint)(sqrt_result << 1)) | 0x80000001UL; division_result = ((uint)(dividend / divisor)) + (((ulong)(dividend % divisor)) << 32); } const ulong sqrt_input = ((ulong*)(ptr))[0] + division_result

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_INTEGER_MATH_SSE2(b, ptr) do if (variant == 2) { VARIANT2_INTEGER_MATH_DIVISION_STEP(b, ptr); VARIANT2_INTEGER_MATH_SQRT_STEP_SSE2(); VARIANT2_INTEGER_MATH_SQRT_FIXUP(sqrt_result); } while(0)

	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	#if DBL_MANT_DIG && (DBL_MANT_DIG >= 50)
	  // double precision floating point type has enough bits of precision on current platform
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_PORTABLE_INTEGER_MATH(b, ptr) do if (variant == 2) { VARIANT2_INTEGER_MATH_DIVISION_STEP(b, ptr); VARIANT2_INTEGER_MATH_SQRT_STEP_FP64(); VARIANT2_INTEGER_MATH_SQRT_FIXUP(sqrt_result); } while (0)
	  #define VARIANT2_PORTABLE_INTEGER_MATH
	#else
	  // double precision floating point type is not good enough on current platform
	  // fall back to the reference code (integer only)
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_PORTABLE_INTEGER_MATH(b, ptr) do if (variant == 2) { VARIANT2_INTEGER_MATH_DIVISION_STEP(b, ptr); VARIANT2_INTEGER_MATH_SQRT_STEP_REF(); } while (0)
	  #define VARIANT2_PORTABLE_INTEGER_MATH
	#endif

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_2_PORTABLE() if (variant == 2) { xor_blocks(long_state + (j ^ 0x10), d); xor_blocks(d, long_state + (j ^ 0x20)); }

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VARIANT2_2() do if (variant == 2) { *U64(hp_state + (j ^ 0x10)) ^= hi; *(U64(hp_state + (j ^ 0x10)) + 1) ^= lo; hi ^= *U64(hp_state + (j ^ 0x20)); lo ^= *(U64(hp_state + (j ^ 0x20)) + 1); } while (0)

	#if ! NO_AES && (__x86_64__ || (_MSC_VER && _WIN64))
	// Optimised code below, uses x86-specific intrinsics, SSE2, AES-NI
	// Fall back to more portable code is down at the bottom


	#if _MSC_VER
	#define STATIC
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define INLINE __inline
	#define INLINE
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RDATA_ALIGN16 __declspec(align(16))
	#define RDATA_ALIGN16
	#elif __MINGW32__
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define STATIC static
	#define STATIC
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define INLINE inline
	#define INLINE
	#define RDATA_ALIGN16
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define STATIC static
	#define STATIC
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define INLINE inline
	#define INLINE
	#define RDATA_ALIGN16
	#endif

	#if __INTEL_COMPILER
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ASM __asm__
	#define ASM
	#elif !_MSC_VER
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ASM __asm__
	#define ASM
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ASM __asm
	#define ASM
	#endif

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define U64(x) ((ulong *) (x))
	#define U64
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define R128(x) ((__m128i *) (x))
	#define R128

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define state_index(x,div) (((*((ulong *)x) >> 4) & (TOTALBLOCKS /(div) - 1)) << 4)
	#define state_index
	#if _MSC_VER
	#if !_WIN64
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define __mul() lo = mul128(c[0], b[0], &hi);
	#define __mul
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define __mul() lo = _umul128(c[0], b[0], &hi);
	#define __mul
	#endif
	#else
	#if __x86_64__
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define __mul() ASM("mulq %3\n\t" : "=d"(hi), "=a"(lo) : "%a" (c[0]), "rm" (b[0]) : "cc");
	#define __mul
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define __mul() lo = mul128(c[0], b[0], &hi);
	#define __mul
	#endif
	#endif

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pre_aes() j = state_index(a,lightFlag); _c = _mm_load_si128(R128(&hp_state[j])); _a = _mm_load_si128(R128(a));
	#define pre_aes
	/*
	 * An SSE-optimized implementation of the second half of CryptoNight step 3.
	 * After using AES to mix a scratchpad value into _c (done by the caller),
	 * this macro xors it with _b and stores the result back to the same index (j) that it
	 * loaded the scratchpad value from.  It then performs a second random memory
	 * read/write from the scratchpad, but this time mixes the values using a 64
	 * bit multiply.
	 * This code is based upon an optimized implementation by dga.
	 */
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define post_aes() VARIANT2_SHUFFLE_ADD_SSE2(hp_state, j); _mm_store_si128(R128(c), _c); _mm_store_si128(R128(&hp_state[j]), _mm_xor_si128(_b, _c)); VARIANT1_1(&hp_state[j]); j = state_index(c,lightFlag); p = U64(&hp_state[j]); b[0] = p[0]; b[1] = p[1]; VARIANT2_INTEGER_MATH_SSE2(b, c); __mul(); VARIANT2_2(); VARIANT2_SHUFFLE_ADD_SSE2(hp_state, j); a[0] += hi; a[1] += lo; p = U64(&hp_state[j]); p[0] = a[0]; p[1] = a[1]; a[0] ^= b[0]; a[1] ^= b[1]; VARIANT1_2(p + 1); _b1 = _b; _b = _c;
	#define post_aes
	#if _MSC_VER
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define THREADV __declspec(thread)
	#define THREADV
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define THREADV __thread
	#define THREADV
	#endif
	//{
	//  union hash_state hs;
	//  struct
	//  {
	//	ushort k[64];
	//	ushort init[(DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE)];
	//  };
	//};
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent to most C++ 'pragma' directives in C#:
	//#pragma pack(pop)

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'THREADV' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static THREADV ushort * hp_state = null;
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'THREADV' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static THREADV int hp_allocated = 0;

	#if _MSC_VER
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cpuid(info,x) __cpuidex(info,x,0)
	#define cpuid
	#else
//C++ TO C# CONVERTER TODO TASK: The following method format was not recognized, possibly due to an unrecognized macro:
	void __cpuidex(int CPUInfo[4],int InfoType,0)
	{
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'ASM' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'ASM' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'ASM' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'ASM' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'ASM' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'ASM' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'ASM' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'ASM' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'ASM' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  ASM __volatile__ = new ASM("cpuid": "=a" (CPUInfo[0]), "=b" (CPUInfo[1]), "=c" (CPUInfo[2]), "=d" (CPUInfo[3]) : "a" (InfoType), "c" (0));
	}
	#endif

	/**
	 * @brief a = (a xor b), where a and b point to 128 bit values
	 */

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void xor_blocks(ushort a, ushort b)
	{
	  ((ulong)(a))[0] ^= ((ulong)(b))[0];
	  ((ulong)(a))[1] ^= ((ulong)(b))[1];
	}

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void xor64(ulong a, ulong b)
	{
	  a ^= b;
	}
//C++ TO C# CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in C#):
private static int force_software_aes_use = -1;

	/**
	 * @brief uses cpuid to determine if the CPU supports the AES instructions
	 * @return true if the CPU supports AES, false otherwise
	 */

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE int force_software_aes()
	{
	//C++ TO C# CONVERTER NOTE: This static local variable declaration (not allowed in C#) has been moved just prior to the method:
	//  static int use = -1;

	  if (force_software_aes_use != -1)
	  {
		return force_software_aes_use;
	  }

//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const char *env = getenv("TURTLECOIN_USE_SOFTWARE_AES");
	  char env = getenv("TURTLECOIN_USE_SOFTWARE_AES");
	  if (env == null)
	  {
		force_software_aes_use = 0;
	  }
	  else if (!string.Compare(env, "0") || !string.Compare(env, "no"))
	  {
		force_software_aes_use = 0;
	  }
	  else
	  {
		force_software_aes_use = 1;
	  }
	  return force_software_aes_use;
	}
//C++ TO C# CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in C#):
private static int check_aes_hw_supported = -1;

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE int check_aes_hw()
	{
	  int[] cpuid_results = new int[4];
	//C++ TO C# CONVERTER NOTE: This static local variable declaration (not allowed in C#) has been moved just prior to the method:
	//  static int supported = -1;

	  if (check_aes_hw_supported >= 0)
	  {
		return check_aes_hw_supported;
	  }

	  __cpuidex(cpuid_results,1,0);
	  return check_aes_hw_supported = cpuid_results[2] & (1 << 25);
	}

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void aes_256_assist1(__m128i t1, __m128i t2)
	{
	  __m128i t4 = new __m128i();
	  t2 = _mm_shuffle_epi32(t2, 0xff);
	  t4 = _mm_slli_si128(t1, 0x04);
	  t1 = _mm_xor_si128(t1, t4);
	  t4 = _mm_slli_si128(t4, 0x04);
	  t1 = _mm_xor_si128(t1, t4);
	  t4 = _mm_slli_si128(t4, 0x04);
	  t1 = _mm_xor_si128(t1, t4);
	  t1 = _mm_xor_si128(t1, t2);
	}

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void aes_256_assist2(__m128i t1, __m128i t3)
	{
	  __m128i t2 = new __m128i();
	  __m128i t4 = new __m128i();
	  t4 = _mm_aeskeygenassist_si128(t1, 0x00);
	  t2 = _mm_shuffle_epi32(t4, 0xaa);
	  t4 = _mm_slli_si128(t3, 0x04);
	  t3 = _mm_xor_si128(t3, t4);
	  t4 = _mm_slli_si128(t4, 0x04);
	  t3 = _mm_xor_si128(t3, t4);
	  t4 = _mm_slli_si128(t4, 0x04);
	  t3 = _mm_xor_si128(t3, t4);
	  t3 = _mm_xor_si128(t3, t2);
	}

	/**
	 * @brief expands 'key' into a form it can be used for AES encryption.
	 *
	 * This is an SSE-optimized implementation of AES key schedule generation.  It
	 * expands the key into multiple round keys, each of which is used in one round
	 * of the AES encryption used to fill (and later, extract randomness from)
	 * the large 2MB buffer.  Note that CryptoNight does not use a completely
	 * standard AES encryption for its buffer expansion, so do not copy this
	 * function outside of Monero without caution!  This version uses the hardware
	 * AESKEYGENASSIST instruction to speed key generation, and thus requires
	 * CPU AES support.
	 * For more information about these functions, see page 19 of Intel's AES instructions
	 * white paper:
	 * https://www.intel.com/content/dam/doc/white-paper/advanced-encryption-standard-new-instructions-set-paper.pdf
	 *
	 * @param key the input 128 bit key
	 * @param expandedKey An output buffer to hold the generated key schedule
	 */

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void aes_expand_key(ushort key, ushort expandedKey)
	{
	  __m128i[] ek = ((__m128i)(expandedKey));
	  __m128i t1 = new __m128i();
	  __m128i t2 = new __m128i();
	  __m128i t3 = new __m128i();

	  t1 = _mm_loadu_si128(((__m128i)(key)));
	  t3 = _mm_loadu_si128(((__m128i)(key + 16)));

	  ek[0] = t1;
	  ek[1] = t3;

	  t2 = _mm_aeskeygenassist_si128(t3, 0x01);
	  aes_256_assist1(t1, t2);
	  ek[2] = t1;
	  aes_256_assist2(t1, t3);
	  ek[3] = t3;

	  t2 = _mm_aeskeygenassist_si128(t3, 0x02);
	  aes_256_assist1(t1, t2);
	  ek[4] = t1;
	  aes_256_assist2(t1, t3);
	  ek[5] = t3;

	  t2 = _mm_aeskeygenassist_si128(t3, 0x04);
	  aes_256_assist1(t1, t2);
	  ek[6] = t1;
	  aes_256_assist2(t1, t3);
	  ek[7] = t3;

	  t2 = _mm_aeskeygenassist_si128(t3, 0x08);
	  aes_256_assist1(t1, t2);
	  ek[8] = t1;
	  aes_256_assist2(t1, t3);
	  ek[9] = t3;

	  t2 = _mm_aeskeygenassist_si128(t3, 0x10);
	  aes_256_assist1(t1, t2);
	  ek[10] = t1;
	}

	/**
	 * @brief a "pseudo" round of AES (similar to but slightly different from normal AES encryption)
	 *
	 * To fill its 2MB scratch buffer, CryptoNight uses a nonstandard implementation
	 * of AES encryption:  It applies 10 rounds of the basic AES encryption operation
	 * to an input 128 bit chunk of data <in>.  Unlike normal AES, however, this is
	 * all it does;  it does not perform the initial AddRoundKey step (this is done
	 * in subsequent steps by aesenc_si128), and it does not use the simpler final round.
	 * Hence, this is a "pseudo" round - though the function actually implements 10 rounds together.
	 *
	 * Note that unlike aesb_pseudo_round, this function works on multiple data chunks.
	 *
	 * @param in a pointer to nblocks * 128 bits of data to be encrypted
	 * @param out a pointer to an nblocks * 128 bit buffer where the output will be stored
	 * @param expandedKey the expanded AES key
	 * @param nblocks the number of 128 blocks of data to be encrypted
	 */

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void aes_pseudo_round(ushort in, ushort @out, ushort expandedKey, int nblocks)
	{
	  __m128i[] k = ((__m128i)(expandedKey));
	  __m128i d = new __m128i();
	  int i;

	  for (i = 0; i < nblocks; i++)
	  {
		d = _mm_loadu_si128(((__m128i)(in + i * DefineConstants.AES_BLOCK_SIZE)));
		d = _mm_aesenc_si128(d, (__m128i)(k[0]));
		d = _mm_aesenc_si128(d, (__m128i)(k[1]));
		d = _mm_aesenc_si128(d, (__m128i)(k[2]));
		d = _mm_aesenc_si128(d, (__m128i)(k[3]));
		d = _mm_aesenc_si128(d, (__m128i)(k[4]));
		d = _mm_aesenc_si128(d, (__m128i)(k[5]));
		d = _mm_aesenc_si128(d, (__m128i)(k[6]));
		d = _mm_aesenc_si128(d, (__m128i)(k[7]));
		d = _mm_aesenc_si128(d, (__m128i)(k[8]));
		d = _mm_aesenc_si128(d, (__m128i)(k[9]));
		_mm_storeu_si128((((__m128i)(@out + i * DefineConstants.AES_BLOCK_SIZE))), d);
	  }
	}

	/**
	 * @brief aes_pseudo_round that loads data from *in and xors it with *xor first
	 *
	 * This function performs the same operations as aes_pseudo_round, but before
	 * performing the encryption of each 128 bit block from <in>, it xors
	 * it with the corresponding block from <xor>.
	 *
	 * @param in a pointer to nblocks * 128 bits of data to be encrypted
	 * @param out a pointer to an nblocks * 128 bit buffer where the output will be stored
	 * @param expandedKey the expanded AES key
	 * @param xor a pointer to an nblocks * 128 bit buffer that is xored into in before encryption (in is left unmodified)
	 * @param nblocks the number of 128 blocks of data to be encrypted
	 */

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void aes_pseudo_round_xor(ushort in, ushort @out, ushort expandedKey, ushort xor, int nblocks)
	{
		__m128i[] k = ((__m128i)(expandedKey));
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
		__m128i * x = ((__m128i)(xor));
		__m128i d = new __m128i();
		int i;

		for (i = 0; i < nblocks; i++)
		{
			d = _mm_loadu_si128(((__m128i)(in + i * DefineConstants.AES_BLOCK_SIZE)));
			d = _mm_xor_si128(d, (__m128i)(x++));
			d = _mm_aesenc_si128(d, (__m128i)(k[0]));
			d = _mm_aesenc_si128(d, (__m128i)(k[1]));
			d = _mm_aesenc_si128(d, (__m128i)(k[2]));
			d = _mm_aesenc_si128(d, (__m128i)(k[3]));
			d = _mm_aesenc_si128(d, (__m128i)(k[4]));
			d = _mm_aesenc_si128(d, (__m128i)(k[5]));
			d = _mm_aesenc_si128(d, (__m128i)(k[6]));
			d = _mm_aesenc_si128(d, (__m128i)(k[7]));
			d = _mm_aesenc_si128(d, (__m128i)(k[8]));
			d = _mm_aesenc_si128(d, (__m128i)(k[9]));
			_mm_storeu_si128((((__m128i)(@out + i * DefineConstants.AES_BLOCK_SIZE))), d);
		}
	}

	#if _MSC_VER || __MINGW32__
	public static int SetLockPagesPrivilege(IntPtr hProcess, int bEnable)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//  struct
	//  {
	//	  uint count;
	//	  LUID_AND_ATTRIBUTES privilege[1];
	//  }
	//  info;

	  IntPtr token;
	  if (!OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, token))
	  {
		  return 0;
	  }

	  info.count = 1;
	  info.privilege[0].Attributes = bEnable != 0 ? SE_PRIVILEGE_ENABLED : 0;

	  if (!LookupPrivilegeValue(null, SE_LOCK_MEMORY_NAME, (info.privilege[0].Luid)))
	  {
		  return 0;
	  }

	  if (!AdjustTokenPrivileges(token, 0, (PTOKEN_PRIVILEGES) & info, 0, null, null))
	  {
		  return 0;
	  }

	  if (GetLastError() != ERROR_SUCCESS)
	  {
		  return 0;
	  }

	  CloseHandle(token);

	  return 1;
	}
	#endif

	/**
	 * @brief allocate the 2MB scratch buffer using OS support for huge pages, if available
	 *
	 * This function tries to allocate the 2MB scratch buffer using a single
	 * 2MB "huge page" (instead of the usual 4KB page sizes) to reduce TLB misses
	 * during the random accesses to the scratch buffer.  This is one of the
	 * important speed optimizations needed to make CryptoNight faster.
	 *
	 * No parameters.  Updates a thread-local pointer, hp_state, to point to
	 * the allocated buffer.
	 */

	public static void slow_hash_allocate_state(uint PAGE_SIZE)
	{
		if (hp_state != null)
		{
			return;
		}

	#if _MSC_VER || __MINGW32__
		SetLockPagesPrivilege(GetCurrentProcess(), 1);
		hp_state = (ushort) VirtualAlloc(hp_state, PAGE_SIZE, MEM_LARGE_PAGES | MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	#else
	#if __APPLE__ || __FreeBSD__ || __OpenBSD__ || __DragonFly__ || __NetBSD__
		hp_state = mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, 0, 0);
	#else
		hp_state = mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB, 0, 0);
	#endif
		if (hp_state == MAP_FAILED)
		{
			hp_state = null;
		}
	#endif
		hp_allocated = 1;
		if (hp_state == null)
		{
			hp_allocated = 0;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in C#:
			hp_state = (ushort) malloc(PAGE_SIZE);
		}
	}

	/**
	 *@brief frees the state allocated by slow_hash_allocate_state
	 */

	public static void slow_hash_free_state(uint PAGE_SIZE)
	{
		if (hp_state == null)
		{
			return;
		}

		if (!hp_allocated)
		{
			hp_state = null;
		}
		else
		{
	#if _MSC_VER || __MINGW32__
			VirtualFree(hp_state, 0, MEM_RELEASE);
	#else
			munmap(hp_state, PAGE_SIZE);
	#endif
		}

		hp_state = null;
		hp_allocated = 0;
	}

	/**
	 * @brief the hash function implementing CryptoNight, used for the Monero proof-of-work
	 *
	 * Computes the hash of <data> (which consists of <length> bytes), returning the
	 * hash in <hash>.  The CryptoNight hash operates by first using Keccak 1600,
	 * the 1600 bit variant of the Keccak hash used in SHA-3, to create a 200 byte
	 * buffer of pseudorandom data by hashing the supplied data.  It then uses this
	 * random data to fill a large 2MB buffer with pseudorandom data by iteratively
	 * encrypting it using 10 rounds of AES per entry.  After this initialization,
	 * it executes 524,288 rounds of mixing through the random 2MB buffer using
	 * AES (typically provided in hardware on modern CPUs) and a 64 bit multiply.
	 * Finally, it re-mixes this large buffer back into
	 * the 200 byte "text" buffer, and then hashes this buffer using one of four
	 * pseudorandomly selected hash functions (Blake, Groestl, JH, or Skein)
	 * to populate the output.
	 *
	 * The 2MB buffer and choice of functions for mixing are designed to make the
	 * algorithm "CPU-friendly" (and thus, reduce the advantage of GPU, FPGA,
	 * or ASIC-based implementations):  the functions used are fast on modern
	 * CPUs, and the 2MB size matches the typical amount of L3 cache available per
	 * core on 2013-era CPUs.  When available, this implementation will use hardware
	 * AES support on x86 CPUs.
	 *
	 * A diagram of the inner loop of this function can be found at
	 * https://www.cs.cmu.edu/~dga/crypto/xmr/cryptonight.png
	 *
	 * @param data the data to hash
	 * @param length the length in bytes of the data
	 * @param hash a pointer to a buffer in which the final 256 bit hash will be stored
	 */
	public static void cn_slow_hash(object data, size_t length, ref string hash, int light, int variant, int prehashed, uint PAGE_SIZE, uint scratchpad, uint iterations)
	{
	  uint TOTALBLOCKS = (PAGE_SIZE / DefineConstants.AES_BLOCK_SIZE);
	  uint init_rounds = (scratchpad / (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  uint aes_rounds = (iterations / 2);
	  size_t lightFlag = (light != 0 ? 2: 1);

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'RDATA_ALIGN16' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  RDATA_ALIGN16 ushort expandedKey[240]; // These buffers are aligned to use later with SSE functions

	  ushort[] text = Arrays.InitializeWithDefaultInstances<ushort>((DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'RDATA_ALIGN16' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  RDATA_ALIGN16 ulong a[2];
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'RDATA_ALIGN16' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  RDATA_ALIGN16 ulong b[4];
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'RDATA_ALIGN16' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  RDATA_ALIGN16 ulong c[2];
	  cn_slow_hash_state state = new cn_slow_hash_state();
	  __m128i _a = new __m128i();
	  __m128i _b = new __m128i();
	  __m128i _b1 = new __m128i();
	  __m128i _c = new __m128i();
	  ulong hi = new ulong();
	  ulong lo = new ulong();

	  size_t i = new size_t();
	  size_t j = new size_t();
	  ulong p = null;
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	  oaes_ctx aes_ctx = null;
	  int useAes = force_software_aes() == 0 && check_aes_hw() != 0;

	  static[] extra_hashesDelegate extra_hashes = new extra_hashesDelegate(hash_extra_blake, hash_extra_groestl, hash_extra_jh, hash_extra_skein);

	  slow_hash_allocate_state(new uint(PAGE_SIZE));

	  /* CryptoNight Step 1:  Use Keccak1600 to initialize the 'state' (and 'text') buffers from the data. */
	  if (prehashed != 0)
	  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		  memcpy(state.hs, data, length);
	  }
	  else
	  {
		  hash_process(state.hs, data, new size_t(length));
	  }
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(text, state.init, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));

	  if (variant == 1)
	  {
		  do
		  {
			  if (length < 43)
			  {
			  Console.Error.Write("Cryptonight variant 1 need at least 43 bytes of data");
			  abort();
			  }
		  } while (0 != 0);
	  }
	  ulong tweak1_2 = (variant == 1) ? (state.hs.w[24] ^ ((ulong)(((ushort)data) + 35))) : 0;
	  ulong division_result = 0;
	  ulong sqrt_result = 0;
	  do
	  {
		  if (variant == 2)
		  {
		  ((ulong)(b))[2] = state.hs.w[8] ^ state.hs.w[10];
		  ((ulong)(b))[3] = state.hs.w[9] ^ state.hs.w[11];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: division_result = state.hs.w[12];
		  division_result.CopyFrom(state.hs.w[12]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: sqrt_result = state.hs.w[13];
		  sqrt_result.CopyFrom(state.hs.w[13]);
		  }
	  } while (0 != 0);

	  /* CryptoNight Step 2:  Iteratively encrypt the results from Keccak to fill
	   * the 2MB large random access buffer.
	   */

	  if (useAes != 0)
	  {
		  aes_expand_key(state.hs.b, expandedKey);
		  for (i = 0; i < init_rounds; i++)
		  {
			  aes_pseudo_round(text, text, expandedKey, DefineConstants.INIT_SIZE_BLK);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			  memcpy(hp_state[i * (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE)], text, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
		  }
	  }
	  else
	  {
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		  aes_ctx = (oaes_ctx) oaes_alloc();
		  oaes_key_import_data(aes_ctx, state.hs.b, DefineConstants.AES_KEY_SIZE);
		  for (i = 0; i < init_rounds; i++)
		  {
			  for (j = 0; j < DefineConstants.INIT_SIZE_BLK; j++)
			  {
				  aesb_pseudo_round(text[DefineConstants.AES_BLOCK_SIZE * j], text[DefineConstants.AES_BLOCK_SIZE * j], aes_ctx.key.exp_data);
			  }

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			  memcpy(hp_state[i * (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE)], text, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
		  }
	  }

	  ((ulong)(a))[0] = ((ulong)(state.k[0]))[0] ^ ((ulong)(state.k[32]))[0];
	  ((ulong)(a))[1] = ((ulong)(state.k[0]))[1] ^ ((ulong)(state.k[32]))[1];
	  ((ulong)(b))[0] = ((ulong)(state.k[16]))[0] ^ ((ulong)(state.k[48]))[0];
	  ((ulong)(b))[1] = ((ulong)(state.k[16]))[1] ^ ((ulong)(state.k[48]))[1];

	  /* CryptoNight Step 3:  Bounce randomly 1,048,576 times (1<<20) through the mixing buffer,
	   * using 524,288 iterations of the following mixing function.  Each execution
	   * performs two reads and writes from the mixing buffer.
	   */

	  _b = _mm_load_si128(((__m128i)(b)));
	  _b1 = _mm_load_si128(((__m128i)(b)) + 1);
	  // Two independent versions, one with AES, one without, to ensure that
	  // the useAes test is only performed once, not every iteration.
	  if (useAes != 0)
	  {
		  for (i = 0; i < aes_rounds; i++)
		  {
			  j = ((((ulong)a >> 4) & (TOTALBLOCKS / (lightFlag) - 1)) << 4);
			  _c = _mm_load_si128(((__m128i)(hp_state[j])));
			  _a = _mm_load_si128(((__m128i)(a)));
			  _c = _mm_aesenc_si128(_c, _a);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  do
			  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  if (variant == 2)
				  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  __m128i chunk1 = _mm_load_si128((__m128i)((hp_state) + ((j) ^ 0x10)));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  __m128i chunk2 = _mm_load_si128((__m128i)((hp_state) + ((j) ^ 0x20)));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  __m128i chunk3 = _mm_load_si128((__m128i)((hp_state) + ((j) ^ 0x30)));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  _mm_store_si128((__m128i)((hp_state) + ((j) ^ 0x10)), _mm_add_epi64(chunk3, _b1));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  _mm_store_si128((__m128i)((hp_state) + ((j) ^ 0x20)), _mm_add_epi64(chunk1, _b));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  _mm_store_si128((__m128i)((hp_state) + ((j) ^ 0x30)), _mm_add_epi64(chunk2, _a));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  }
			  } while (0 != 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  _mm_store_si128(((__m128i)(c)), _c);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  _mm_store_si128(((__m128i)(hp_state[j])), _mm_xor_si128(_b, _c));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  do
			  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  if (variant == 1)
				  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  ushort tmp = ((ushort)(hp_state[j]))[11];
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  const uint table = 0x75310;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  ushort index = (((tmp >> 3) & 6) | (tmp & 1)) << 1;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  ((ushort)(hp_state[j]))[11] = tmp ^ ((table >> index) & 0x30);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  }
			  } while (0 != 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  j = ((((ulong)c >> 4) & (TOTALBLOCKS / (lightFlag) - 1)) << 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  p = ((ulong)(hp_state[j]));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  b[0] = p[0];
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  b[1] = p[1];
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  do
			  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  if (variant == 2)
				  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  ((ulong)(b))[0] ^= division_result ^ (sqrt_result << 32);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  ulong dividend = ((ulong)(c))[1];
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  uint divisor = (((ulong)(c))[0] + (uint)(sqrt_result << 1)) | 0x80000001U;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  division_result = ((uint)(dividend / divisor)) + (((ulong)(dividend % divisor)) << 32);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  }
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  ulong sqrt_input = ((ulong)(c))[0] + division_result;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  do
				  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  __m128i exp_double_bias = _mm_set_epi64x(0, 1023UL << 52);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  __m128d x = _mm_castsi128_pd(_mm_add_epi64(_mm_cvtsi64_si128(sqrt_input >> 12), exp_double_bias));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  x = _mm_sqrt_sd(_mm_setzero_pd(), x);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  sqrt_result = (ulong)(_mm_cvtsi128_si64(_mm_sub_epi64(_mm_castpd_si128(x), exp_double_bias))) >> 19;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  } while (0 != 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  do
				  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  ulong s = sqrt_result >> 1;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  ulong b = sqrt_result & 1;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  ulong r2 = (ulong)(s) * (s + b) + (sqrt_result << 32);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  sqrt_result += ((r2 + b > sqrt_input) ? -1 : 0) + ((r2 + (1UL << 32) < sqrt_input - s) ? 1 : 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  } while (0 != 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  }
			  } while (0 != 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  __mul();
			  do
			  {
				  if (variant == 2)
				  {
				  (ulong)(hp_state + (j ^ 0x10)) ^= hi;
				  *(((ulong)(hp_state + (j ^ 0x10))) + 1) ^= lo;
				  hi ^= (ulong)(hp_state + (j ^ 0x20));
				  lo ^= *(((ulong)(hp_state + (j ^ 0x20))) + 1);
				  }
			  } while (0 != 0);
			  do
			  {
				  if (variant == 2)
				  {
				  __m128i chunk1 = _mm_load_si128((__m128i)((hp_state) + ((j) ^ 0x10)));
				  __m128i chunk2 = _mm_load_si128((__m128i)((hp_state) + ((j) ^ 0x20)));
				  __m128i chunk3 = _mm_load_si128((__m128i)((hp_state) + ((j) ^ 0x30)));
				  _mm_store_si128((__m128i)((hp_state) + ((j) ^ 0x10)), _mm_add_epi64(chunk3, _b1));
				  _mm_store_si128((__m128i)((hp_state) + ((j) ^ 0x20)), _mm_add_epi64(chunk1, _b));
				  _mm_store_si128((__m128i)((hp_state) + ((j) ^ 0x30)), _mm_add_epi64(chunk2, _a));
				  }
			  } while (0 != 0);
			  a[0] += hi;
			  a[1] += lo;
			  p = ((ulong)(hp_state[j]));
			  p[0] = a[0];
			  p[1] = a[1];
			  a[0] ^= b[0];
			  a[1] ^= b[1];
			  do
			  {
				  if (variant == 1)
				  {
				  xor64(p + 1, new ulong(tweak1_2));
				  }
			  } while (0 != 0);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: _b1 = _b;
			  _b1.CopyFrom(_b);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: _b = _c;
			  _b.CopyFrom(_c);
		  }
	  }
	  else
	  {
		  for (i = 0; i < aes_rounds; i++)
		  {
			  j = ((((ulong)a >> 4) & (TOTALBLOCKS / (lightFlag) - 1)) << 4);
			  _c = _mm_load_si128(((__m128i)(hp_state[j])));
			  _a = _mm_load_si128(((__m128i)(a)));
			  aesb_single_round((ushort) _c, (ushort) _c, (ushort) _a);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  do
			  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  if (variant == 2)
				  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  __m128i chunk1 = _mm_load_si128((__m128i)((hp_state) + ((j) ^ 0x10)));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  __m128i chunk2 = _mm_load_si128((__m128i)((hp_state) + ((j) ^ 0x20)));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  __m128i chunk3 = _mm_load_si128((__m128i)((hp_state) + ((j) ^ 0x30)));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  _mm_store_si128((__m128i)((hp_state) + ((j) ^ 0x10)), _mm_add_epi64(chunk3, _b1));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  _mm_store_si128((__m128i)((hp_state) + ((j) ^ 0x20)), _mm_add_epi64(chunk1, _b));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  _mm_store_si128((__m128i)((hp_state) + ((j) ^ 0x30)), _mm_add_epi64(chunk2, _a));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  }
			  } while (0 != 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  _mm_store_si128(((__m128i)(c)), _c);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  _mm_store_si128(((__m128i)(hp_state[j])), _mm_xor_si128(_b, _c));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  do
			  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  if (variant == 1)
				  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  ushort tmp = ((ushort)(hp_state[j]))[11];
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  const uint table = 0x75310;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  ushort index = (((tmp >> 3) & 6) | (tmp & 1)) << 1;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  ((ushort)(hp_state[j]))[11] = tmp ^ ((table >> index) & 0x30);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  }
			  } while (0 != 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  j = ((((ulong)c >> 4) & (TOTALBLOCKS / (lightFlag) - 1)) << 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  p = ((ulong)(hp_state[j]));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  b[0] = p[0];
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  b[1] = p[1];
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  do
			  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  if (variant == 2)
				  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  ((ulong)(b))[0] ^= division_result ^ (sqrt_result << 32);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  ulong dividend = ((ulong)(c))[1];
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  uint divisor = (((ulong)(c))[0] + (uint)(sqrt_result << 1)) | 0x80000001U;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  division_result = ((uint)(dividend / divisor)) + (((ulong)(dividend % divisor)) << 32);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  }
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  ulong sqrt_input = ((ulong)(c))[0] + division_result;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  do
				  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  __m128i exp_double_bias = _mm_set_epi64x(0, 1023UL << 52);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  __m128d x = _mm_castsi128_pd(_mm_add_epi64(_mm_cvtsi64_si128(sqrt_input >> 12), exp_double_bias));
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  x = _mm_sqrt_sd(_mm_setzero_pd(), x);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  sqrt_result = (ulong)(_mm_cvtsi128_si64(_mm_sub_epi64(_mm_castpd_si128(x), exp_double_bias))) >> 19;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  } while (0 != 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  do
				  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  ulong s = sqrt_result >> 1;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  ulong b = sqrt_result & 1;
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  ulong r2 = (ulong)(s) * (s + b) + (sqrt_result << 32);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
					  sqrt_result += ((r2 + b > sqrt_input) ? -1 : 0) + ((r2 + (1UL << 32) < sqrt_input - s) ? 1 : 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  } while (0 != 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
				  }
			  } while (0 != 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro '__mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  __mul();
			  do
			  {
				  if (variant == 2)
				  {
				  (ulong)(hp_state + (j ^ 0x10)) ^= hi;
				  *(((ulong)(hp_state + (j ^ 0x10))) + 1) ^= lo;
				  hi ^= (ulong)(hp_state + (j ^ 0x20));
				  lo ^= *(((ulong)(hp_state + (j ^ 0x20))) + 1);
				  }
			  } while (0 != 0);
			  do
			  {
				  if (variant == 2)
				  {
				  __m128i chunk1 = _mm_load_si128((__m128i)((hp_state) + ((j) ^ 0x10)));
				  __m128i chunk2 = _mm_load_si128((__m128i)((hp_state) + ((j) ^ 0x20)));
				  __m128i chunk3 = _mm_load_si128((__m128i)((hp_state) + ((j) ^ 0x30)));
				  _mm_store_si128((__m128i)((hp_state) + ((j) ^ 0x10)), _mm_add_epi64(chunk3, _b1));
				  _mm_store_si128((__m128i)((hp_state) + ((j) ^ 0x20)), _mm_add_epi64(chunk1, _b));
				  _mm_store_si128((__m128i)((hp_state) + ((j) ^ 0x30)), _mm_add_epi64(chunk2, _a));
				  }
			  } while (0 != 0);
			  a[0] += hi;
			  a[1] += lo;
			  p = ((ulong)(hp_state[j]));
			  p[0] = a[0];
			  p[1] = a[1];
			  a[0] ^= b[0];
			  a[1] ^= b[1];
			  do
			  {
				  if (variant == 1)
				  {
				  xor64(p + 1, new ulong(tweak1_2));
				  }
			  } while (0 != 0);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: _b1 = _b;
			  _b1.CopyFrom(_b);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: _b = _c;
			  _b.CopyFrom(_c);
		  }
	  }

	  /* CryptoNight Step 4:  Sequentially pass through the mixing buffer and use 10 rounds
	   * of AES encryption to mix the random data back into the 'text' buffer.  'text'
	   * was originally created with the output of Keccak1600. */

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(text, state.init, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  if (useAes != 0)
	  {
		  aes_expand_key(state.hs.b[32], expandedKey);
		  for (i = 0; i < init_rounds; i++)
		  {
			  // add the xor to the pseudo round
			  aes_pseudo_round_xor(text, text, expandedKey, hp_state[i * (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE)], DefineConstants.INIT_SIZE_BLK);
		  }
	  }
	  else
	  {
		  oaes_key_import_data(aes_ctx, state.hs.b[32], DefineConstants.AES_KEY_SIZE);
		  for (i = 0; i < init_rounds; i++)
		  {
			  for (j = 0; j < DefineConstants.INIT_SIZE_BLK; j++)
			  {
				  xor_blocks(text[j * DefineConstants.AES_BLOCK_SIZE], hp_state[i * (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE) + j * DefineConstants.AES_BLOCK_SIZE]);
				  aesb_pseudo_round(text[DefineConstants.AES_BLOCK_SIZE * j], text[DefineConstants.AES_BLOCK_SIZE * j], aes_ctx.key.exp_data);
			  }
		  }
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
		  oaes_free((OAES_CTX) aes_ctx);
	  }

	  /* CryptoNight Step 5:  Apply Keccak to the state again, and then
	   * use the resulting data to select which of four finalizer
	   * hash functions to apply to the data (Blake, Groestl, JH, or Skein).
	   * Use this hash to squeeze the state array down
	   * to the final 256 bit hash output.
	   */

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(state.init, text, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  hash_permutation(state.hs);
	  extra_hashes[state.hs.b[0] & 3](state, 200, hash);
	  slow_hash_free_state(new uint(PAGE_SIZE));
	}

	public delegate void extra_hashesDelegate(object UnnamedParameter, size_t UnnamedParameter2, ref string UnnamedParameter3);

	#elif ! NO_AES && (__arm__ || __aarch64__)
	public static void slow_hash_allocate_state()
	{
	  // Do nothing, this is just to maintain compatibility with the upgraded slow-hash.c
	  return;
	}

	public static void slow_hash_free_state()
	{
	  // As above
	  return;
	}

	#if __GNUC__
	#define RDATA_ALIGN16
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define STATIC static
	#define STATIC
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define INLINE inline
	#define INLINE
	#else
	#define RDATA_ALIGN16
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define STATIC static
	#define STATIC
	#define INLINE
	#endif

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define U64(x) ((ulong *) (x))
	#define U64

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void xor64(ulong a, ulong b)
	{
		a ^= b;
	}
	//{
	//	union hash_state hs;
	//	struct
	//	{
	//		ushort k[64];
	//		ushort init[(DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE)];
	//	};
	//};
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent to most C++ 'pragma' directives in C#:
	//#pragma pack(pop)

	#if __aarch64__ && __ARM_FEATURE_CRYPTO

	/* ARMv8-A optimized with NEON and AES instructions.
	 * Copied from the x86-64 AES-NI implementation. It has much the same
	 * characteristics as x86-64: there's no 64x64=128 multiplier for vectors,
	 * and moving between vector and regular registers stalls the pipeline.
	 */

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define state_index(x,div) (((*((ulong *)x) >> 4) & (TOTALBLOCKS /(div) - 1)) << 4)
	#define state_index
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define __mul() __asm__("mul %0, %1, %2\n\t" : "=r"(lo) : "r"(c[0]), "r"(b[0]) ); __asm__("umulh %0, %1, %2\n\t" : "=r"(hi) : "r"(c[0]), "r"(b[0]) );
	#define __mul

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pre_aes() j = state_index(a,lightFlag); _c = vld1q_u8(&hp_state[j]); _a = vld1q_u8((const ushort *)a);
	#define pre_aes
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define post_aes() VARIANT2_SHUFFLE_ADD_NEON(hp_state, j); vst1q_u8((ushort *)c, _c); vst1q_u8(&hp_state[j], veorq_u8(_b, _c)); VARIANT1_1(&hp_state[j]); j = state_index(c,lightFlag); p = U64(&hp_state[j]); b[0] = p[0]; b[1] = p[1]; VARIANT2_PORTABLE_INTEGER_MATH(b, c); __mul(); VARIANT2_2(); VARIANT2_SHUFFLE_ADD_NEON(hp_state, j); a[0] += hi; a[1] += lo; p = U64(&hp_state[j]); p[0] = a[0]; p[1] = a[1]; a[0] ^= b[0]; a[1] ^= b[1]; VARIANT1_2(p + 1); _b1 = _b; _b = _c;
	#define post_aes

	/* Note: this was based on a standard 256bit key schedule but
	 * it's been shortened since Cryptonight doesn't use the full
	 * key schedule. Don't try to use this for vanilla AES.
	*/
	internal static void aes_expand_key(ushort key, ushort expandedKey)
	{
	int[] rcon = {0x01, 0x01, 0x01, 0x01, 0x0c0f0e0d, 0x0c0f0e0d, 0x0c0f0e0d, 0x0c0f0e0d, 0x1b, 0x1b, 0x1b, 0x1b};
	__asm__("	eor	v0.16b,v0.16b,v0.16b\n" + "	ld1	{v3.16b},[%0],#16\n" + "	ld1	{v1.4s,v2.4s},[%2],#32\n" + "	ld1	{v4.16b},[%0]\n" + "	mov	w2,#5\n" + "	st1	{v3.4s},[%1],#16\n" + "\n" + "1:\n" + "	tbl	v6.16b,{v4.16b},v2.16b\n" + "	ext	v5.16b,v0.16b,v3.16b,#12\n" + "	st1	{v4.4s},[%1],#16\n" + "	aese	v6.16b,v0.16b\n" + "	subs	w2,w2,#1\n" + "\n" + "	eor	v3.16b,v3.16b,v5.16b\n" + "	ext	v5.16b,v0.16b,v5.16b,#12\n" + "	eor	v3.16b,v3.16b,v5.16b\n" + "	ext	v5.16b,v0.16b,v5.16b,#12\n" + "	eor	v6.16b,v6.16b,v1.16b\n" + "	eor	v3.16b,v3.16b,v5.16b\n" + "	shl	v1.16b,v1.16b,#1\n" + "	eor	v3.16b,v3.16b,v6.16b\n" + "	st1	{v3.4s},[%1],#16\n" + "	b.eq	2f\n" + "\n" + "	dup	v6.4s,v3.s[3]		// just splat\n" + "	ext	v5.16b,v0.16b,v4.16b,#12\n" + "	aese	v6.16b,v0.16b\n" + "\n" + "	eor	v4.16b,v4.16b,v5.16b\n" + "	ext	v5.16b,v0.16b,v5.16b,#12\n" + "	eor	v4.16b,v4.16b,v5.16b\n" + "	ext	v5.16b,v0.16b,v5.16b,#12\n" + "	eor	v4.16b,v4.16b,v5.16b\n" + "\n" + "	eor	v4.16b,v4.16b,v6.16b\n" + "	b	1b\n" + "\n" + "2:\n" : : "r"(key), "r"(expandedKey), "r"(rcon));
	}

	/* An ordinary AES round is a sequence of SubBytes, ShiftRows, MixColumns, AddRoundKey. There
	 * is also an InitialRound which consists solely of AddRoundKey. The ARM instructions slice
	 * this sequence differently; the aese instruction performs AddRoundKey, SubBytes, ShiftRows.
	 * The aesmc instruction does the MixColumns. Since the aese instruction moves the AddRoundKey
	 * up front, and Cryptonight's hash skips the InitialRound step, we have to kludge it here by
	 * feeding in a vector of zeros for our first step. Also we have to do our own Xor explicitly
	 * at the last step, to provide the AddRoundKey that the ARM instructions omit.
	 */
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void aes_pseudo_round(ushort in, ushort @out, ushort expandedKey, int nblocks)
	{
		uint8x16_t[] k = (uint8x16_t)expandedKey;
		uint8x16_t zero = new uint8x16_t();
		uint8x16_t tmp = new uint8x16_t();
		int i;

		for (i = 0; i < nblocks; i++)
		{
			uint8x16_t tmp = vld1q_u8(in + i * DefineConstants.AES_BLOCK_SIZE);
			tmp = vaeseq_u8(tmp, zero);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[0]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[1]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[2]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[3]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[4]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[5]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[6]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[7]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[8]);
			tmp = vaesmcq_u8(tmp);
			tmp = veorq_u8(tmp, k[9]);
			vst1q_u8(@out + i * DefineConstants.AES_BLOCK_SIZE, tmp);
		}
	}

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void aes_pseudo_round_xor(ushort in, ushort @out, ushort expandedKey, ushort xor, int nblocks)
	{
		uint8x16_t[] k = (uint8x16_t)expandedKey;
		uint8x16_t[] x = (uint8x16_t)xor;
		uint8x16_t tmp = new uint8x16_t();
		int i;

		for (i = 0; i < nblocks; i++)
		{
			uint8x16_t tmp = vld1q_u8(in + i * DefineConstants.AES_BLOCK_SIZE);
			tmp = vaeseq_u8(tmp, x[i]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[0]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[1]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[2]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[3]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[4]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[5]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[6]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[7]);
			tmp = vaesmcq_u8(tmp);
			tmp = vaeseq_u8(tmp, k[8]);
			tmp = vaesmcq_u8(tmp);
			tmp = veorq_u8(tmp, k[9]);
			vst1q_u8(@out + i * DefineConstants.AES_BLOCK_SIZE, tmp);
		}
	}

	#if FORCE_USE_HEAP
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE object aligned_malloc(size_t size, size_t align)
	{
		object result;
	#if _MSC_VER
		result = _aligned_malloc(size, align);
	#else
		if (posix_memalign(result, align, size))
		{
			result = null;
		}
	#endif
		return result;
	}

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void aligned_free(object ptr)
	{
	#if _MSC_VER
		_aligned_free(ptr);
	#else
//C++ TO C# CONVERTER TODO TASK: The memory management function 'free' has no equivalent in C#:
		free(ptr);
	#endif
	}
	#endif

	public static void cn_slow_hash(object data, size_t length, ref string hash, int light, int variant, int prehashed, uint PAGE_SIZE, uint scratchpad, uint iterations)
	{
	  uint TOTALBLOCKS = (PAGE_SIZE / DefineConstants.AES_BLOCK_SIZE);
	  uint init_rounds = (scratchpad / (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  uint aes_rounds = (iterations / 2);
	  size_t lightFlag = (light != 0 ? 2: 1);

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'RDATA_ALIGN16' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  RDATA_ALIGN16 ushort expandedKey[240];

	#if ! FORCE_USE_HEAP
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'RDATA_ALIGN16' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  RDATA_ALIGN16 ushort hp_state[PAGE_SIZE];
	#else
	  ushort hp_state = (ushort)aligned_malloc(new uint(PAGE_SIZE), 16);
	#endif

	  ushort[] text = Arrays.InitializeWithDefaultInstances<ushort>((DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'RDATA_ALIGN16' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  RDATA_ALIGN16 ulong a[2];
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'RDATA_ALIGN16' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  RDATA_ALIGN16 ulong b[4];
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'RDATA_ALIGN16' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  RDATA_ALIGN16 ulong c[2];
	  cn_slow_hash_state state = new cn_slow_hash_state();
	  uint8x16_t _a = new uint8x16_t();
	  uint8x16_t _b = new uint8x16_t();
	  uint8x16_t _b1 = new uint8x16_t();
	  uint8x16_t _c = new uint8x16_t();
	  uint8x16_t zero = new uint8x16_t();
	  ulong hi = new ulong();
	  ulong lo = new ulong();

	  size_t i = new size_t();
	  size_t j = new size_t();
	  ulong p = null;

	  static[] extra_hashesDelegate extra_hashes = new extra_hashesDelegate(hash_extra_blake, hash_extra_groestl, hash_extra_jh, hash_extra_skein);

	  /* CryptoNight Step 1:  Use Keccak1600 to initialize the 'state' (and 'text') buffers from the data. */

	  if (prehashed != 0)
	  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		  memcpy(state.hs, data, length);
	  }
	  else
	  {
		  hash_process(state.hs, data, new size_t(length));
	  }
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(text, state.init, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));

	  if (variant == 1)
	  {
		  do
		  {
			  if (length < 43)
			  {
			  Console.Error.Write("Cryptonight variant 1 need at least 43 bytes of data");
			  abort();
			  }
		  } while (0 != 0);
	  }
	  ulong tweak1_2 = (variant == 1) ? (state.hs.w[24] ^ ((ulong)(((ushort)data) + 35))) : 0;
	  ulong division_result = 0;
	  ulong sqrt_result = 0;
	  do
	  {
		  if (variant == 2)
		  {
		  ((ulong)(b))[2] = state.hs.w[8] ^ state.hs.w[10];
		  ((ulong)(b))[3] = state.hs.w[9] ^ state.hs.w[11];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: division_result = state.hs.w[12];
		  division_result.CopyFrom(state.hs.w[12]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: sqrt_result = state.hs.w[13];
		  sqrt_result.CopyFrom(state.hs.w[13]);
		  }
	  } while (0 != 0);

	  /* CryptoNight Step 2:  Iteratively encrypt the results from Keccak to fill
	   * the 2MB large random access buffer.
	   */

	  aes_expand_key(state.hs.b, expandedKey);
	  for (i = 0; i < init_rounds; i++)
	  {
		  aes_pseudo_round(text, text, expandedKey, DefineConstants.INIT_SIZE_BLK);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		  memcpy(hp_state[i * (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE)], text, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  }

	  ((ulong)(a))[0] = ((ulong)(state.k[0]))[0] ^ ((ulong)(state.k[32]))[0];
	  ((ulong)(a))[1] = ((ulong)(state.k[0]))[1] ^ ((ulong)(state.k[32]))[1];
	  ((ulong)(b))[0] = ((ulong)(state.k[16]))[0] ^ ((ulong)(state.k[48]))[0];
	  ((ulong)(b))[1] = ((ulong)(state.k[16]))[1] ^ ((ulong)(state.k[48]))[1];

	  /* CryptoNight Step 3:  Bounce randomly 1,048,576 times (1<<20) through the mixing buffer,
	   * using 524,288 iterations of the following mixing function.  Each execution
	   * performs two reads and writes from the mixing buffer.
	   */

	  _b = vld1q_u8((ushort)b);
	  _b1 = vld1q_u8(((ushort)b) + DefineConstants.AES_BLOCK_SIZE);

	  for (i = 0; i < aes_rounds; i++)
	  {
		  j = ((((ulong)a >> 4) & (TOTALBLOCKS / (lightFlag) - 1)) << 4);
		  _c = vld1q_u8(hp_state[j]);
		  _a = vld1q_u8((ushort)a);
		  _c = vaeseq_u8(_c, zero);
		  _c = vaesmcq_u8(_c);
		  _c = veorq_u8(_c, _a);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		  do
		  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  if (variant == 2)
			  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  uint64x2_t chunk1 = vld1q_u64(((ulong)((hp_state) + ((j) ^ 0x10))));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  uint64x2_t chunk2 = vld1q_u64(((ulong)((hp_state) + ((j) ^ 0x20))));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  uint64x2_t chunk3 = vld1q_u64(((ulong)((hp_state) + ((j) ^ 0x30))));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  vst1q_u64(((ulong)((hp_state) + ((j) ^ 0x10))), vaddq_u64(chunk3, vreinterpretq_u64_u8(_b1)));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  vst1q_u64(((ulong)((hp_state) + ((j) ^ 0x20))), vaddq_u64(chunk1, vreinterpretq_u64_u8(_b)));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  vst1q_u64(((ulong)((hp_state) + ((j) ^ 0x30))), vaddq_u64(chunk2, vreinterpretq_u64_u8(_a)));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  }
		  } while (0 != 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		  vst1q_u8((ushort)c, _c);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		  vst1q_u8(hp_state[j], veorq_u8(_b, _c));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		  do
		  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  if (variant == 1)
			  {
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  ushort tmp = ((ushort)(hp_state[j]))[11];
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  const uint table = 0x75310;
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  ushort index = (((tmp >> 3) & 6) | (tmp & 1)) << 1;
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  ((ushort)(hp_state[j]))[11] = tmp ^ ((table >> index) & 0x30);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
			  }
		  } while (0 != 0);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		  j = ((((ulong)c >> 4) & (TOTALBLOCKS / (lightFlag) - 1)) << 4);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		  p = ((ulong)(hp_state[j]));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		  b[0] = p[0];
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		  b[1] = p[1];
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		  VARIANT2_PORTABLE_INTEGER_MATH(b, c);
		  __asm__("mul %0, %1, %2\n\t" : "=r"(lo) : "r"(c[0]), "r"(b[0]));
		  __asm__("umulh %0, %1, %2\n\t" : "=r"(hi) : "r"(c[0]), "r"(b[0]));
		  ;
		  do
		  {
			  if (variant == 2)
			  {
			  (ulong)(hp_state + (j ^ 0x10)) ^= hi;
			  *(((ulong)(hp_state + (j ^ 0x10))) + 1) ^= lo;
			  hi ^= (ulong)(hp_state + (j ^ 0x20));
			  lo ^= *(((ulong)(hp_state + (j ^ 0x20))) + 1);
			  }
		  } while (0 != 0);
		  do
		  {
			  if (variant == 2)
			  {
			  uint64x2_t chunk1 = vld1q_u64(((ulong)((hp_state) + ((j) ^ 0x10))));
			  uint64x2_t chunk2 = vld1q_u64(((ulong)((hp_state) + ((j) ^ 0x20))));
			  uint64x2_t chunk3 = vld1q_u64(((ulong)((hp_state) + ((j) ^ 0x30))));
			  vst1q_u64(((ulong)((hp_state) + ((j) ^ 0x10))), vaddq_u64(chunk3, vreinterpretq_u64_u8(_b1)));
			  vst1q_u64(((ulong)((hp_state) + ((j) ^ 0x20))), vaddq_u64(chunk1, vreinterpretq_u64_u8(_b)));
			  vst1q_u64(((ulong)((hp_state) + ((j) ^ 0x30))), vaddq_u64(chunk2, vreinterpretq_u64_u8(_a)));
			  }
		  } while (0 != 0);
		  a[0] += hi;
		  a[1] += lo;
		  p = ((ulong)(hp_state[j]));
		  p[0] = a[0];
		  p[1] = a[1];
		  a[0] ^= b[0];
		  a[1] ^= b[1];
		  do
		  {
			  if (variant == 1)
			  {
			  xor64(p + 1, new ulong(tweak1_2));
			  }
		  } while (0 != 0);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: _b1 = _b;
		  _b1.CopyFrom(_b);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: _b = _c;
		  _b.CopyFrom(_c);
	  }

	  /* CryptoNight Step 4:  Sequentially pass through the mixing buffer and use 10 rounds
	   * of AES encryption to mix the random data back into the 'text' buffer.  'text'
	   * was originally created with the output of Keccak1600. */

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(text, state.init, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));

	  aes_expand_key(state.hs.b[32], expandedKey);
	  for (i = 0; i < init_rounds; i++)
	  {
		  // add the xor to the pseudo round
		  aes_pseudo_round_xor(text, text, expandedKey, hp_state[i * (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE)], DefineConstants.INIT_SIZE_BLK);
	  }

	  /* CryptoNight Step 5:  Apply Keccak to the state again, and then
	   * use the resulting data to select which of four finalizer
	   * hash functions to apply to the data (Blake, Groestl, JH, or Skein).
	   * Use this hash to squeeze the state array down
	   * to the final 256 bit hash output.
	   */

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(state.init, text, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  hash_permutation(state.hs);
	  extra_hashes[state.hs.b[0] & 3](state, 200, hash);

	#if FORCE_USE_HEAP
	  aligned_free(hp_state);
	#endif
	}

	public delegate void extra_hashesDelegate(object UnnamedParameter, size_t UnnamedParameter2, ref string UnnamedParameter3);
	#else

	// ND: Some minor optimizations for ARMv7 (raspberrry pi 2), effect seems to be ~40-50% faster.
	//     Needs more work.

	#if NO_OPTIMIZED_MULTIPLY_ON_ARM
	/* The asm corresponds to this C code */
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SHORT uint
	#define SHORT
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LONG ulong
	#define LONG

	public static void mul(ushort ca, ushort cb, ushort cres)
	{
	  uint aa = (uint)ca;
	  uint bb = (uint)cb;
	  uint res = (uint)cres;
//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//  union
	//  {
	//	uint tmp[8];
	//	ulong ltmp[4];
	//  }
	//  t;
	  ulong A = aa[1];
	  ulong a = aa[0];
	  ulong B = bb[1];
	  ulong b = bb[0];

	  // Aa * Bb = ab + aB_ + Ab_ + AB__
	  t.ltmp[0] = a * b;
	  t.ltmp[1] = a * B;
	  t.ltmp[2] = A * b;
	  t.ltmp[3] = A * B;

	  res[2] = t.tmp[0];
	  t.ltmp[1] += t.tmp[1];
	  t.ltmp[1] += t.tmp[4];
	  t.ltmp[3] += t.tmp[3];
	  t.ltmp[3] += t.tmp[5];
	  res[3] = t.tmp[2];
	  res[0] = t.tmp[6];
	  res[1] = t.tmp[7];
	}
	#else

	#if __aarch64__
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mul(a, b, c) cn_mul128((const ulong *)a, (const ulong *)b, (ulong *)c)
	#define mul
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC void cn_mul128(ulong[] a, ulong[] b, ulong[] r)
	{
	  ulong lo = new ulong();
	  ulong hi = new ulong();
	  __asm__("mul %0, %1, %2\n\t" : "=r"(lo) : "r"(a[0]), "r"(b[0]));
	  __asm__("umulh %0, %1, %2\n\t" : "=r"(hi) : "r"(a[0]), "r"(b[0]));
	  r[0] = hi;
	  r[1] = lo;
	}
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mul(a, b, c) cn_mul128((const uint *)a, (const uint *)b, (uint *)c)
	#define mul
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC void cn_mul128(uint[] aa, uint[] bb, uint[] r)
	{
	  uint t0 = new uint();
	  uint t1 = new uint();
	  uint t2 = 0;
	  uint t3 = 0;
	__asm__ __volatile__ = new __asm__("umull %[t0], %[t1], %[a], %[b]\n\t" + "str   %[t0], %[ll]\n\t" + "eor   %[t0], %[t0]\n\t" + "umlal %[t1], %[t0], %[a], %[B]\n\t" + "umlal %[t1], %[t2], %[A], %[b]\n\t" + "str   %[t1], %[lh]\n\t" + "umlal %[t0], %[t3], %[A], %[B]\n\t" + "adds  %[t0], %[t0], %[t2]\n\t" + "adc   %[t1], %[t3], #0\n\t" + "str   %[t0], %[hl]\n\t" + "str   %[t1], %[hh]\n\t" : [t0]"=&r"(t0), [t1]"=&r"(t1), [t2]"+r"(t2), [t3]"+r"(t3), [hl]"=m"(r[0]), [hh]"=m"(r[1]), [ll]"=m"(r[2]), [lh]"=m"(r[3]) : [A]"r"(aa[1]), [a]"r"(aa[0]), [B]"r"(bb[1]), [b]"r"(bb[0]) : "cc");
	}
	#endif
	#endif

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void copy_block(ushort dst, ushort src)
	{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(dst, src, DefineConstants.AES_BLOCK_SIZE);
	}

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void sum_half_blocks(ushort a, ushort b)
	{
	  ulong a0 = new ulong();
	  ulong a1 = new ulong();
	  ulong b0 = new ulong();
	  ulong b1 = new ulong();
	  a0 = ((ulong)(a))[0];
	  a1 = ((ulong)(a))[1];
	  b0 = ((ulong)(b))[0];
	  b1 = ((ulong)(b))[1];
	  a0 += b0;
	  a1 += b1;
	  ((ulong)(a))[0] = a0;
	  ((ulong)(a))[1] = a1;
	}

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void swap_blocks(ushort a, ushort b)
	{
	  ulong[] t = Arrays.InitializeWithDefaultInstances<ulong>(2);
	  ((ulong)(t))[0] = ((ulong)(a))[0];
	  ((ulong)(t))[1] = ((ulong)(a))[1];
	  ((ulong)(a))[0] = ((ulong)(b))[0];
	  ((ulong)(a))[1] = ((ulong)(b))[1];
	  ((ulong)(b))[0] = ((ulong)(t))[0];
	  ((ulong)(b))[1] = ((ulong)(t))[1];
	}

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'STATIC' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'INLINE' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	public static STATIC INLINE void xor_blocks(ushort a, ushort b)
	{
	  ((ulong)(a))[0] ^= ((ulong)(b))[0];
	  ((ulong)(a))[1] ^= ((ulong)(b))[1];
	}

	public static void cn_slow_hash(object data, size_t length, ref string hash, int light, int variant, int prehashed, uint PAGE_SIZE, uint scratchpad, uint iterations)
	{
	  uint init_rounds = (scratchpad / (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  uint aes_rounds = (iterations / 2);
	  size_t lightFlag = (light != 0 ? 2: 1);

	  ushort[] text = Arrays.InitializeWithDefaultInstances<ushort>((DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  ushort[] a = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.AES_BLOCK_SIZE);
	  ushort[] b = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.AES_BLOCK_SIZE * 2);
	  ushort[] c = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.AES_BLOCK_SIZE);
	  ushort[] c1 = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.AES_BLOCK_SIZE);
	  ushort[] d = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.AES_BLOCK_SIZE);
	  ushort[] aes_key = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.AES_KEY_SIZE);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'RDATA_ALIGN16' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  RDATA_ALIGN16 ushort expandedKey[256];

	  cn_slow_hash_state state = new cn_slow_hash_state();

	  size_t i = new size_t();
	  size_t j = new size_t();
	  ushort p = null;
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	  oaes_ctx aes_ctx;
	  static[] extra_hashesDelegate extra_hashes = new extra_hashesDelegate(hash_extra_blake, hash_extra_groestl, hash_extra_jh, hash_extra_skein);

	#if ! FORCE_USE_HEAP
	  ushort[] long_state = Arrays.InitializeWithDefaultInstances<ushort>(PAGE_SIZE);
	#else
//C++ TO C# CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in C#:
	  ushort long_state = (ushort)malloc(PAGE_SIZE);
	#endif

	  if (prehashed != 0)
	  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		  memcpy(state.hs, data, length);
	  }
	  else
	  {
		  hash_process(state.hs, data, new size_t(length));
	  }
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(text, state.init, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	  aes_ctx = (oaes_ctx) oaes_alloc();
	  oaes_key_import_data(aes_ctx, state.hs.b, DefineConstants.AES_KEY_SIZE);

	  if (variant == 1)
	  {
		  do
		  {
			  if (length < 43)
			  {
			  Console.Error.Write("Cryptonight variant 1 need at least 43 bytes of data");
			  abort();
			  }
		  } while (0 != 0);
	  }
	  ulong tweak1_2 = (variant == 1) ? (state.hs.w[24] ^ ((ulong)(((ushort)data) + 35))) : 0;
	  ulong division_result = 0;
	  ulong sqrt_result = 0;
	  do
	  {
		  if (variant == 2)
		  {
		  ((ulong)(b))[2] = state.hs.w[8] ^ state.hs.w[10];
		  ((ulong)(b))[3] = state.hs.w[9] ^ state.hs.w[11];
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: division_result = state.hs.w[12];
		  division_result.CopyFrom(state.hs.w[12]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: sqrt_result = state.hs.w[13];
		  sqrt_result.CopyFrom(state.hs.w[13]);
		  }
	  } while (0 != 0);

	  // use aligned data
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(expandedKey, aes_ctx.key.exp_data, aes_ctx.key.exp_data_len);
	  for (i = 0; i < init_rounds; i++)
	  {
		  for (j = 0; j < DefineConstants.INIT_SIZE_BLK; j++)
		  {
			  aesb_pseudo_round(text[DefineConstants.AES_BLOCK_SIZE * j], text[DefineConstants.AES_BLOCK_SIZE * j], expandedKey);
		  }
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		  memcpy(long_state[i * (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE)], text, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  }

	  ((ulong)(a))[0] = ((ulong)(state.k[0]))[0] ^ ((ulong)(state.k[32]))[0];
	  ((ulong)(a))[1] = ((ulong)(state.k[0]))[1] ^ ((ulong)(state.k[32]))[1];
	  ((ulong)(b))[0] = ((ulong)(state.k[16]))[0] ^ ((ulong)(state.k[48]))[0];
	  ((ulong)(b))[1] = ((ulong)(state.k[16]))[1] ^ ((ulong)(state.k[48]))[1];

	  for (i = 0; i < aes_rounds; i++)
	  {
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MASK(div) ((uint)(((PAGE_SIZE / AES_BLOCK_SIZE) / (div) - 1) << 4))
		#define MASK
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define state_index(x,div) ((*(uint *) x) & MASK(div))
		#define state_index

		// Iteration 1
		j = (((uint) a) & ((uint)(((PAGE_SIZE / DefineConstants.AES_BLOCK_SIZE) / (lightFlag) - 1) << 4)));
		p = long_state[j];
		aesb_single_round(p, p, a);
		copy_block(c1, p);

		do
		{
			if (variant == 2)
			{
			ulong[] chunk1 = ((ulong)((long_state) + ((j) ^ 0x10)));
			ulong[] chunk2 = ((ulong)((long_state) + ((j) ^ 0x20)));
			ulong[] chunk3 = ((ulong)((long_state) + ((j) ^ 0x30)));
			ulong[] chunk1_old = {chunk1[0], chunk1[1]};
			ulong[] b1 = Arrays.InitializeWithDefaultInstances<ulong>(2);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(b1, b + 16, 16);
			chunk1[0] = chunk3[0] + b1[0];
			chunk1[1] = chunk3[1] + b1[1];
			ulong[] a0 = Arrays.InitializeWithDefaultInstances<ulong>(2);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(a0, a, 16);
			chunk3[0] = chunk2[0] + a0[0];
			chunk3[1] = chunk2[1] + a0[1];
			ulong[] b0 = Arrays.InitializeWithDefaultInstances<ulong>(2);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(b0, b, 16);
			chunk2[0] = chunk1_old[0] + b0[0];
			chunk2[1] = chunk1_old[1] + b0[1];
			}
		} while (0 != 0);
		xor_blocks(p, b);
		do
		{
			if (variant == 1)
			{
			ushort tmp = ((ushort)(p))[11];
			const uint table = 0x75310;
			ushort index = (((tmp >> 3) & 6) | (tmp & 1)) << 1;
			((ushort)(p))[11] = tmp ^ ((table >> index) & 0x30);
			}
		} while (0 != 0);

		// Iteration 2
		j = (((uint) c1) & ((uint)(((PAGE_SIZE / DefineConstants.AES_BLOCK_SIZE) / (lightFlag) - 1) << 4)));
		p = long_state[j];
		copy_block(c, p);

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		VARIANT2_PORTABLE_INTEGER_MATH(c, c1);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
		mul(c1, c, d);
		if (variant == 2)
		{
			xor_blocks(long_state + (j ^ 0x10), d);
			xor_blocks(d, long_state + (j ^ 0x20));
		};
		do
		{
			if (variant == 2)
			{
			ulong[] chunk1 = ((ulong)((long_state) + ((j) ^ 0x10)));
			ulong[] chunk2 = ((ulong)((long_state) + ((j) ^ 0x20)));
			ulong[] chunk3 = ((ulong)((long_state) + ((j) ^ 0x30)));
			ulong[] chunk1_old = {chunk1[0], chunk1[1]};
			ulong[] b1 = Arrays.InitializeWithDefaultInstances<ulong>(2);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(b1, b + 16, 16);
			chunk1[0] = chunk3[0] + b1[0];
			chunk1[1] = chunk3[1] + b1[1];
			ulong[] a0 = Arrays.InitializeWithDefaultInstances<ulong>(2);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(a0, a, 16);
			chunk3[0] = chunk2[0] + a0[0];
			chunk3[1] = chunk2[1] + a0[1];
			ulong[] b0 = Arrays.InitializeWithDefaultInstances<ulong>(2);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(b0, b, 16);
			chunk2[0] = chunk1_old[0] + b0[0];
			chunk2[1] = chunk1_old[1] + b0[1];
			}
		} while (0 != 0);
		sum_half_blocks(a, d);
		swap_blocks(a, c);
		xor_blocks(a, c);
		do
		{
			if (variant == 1)
			{
			xor64(((ulong)(c)) + 1, new ulong(tweak1_2));
			}
		} while (0 != 0);
		copy_block(p, c);

		if (variant >= 2)
		{
		  copy_block(b + DefineConstants.AES_BLOCK_SIZE, b);
		}
		copy_block(b, c1);
	  }

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(text, state.init, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  oaes_key_import_data(aes_ctx, state.hs.b[32], DefineConstants.AES_KEY_SIZE);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(expandedKey, aes_ctx.key.exp_data, aes_ctx.key.exp_data_len);
	  for (i = 0; i < init_rounds; i++)
	  {
		  for (j = 0; j < DefineConstants.INIT_SIZE_BLK; j++)
		  {
			  xor_blocks(text[j * DefineConstants.AES_BLOCK_SIZE], long_state[i * (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE) + j * DefineConstants.AES_BLOCK_SIZE]);
			  aesb_pseudo_round(text[DefineConstants.AES_BLOCK_SIZE * j], text[DefineConstants.AES_BLOCK_SIZE * j], expandedKey);
		  }
	  }

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	  oaes_free((OAES_CTX) aes_ctx);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(state.init, text, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  hash_permutation(state.hs);
	  extra_hashes[state.hs.b[0] & 3](state, 200, hash);
	#if FORCE_USE_HEAP
	  long_state = null;
	#endif
	}

	public delegate void extra_hashesDelegate(object UnnamedParameter, size_t UnnamedParameter2, ref string UnnamedParameter3);
	#endif

	#else
	// Portable implementation as a fallback

	public static void slow_hash_allocate_state()
	{
	  // Do nothing, this is just to maintain compatibility with the upgraded slow-hash.c
	  return;
	}

	public static void slow_hash_free_state()
	{
	  // As above
	  return;
	}

	public delegate void extra_hashesDelegate(object UnnamedParameter, size_t UnnamedParameter2, ref string UnnamedParameter3);
	internal static extra_hashesDelegate[] extra_hashes = new extra_hashesDelegate(hash_extra_blake, hash_extra_groestl, hash_extra_jh, hash_extra_skein);

	//int aesb_single_round(ushort in, ushort @out, ushort expandedKey);Tangible Method Implementation Not Found-aesb_single_round
	//int aesb_pseudo_round(ushort in, ushort @out, ushort expandedKey);Tangible Method Implementation Not Found-aesb_pseudo_round

	internal static size_t e2i(ushort a, size_t count)
	{
		return ((ulong)a / DefineConstants.AES_BLOCK_SIZE) & (count - 1);
	}

	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	internal static void mul(ushort a, ushort b, ushort res)
	{
	  ulong a0 = new ulong();
	  ulong b0 = new ulong();
	  ulong hi = new ulong();
	  ulong lo = new ulong();

	  a0 = SWAP64LE(((ulong)a)[0]);
	  b0 = SWAP64LE(((ulong)b)[0]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: lo = mul128(a0, b0, &hi);
	  lo.CopyFrom(mul128(new ulong(a0), new ulong(b0), hi));
	  ((ulong)res)[0] = SWAP64LE(hi);
	  ((ulong)res)[1] = SWAP64LE(lo);
	}

	internal static void sum_half_blocks(ushort a, ushort b)
	{
	  ulong a0 = new ulong();
	  ulong a1 = new ulong();
	  ulong b0 = new ulong();
	  ulong b1 = new ulong();

	  a0 = SWAP64LE(((ulong)a)[0]);
	  a1 = SWAP64LE(((ulong)a)[1]);
	  b0 = SWAP64LE(((ulong)b)[0]);
	  b1 = SWAP64LE(((ulong)b)[1]);
	  a0 += b0;
	  a1 += b1;
	  ((ulong)a)[0] = SWAP64LE(a0);
	  ((ulong)a)[1] = SWAP64LE(a1);
	}
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define U64(x) ((ulong *) (x))
	#define U64

	internal static void copy_block(ushort dst, ushort src)
	{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(dst, src, DefineConstants.AES_BLOCK_SIZE);
	}

	internal static void swap_blocks(ushort a, ushort b)
	{
	  ulong[] t = Arrays.InitializeWithDefaultInstances<ulong>(2);
	  ((ulong)(t))[0] = ((ulong)(a))[0];
	  ((ulong)(t))[1] = ((ulong)(a))[1];
	  ((ulong)(a))[0] = ((ulong)(b))[0];
	  ((ulong)(a))[1] = ((ulong)(b))[1];
	  ((ulong)(b))[0] = ((ulong)(t))[0];
	  ((ulong)(b))[1] = ((ulong)(t))[1];
	}

	internal static void xor_blocks(ushort[] a, ushort[] b)
	{
	  size_t i = new size_t();
	  for (i = 0; i < DefineConstants.AES_BLOCK_SIZE; i++)
	  {
		a[i] ^= b[i];
	  }
	}

	internal static void xor64(ushort[] left, ushort[] right)
	{
	  size_t i = new size_t();
	  for (i = 0; i < 8; ++i)
	  {
		left[i] ^= right[i];
	  }
	}
	//{
	//  union hash_state hs;
	//  struct
	//  {
	//	ushort k[64];
	//	ushort init[(DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE)];
	//  };
	//};
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent to most C++ 'pragma' directives in C#:
	//#pragma pack(pop)

	public static void cn_slow_hash(object data, size_t length, ref string hash, int light, int variant, int prehashed, uint PAGE_SIZE, uint scratchpad, uint iterations)
	{
	  uint init_rounds = (scratchpad / (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  uint aes_rounds = (iterations / 2);
	  size_t aes_init = (PAGE_SIZE / DefineConstants.AES_BLOCK_SIZE);

	#if ! FORCE_USE_HEAP
	  ushort[] long_state = Arrays.InitializeWithDefaultInstances<ushort>(PAGE_SIZE);
	#else
//C++ TO C# CONVERTER TODO TASK: The memory management function 'malloc' has no equivalent in C#:
	  ushort long_state = (ushort)malloc(PAGE_SIZE);
	#endif

	  cn_slow_hash_state state = new cn_slow_hash_state();
	  ushort[] text = Arrays.InitializeWithDefaultInstances<ushort>((DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  ushort[] a = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.AES_BLOCK_SIZE);
	  ushort[] b = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.AES_BLOCK_SIZE * 2);
	  ushort[] c1 = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.AES_BLOCK_SIZE);
	  ushort[] c2 = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.AES_BLOCK_SIZE);
	  ushort[] d = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.AES_BLOCK_SIZE);
	  size_t i = new size_t();
	  size_t j = new size_t();
	  ushort[] aes_key = Arrays.InitializeWithDefaultInstances<ushort>(DefineConstants.AES_KEY_SIZE);
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	  oaes_ctx aes_ctx;

	  if (prehashed != 0)
	  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(state.hs, data, length);
	  }
	  else
	  {
		hash_process(state.hs, data, new size_t(length));
	  }
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(text, state.init, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(aes_key, state.hs.b, DefineConstants.AES_KEY_SIZE);
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	  aes_ctx = (oaes_ctx) oaes_alloc();

	  ushort[] tweak1_2 = Arrays.InitializeWithDefaultInstances<ushort>(8);
	  do
	  {
		  if (variant == 1)
		  {
		  do
		  {
			  if (length < 43)
			  {
			  Console.Error.Write("Cryptonight variant 1 need at least 43 bytes of data");
			  abort();
			  }
		  } while (0 != 0);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		  memcpy(tweak1_2, state.hs.b[192], sizeof(ushort));
		  xor64(tweak1_2, (((ushort)data) + 35));
		  }
	  } while (0 != 0);
	  ulong division_result = 0;
	  ulong sqrt_result = 0;
	  do
	  {
		  if (variant == 2)
		  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		  memcpy(b + DefineConstants.AES_BLOCK_SIZE, state.hs.b + 64, DefineConstants.AES_BLOCK_SIZE);
		  xor64(b + DefineConstants.AES_BLOCK_SIZE, state.hs.b + 80);
		  xor64(b + DefineConstants.AES_BLOCK_SIZE + 8, state.hs.b + 88);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: division_result = state.hs.w[12];
		  division_result.CopyFrom(state.hs.w[12]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: sqrt_result = state.hs.w[13];
		  sqrt_result.CopyFrom(state.hs.w[13]);
		  }
	  } while (0 != 0);

	  oaes_key_import_data(aes_ctx, aes_key, DefineConstants.AES_KEY_SIZE);
	  for (i = 0; i < init_rounds; i++)
	  {
		for (j = 0; j < DefineConstants.INIT_SIZE_BLK; j++)
		{
		  aesb_pseudo_round(text[DefineConstants.AES_BLOCK_SIZE * j], text[DefineConstants.AES_BLOCK_SIZE * j], aes_ctx.key.exp_data);
		}
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(long_state[i * (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE)], text, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE));
	  }

	  for (i = 0; i < DefineConstants.AES_BLOCK_SIZE; i++)
	  {
		a[i] = state.k[i] ^ state.k[DefineConstants.AES_BLOCK_SIZE * 2 + i];
		b[i] = state.k[DefineConstants.AES_BLOCK_SIZE + i] ^ state.k[DefineConstants.AES_BLOCK_SIZE * 3 + i];
	  }

	  for (i = 0; i < aes_rounds; i++)
	  {
		/* Dependency chain: address -> read value ------+
		 * written value <-+ hard function (AES or MUL) <+
		 * next address  <-+
		 */
		/* Iteration 1 */
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: j = e2i(a, aes_init);
		j.CopyFrom(e2i(a, new size_t(aes_init)));
		copy_block(c1, long_state[j]);
		aesb_single_round(c1, c1, a);
		do
		{
			if (variant == 2)
			{
			ulong[] chunk1 = ((ulong)((long_state) + ((j) ^ 0x10)));
			ulong[] chunk2 = ((ulong)((long_state) + ((j) ^ 0x20)));
			ulong[] chunk3 = ((ulong)((long_state) + ((j) ^ 0x30)));
			ulong[] chunk1_old = {chunk1[0], chunk1[1]};
			ulong[] b1 = Arrays.InitializeWithDefaultInstances<ulong>(2);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(b1, b + 16, 16);
			chunk1[0] = chunk3[0] + b1[0];
			chunk1[1] = chunk3[1] + b1[1];
			ulong[] a0 = Arrays.InitializeWithDefaultInstances<ulong>(2);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(a0, a, 16);
			chunk3[0] = chunk2[0] + a0[0];
			chunk3[1] = chunk2[1] + a0[1];
			ulong[] b0 = Arrays.InitializeWithDefaultInstances<ulong>(2);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(b0, b, 16);
			chunk2[0] = chunk1_old[0] + b0[0];
			chunk2[1] = chunk1_old[1] + b0[1];
			}
		} while (0 != 0);
		copy_block(long_state[j], c1);
		xor_blocks(long_state[j], b);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'VARIANT2_PORTABLE_INTEGER_MATH' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'mul' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		assert(j == e2i(a, new size_t(aes_init)); do if (variant == 1) {const ushort tmp = ((const ushort*)(long_state[j]))[11]; static const uint table = 0x75310; const ushort index = (((tmp >> 3) & 6) | (tmp & 1)) << 1; ((ushort*)(long_state[j]))[11] = tmp ^ ((table >> index) & 0x30);} while (0); j = e2i(c1, new size_t(aes_init)); copy_block(c2, long_state[j]); VARIANT2_PORTABLE_INTEGER_MATH(c2, c1); mul(c1, c2, d); if (variant == 2) {xor_blocks(long_state + (j ^ 0x10), d); xor_blocks(d, long_state + (j ^ 0x20));}; do if (variant == 2)
		{
			ulong * chunk1 = ((ulong *)((long_state) + ((j) ^ 0x10))); ulong * chunk2 = ((ulong *)((long_state) + ((j) ^ 0x20))); ulong * chunk3 = ((ulong *)((long_state) + ((j) ^ 0x30))); const ulong chunk1_old[2] = {chunk1[0], chunk1[1]}; ulong b1[2]; memcpy(b1, b + 16, 16); chunk1[0] = chunk3[0] + b1[0]; chunk1[1] = chunk3[1] + b1[1]; ulong a0[2]; memcpy(a0, a, 16); chunk3[0] = chunk2[0] + a0[0]; chunk3[1] = chunk2[1] + a0[1]; ulong b0[2]; memcpy(b0, b, 16); chunk2[0] = chunk1_old[0] + b0[0]; chunk2[1] = chunk1_old[1] + b0[1];
		} while (0); swap_blocks(a, c1); sum_half_blocks(c1, d); swap_blocks(c1, c2); xor_blocks(c1, c2); do if(variant == 1) { xor64(c2 + 8, tweak1_2); } while(0); copy_block(long_state[j], c2); assert(j == e2i(a, new size_t(aes_init)); if(variant == 2) { copy_block(b + DefineConstants.AES_BLOCK_SIZE, b); } copy_block(b, a); copy_block(a, c1);
		}
		memcpy(text, state.init, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE)); oaes_key_import_data(aes_ctx, state.hs.b[32], DefineConstants.AES_KEY_SIZE); for (i = 0; i < init_rounds; i++)
		{
		for (j = 0; j < DefineConstants.INIT_SIZE_BLK; j++) {xor_blocks(text[j * DefineConstants.AES_BLOCK_SIZE], long_state[i * (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE) + j * DefineConstants.AES_BLOCK_SIZE]); aesb_pseudo_round(text[DefineConstants.AES_BLOCK_SIZE * j], text[DefineConstants.AES_BLOCK_SIZE * j], aes_ctx.key.exp_data);}
		}
		memcpy(state.init, text, (DefineConstants.INIT_SIZE_BLK * DefineConstants.AES_BLOCK_SIZE)); hash_permutation(state.hs); extra_hashes[state.hs.b[0] & 3](state, 200, hash); oaes_free((OAES_CTX * *) aes_ctx);

	#if FORCE_USE_HEAP
	  long_state = null;
	#endif
	  }

	#endif
	// Copyright (c) 2012-2017, The CryptoNote developers, The Bytecoin developers
	//
	// This file is part of Bytecoin.
	//
	// Bytecoin is free software: you can redistribute it and/or modify
	// it under the terms of the GNU Lesser General Public License as published by
	// the Free Software Foundation, either version 3 of the License, or
	// (at your option) any later version.
	//
	// Bytecoin is distributed in the hope that it will be useful,
	// but WITHOUT ANY WARRANTY; without even the implied warranty of
	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	// GNU Lesser General Public License for more details.
	//
	// You should have received a copy of the GNU Lesser General Public License
	// along with Bytecoin.  If not, see <http://www.gnu.org/licenses/>.


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define inline __inline
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IDENT32(x) ((uint) (x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IDENT64(x) ((ulong) (x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32(x) ((((uint) (x) & 0x000000ff) << 24) | (((uint) (x) & 0x0000ff00) << 8) | (((uint) (x) & 0x00ff0000) >> 8) | (((uint) (x) & 0xff000000) >> 24))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64(x) ((((ulong) (x) & 0x00000000000000ff) << 56) | (((ulong) (x) & 0x000000000000ff00) << 40) | (((ulong) (x) & 0x0000000000ff0000) << 24) | (((ulong) (x) & 0x00000000ff000000) << 8) | (((ulong) (x) & 0x000000ff00000000) >> 8) | (((ulong) (x) & 0x0000ff0000000000) >> 24) | (((ulong) (x) & 0x00ff000000000000) >> 40) | (((ulong) (x) & 0xff00000000000000) >> 56))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32LE IDENT32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32BE SWAP32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32le ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32be swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32le mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32be mem_inplace_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32le memcpy_ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32be memcpy_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64LE IDENT64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64BE SWAP64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64le ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64be swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64le mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64be mem_inplace_swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64le memcpy_ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64be memcpy_swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32BE IDENT32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP32LE SWAP32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32be ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap32le swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32be mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap32le mem_inplace_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32be memcpy_ident32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap32le memcpy_swap32
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64BE IDENT64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SWAP64LE SWAP64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64be ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define swap64le swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64be mem_inplace_ident
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define mem_inplace_swap64le mem_inplace_swap64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64be memcpy_ident64
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define memcpy_swap64le memcpy_swap64

	public static void tree_hash(string[](*hashes), size_t count, ref string root_hash)
	{
	  Debug.Assert(count > 0);
	  if (count == 1)
	  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(root_hash, hashes, AnonymousEnum.HASH_SIZE);
	  }
	  else if (count == 2)
	  {
		cn_fast_hash(hashes, 2 * AnonymousEnum.HASH_SIZE, ref root_hash);
	  }
	  else
	  {
		size_t i = new size_t();
		size_t j = new size_t();
		size_t cnt = count - 1;
		string ints = new string(new char[(int)AnonymousEnum.HASH_SIZE]);
		for (i = 1; i < 8 * sizeof(size_t); i <<= 1)
		{
		  cnt |= cnt >> i;
		}
		cnt &= ~(cnt >> 1);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'alloca' has no equivalent in C#:
		ints = alloca(cnt * AnonymousEnum.HASH_SIZE);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(ints, hashes, (2 * cnt - count) * AnonymousEnum.HASH_SIZE);
		for (i = 2 * cnt - count, j = 2 * cnt - count; j < cnt; i += 2, ++j)
		{
		  cn_fast_hash(hashes[i], 2 * AnonymousEnum.HASH_SIZE, ref ints[j]);
		}
		Debug.Assert(i == count);
		while (cnt > 2)
		{
		  cnt >>= 1;
		  for (i = 0, j = 0; j < cnt; i += 2, ++j)
		  {
			cn_fast_hash(ints[i], 2 * AnonymousEnum.HASH_SIZE, ref ints[j]);
		  }
		}
		cn_fast_hash(ints[0], 2 * AnonymousEnum.HASH_SIZE, ref root_hash);
	  }
	}

	public static size_t tree_depth(size_t count)
	{
	  size_t i = new size_t();
	  size_t depth = 0;
	  Debug.Assert(count > 0);
	  for (i = sizeof(size_t) << 2; i > 0; i >>= 1)
	  {
		if (count >> i > 0)
		{
		  count >>= i;
		  depth += i;
		}
	  }
	  return depth;
	}

	public static void tree_branch(string[](*hashes), size_t count, string branch)
	{
	  size_t i = new size_t();
	  size_t j = new size_t();
	  size_t cnt = 1;
	  size_t depth = 0;
	  string ints = new string(new char[(int)AnonymousEnum.HASH_SIZE]);
	  Debug.Assert(count > 0);
	  for (i = sizeof(size_t) << 2; i > 0; i >>= 1)
	  {
		if (cnt << i <= count)
		{
		  cnt <<= i;
		  depth += i;
		}
	  }
	  Debug.Assert(cnt == 1UL << depth);
	  Debug.Assert(depth == tree_depth(new size_t(count)));
//C++ TO C# CONVERTER TODO TASK: The memory management function 'alloca' has no equivalent in C#:
	  ints = alloca((cnt - 1) * AnonymousEnum.HASH_SIZE);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(ints, hashes + 1, (2 * cnt - count - 1) * AnonymousEnum.HASH_SIZE);
	  for (i = 2 * cnt - count, j = 2 * cnt - count - 1; j < cnt - 1; i += 2, ++j)
	  {
		cn_fast_hash(hashes[i], 2 * AnonymousEnum.HASH_SIZE, ref ints[j]);
	  }
	  Debug.Assert(i == count);
	  while (depth > 0)
	  {
		Debug.Assert(cnt == 1UL << depth);
		cnt >>= 1;
		--depth;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(branch[depth], ints[0], AnonymousEnum.HASH_SIZE);
		for (i = 1, j = 0; j < cnt - 1; i += 2, ++j)
		{
		  cn_fast_hash(ints[i], 2 * AnonymousEnum.HASH_SIZE, ref ints[j]);
		}
	  }
	}

	public static void tree_hash_from_branch(string[](*branch), size_t depth, string leaf, object path, ref string root_hash)
	{
	  if (depth == 0)
	  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(root_hash, leaf, AnonymousEnum.HASH_SIZE);
	  }
	  else
	  {
		char[,] buffer = new char[2, (int)AnonymousEnum.HASH_SIZE];
		int from_leaf = 1;
		string leaf_path;
		string branch_path;
		while (depth > 0)
		{
		  --depth;
		  if (path && (((string) path)[depth >> 3] & (1 << (depth & 7))) != 0)
		  {
			leaf_path = buffer[1];
			branch_path = buffer[0];
		  }
		  else
		  {
			leaf_path = buffer[0];
			branch_path = buffer[1];
		  }
		  if (from_leaf != 0)
		  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(leaf_path, leaf, AnonymousEnum.HASH_SIZE);
			from_leaf = 0;
		  }
		  else
		  {
			cn_fast_hash(buffer, 2 * AnonymousEnum.HASH_SIZE, ref leaf_path);
		  }
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		  memcpy(branch_path, branch[depth], AnonymousEnum.HASH_SIZE);
		}
		cn_fast_hash(buffer, 2 * AnonymousEnum.HASH_SIZE, ref root_hash);
	  }
	}

	public static std::ostream print256<T>(std::ostream o, T v)
	{
	  return o << Common.GlobalMembers.podToHex(v);
	}

//--------------------------------------------------------------------------------

	public static bool parse_hash256(string str_hash, Crypto.Hash hash)
	{
	  return Common.GlobalMembers.podFromHex(str_hash, hash);
	}

	public static ulong getSignaturesCount(TransactionInput input)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//  struct txin_signature_size_visitor : public boost::static_visitor < ulong >
	//  {
	//	ulong operator ()(const BaseInput& txin) const
	//	{
	//		return 0;
	//	}
	//	ulong operator ()(const KeyInput& txin) const
	//	{
	//		return txin.outputIndexes.size();
	//	}
	//  };

	  return boost::apply_visitor(txin_signature_size_visitor(), input);
	}

	public static void getVariantValue(CryptoNote.ISerializer serializer, ushort tag, ref CryptoNote.TransactionInput in)
	{
	  switch (tag)
	  {
	  case 0xff:
	  {
		CryptoNote.BaseInput v = new CryptoNote.BaseInput();
		serializer.functorMethod(v, "value");
		in = v;
		break;
	  }
	  case 0x2:
	  {
		CryptoNote.KeyInput v = new CryptoNote.KeyInput();
		serializer.functorMethod(v, "value");
		in = v;
		break;
	  }
	  default:
		throw new System.Exception("Unknown variant tag");
	  }
	}

	public static void getVariantValue(CryptoNote.ISerializer serializer, ushort tag, ref CryptoNote.TransactionOutputTarget @out)
	{
	  switch (tag)
	  {
	  case 0x2:
	  {
		CryptoNote.KeyOutput v = new CryptoNote.KeyOutput();
		serializer.functorMethod(v, "data");
		@out = v;
		break;
	  }
	  default:
		throw new System.Exception("Unknown variant tag");
	  }
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static bool serializePod<T>(T v, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return serializer.binary(v, sizeof(T), new Common.StringView(name));
	}

	public static bool serializeVarintVector(List<uint> vector, CryptoNote.ISerializer serializer, Common.StringView name)
	{
	  ulong size = vector.Count;

	  if (!serializer.beginArray(size, new Common.StringView(name)))
	  {
		vector.Clear();
		return false;
	  }

	  vector.Resize(size);

	  for (ulong i = 0; i < size; ++i)
	  {
		serializer.functorMethod(vector[i], "");
	  }

	  serializer.endArray();
	  return true;
	}
	  public static readonly ulong MEGABYTE = 1024 * 1024;


	public static std::error_code make_error_code(CryptoNote.error.DataBaseErrorCodes e)
	{
	  return std::error_code((int)e, CryptoNote.error.DataBaseErrorCategory.INSTANCE);
	}
	  public static readonly string RAW_BLOCK_NAME = "raw_block";
	  public static readonly string RAW_TXS_NAME = "raw_txs";

// LWMA-3 difficulty algorithm 
// Copyright (c) 2017-2018 Zawy, MIT License
// https://github.com/zawy12/difficulty-algorithms/issues/3
	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.


	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.


	public static ulong nextDifficultyV6(List<ulong> timestamps, List<ulong> cumulativeDifficulties)
	{
		ulong T = CryptoNote.parameters.DIFFICULTY_TARGET;
		ulong N = CryptoNote.parameters.DIFFICULTY_WINDOW_V3;
		ulong L = new ulong(0);
		ulong ST = new ulong();
		ulong sum_3_ST = new ulong(0);
		ulong next_D = new ulong();
		ulong prev_D = new ulong();
		ulong thisTimestamp = new ulong();
		ulong previousTimestamp = new ulong();

		/* If we are starting up, returning a difficulty guess. If you are a
		   new coin, you might want to set this to a decent estimate of your
		   hashrate */
		if (timestamps.Count <= 10)
		{
			return 10000;
		}

		/* Don't have the full amount of blocks yet, starting up */
		if (timestamps.Count < CryptoNote.parameters.DIFFICULTY_BLOCKS_COUNT_V3)
		{
			N = timestamps.Count - 1;
		}

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: previousTimestamp = timestamps[0];
		previousTimestamp.CopyFrom(timestamps[0]);

		for (ulong i = 1; i <= N; i++)
		{
			if (timestamps[i] > previousTimestamp)
			{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: thisTimestamp = timestamps[i];
				thisTimestamp.CopyFrom(timestamps[i]);
			}
			else
			{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: thisTimestamp = previousTimestamp + 1;
				thisTimestamp.CopyFrom(previousTimestamp + 1);
			}

			ST = Math.Min(6 * T, thisTimestamp - previousTimestamp);

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: previousTimestamp = thisTimestamp;
			previousTimestamp.CopyFrom(thisTimestamp);

			L += ST * i;

			if (i > N - 3)
			{
				sum_3_ST += ST;
			}
		}

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: next_D = ((cumulativeDifficulties[N] - cumulativeDifficulties[0]) * T * (N+1) * 99) / (100 * 2 * L);
		next_D.CopyFrom(((cumulativeDifficulties[N] - cumulativeDifficulties[0]) * T * (N + 1) * 99) / (100 * 2 * L));

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: prev_D = cumulativeDifficulties[N] - cumulativeDifficulties[N-1];
		prev_D.CopyFrom(cumulativeDifficulties[N] - cumulativeDifficulties[N - 1]);

		next_D = Math.Max((prev_D * 67) / 100, Math.Min(next_D, (prev_D * 150) / 100));

		if (sum_3_ST < (8 * T) / 10)
		{
			next_D = Math.Max(next_D, (prev_D * 108) / 100);
		}

		return next_D;
	}

// LWMA-2 difficulty algorithm 
// Copyright (c) 2017-2018 Zawy, MIT License
// https://github.com/zawy12/difficulty-algorithms/issues/3

	public static ulong nextDifficultyV5(List<ulong> timestamps, List<ulong> cumulativeDifficulties)
	{
		long T = CryptoNote.parameters.DIFFICULTY_TARGET;
		long N = CryptoNote.parameters.DIFFICULTY_WINDOW_V3;
		long L = new long(0);
		long ST = new long();
		long sum_3_ST = new long(0);
		long next_D = new long();
		long prev_D = new long();

		/* If we are starting up, returning a difficulty guess. If you are a
		   new coin, you might want to set this to a decent estimate of your
		   hashrate */
		if (timestamps.Count < (ulong)(N + 1))
		{
			return 10000;
		}

		for (long i = 1; i <= N; i++)
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: ST = static_cast<long>(timestamps[i]) - static_cast<long>(timestamps[i-1]);
			ST.CopyFrom((long)timestamps[i] - (long)timestamps[i - 1]);

			ST = Math.Max(-4 * T, Math.Min(ST, 6 * T));

			L += ST * i;

			if (i > N - 3)
			{
				sum_3_ST += ST;
			}
		}

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: next_D = (static_cast<long>(cumulativeDifficulties[N] - cumulativeDifficulties[0]) * T * (N+1) * 99) / (100 * 2 * L);
		next_D.CopyFrom(((long)(cumulativeDifficulties[N] - cumulativeDifficulties[0]) * T * (N + 1) * 99) / (100 * 2 * L));

		prev_D = cumulativeDifficulties[N] - cumulativeDifficulties[N - 1];

		next_D = Math.Max((prev_D * 67) / 100, Math.Min(next_D, (prev_D * 150) / 100));

		if (sum_3_ST < (8 * T) / 10)
		{
			next_D = Math.Max(next_D, (prev_D * 108) / 100);
		}

		return (ulong)next_D;
	}

// LWMA-2 difficulty algorithm 
// Copyright (c) 2017-2018 Zawy, MIT License
// https://github.com/zawy12/difficulty-algorithms/issues/3

	public static ulong nextDifficultyV4(List<ulong> timestamps, List<ulong> cumulativeDifficulties)
	{
		long T = CryptoNote.parameters.DIFFICULTY_TARGET;
		long N = CryptoNote.parameters.DIFFICULTY_WINDOW_V3;
		long L = new long(0);
		long ST = new long();
		long sum_3_ST = new long(0);
		long next_D = new long();
		long prev_D = new long();

		if (timestamps.Count <= (ulong)N)
		{
			return 1000;
		}

		for (long i = 1; i <= N; i++)
		{
			ST = clamp(-6 * T, (long)timestamps[i] - (long)timestamps[i - 1], 6 * T);

			L += ST * i;

			if (i > N - 3)
			{
				sum_3_ST += ST;
			}
		}

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: next_D = (static_cast<long>(cumulativeDifficulties[N] - cumulativeDifficulties[0]) * T * (N+1) * 99) / (100 * 2 * L);
		next_D.CopyFrom(((long)(cumulativeDifficulties[N] - cumulativeDifficulties[0]) * T * (N + 1) * 99) / (100 * 2 * L));
		prev_D = cumulativeDifficulties[N] - cumulativeDifficulties[N - 1];

		/* Make sure we don't divide by zero if 50x attacker (thanks fireice) */
		next_D = Math.Max((prev_D * 67) / 100, Math.Min(next_D, (prev_D * 150) / 100));

		if (sum_3_ST < (8 * T) / 10)
		{
			next_D = Math.Max(next_D, (prev_D * 110) / 100);
		}

		return (ulong)next_D;
	}

// LWMA-2 difficulty algorithm 
// Copyright (c) 2017-2018 Zawy, MIT License
// https://github.com/zawy12/difficulty-algorithms/issues/3

	public static ulong nextDifficultyV3(List<ulong> timestamps, List<ulong> cumulativeDifficulties)
	{
		long T = CryptoNote.parameters.DIFFICULTY_TARGET;
		long N = CryptoNote.parameters.DIFFICULTY_WINDOW_V3;
		long FTL = CryptoNote.parameters.CRYPTONOTE_BLOCK_FUTURE_TIME_LIMIT_V3;
		long L = new long(0);
		long ST = new long();
		long sum_3_ST = new long(0);
		long next_D = new long();
		long prev_D = new long();

		if (timestamps.Count <= (ulong)N)
		{
			return 1000;
		}

		for (long i = 1; i <= N; i++)
		{
			ST = Math.Max(-FTL, Math.Min((long)timestamps[i] - (long)timestamps[i - 1], 6 * T));

			L += ST * i;

			if (i > N - 3)
			{
				sum_3_ST += ST;
			}
		}

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: next_D = (static_cast<long>(cumulativeDifficulties[N] - cumulativeDifficulties[0]) * T * (N+1) * 99) / (100 * 2 * L);
		next_D.CopyFrom(((long)(cumulativeDifficulties[N] - cumulativeDifficulties[0]) * T * (N + 1) * 99) / (100 * 2 * L));
		prev_D = cumulativeDifficulties[N] - cumulativeDifficulties[N - 1];

		/* Make sure we don't divide by zero if 50x attacker (thanks fireice) */
		next_D = Math.Max((prev_D * 70) / 100, Math.Min(next_D, (prev_D * 107) / 100));

		if (sum_3_ST < (8 * T) / 10)
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: next_D = (prev_D * 110) / 100;
			next_D.CopyFrom((prev_D * 110) / 100);
		}

		return (ulong)next_D;
	}

	/* TODO: This has been added in the stdlib in c++17 */
//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static T clamp<T>(T n, T lower, T upper)
	{
		return Math.Max(lower, Math.Min(n, upper));
	}

	  public static readonly string DB_NAME = "DB";
	  public static readonly string TESTNET_DB_NAME = "testnet_DB";

	#if MSVC
	public static char suppressMSVCWarningLNK4221;
	#endif

	#if MSVC
	public static char suppressMSVCWarningLNK4221;
	#endif


	  public static void derivePublicKey(AccountPublicAddress to, SecretKey txKey, size_t outputIndex, PublicKey ephemeralKey)
	  {
		KeyDerivation derivation = new KeyDerivation();
		generate_key_derivation(to.viewPublicKey, txKey, derivation);
		derive_public_key(derivation, outputIndex, to.spendPublicKey, ephemeralKey);
	  }

	public static readonly string INPUT_DATA = "0100fb8e8ac805899323371bb790db19218afd8db8e3755d8b90f39b3d5506a9abce4fa912244500000000ee8146d49fa93ee724deb57d12cbc6c6f3b924d946127c7a97418f9348828f0f02";

	public static readonly string CN_FAST_HASH = "b542df5b6e7f5f05275c98e7345884e2ac726aeeb07e03e44e0389eb86cd05f0";

	public static readonly string CN_SLOW_HASH_V0 = "1b606a3f4a07d6489a1bcd07697bd16696b61c8ae982f61a90160f4e52828a7f";
	public static readonly string CN_SLOW_HASH_V1 = "c9fae8425d8688dc236bcdbc42fdb42d376c6ec190501aa84b04a4b4cf1ee122";
	public static readonly string CN_SLOW_HASH_V2 = "871fcd6823f6a879bb3f33951c8e8e891d4043880b02dfa1bb3be498b50e7578";

	public static readonly string CN_LITE_SLOW_HASH_V0 = "28a22bad3f93d1408fca472eb5ad1cbe75f21d053c8ce5b3af105a57713e21dd";
	public static readonly string CN_LITE_SLOW_HASH_V1 = "87c4e570653eb4c2b42b7a0d546559452dfab573b82ec52f152b7ff98e79446f";
	public static readonly string CN_LITE_SLOW_HASH_V2 = "b7e78fab22eb19cb8c9c3afe034fb53390321511bab6ab4915cd538a630c3c62";

	public static readonly string[] CN_SOFT_SHELL_V0 = {"5e1891a15d5d85c09baf4a3bbe33675cfa3f77229c8ad66c01779e590528d6d3", "e1239347694df77cab780b7ec8920ec6f7e48ecef1d8c368e06708c08e1455f1", "118a03801c564d12f7e68972419303fe06f7a54ab8f44a8ce7deafbc6b1b5183", "8be48f7955eb3f9ac2275e445fe553f3ef359ea5c065cde98ff83011f407a0ec", "d33da3541960046e846530dcc9872b1914a62c09c7d732bff03bec481866ae48", "8be48f7955eb3f9ac2275e445fe553f3ef359ea5c065cde98ff83011f407a0ec", "118a03801c564d12f7e68972419303fe06f7a54ab8f44a8ce7deafbc6b1b5183", "e1239347694df77cab780b7ec8920ec6f7e48ecef1d8c368e06708c08e1455f1", "5e1891a15d5d85c09baf4a3bbe33675cfa3f77229c8ad66c01779e590528d6d3", "e1239347694df77cab780b7ec8920ec6f7e48ecef1d8c368e06708c08e1455f1", "118a03801c564d12f7e68972419303fe06f7a54ab8f44a8ce7deafbc6b1b5183", "8be48f7955eb3f9ac2275e445fe553f3ef359ea5c065cde98ff83011f407a0ec", "d33da3541960046e846530dcc9872b1914a62c09c7d732bff03bec481866ae48", "8be48f7955eb3f9ac2275e445fe553f3ef359ea5c065cde98ff83011f407a0ec", "118a03801c564d12f7e68972419303fe06f7a54ab8f44a8ce7deafbc6b1b5183", "e1239347694df77cab780b7ec8920ec6f7e48ecef1d8c368e06708c08e1455f1", "5e1891a15d5d85c09baf4a3bbe33675cfa3f77229c8ad66c01779e590528d6d3"};

	public static readonly string[] CN_SOFT_SHELL_V1 = {"ae7f864a7a2f2b07dcef253581e60a014972b9655a152341cb989164761c180a", "ce8687bdd08c49bd1da3a6a74bf28858670232c1a0173ceb2466655250f9c56d", "ddb6011d400ac8725995fb800af11646bb2fef0d8b6136b634368ad28272d7f4", "02576f9873dc9c8b1b0fc14962982734dfdd41630fc936137a3562b8841237e1", "d37e2785ab7b3d0a222940bf675248e7b96054de5c82c5f0b141014e136eadbc", "02576f9873dc9c8b1b0fc14962982734dfdd41630fc936137a3562b8841237e1", "ddb6011d400ac8725995fb800af11646bb2fef0d8b6136b634368ad28272d7f4", "ce8687bdd08c49bd1da3a6a74bf28858670232c1a0173ceb2466655250f9c56d", "ae7f864a7a2f2b07dcef253581e60a014972b9655a152341cb989164761c180a", "ce8687bdd08c49bd1da3a6a74bf28858670232c1a0173ceb2466655250f9c56d", "ddb6011d400ac8725995fb800af11646bb2fef0d8b6136b634368ad28272d7f4", "02576f9873dc9c8b1b0fc14962982734dfdd41630fc936137a3562b8841237e1", "d37e2785ab7b3d0a222940bf675248e7b96054de5c82c5f0b141014e136eadbc", "02576f9873dc9c8b1b0fc14962982734dfdd41630fc936137a3562b8841237e1", "ddb6011d400ac8725995fb800af11646bb2fef0d8b6136b634368ad28272d7f4", "ce8687bdd08c49bd1da3a6a74bf28858670232c1a0173ceb2466655250f9c56d", "ae7f864a7a2f2b07dcef253581e60a014972b9655a152341cb989164761c180a"};

	public static readonly string[] CN_SOFT_SHELL_V2 = {"b2172ec9466e1aee70ec8572a14c233ee354582bcb93f869d429744de5726a26", "b2623a2b041dc5ae3132b964b75e193558c7095e725d882a3946aae172179cf1", "141878a7b58b0f57d00b8fc2183cce3517d9d68becab6fee52abb3c1c7d0805b", "4646f9919791c28f0915bc0005ed619bee31d42359f7a8af5de5e1807e875364", "3fedc7ab0f8d14122fc26062de1af7a6165755fcecdf0f12fa3ccb3ff63629d0", "4646f9919791c28f0915bc0005ed619bee31d42359f7a8af5de5e1807e875364", "141878a7b58b0f57d00b8fc2183cce3517d9d68becab6fee52abb3c1c7d0805b", "b2623a2b041dc5ae3132b964b75e193558c7095e725d882a3946aae172179cf1", "b2172ec9466e1aee70ec8572a14c233ee354582bcb93f869d429744de5726a26", "b2623a2b041dc5ae3132b964b75e193558c7095e725d882a3946aae172179cf1", "141878a7b58b0f57d00b8fc2183cce3517d9d68becab6fee52abb3c1c7d0805b", "4646f9919791c28f0915bc0005ed619bee31d42359f7a8af5de5e1807e875364", "3fedc7ab0f8d14122fc26062de1af7a6165755fcecdf0f12fa3ccb3ff63629d0", "4646f9919791c28f0915bc0005ed619bee31d42359f7a8af5de5e1807e875364", "141878a7b58b0f57d00b8fc2183cce3517d9d68becab6fee52abb3c1c7d0805b", "b2623a2b041dc5ae3132b964b75e193558c7095e725d882a3946aae172179cf1", "b2172ec9466e1aee70ec8572a14c233ee354582bcb93f869d429744de5726a26"};

	internal static bool CompareHashes(Hash leftHash, string right)
	{
	  Hash rightHash = new Hash();
	  if (!Common.GlobalMembers.podFromHex(right, rightHash))
	  {
		return false;
	  }

	  return (leftHash == rightHash);
	}

	static void Main(int argc, string[] args)
	{
	  bool o_help;
	  bool o_version;
	  bool o_benchmark;
	  int o_iterations;

	  cxxopts.Options options = new cxxopts.Options(args[0], getProjectCLIHeader());

	  options.add_options("Core")("h,help", "Display this help message", cxxopts.value<bool>(o_help).implicit_value("true"))("v,version", "Output software version information", cxxopts.value<bool>(o_version).default_value("false").implicit_value("true"));

	  options.add_options("Performance Testing")("b,benchmark", "Run quick performance benchmark", cxxopts.value<bool>(o_benchmark).default_value("false").implicit_value("true"))("i,iterations", "The number of iterations for the benchmark test. Minimum of 1,000 iterations required.", cxxopts.value<int>(o_iterations).default_value(Convert.ToString(DefineConstants.PERFORMANCE_ITERATIONS)), "#");

	  try
	  {
		var result = options.parse(argc, args);
	  }
	  catch (cxxopts.OptionException e)
	  {
		Console.Write("Error: Unable to parse command line argument options: ");
		Console.Write(e.what());
		Console.Write("\n");
		Console.Write("\n");
		Console.Write(options.help({}));
		Console.Write("\n");
		Environment.Exit(1);
	  }

	  if (o_help) // Do we want to display the help message?
	  {
		Console.Write(options.help({}));
		Console.Write("\n");
		Environment.Exit(0);
	  }
	  else if (o_version) // Do we want to display the software version?
	  {
		Console.Write(getProjectCLIHeader());
		Console.Write("\n");
		Environment.Exit(0);
	  }

	  if (o_iterations < 1000 && o_benchmark)
	  {
		Console.Write("\n");
		Console.Write("Error: The number of --iterations should be at least 1,000 for reasonable accuracy");
		Console.Write("\n");
		Environment.Exit(1);
	  }

	  try
	  {
		BinaryArray rawData = Common.fromHex(INPUT_DATA);

		Console.Write(getProjectCLIHeader());
		Console.Write("\n");

		Console.Write("Input: ");
		Console.Write(INPUT_DATA);
		Console.Write("\n");
		Console.Write("\n");

		Hash hash = new Hash();

		Crypto.GlobalMembers.cn_fast_hash(rawData.data(), rawData.size(), hash);
		Console.Write("cn_fast_hash: ");
		Console.Write(Common.toHex(hash, sizeof(Hash)));
		Console.Write("\n");
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: System.Diagnostics.Debug.Assert(CompareHashes(hash, CN_FAST_HASH));
		Debug.Assert(CompareHashes(new Crypto.Hash(hash), CN_FAST_HASH));

		Console.Write("\n");

		Crypto.GlobalMembers.cn_slow_hash_v0(rawData.data(), rawData.size(), hash);
		Console.Write("cn_slow_hash_v0: ");
		Console.Write(Common.toHex(hash, sizeof(Hash)));
		Console.Write("\n");
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: System.Diagnostics.Debug.Assert(CompareHashes(hash, CN_SLOW_HASH_V0));
		Debug.Assert(CompareHashes(new Crypto.Hash(hash), CN_SLOW_HASH_V0));

		if (rawData.size() >= 43)
		{
		  Crypto.GlobalMembers.cn_slow_hash_v1(rawData.data(), rawData.size(), hash);
		  Console.Write("cn_slow_hash_v1: ");
		  Console.Write(Common.toHex(hash, sizeof(Hash)));
		  Console.Write("\n");
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: System.Diagnostics.Debug.Assert(CompareHashes(hash, CN_SLOW_HASH_V1));
		  Debug.Assert(CompareHashes(new Crypto.Hash(hash), CN_SLOW_HASH_V1));

		  Crypto.GlobalMembers.cn_slow_hash_v2(rawData.data(), rawData.size(), hash);
		  Console.Write("cn_slow_hash_v2: ");
		  Console.Write(Common.toHex(hash, sizeof(Hash)));
		  Console.Write("\n");
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: System.Diagnostics.Debug.Assert(CompareHashes(hash, CN_SLOW_HASH_V2));
		  Debug.Assert(CompareHashes(new Crypto.Hash(hash), CN_SLOW_HASH_V2));

		  Console.Write("\n");

		  Crypto.GlobalMembers.cn_lite_slow_hash_v0(rawData.data(), rawData.size(), hash);
		  Console.Write("cn_lite_slow_hash_v0: ");
		  Console.Write(Common.toHex(hash, sizeof(Hash)));
		  Console.Write("\n");
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: System.Diagnostics.Debug.Assert(CompareHashes(hash, CN_LITE_SLOW_HASH_V0));
		  Debug.Assert(CompareHashes(new Crypto.Hash(hash), CN_LITE_SLOW_HASH_V0));

		  Crypto.GlobalMembers.cn_lite_slow_hash_v1(rawData.data(), rawData.size(), hash);
		  Console.Write("cn_lite_slow_hash_v1: ");
		  Console.Write(Common.toHex(hash, sizeof(Hash)));
		  Console.Write("\n");
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: System.Diagnostics.Debug.Assert(CompareHashes(hash, CN_LITE_SLOW_HASH_V1));
		  Debug.Assert(CompareHashes(new Crypto.Hash(hash), CN_LITE_SLOW_HASH_V1));

		  Crypto.GlobalMembers.cn_lite_slow_hash_v2(rawData.data(), rawData.size(), hash);
		  Console.Write("cn_lite_slow_hash_v2: ");
		  Console.Write(Common.toHex(hash, sizeof(Hash)));
		  Console.Write("\n");
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: System.Diagnostics.Debug.Assert(CompareHashes(hash, CN_LITE_SLOW_HASH_V2));
		  Debug.Assert(CompareHashes(new Crypto.Hash(hash), CN_LITE_SLOW_HASH_V2));

		  Console.Write("\n");

		  for (uint height = 0; height <= 8192; height = height + 512)
		  {
			Crypto.GlobalMembers.cn_soft_shell_slow_hash_v0(rawData.data(), rawData.size(), hash, new uint(height));
			Console.Write("cn_soft_shell_slow_hash_v0 (");
			Console.Write(height);
			Console.Write("): ");
			Console.Write(Common.toHex(hash, sizeof(Hash)));
			Console.Write("\n");
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: System.Diagnostics.Debug.Assert(CompareHashes(hash, CN_SOFT_SHELL_V0[height / 512]));
			Debug.Assert(CompareHashes(new Crypto.Hash(hash), CN_SOFT_SHELL_V0[height / 512]));
		  }

		  Console.Write("\n");

		  for (uint height = 0; height <= 8192; height = height + 512)
		  {
			Crypto.GlobalMembers.cn_soft_shell_slow_hash_v1(rawData.data(), rawData.size(), hash, new uint(height));
			Console.Write("cn_soft_shell_slow_hash_v1 (");
			Console.Write(height);
			Console.Write("): ");
			Console.Write(Common.toHex(hash, sizeof(Hash)));
			Console.Write("\n");
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: System.Diagnostics.Debug.Assert(CompareHashes(hash, CN_SOFT_SHELL_V1[height / 512]));
			Debug.Assert(CompareHashes(new Crypto.Hash(hash), CN_SOFT_SHELL_V1[height / 512]));
		  }

		  Console.Write("\n");

		  for (uint height = 0; height <= 8192; height = height + 512)
		  {
			Crypto.GlobalMembers.cn_soft_shell_slow_hash_v2(rawData.data(), rawData.size(), hash, new uint(height));
			Console.Write("cn_soft_shell_slow_hash_v2 (");
			Console.Write(height);
			Console.Write("): ");
			Console.Write(Common.toHex(hash, sizeof(Hash)));
			Console.Write("\n");
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: System.Diagnostics.Debug.Assert(CompareHashes(hash, CN_SOFT_SHELL_V2[height / 512]));
			Debug.Assert(CompareHashes(new Crypto.Hash(hash), CN_SOFT_SHELL_V2[height / 512]));
		  }
		}

		if (o_benchmark)
		{
		  Console.Write("\nPerformance Tests: Please wait, this may take a while depending on your system...\n\n");

		  var startTimer = std::chrono.high_resolution_clock.now();
		  for (var i = 0; i < DefineConstants.PERFORMANCE_ITERATIONS; i++)
		  {
			Crypto.GlobalMembers.cn_slow_hash_v0(rawData.data(), rawData.size(), hash);
		  }
		  var elapsedTime = std::chrono.high_resolution_clock.now() - startTimer;
		  Console.Write("cn_slow_hash_v0: ");
		  Console.Write((DefineConstants.PERFORMANCE_ITERATIONS / std::chrono.duration_cast<std::chrono.seconds>(elapsedTime).count()));
		  Console.Write(" H/s\n");

		  if (rawData.size() >= 43)
		  {
			startTimer = std::chrono.high_resolution_clock.now();
			for (var i = 0; i < DefineConstants.PERFORMANCE_ITERATIONS; i++)
			{
			  Crypto.GlobalMembers.cn_slow_hash_v1(rawData.data(), rawData.size(), hash);
			}
			elapsedTime = std::chrono.high_resolution_clock.now() - startTimer;
			Console.Write("cn_slow_hash_v1: ");
			Console.Write((DefineConstants.PERFORMANCE_ITERATIONS / std::chrono.duration_cast<std::chrono.seconds>(elapsedTime).count()));
			Console.Write(" H/s\n");

			startTimer = std::chrono.high_resolution_clock.now();
			for (var i = 0; i < DefineConstants.PERFORMANCE_ITERATIONS; i++)
			{
			  Crypto.GlobalMembers.cn_slow_hash_v2(rawData.data(), rawData.size(), hash);
			}
			elapsedTime = std::chrono.high_resolution_clock.now() - startTimer;
			Console.Write("cn_slow_hash_v2: ");
			Console.Write((DefineConstants.PERFORMANCE_ITERATIONS / std::chrono.duration_cast<std::chrono.seconds>(elapsedTime).count()));
			Console.Write(" H/s\n");
		  }

		  startTimer = std::chrono.high_resolution_clock.now();
		  for (var i = 0; i < DefineConstants.PERFORMANCE_ITERATIONS; i++)
		  {
			Crypto.GlobalMembers.cn_lite_slow_hash_v0(rawData.data(), rawData.size(), hash);
		  }
		  elapsedTime = std::chrono.high_resolution_clock.now() - startTimer;
		  Console.Write("cn_lite_slow_hash_v0: ");
		  Console.Write((DefineConstants.PERFORMANCE_ITERATIONS / std::chrono.duration_cast<std::chrono.seconds>(elapsedTime).count()));
		  Console.Write(" H/s\n");

		  if (rawData.size() >= 43)
		  {
			startTimer = std::chrono.high_resolution_clock.now();
			for (var i = 0; i < DefineConstants.PERFORMANCE_ITERATIONS; i++)
			{
			  Crypto.GlobalMembers.cn_lite_slow_hash_v1(rawData.data(), rawData.size(), hash);
			}
			elapsedTime = std::chrono.high_resolution_clock.now() - startTimer;
			Console.Write("cn_lite_slow_hash_v1: ");
			Console.Write((DefineConstants.PERFORMANCE_ITERATIONS / std::chrono.duration_cast<std::chrono.seconds>(elapsedTime).count()));
			Console.Write(" H/s\n");

			startTimer = std::chrono.high_resolution_clock.now();
			for (var i = 0; i < DefineConstants.PERFORMANCE_ITERATIONS; i++)
			{
			  Crypto.GlobalMembers.cn_lite_slow_hash_v2(rawData.data(), rawData.size(), hash);
			}
			elapsedTime = std::chrono.high_resolution_clock.now() - startTimer;
			Console.Write("cn_lite_slow_hash_v2: ");
			Console.Write((DefineConstants.PERFORMANCE_ITERATIONS / std::chrono.duration_cast<std::chrono.seconds>(elapsedTime).count()));
			Console.Write(" H/s\n");
		  }
		}
	  }
	  catch (System.Exception e)
	  {
		Console.Write("Something went terribly wrong...");
		Console.Write("\n");
		Console.Write(e.Message);
		Console.Write("\n");
		Console.Write("\n");
	  }

	}

	  public static DaemonConfiguration initConfiguration()
	  {
		DaemonConfiguration config = new DaemonConfiguration();

		std::stringstream logfile = new std::stringstream();
		  logfile << CryptoNote.CRYPTONOTE_NAME << "d.log";

		config.dataDirectory = Tools.getDefaultDataDirectory();
		config.checkPoints = "default";
		config.logFile = logfile.str();
		config.logLevel = (int)Logging.Level.WARNING;
		config.dbMaxOpenFiles = CryptoNote.DATABASE_DEFAULT_MAX_OPEN_FILES;
		config.dbReadCacheSize = CryptoNote.DATABASE_READ_BUFFER_MB_DEFAULT_SIZE;
		config.dbThreads = CryptoNote.DATABASE_DEFAULT_BACKGROUND_THREADS_COUNT;
		config.dbWriteBufferSize = CryptoNote.DATABASE_WRITE_BUFFER_MB_DEFAULT_SIZE;
		config.p2pInterface = "0.0.0.0";
		config.p2pPort = CryptoNote.P2P_DEFAULT_PORT;
		config.p2pExternalPort = 0;
		config.rpcInterface = "127.0.0.1";
		config.rpcPort = CryptoNote.RPC_DEFAULT_PORT;
		config.noConsole = false;
		config.enableBlockExplorer = false;
		config.localIp = false;
		config.hideMyPort = false;
		config.help = false;
		config.version = false;
		config.osVersion = false;
		config.printGenesisTx = false;
		config.dumpConfig = false;

		return config;
	  }

	  public static DaemonConfiguration initConfiguration(string path)
	  {
		DaemonConfiguration config = initConfiguration();

		config.logFile = Common.ReplaceExtenstion(Common.NativePathToGeneric(path), ".log");

		return config;
	  }

	  public static void handleSettings(int argc, string[] argv, DaemonConfiguration config)
	  {
		cxxopts.Options options = new cxxopts.Options(argv[0], CryptoNote.getProjectCLIHeader());

		options.add_options("Core")("help", "Display this help message", cxxopts.value<bool>().implicit_value("true"))("os-version", "Output Operating System version information", cxxopts.value<bool>().default_value("false").implicit_value("true"))("version","Output daemon version information",cxxopts.value<bool>().default_value("false").implicit_value("true"));

		options.add_options("Genesis Block")("genesis-block-reward-address", "Specify the address for any premine genesis block rewards", cxxopts.value<List<string>>(), "<address>")("print-genesis-tx", "Print the genesis block transaction hex and exits", cxxopts.value<bool>().default_value("false").implicit_value("true"));

		options.add_options("Daemon")("c,config-file", "Specify the <path> to a configuration file", cxxopts.value<string>(), "<path>")("data-dir", "Specify the <path> to the Blockchain data directory", cxxopts.value<string>().default_value(config.dataDirectory), "<path>")("dump-config", "Prints the current configuration to the screen", cxxopts.value<bool>().default_value("false").implicit_value("true"))("load-checkpoints", "Specify a file <path> containing a CSV of Blockchain checkpoints for faster sync. A value of 'default' uses the built-in checkpoints.", cxxopts.value<string>().default_value(config.checkPoints), "<path>")("log-file", "Specify the <path> to the log file", cxxopts.value<string>().default_value(config.logFile), "<path>")("log-level", "Specify log level", cxxopts.value<int>().default_value(Convert.ToString(config.logLevel)), "#")("no-console", "Disable daemon console commands", cxxopts.value<bool>().default_value("false").implicit_value("true"))("save-config", "Save the configuration to the specified <file>", cxxopts.value<string>(), "<file>");

		options.add_options("RPC")("enable-blockexplorer", "Enable the Blockchain Explorer RPC", cxxopts.value<bool>().default_value("false").implicit_value("true"))("enable-cors", "Adds header 'Access-Control-Allow-Origin' to the RPC responses using the <domain>. Uses the value specified as the domain. Use * for all.", cxxopts.value<List<string>>(), "<domain>")("fee-address", "Sets the convenience charge <address> for light wallets that use the daemon", cxxopts.value<string>(), "<address>")("fee-amount", "Sets the convenience charge amount for light wallets that use the daemon", cxxopts.value<int>().default_value("0"), "#");

		options.add_options("Network")("allow-local-ip", "Allow the local IP to be added to the peer list", cxxopts.value<bool>().default_value("false").implicit_value("true"))("hide-my-port", "Do not announce yourself as a peerlist candidate", cxxopts.value<bool>().default_value("false").implicit_value("true"))("p2p-bind-ip", "Interface IP address for the P2P service", cxxopts.value<string>().default_value(config.p2pInterface), "<ip>")("p2p-bind-port", "TCP port for the P2P service", cxxopts.value<int>().default_value(Convert.ToString(config.p2pPort)), "#")("p2p-external-port", "External TCP port for the P2P service (NAT port forward)", cxxopts.value<int>().default_value("0"), "#")("rpc-bind-ip", "Interface IP address for the RPC service", cxxopts.value<string>().default_value(config.rpcInterface), "<ip>")("rpc-bind-port", "TCP port for the RPC service", cxxopts.value<int>().default_value(Convert.ToString(config.rpcPort)), "#");

		options.add_options("Peer")("add-exclusive-node", "Manually add a peer to the local peer list ONLY attempt connections to it. [ip:port]", cxxopts.value<List<string>>(), "<ip:port>")("add-peer", "Manually add a peer to the local peer list", cxxopts.value<List<string>>(), "<ip:port>")("add-priority-node", "Manually add a peer to the local peer list and attempt to maintain a connection to it [ip:port]", cxxopts.value<List<string>>(), "<ip:port>")("seed-node", "Connect to a node to retrieve the peer list and then disconnect", cxxopts.value<List<string>>(), "<ip:port>");

		options.add_options("Database")("db-max-open-files", "Number of files that can be used by the database at one time", cxxopts.value<int>().default_value(Convert.ToString(config.dbMaxOpenFiles)), "#")("db-read-buffer-size", "Size of the database read cache in megabytes (MB)", cxxopts.value<int>().default_value(Convert.ToString(config.dbReadCacheSize)), "#")("db-threads", "Number of background threads used for compaction and flush operations", cxxopts.value<int>().default_value(Convert.ToString(config.dbThreads)), "#")("db-write-buffer-size", "Size of the database write buffer in megabytes (MB)", cxxopts.value<int>().default_value(Convert.ToString(config.dbWriteBufferSize)), "#");

		try
		{
		  var cli = options.parse(argc, argv);

		  if (cli.count("config-file") > 0)
		  {
			config.configFile = cli["config-file"].@as<string>();
		  }

		  if (cli.count("save-config") > 0)
		  {
			config.outputFile = cli["save-config"].@as<string>();
		  }

		  if (cli.count("genesis-block-reward-address") > 0)
		  {
			config.genesisAwardAddresses = cli["genesis-block-reward-address"].@as<List<string>>();
		  }

		  if (cli.count("help") > 0)
		  {
			config.help = cli["help"].@as<bool>();
		  }

		  if (cli.count("version") > 0)
		  {
			config.version = cli["version"].@as<bool>();
		  }

		  if (cli.count("os-version") > 0)
		  {
			config.osVersion = cli["os-version"].@as<bool>();
		  }

		  if (cli.count("print-genesis-tx") > 0)
		  {
			config.printGenesisTx = cli["print-genesis-tx"].@as<bool>();
		  }

		  if (cli.count("dump-config") > 0)
		  {
			config.dumpConfig = cli["dump-config"].@as<bool>();
		  }

		  if (cli.count("data-dir") > 0)
		  {
			config.dataDirectory = cli["data-dir"].@as<string>();
		  }

		  if (cli.count("load-checkpoints") > 0)
		  {
			config.checkPoints = cli["load-checkpoints"].@as<string>();
		  }

		  if (cli.count("log-file") > 0)
		  {
			config.logFile = cli["log-file"].@as<string>();
		  }

		  if (cli.count("log-level") > 0)
		  {
			config.logLevel = cli["log-level"].@as<int>();
		  }

		  if (cli.count("no-console") > 0)
		  {
			config.noConsole = cli["no-console"].@as<bool>();
		  }

		  if (cli.count("db-max-open-files") > 0)
		  {
			config.dbMaxOpenFiles = cli["db-max-open-files"].@as<int>();
		  }

		  if (cli.count("db-read-buffer-size") > 0)
		  {
			config.dbReadCacheSize = cli["db-read-buffer-size"].@as<int>();
		  }

		  if (cli.count("db-threads") > 0)
		  {
			config.dbThreads = cli["db-threads"].@as<int>();
		  }

		  if (cli.count("db-write-buffer-size") > 0)
		  {
			config.dbWriteBufferSize = cli["db-write-buffer-size"].@as<int>();
		  }

		  if (cli.count("local-ip") > 0)
		  {
			config.localIp = cli["local-ip"].@as<bool>();
		  }

		  if (cli.count("hide-my-port") > 0)
		  {
			config.hideMyPort = cli["hide-my-port"].@as<bool>();
		  }

		  if (cli.count("p2p-bind-ip") > 0)
		  {
			config.p2pInterface = cli["p2p-bind-ip"].@as<string>();
		  }

		  if (cli.count("p2p-bind-port") > 0)
		  {
			config.p2pPort = cli["p2p-bind-port"].@as<int>();
		  }

		  if (cli.count("p2p-external-port") > 0)
		  {
			config.p2pExternalPort = cli["p2p-external-port"].@as<int>();
		  }

		  if (cli.count("rpc-bind-ip") > 0)
		  {
			config.rpcInterface = cli["rpc-bind-ip"].@as<string>();
		  }

		  if (cli.count("rpc-bind-port") > 0)
		  {
			config.rpcPort = cli["rpc-bind-port"].@as<int>();
		  }

		  if (cli.count("add-exclusive-node") > 0)
		  {
			config.exclusiveNodes = cli["add-exclusive-node"].@as<List<string>>();
		  }

		  if (cli.count("add-peer") > 0)
		  {
			config.peers = cli["add-peer"].@as<List<string>>();
		  }

		  if (cli.count("add-priority-node") > 0)
		  {
			config.priorityNodes = cli["add-priority-node"].@as<List<string>>();
		  }

		  if (cli.count("seed-node") > 0)
		  {
			config.seedNodes = cli["seed-node"].@as<List<string>>();
		  }

		  if (cli.count("enable-blockexplorer") > 0)
		  {
			config.enableBlockExplorer = cli["enable-blockexplorer"].@as<bool>();
		  }

		  if (cli.count("enable-cors") > 0)
		  {
			config.enableCors = cli["enable-cors"].@as<List<string>>();
		  }

		  if (cli.count("fee-address") > 0)
		  {
			config.feeAddress = cli["fee-address"].@as<string>();
		  }

		  if (cli.count("fee-amount") > 0)
		  {
			config.feeAmount = cli["fee-amount"].@as<int>();
		  }

		  if (config.help) // Do we want to display the help message?
		  {
			Console.Write(options.help({}));
			Console.Write("\n");
			Environment.Exit(0);
		  }
		  else if (config.version) // Do we want to display the software version?
		  {
			Console.Write(CryptoNote.getProjectCLIHeader());
			Console.Write("\n");
			Environment.Exit(0);
		  }
		  else if (config.osVersion) // Do we want to display the OS version information?
		  {
			Console.Write(CryptoNote.getProjectCLIHeader());
			Console.Write("OS: ");
			Console.Write(Tools.get_os_version_string());
			Console.Write("\n");
			Environment.Exit(0);
		  }
		}
		catch (cxxopts.OptionException e)
		{
		  Console.Write("Error: Unable to parse command line argument options: ");
		  Console.Write(e.what());
		  Console.Write("\n");
		  Console.Write("\n");
		  Console.Write(options.help({}));
		  Console.Write("\n");
		  Environment.Exit(1);
		}
	  }

	  public static void handleSettings(string configFile, DaemonConfiguration config)
	  {
		std::ifstream data = new std::ifstream(configFile);

		if (!data.good())
		{
		  throw new System.Exception("The --config-file you specified does not exist, please check the filename and try again.");
		}

		json j = new json();
		data >> j;

		if (j.find("data-dir") != j.end())
		{
		  config.dataDirectory = j["data-dir"].get<string>();
		}

		if (j.find("load-checkpoints") != j.end())
		{
		  config.checkPoints = j["load-checkpoints"].get<string>();
		}

		if (j.find("log-file") != j.end())
		{
		  config.logFile = j["log-file"].get<string>();
		}

		if (j.find("log-level") != j.end())
		{
		  config.logLevel = j["log-level"].get<int>();
		}

		if (j.find("no-console") != j.end())
		{
		  config.noConsole = j["no-console"].get<bool>();
		}

		if (j.find("db-max-open-files") != j.end())
		{
		  config.dbMaxOpenFiles = j["db-max-open-files"].get<int>();
		}

		if (j.find("db-read-buffer-size") != j.end())
		{
		  config.dbReadCacheSize = j["db-read-buffer-size"].get<int>();
		}

		if (j.find("db-threads") != j.end())
		{
		  config.dbThreads = j["db-threads"].get<int>();
		}

		if (j.find("db-write-buffer-size") != j.end())
		{
		  config.dbWriteBufferSize = j["db-write-buffer-size"].get<int>();
		}

		if (j.find("allow-local-ip") != j.end())
		{
		  config.localIp = j["allow-local-ip"].get<bool>();
		}

		if (j.find("hide-my-port") != j.end())
		{
		  config.hideMyPort = j["hide-my-port"].get<bool>();
		}

		if (j.find("p2p-bind-ip") != j.end())
		{
		  config.p2pInterface = j["p2p-bind-ip"].get<string>();
		}

		if (j.find("p2p-bind-port") != j.end())
		{
		  config.p2pPort = j["p2p-bind-port"].get<int>();
		}

		if (j.find("p2p-external-port") != j.end())
		{
		  config.p2pExternalPort = j["p2p-external-port"].get<int>();
		}

		if (j.find("rpc-bind-ip") != j.end())
		{
		  config.rpcInterface = j["rpc-bind-ip"].get<string>();
		}

		if (j.find("rpc-bind-port") != j.end())
		{
		  config.rpcPort = j["rpc-bind-port"].get<int>();
		}

		if (j.find("add-exclusive-node") != j.end())
		{
		  config.exclusiveNodes = j["add-exclusive-node"].get<List<string>>();
		}

		if (j.find("add-peer") != j.end())
		{
		  config.peers = j["add-peer"].get<List<string>>();
		}

		if (j.find("add-priority-node") != j.end())
		{
		  config.priorityNodes = j["add-priority-node"].get<List<string>>();
		}

		if (j.find("seed-node") != j.end())
		{
		  config.seedNodes = j["seed-node"].get<List<string>>();
		}

		if (j.find("enable-blockexplorer") != j.end())
		{
		  config.enableBlockExplorer = j["enable-blockexplorer"].get<bool>();
		}

		if (j.find("enable-cors") != j.end())
		{
		  config.enableCors = j["enable-cors"].get<List<string>>();
		}

		if (j.find("fee-address") != j.end())
		{
		  config.feeAddress = j["fee-address"].get<string>();
		}

		if (j.find("fee-amount") != j.end())
		{
		  config.feeAmount = j["fee-amount"].get<int>();
		}
	  }

	  public static json asJSON(DaemonConfiguration config)
	  {
		json j = new json(
		{
			{"data-dir", config.dataDirectory},
			{"load-checkpoints", config.checkPoints},
			{"log-file", config.logFile},
			{"log-level", config.logLevel},
			{"no-console", config.noConsole},
			{"db-max-open-files", config.dbMaxOpenFiles},
			{"db-read-buffer-size", config.dbReadCacheSize},
			{"db-threads", config.dbThreads},
			{"db-write-buffer-size", config.dbWriteBufferSize},
			{"allow-local-ip", config.localIp},
			{"hide-my-port", config.hideMyPort},
			{"p2p-bind-ip", config.p2pInterface},
			{"p2p-bind-port", config.p2pPort},
			{"p2p-external-port", config.p2pExternalPort},
			{"rpc-bind-ip", config.rpcInterface},
			{"rpc-bind-port", config.rpcPort},
			{"add-exclusive-node", config.exclusiveNodes},
			{"add-peer", config.peers},
			{"add-priority-node", config.priorityNodes},
			{"seed-node", config.seedNodes},
			{"enable-blockexplorer", config.enableBlockExplorer},
			{"enable-cors", config.enableCors},
			{"fee-address", config.feeAddress},
			{"fee-amount", config.feeAmount}
		});

		return j;
	  }

	  public static string asString(DaemonConfiguration config)
	  {
		json j = asJSON(config);
		return j.dump(2);
	  }

	  public static void asFile(DaemonConfiguration config, string filename)
	  {
		json j = asJSON(config);
		std::ofstream data = new std::ofstream(filename);
		data << std::setw(2) << j << std::endl;
	  }

	public static void print_genesis_tx_hex(List<string> rewardAddresses, bool blockExplorerMode, LoggerManager logManager)
	{
	  List<CryptoNote.AccountPublicAddress> rewardTargets = new List<CryptoNote.AccountPublicAddress>();

	  CryptoNote.CurrencyBuilder currencyBuilder = new CryptoNote.CurrencyBuilder(logManager);
	  currencyBuilder.isBlockexplorer(blockExplorerMode);

	  CryptoNote.Currency currency = currencyBuilder.currency();

	  foreach (var rewardAddress in rewardAddresses)
	  {
		CryptoNote.AccountPublicAddress address = new CryptoNote.AccountPublicAddress();
		if (!currency.parseAccountAddressString(rewardAddress, address))
		{
		  Console.Write("Failed to parse genesis reward address: ");
		  Console.Write(rewardAddress);
		  Console.Write("\n");
		  return;
		}
		rewardTargets.emplace_back(std::move(address));
	  }

	  CryptoNote.Transaction transaction = new CryptoNote.Transaction();

	  if (rewardTargets.Count == 0)
	  {
		if (CryptoNote.parameters.GENESIS_BLOCK_REWARD > 0)
		{
		  Console.Write("Error: Genesis Block Reward Addresses are not defined");
		  Console.Write("\n");
		  return;
		}
		transaction = new CryptoNote.CurrencyBuilder(logManager).generateGenesisTransaction();
	  }
	  else
	  {
		transaction = new CryptoNote.CurrencyBuilder(logManager).generateGenesisTransaction();
	  }

	  string transactionHex = Common.toHex(CryptoNote.GlobalMembers.toBinaryArray(transaction));
	  Console.Write(getProjectCLIHeader());
	  Console.Write("\n");
	  Console.Write("\n");
	  Console.Write("Replace the current GENESIS_COINBASE_TX_HEX line in src/config/CryptoNoteConfig.h with this one:");
	  Console.Write("\n");
	  Console.Write("const char GENESIS_COINBASE_TX_HEX[] = \"");
	  Console.Write(transactionHex);
	  Console.Write("\";");
	  Console.Write("\n");

	  return;
	}

	public static JsonValue buildLoggerConfiguration(Level level, string logfile)
	{
	  JsonValue loggerConfiguration = new JsonValue(JsonValue.OBJECT);
	  loggerConfiguration.insert("globalLevel", (long)level);

	  JsonValue cfgLoggers = loggerConfiguration.insert("loggers", JsonValue.ARRAY);

	  JsonValue fileLogger = cfgLoggers.pushBack(JsonValue.OBJECT);
	  fileLogger.insert("type", "file");
	  fileLogger.insert("filename", logfile);
	  fileLogger.insert("level", (long)TRACE);

	  JsonValue consoleLogger = cfgLoggers.pushBack(JsonValue.OBJECT);
	  consoleLogger.insert("type", "console");
	  consoleLogger.insert("level", (long)TRACE);
	  consoleLogger.insert("pattern", "%D %T %L ");

	  return loggerConfiguration;
	}

	/* Wait for input so users can read errors before the window closes if they
	   launch from a GUI rather than a terminal */
	public static void pause_for_input(int argc)
	{
	  /* if they passed arguments they're probably in a terminal so the errors will
	     stay visible */
	  if (argc == 1)
	  {
		#if WIN32
		if (_isatty(_fileno(stdout)) && _isatty(_fileno(stdin)))
		{
		#else
		if (isatty(fileno(stdout)) && isatty(fileno(stdin)))
		{
		#endif
		  Console.Write("Press any key to close the program: ");
		  Console.Read();
		}
	  }
	}

	static int Main(int argc, string[] args)
	{
	  DaemonConfiguration config = initConfiguration(args[0]);

	#if WIN32
	  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
	#endif

	  LoggerManager logManager = new LoggerManager();
	  LoggerRef logger = new LoggerRef(logManager, "daemon");

	  // Initial loading of CLI parameters
	  handleSettings(argc, args, config);

	  if (config.printGenesisTx) // Do we weant to generate the Genesis Tx?
	  {
		print_genesis_tx_hex(new List<string>(config.genesisAwardAddresses), false, logManager);
		Environment.Exit(0);
	  }

	  // If the user passed in the --config-file option, we need to handle that first
	  if (!string.IsNullOrEmpty(config.configFile))
	  {
		try
		{
		  handleSettings(config.configFile, config);
		}
		catch (System.Exception e)
		{
		  Console.Write("\n");
		  Console.Write("There was an error parsing the specified configuration file. Please check the file and try again");
		  Console.Write("\n");
		  Console.Write(e.Message);
		  Console.Write("\n");
		  Environment.Exit(1);
		}
	  }

	  // Load in the CLI specified parameters again to overwrite anything from the config file
	  handleSettings(argc, args, config);

	  if (config.dumpConfig)
	  {
		Console.Write(getProjectCLIHeader());
		Console.Write(asString(config));
		Console.Write("\n");
		Environment.Exit(0);
	  }
	  else if (!string.IsNullOrEmpty(config.outputFile))
	  {
		try
		{
		  asFile(config, config.outputFile);
		  Console.Write(getProjectCLIHeader());
		  Console.Write("Configuration saved to: ");
		  Console.Write(config.outputFile);
		  Console.Write("\n");
		  Environment.Exit(0);
		}
		catch (System.Exception e)
		{
		  Console.Write(getProjectCLIHeader());
		  Console.Write("Could not save configuration to: ");
		  Console.Write(config.outputFile);
		  Console.Write("\n");
		  Console.Write(e.Message);
		  Console.Write("\n");
		  Environment.Exit(1);
		}
	  }

	  try
	  {
		var modulePath = Common.NativePathToGeneric(args[0]);
		var cfgLogFile = Common.NativePathToGeneric(config.logFile);

		if (cfgLogFile.empty())
		{
		  cfgLogFile = Common.ReplaceExtenstion(modulePath, ".log");
		}
		else
		{
		  if (!Common.HasParentPath(cfgLogFile))
		  {
	  cfgLogFile = Common.CombinePath(Common.GetPathDirectory(modulePath), cfgLogFile);
		  }
		}

		Level cfgLogLevel = (Level)((int)Logging.Level.ERROR + config.logLevel);

		// configure logging
		logManager.configure(buildLoggerConfiguration(cfgLogLevel, cfgLogFile));

		logger.functorMethod(INFO, BRIGHT_GREEN) << getProjectCLIHeader() << std::endl;

		logger.functorMethod(INFO) << "Program Working Directory: " << args[0];

		//create objects and link them
		CryptoNote.CurrencyBuilder currencyBuilder = new CryptoNote.CurrencyBuilder(logManager);
		currencyBuilder.isBlockexplorer(config.enableBlockExplorer);

		try
		{
		  currencyBuilder.currency();
		}
		catch (System.Exception)
		{
		  Console.Write("GENESIS_COINBASE_TX_HEX constant has an incorrect value. Please launch: ");
		  Console.Write(CryptoNote.CRYPTONOTE_NAME);
		  Console.Write("d --print-genesis-tx");
		  Console.Write("\n");
		  return 1;
		}
		CryptoNote.Currency currency = currencyBuilder.currency();

		bool use_checkpoints = !string.IsNullOrEmpty(config.checkPoints);
		CryptoNote.Checkpoints checkpoints = new CryptoNote.Checkpoints(logManager);

		if (use_checkpoints)
		{
		  logger.functorMethod(INFO) << "Loading Checkpoints for faster initial sync...";
		  if (config.checkPoints == "default")
		  {
			foreach (var cp in CryptoNote.CHECKPOINTS)
			{
			  checkpoints.addCheckpoint(cp.index, cp.blockId);
			}
			  logger.functorMethod(INFO) << "Loaded " << CryptoNote.CHECKPOINTS.size() << " default checkpoints";
		  }
		  else
		  {
			bool results = checkpoints.loadCheckpointsFromFile(config.checkPoints);
			if (!results)
			{
			  throw new System.Exception("Failed to load checkpoints");
			}
		  }
		}

		NetNodeConfig netNodeConfig = new NetNodeConfig();
		netNodeConfig.init(config.p2pInterface, config.p2pPort, config.p2pExternalPort, config.localIp, config.hideMyPort, config.dataDirectory, new List<string>(config.peers), new List<string>(config.exclusiveNodes), new List<string>(config.priorityNodes), new List<string>(config.seedNodes));

		DataBaseConfig dbConfig = new DataBaseConfig();
		dbConfig.init(config.dataDirectory, config.dbThreads, config.dbMaxOpenFiles, config.dbWriteBufferSize, config.dbReadCacheSize);

		if (dbConfig.isConfigFolderDefaulted())
		{
		  if (!Tools.create_directories_if_necessary(dbConfig.getDataDir()))
		  {
			throw new System.Exception("Can't create directory: " + dbConfig.getDataDir());
		  }
		}
		else
		{
		  if (!Tools.directoryExists(dbConfig.getDataDir()))
		  {
			throw new System.Exception("Directory does not exist: " + dbConfig.getDataDir());
		  }
		}

		RocksDBWrapper database = new RocksDBWrapper(logManager);
		database.init(dbConfig);
	Tools.ScopeExit dbShutdownOnExit(() =>
	{
		database.shutdown();
	});

		if (!DatabaseBlockchainCache.checkDBSchemeVersion(database, logManager))
		{
		  dbShutdownOnExit.cancel();
		  database.shutdown();

		  database.destroy(dbConfig);

		  database.init(dbConfig);
		  dbShutdownOnExit.resume();
		}

		System.Dispatcher dispatcher = new System.Dispatcher();
		logger.functorMethod(INFO) << "Initializing core...";
		CryptoNote.Core ccore = new CryptoNote.Core(currency, logManager, std::move(checkpoints), dispatcher, std::unique_ptr<IBlockchainCacheFactory>(new DatabaseBlockchainCacheFactory(database, logger.getLogger())), createSwappedMainChainStorage(config.dataDirectory, currency));

		ccore.load();
		logger.functorMethod(INFO) << "Core initialized OK";

		CryptoNote.CryptoNoteProtocolHandler cprotocol = new CryptoNote.CryptoNoteProtocolHandler(currency, dispatcher, ccore, null, logManager);
		CryptoNote.NodeServer p2psrv = new CryptoNote.NodeServer(dispatcher, cprotocol, logManager);
		CryptoNote.RpcServer rpcServer = new CryptoNote.RpcServer(dispatcher, logManager, ccore, p2psrv, cprotocol);

		cprotocol.set_p2p_endpoint(p2psrv);
		DaemonCommandsHandler dch = new DaemonCommandsHandler(ccore, p2psrv, logManager, rpcServer);
		logger.functorMethod(INFO) << "Initializing p2p server...";
		if (!p2psrv.init(netNodeConfig))
		{
		  logger.functorMethod(ERROR, BRIGHT_RED) << "Failed to initialize p2p server.";
		  return 1;
		}

		logger.functorMethod(INFO) << "P2p server initialized OK";

		if (!config.noConsole)
		{
		  dch.start_handling();
		}

		// Fire up the RPC Server
		logger.functorMethod(INFO) << "Starting core rpc server on address " << config.rpcInterface << ":" << config.rpcPort;
		rpcServer.setFeeAddress(config.feeAddress);
		rpcServer.setFeeAmount(config.feeAmount);
		rpcServer.enableCors(new List<string>(config.enableCors));
		rpcServer.start(config.rpcInterface, config.rpcPort);
		logger.functorMethod(INFO) << "Core rpc server started ok";

	Tools.SignalHandler.install(() =>
	{
	  dch.stop_handling();
	  p2psrv.sendStopSignal();
	});

		logger.functorMethod(INFO) << "Starting p2p net loop...";
		p2psrv.run();
		logger.functorMethod(INFO) << "p2p net loop stopped";

		dch.stop_handling();

		//stop components
		logger.functorMethod(INFO) << "Stopping core rpc server...";
		rpcServer.stop();

		//deinitialize components
		logger.functorMethod(INFO) << "Deinitializing p2p...";
		p2psrv.deinit();

		cprotocol.set_p2p_endpoint(null);
		ccore.save();

	  }
	  catch (System.Exception e)
	  {
		logger.functorMethod(ERROR, BRIGHT_RED) << "Exception: " << e.Message;
		return 1;
	  }

	  logger.functorMethod(INFO) << "Node stopped.";
	}

	internal static bool print_as_json<T>(T obj)
	{
	  Console.Write(CryptoNote.GlobalMembers.storeToJson(obj));
	  Console.Write("\n");
	  return true;
	}

	public static string printTransactionShortInfo(CryptoNote.CachedTransaction transaction)
	{
	  std::stringstream ss = new std::stringstream();

	  ss << "id: " << transaction.getTransactionHash() << std::endl;
	  ss << "fee: " << transaction.getTransactionFee() << std::endl;
	  ss << "blobSize: " << transaction.getTransactionBinaryArray().size() << std::endl;

	  return ss.str();
	}

	public static string printTransactionFullInfo(CryptoNote.CachedTransaction transaction)
	{
	  std::stringstream ss = new std::stringstream();
	  ss << printTransactionShortInfo(transaction);
	  ss << "JSON: \n" << CryptoNote.GlobalMembers.storeToJson(transaction.getTransaction()) << std::endl;

	  return ss.str();
	}



	public static void throwIfNotGood(std::istream stream)
	{
	  if (!stream.good())
	  {
		if (stream.eof())
		{
		  throw std::system_error(make_error_code(CryptoNote.error.HttpParserErrorCodes.END_OF_STREAM));
		}
		else
		{
		  throw std::system_error(make_error_code(CryptoNote.error.HttpParserErrorCodes.STREAM_NOT_GOOD));
		}
	  }
	}

	public static std::error_code make_error_code(CryptoNote.error.HttpParserErrorCodes e)
	{
	  return std::error_code((int)e, CryptoNote.error.HttpParserErrorCategory.INSTANCE);
	}

	public static string getStatusString(CryptoNote.HttpResponse.HTTP_STATUS status)
	{
	  switch (status)
	  {
	  case CryptoNote.HttpResponse.STATUS_200:
		return "200 OK";
	  case CryptoNote.HttpResponse.STATUS_404:
		return "404 Not Found";
	  case CryptoNote.HttpResponse.STATUS_500:
		return "500 Internal Server Error";
	  default:
		throw new System.Exception("Unknown HTTP status code is given");
	  }

	  return ""; //unaccessible
	}

	public static string getErrorBody(CryptoNote.HttpResponse.HTTP_STATUS status)
	{
	  switch (status)
	  {
	  case CryptoNote.HttpResponse.STATUS_404:
		return "Requested url is not found\n";
	  case CryptoNote.HttpResponse.STATUS_500:
		return "Internal server error is occurred\n";
	  default:
		throw new System.Exception("Error body for given status is not available");
	  }

	  return ""; //unaccessible
	}



	static int Main(int argc, string[] args)
	{
	  try
	  {
		CryptoNote.MiningConfig config = new CryptoNote.MiningConfig();
		config.parse(argc, args);

		Logging.LoggerGroup loggerGroup = new Logging.LoggerGroup();
		Logging.ConsoleLogger consoleLogger = new Logging.ConsoleLogger((Logging.Level)config.logLevel);
		loggerGroup.addLogger(consoleLogger);

		System.Dispatcher dispatcher = new System.Dispatcher();
		Miner.MinerManager app = new Miner.MinerManager(dispatcher, config, loggerGroup.functorMethod);

		app.start();
	  }
	  catch (System.Exception e)
	  {
		std::cerr << "Fatal: " << e.Message << std::endl;
		return 1;
	  }

	}


	public static std::error_code make_error_code(CryptoNote.error.NodeErrorCodes e)
	{
	  return std::error_code((int)e, CryptoNote.error.NodeErrorCategory.INSTANCE);
	}

	public static readonly ulong LEVIN_SIGNATURE = 0x0101010101012101L; //Bender's nightmare
	public static readonly uint LEVIN_PACKET_REQUEST = 0x00000001;
	public static readonly uint LEVIN_PACKET_RESPONSE = 0x00000002;
	public static readonly uint LEVIN_DEFAULT_MAX_PACKET_SIZE = 100000000; //100MB by default
	public static readonly uint LEVIN_PROTOCOL_VER_1 = 1;

	public static size_t get_random_index_with_fixed_probability(size_t max_index)
	{
	  //divide by zero workaround
	  if (max_index == null)
	  {
		return 0;
	  }
	  size_t x = Crypto.GlobalMembers.rand<size_t>() % (max_index + 1);
	  return (x * x * x) / (max_index * max_index); //parabola \/
	}


	public static void addPortMapping(Logging.LoggerRef logger, uint port)
	{
	  // Add UPnP port mapping
	  logger.functorMethod(INFO) << "Attempting to add IGD port mapping.";
	  int result;
	  UPNPDev deviceList = upnpDiscover(1000, null, null, 0, 0, result);
	  UPNPUrls urls = new UPNPUrls();
	  IGDdatas igdData = new IGDdatas();
	  string lanAddress = new string(new char[64]);
	  result = UPNP_GetValidIGD(deviceList, urls, igdData, lanAddress, sizeof (char));
	  freeUPNPDevlist(deviceList);
	  if (result != 0)
	  {
		if (result == 1)
		{
		  std::ostringstream portString = new std::ostringstream();
		  portString << port;
		  if (UPNP_AddPortMapping(urls.controlURL, igdData.first.servicetype, portString.str().c_str(), portString.str().c_str(), lanAddress, CryptoNote.CRYPTONOTE_NAME, "TCP", 0, "0") != 0)
		  {
			logger.functorMethod(ERROR) << "UPNP_AddPortMapping failed.";
		  }
		  else
		  {
			logger.functorMethod(INFO) << "Added IGD port mapping.";
		  }
		}
		else if (result == 2)
		{
		  logger.functorMethod(INFO) << "IGD was found but reported as not connected.";
		}
		else if (result == 3)
		{
		  logger.functorMethod(INFO) << "UPnP device was found but not recognized as IGD.";
		}
		else
		{
		  logger.functorMethod(ERROR) << "UPNP_GetValidIGD returned an unknown result code.";
		}

		FreeUPNPUrls(urls);
	  }
	  else
	  {
		logger.functorMethod(INFO) << "No IGD was found.";
	  }
	}

	public static bool parse_peer_from_string(NetworkAddress pe, string node_addr)
	{
	  return Common.parseIpAddressAndPort(pe.ip, pe.port, node_addr);
	}




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define KV_MEMBER(member) s(member, #member);

	public static void serialize(NetworkAddress na, CryptoNote.ISerializer s)
	{
		s.functorMethod(na.ip, "ip");
		s.functorMethod(na.port, "port");
	}

	public static void serialize(PeerlistEntry pe, CryptoNote.ISerializer s)
	{
		s.functorMethod(pe.adr, "adr");
		s.functorMethod(pe.id, "id");
		s.functorMethod(pe.last_seen, "last_seen");
	}



	//int swapcontext(ucontext UnnamedParameter, ucontext UnnamedParameter2);Tangible Method Implementation Not Found-swapcontext
private delegate void Delegate();

	//void makecontext(ucontext UnnamedParameter, voidDelegate void, intptr_t UnnamedParameter2);Tangible Method Implementation Not Found-makecontext
	//int getmcontext(mcontext UnnamedParameter);Tangible Method Implementation Not Found-getmcontext
	//void setmcontext(mcontext UnnamedParameter);Tangible Method Implementation Not Found-setmcontext
private delegate void funcDelegate();



	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	public static void makecontext(uctx ucp, funcDelegate func, intptr_t arg)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  int * sp;

//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
	  memset(ucp.uc_mcontext, 0, sizeof (ucp.uc_mcontext));
	  ucp.uc_mcontext.mc_rdi = (int)arg;
	  sp = (int)ucp.uc_stack.ss_sp + ucp.uc_stack.ss_size / sizeof(int);
	  sp -= 1;
	  sp = (object)((uintptr_t)sp - (uintptr_t)sp % 16); // 16-align for OS X
	  *--sp = 0; // return address
	  ucp.uc_mcontext.mc_rip = (int)func;
	  ucp.uc_mcontext.mc_rsp = (int)sp;
	}

	//C++ TO C# CONVERTER TODO TASK: The following line could not be converted:
	public static int swapcontext(uctx oucp, uctx ucp)
	{
	  if (getmcontext((oucp).uc_mcontext) == 0)
	  {
		setmcontext((ucp).uc_mcontext);
	  }
	  return 0;
	}

	public static void insertOrPush<T>(JsonValue js, Common.StringView name, T value)
	{
	  if (js.isArray())
	  {
		js.pushBack(new JsonValue(value));
	  }
	  else
	  {
		js.insert((string)name, new JsonValue(value));
	  }
	}


	public static T readPod<T>(Common.IInputStream s)
	{
	  T v = new default(T);
	  read(s, v, sizeof(T));
	  return v;
	}

//C++ TO C# CONVERTER TODO TASK: C++ template specifiers containing defaults cannot be converted to C#:
//ORIGINAL LINE: template <typename T, typename JsonT = T>
	public static JsonValue readPodJson<T, JsonT = T>(Common.IInputStream s)
	{
	  JsonValue jv = new JsonValue();
	  jv = (JsonT)(readPod<T>(s));
	  return jv.functorMethod;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static JsonValue readIntegerJson<T>(Common.IInputStream s)
	{
	  return readPodJson<T, long>(s);
	}

	public static ulong readVarint(Common.IInputStream s)
	{
	  ushort b = read<ushort>(s);
	  ushort size_mask = b & GlobalMembers.PORTABLE_RAW_SIZE_MARK_MASK;
	  ulong bytesLeft = 0;

	  switch (size_mask)
	  {
	  case GlobalMembers.PORTABLE_RAW_SIZE_MARK_BYTE:
		bytesLeft = 0;
		break;
	  case GlobalMembers.PORTABLE_RAW_SIZE_MARK_WORD:
		bytesLeft = 1;
		break;
	  case GlobalMembers.PORTABLE_RAW_SIZE_MARK_DWORD:
		bytesLeft = 3;
		break;
	  case GlobalMembers.PORTABLE_RAW_SIZE_MARK_INT64:
		bytesLeft = 7;
		break;
	  }

	  ulong value = b;

	  for (ulong i = 1; i <= bytesLeft; ++i)
	  {
		ulong n = read<ushort>(s);
		value |= n << (i * 8);
	  }

	  value >>= 2;
	  return value;
	}

	public static string readString(Common.IInputStream s)
	{
	  var size = readVarint(s);
	  string str;
	  str.resize(size);
	  if (size != null)
	  {
		read(s, str[0], size);
	  }
	  return str;
	}

	public static JsonValue readStringJson(Common.IInputStream s)
	{
	  return new JsonValue(readString(s));
	}

	public static void readName(Common.IInputStream s, string name)
	{
	  ushort len = readPod<ushort>(s);
	  if (len != null)
	  {
		name.resize(len);
		read(s, name[0], len);
	  }
	}

	public static JsonValue loadValue(Common.IInputStream stream, ushort type)
	{
	  switch (type)
	  {
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_INT64:
		  return readIntegerJson<long>(stream);
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_INT32:
		  return readIntegerJson<int>(stream);
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_INT16:
		  return readIntegerJson<short>(stream);
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_INT8:
		  return readIntegerJson<short>(stream);
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_UINT64:
		  return readIntegerJson<ulong>(stream);
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_UINT32:
		  return readIntegerJson<uint>(stream);
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_UINT16:
		  return readIntegerJson<ushort>(stream);
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_UINT8:
		  return readIntegerJson<ushort>(stream);
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_DOUBLE:
		  return readPodJson<double>(stream);
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_BOOL:
		  return new JsonValue(read<ushort>(stream) != 0);
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_STRING:
		  return readStringJson(stream);
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_OBJECT:
		  return loadSection(stream);
	  case GlobalMembers.BIN_KV_SERIALIZE_TYPE_ARRAY:
		  return loadArray(stream, new ushort(type));
	  default:
		throw new System.Exception("Unknown data type");
		break;
	  }
	}
	public static JsonValue loadSection(Common.IInputStream stream)
	{
	  JsonValue sec = new JsonValue(JsonValue.OBJECT);
	  ulong count = readVarint(stream);
	  string name;

	  while (count-- != null)
	  {
		readName(stream, name);
		sec.insert.functorMethod(name, loadEntry(stream));
	  }

	  return sec.functorMethod;
	}
	public static JsonValue loadEntry(Common.IInputStream stream)
	{
	  ushort type = readPod<ushort>(stream);

	  if (type & GlobalMembers.BIN_KV_SERIALIZE_FLAG_ARRAY != null)
	  {
		type &= ~GlobalMembers.BIN_KV_SERIALIZE_FLAG_ARRAY;
		return loadArray(stream, new ushort(type));
	  }

	  return loadValue(stream, new ushort(type));
	}
	public static JsonValue loadArray(Common.IInputStream stream, ushort itemType)
	{
	  JsonValue arr = new JsonValue(JsonValue.ARRAY);
	  ulong count = readVarint(stream);

	  while (count-- != null)
	  {
		arr.pushBack.functorMethod(loadValue(stream, new ushort(itemType)));
	  }

	  return arr.functorMethod;
	}


	public static JsonValue parseBinary(Common.IInputStream stream)
	{
	  var hdr = readPod<KVBinaryStorageBlockHeader>(stream);

	  if (hdr.m_signature_a != GlobalMembers.PORTABLE_STORAGE_SIGNATUREA || hdr.m_signature_b != GlobalMembers.PORTABLE_STORAGE_SIGNATUREB)
	  {
		throw new System.Exception("Invalid binary storage signature");
	  }

	  if (hdr.m_ver != GlobalMembers.PORTABLE_STORAGE_FORMAT_VER)
	  {
		throw new System.Exception("Unknown binary storage format version");
	  }

	  return loadSection(stream);
	}



	public static void writePod<T>(IOutputStream s, T value)
	{
	  write(s, value, sizeof(T));
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class T>
	public static ulong packVarint<T>(IOutputStream s, ushort type_or, ulong pv)
	{
	  T v = (T)(pv << 2);
	  v |= type_or;
	  write(s, v, sizeof(T));
	  return sizeof(T);
	}

	public static void writeElementName(IOutputStream s, Common.StringView name)
	{
	  if (name.getSize() > ushort.MaxValue)
	  {
		throw new System.Exception("Element name is too long");
	  }

	  ushort len = (ushort)name.getSize();
	  write(s, len, sizeof(ushort));
	  write(s, name.getData(), len);
	}

	public static ulong writeArraySize(IOutputStream s, ulong val)
	{
	  if (val <= 63)
	  {
		return packVarint<ushort>(s, new ushort(GlobalMembers.PORTABLE_RAW_SIZE_MARK_BYTE), new ulong(val));
	  }
	  else if (val <= 16383)
	  {
		return packVarint<ushort>(s, new ushort(GlobalMembers.PORTABLE_RAW_SIZE_MARK_WORD), new ulong(val));
	  }
	  else if (val <= 1073741823)
	  {
		return packVarint<uint>(s, new ushort(GlobalMembers.PORTABLE_RAW_SIZE_MARK_DWORD), new ulong(val));
	  }
	  else
	  {
		if (val > 4611686018427387903)
		{
		  throw new System.Exception("failed to pack varint - too big amount");
		}
		return packVarint<ulong>(s, new ushort(GlobalMembers.PORTABLE_RAW_SIZE_MARK_INT64), new ulong(val));
	  }
	}
	#if MSVC
	public static char suppressMSVCWarningLNK4221;
	#endif


	public static readonly int RETRY_TIMEOUT = 5;


	public static HashSet<Crypto.Hash> transactions_hash_seen = new HashSet<Crypto.Hash>();
	public static HashSet<Crypto.PublicKey> public_keys_seen = new HashSet<Crypto.PublicKey>();
	public static object seen_mutex = new object();

	public static void checkOutputKey(KeyDerivation derivation, PublicKey key, uint keyIndex, uint outputIndex, HashSet<PublicKey> spendKeys, Dictionary<PublicKey, List<uint>> outputs)
	{

	  PublicKey spendKey = new PublicKey();
	  underive_public_key(derivation, keyIndex, key, spendKey);

	  if (spendKeys.find(spendKey) != spendKeys.end())
	  {
		outputs[spendKey].Add((uint)outputIndex);
	  }

	}

	public static void findMyOutputs(ITransactionReader tx, SecretKey viewSecretKey, HashSet<PublicKey> spendKeys, Dictionary<PublicKey, List<uint>> outputs)
	{

	  var txPublicKey = tx.getTransactionPublicKey();
	  KeyDerivation derivation = new KeyDerivation();

	  if (!generate_key_derivation(txPublicKey, viewSecretKey, derivation))
	  {
		return;
	  }

	  uint keyIndex = 0;
	  uint outputCount = tx.getOutputCount();

	  for (uint idx = 0; idx < outputCount; ++idx)
	  {

		var outType = tx.getOutputType(size_t(idx));

		if (outType == CryptoNote.TransactionTypes.OutputType.Key)
		{

		  ulong amount;
		  KeyOutput @out = new KeyOutput();
		  tx.getOutput(idx, @out, ref amount);
		  checkOutputKey(derivation, @out.key, keyIndex, idx, spendKeys, outputs);
		  ++keyIndex;

		}
	  }
	}

	public static List<Crypto.Hash> getBlockHashes(CryptoNote.CompleteBlock[] blocks, uint count)
	{
	  List<Crypto.Hash> result = new List<Crypto.Hash>();
	  result.Capacity = count;

	  for (uint i = 0; i < count; ++i)
	  {
		result.Add(blocks[i].blockHash);
	  }

	  return result;
	}

	public static std::error_code make_error_code(CryptoNote.error.WalletErrorCodes e)
	{
	  return std::error_code((int)e, CryptoNote.error.WalletErrorCategory.INSTANCE);
	}

	public static void asyncRequestCompletion(System.Event requestFinished)
	{
	  requestFinished.set();
	}

	public static CryptoNote.WalletEvent makeTransactionUpdatedEvent(uint id)
	{
	  CryptoNote.WalletEvent event = new CryptoNote.WalletEvent();
	  event.type = CryptoNote.WalletEventType.TRANSACTION_UPDATED;
	  event.transactionUpdated.transactionIndex = id;

	  return event;
	}

	public static CryptoNote.WalletEvent makeTransactionCreatedEvent(uint id)
	{
	  CryptoNote.WalletEvent event = new CryptoNote.WalletEvent();
	  event.type = CryptoNote.WalletEventType.TRANSACTION_CREATED;
	  event.transactionCreated.transactionIndex = id;

	  return event;
	}

	public static CryptoNote.WalletEvent makeMoneyUnlockedEvent()
	{
	  CryptoNote.WalletEvent event = new CryptoNote.WalletEvent();
	  event.type = CryptoNote.WalletEventType.BALANCE_UNLOCKED;

	  return event;
	}

	public static CryptoNote.WalletEvent makeSyncProgressUpdatedEvent(uint current, uint total)
	{
	  CryptoNote.WalletEvent event = new CryptoNote.WalletEvent();
	  event.type = CryptoNote.WalletEventType.SYNC_PROGRESS_UPDATED;
	  event.synchronizationProgressUpdated.processedBlockCount = current;
	  event.synchronizationProgressUpdated.totalBlockCount = total;

	  return event;
	}

	public static CryptoNote.WalletEvent makeSyncCompletedEvent()
	{
	  CryptoNote.WalletEvent event = new CryptoNote.WalletEvent();
	  event.type = CryptoNote.WalletEventType.SYNC_COMPLETED;

	  return event;
	}

	public static uint getTransactionSize(ITransactionReader transaction)
	{
	  return transaction.getTransactionData().size();
	}

	public static ulong calculateDonationAmount(ulong freeAmount, ulong donationThreshold, ulong dustThreshold)
	{
	  List<ulong> decomposedAmounts = new List<ulong>();
	  decomposeAmount(freeAmount, dustThreshold, decomposedAmounts);

	  decomposedAmounts.Sort((a, b) => -1 * a.CompareTo(b));

	  ulong donationAmount = 0;
	  foreach (var amount in decomposedAmounts)
	  {
		if (amount > donationThreshold - donationAmount)
		{
		  continue;
		}

		donationAmount += amount;
	  }

	  Debug.Assert(donationAmount <= freeAmount);
	  return donationAmount;
	}

	public static void serialize(UnlockTransactionJobDtoV2 value, CryptoNote.ISerializer serializer)
	{
	  serializer.functorMethod(value.blockHeight, "blockHeight");
	  serializer.functorMethod(value.transactionHash, "transactionHash");
	  serializer.functorMethod(value.walletSpendPublicKey, "walletSpendPublicKey");
	}

	public static void serialize(WalletTransactionDtoV2 value, CryptoNote.ISerializer serializer)
	{

	  std::underlying_type<CryptoNote.WalletTransactionState>.type state = (std::underlying_type<CryptoNote.WalletTransactionState>.type)value.state;
	  serializer.functorMethod(state, "state");
	  value.state = (CryptoNote.WalletTransactionState)state;

	  serializer.functorMethod(value.timestamp, "timestamp");
	  CryptoNote.serializeBlockHeight(serializer.functorMethod, value.blockHeight, "blockHeight");
	  serializer.functorMethod(value.hash, "hash");
	  serializer.functorMethod(value.totalAmount, "totalAmount");
	  serializer.functorMethod(value.fee, "fee");
	  serializer.functorMethod(value.creationTime, "creationTime");
	  serializer.functorMethod(value.unlockTime, "unlockTime");
	  serializer.functorMethod(value.extra, "extra");
	  serializer.functorMethod(value.isBase, "isBase");
	}

	public static void serialize(WalletTransferDtoV2 value, CryptoNote.ISerializer serializer)
	{
	  serializer.functorMethod(value.address, "address");
	  serializer.functorMethod(value.amount, "amount");
	  serializer.functorMethod(value.type, "type");
	}


	public static PaymentGateService ppg;

	#if WIN32
	public static IntPtr serviceStatusHandle;

	public static string GetLastErrorMessage(uint errorMessageID)
	{
	  string messageBuffer = null;
	  uint size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, null, errorMessageID, 0, (string) messageBuffer, 0, null);

	  string message = new string(messageBuffer, size);

	  LocalFree(messageBuffer);

	  return message;
	}

//C++ TO C# CONVERTER NOTE: __stdcall is not available in C#:
//ORIGINAL LINE: void __stdcall serviceHandler(uint fdwControl)
	public static void serviceHandler(uint fdwControl)
	{
	  if (fdwControl == SERVICE_CONTROL_STOP)
	  {
		Logging.LoggerRef log = new Logging.LoggerRef(ppg.getLogger(), "serviceHandler");
		log(Logging.INFO, Logging.BRIGHT_YELLOW) << "Stop signal caught";

		SERVICE_STATUS serviceStatus = new SERVICE_STATUS(SERVICE_WIN32_OWN_PROCESS, SERVICE_STOP_PENDING, 0, NO_ERROR, 0, 0, 0);
		SetServiceStatus(serviceStatusHandle, serviceStatus);

		ppg.stop();
	  }
	}

//C++ TO C# CONVERTER NOTE: __stdcall is not available in C#:
//ORIGINAL LINE: void __stdcall serviceMain(uint dwArgc, char **lpszArgv)
	public static void serviceMain(uint dwArgc, string[] lpszArgv)
	{
	  Logging.LoggerRef logRef = new Logging.LoggerRef(ppg.getLogger(), "WindowsService");

	  serviceStatusHandle = RegisterServiceCtrlHandler("PaymentGate", serviceHandler);
	  if (serviceStatusHandle == null)
	  {
		logRef(Logging.FATAL, Logging.BRIGHT_RED) << "Couldn't make RegisterServiceCtrlHandler call: " << GetLastErrorMessage(GetLastError());
		return;
	  }

	  SERVICE_STATUS serviceStatus = new SERVICE_STATUS(SERVICE_WIN32_OWN_PROCESS, SERVICE_START_PENDING, 0, NO_ERROR, 0, 1, 3000);
	  if (SetServiceStatus(serviceStatusHandle, serviceStatus) != 1)
	  {
		logRef(Logging.FATAL, Logging.BRIGHT_RED) << "Couldn't make SetServiceStatus call: " << GetLastErrorMessage(GetLastError());
		return;
	  }

	  serviceStatus = new SERVICE_STATUS(SERVICE_WIN32_OWN_PROCESS, SERVICE_RUNNING, SERVICE_ACCEPT_STOP, NO_ERROR, 0, 0, 0);
	  if (SetServiceStatus(serviceStatusHandle, serviceStatus) != 1)
	  {
		logRef(Logging.FATAL, Logging.BRIGHT_RED) << "Couldn't make SetServiceStatus call: " << GetLastErrorMessage(GetLastError());
		return;
	  }

	  try
	  {
		ppg.run();
	  }
	  catch (System.Exception ex)
	  {
		logRef(Logging.FATAL, Logging.BRIGHT_RED) << "Error occurred: " << ex.Message;
	  }

	  serviceStatus = new SERVICE_STATUS(SERVICE_WIN32_OWN_PROCESS, SERVICE_STOPPED, 0, NO_ERROR, 0, 0, 0);
	  SetServiceStatus(serviceStatusHandle, serviceStatus);
	}
	#else
	public static int daemonize()
	{
	  pid_t pid = new pid_t();
	  pid = fork();

	  if (pid < 0)
	  {
		return pid;
	  }

	  if (pid > 0)
	  {
		return pid;
	  }

	  if (setsid() < 0)
	  {
		return -1;
	  }

	  signal(SIGCHLD, SIG_IGN);
	  signal(SIGHUP, SIG_IGN);
	  signal(SIGPIPE, SIG_IGN);

	  pid = fork();

	  if (pid < 0)
	  {
		return pid;
	  }

	  if (pid > 0)
	  {
		return pid;
	  }

	  umask(0);

	  return 0;
	}
	#endif

	public static int runDaemon()
	{
	#if WIN32

	  SERVICE_TABLE_ENTRY[] serviceTable =
	  {
		  {"Payment Gate", serviceMain},
		  {null, null}
	  };

	  Logging.LoggerRef logRef = new Logging.LoggerRef(ppg.getLogger(), "RunService");

	  if (StartServiceCtrlDispatcher(serviceTable) != 1)
	  {
		logRef(Logging.FATAL, Logging.BRIGHT_RED) << "Couldn't start service: " << GetLastErrorMessage(GetLastError());
		return 1;
	  }

	  logRef(Logging.INFO) << "Service stopped";
	  return 0;

	#else

	  int daemonResult = daemonize();
	  if (daemonResult > 0)
	  {
		//parent
		return 0;
	  }
	  else if (daemonResult < 0)
	  {
		//error occurred
		return 1;
	  }

	  ppg.run();

	  return 0;

	#endif
	}

	public static int registerService()
	{
	#if WIN32
	  Logging.LoggerRef logRef = new Logging.LoggerRef(ppg.getLogger(), "ServiceRegistrator");

	  string pathBuff = new string(new char[MAX_PATH]);
	  string modulePath;
	  IntPtr scManager = null;
	  IntPtr scService = null;
	  int ret = 0;

	  for (;;)
	  {
		if (GetModuleFileName(null, pathBuff, ARRAYSIZE(pathBuff)) == 0)
		{
		  logRef(Logging.FATAL, Logging.BRIGHT_RED) << "GetModuleFileName failed with error: " << GetLastErrorMessage(GetLastError());
		  ret = 1;
		  break;
		}

		modulePath.assign(pathBuff);

		string moduleDir = modulePath.Substring(0, modulePath.LastIndexOfAny((Convert.ToString('\\')).ToCharArray()) + 1);
		modulePath += " --config=" + moduleDir + "payment_service.conf -d";

		scManager = OpenSCManager(null, null, SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE);
		if (scManager == null)
		{
		  logRef(Logging.FATAL, Logging.BRIGHT_RED) << "OpenSCManager failed with error: " << GetLastErrorMessage(GetLastError());
		  ret = 1;
		  break;
		}

		scService = CreateService(scManager, DefineConstants.SERVICE_NAME, null, SERVICE_QUERY_STATUS, SERVICE_WIN32_OWN_PROCESS, SERVICE_AUTO_START, SERVICE_ERROR_NORMAL, modulePath, null, null, null, null, null);

		if (scService == null)
		{
		  logRef(Logging.FATAL, Logging.BRIGHT_RED) << "CreateService failed with error: " << GetLastErrorMessage(GetLastError());
		  ret = 1;
		  break;
		}

		logRef(Logging.INFO) << "Service is registered successfully";
		logRef(Logging.INFO) << "Please make sure " << moduleDir + "payment_service.conf" << " exists";
		break;
	  }

	  if (scManager != null)
	  {
		CloseServiceHandle(scManager);
	  }

	  if (scService != null)
	  {
		CloseServiceHandle(scService);
	  }

	  return ret;
	#else
	  return 0;
	#endif
	}

	public static int unregisterService()
	{
	#if WIN32
	  Logging.LoggerRef logRef = new Logging.LoggerRef(ppg.getLogger(), "ServiceDeregistrator");

	  IntPtr scManager = null;
	  IntPtr scService = null;
	  SERVICE_STATUS ssSvcStatus = new SERVICE_STATUS();
	  int ret = 0;

	  for (;;)
	  {
		scManager = OpenSCManager(null, null, SC_MANAGER_CONNECT);
		if (scManager == null)
		{
		  logRef(Logging.FATAL, Logging.BRIGHT_RED) << "OpenSCManager failed with error: " << GetLastErrorMessage(GetLastError());
		  ret = 1;
		  break;
		}

		scService = OpenService(scManager, DefineConstants.SERVICE_NAME, SERVICE_STOP | SERVICE_QUERY_STATUS | DELETE);
		if (scService == null)
		{
		  logRef(Logging.FATAL, Logging.BRIGHT_RED) << "OpenService failed with error: " << GetLastErrorMessage(GetLastError());
		  ret = 1;
		  break;
		}

		if (ControlService(scService, SERVICE_CONTROL_STOP, ssSvcStatus))
		{
		  logRef(Logging.INFO) << "Stopping " << DefineConstants.SERVICE_NAME;
		  Sleep(1000);

		  while (QueryServiceStatus(scService, ssSvcStatus))
		  {
			if (ssSvcStatus.dwCurrentState == SERVICE_STOP_PENDING)
			{
			  logRef(Logging.INFO) << "Waiting...";
			  Sleep(1000);
			}
			else
			{
			  break;
			}
		  }

		  Console.Write("\n");
		  if (ssSvcStatus.dwCurrentState == SERVICE_STOPPED)
		  {
			logRef(Logging.INFO) << DefineConstants.SERVICE_NAME << " is stopped";
		  }
		  else
		  {
			logRef(Logging.FATAL, Logging.BRIGHT_RED) << DefineConstants.SERVICE_NAME << " failed to stop" << std::endl;
		  }
		}

		if (!DeleteService(scService))
		{
		  logRef(Logging.FATAL, Logging.BRIGHT_RED) << "DeleteService failed with error: " << GetLastErrorMessage(GetLastError());
		  ret = 1;
		  break;
		}

		logRef(Logging.INFO) << DefineConstants.SERVICE_NAME << " is removed";
		break;
	  }

	  if (scManager != null)
	  {
		CloseServiceHandle(scManager);
	  }

	  if (scService != null)
	  {
		CloseServiceHandle(scService);
	  }

	  return ret;
	#else
	  return 0;
	#endif
	}

	static int Main(int argc, string[] args)
	{
	  PaymentGateService pg = new PaymentGateService();
	  ppg = pg;

	  try
	  {
		if (!pg.init(argc, args))
		{
		}

		Console.Write(CryptoNote.getProjectCLIHeader());

		auto config = pg.getConfig();

		if (config.serviceConfig.generateNewContainer)
		{
		  System.Dispatcher d = new System.Dispatcher();
		  generateNewWallet(pg.getCurrency(), pg.getWalletConfig(), pg.getLogger(), d);
		}

		if (config.serviceConfig.registerService)
		{
		  return registerService();
		}

		if (config.serviceConfig.unregisterService)
		{
		  return unregisterService();
		}

		if (config.serviceConfig.daemonize)
		{
		  if (runDaemon() != 0)
		  {
			throw new System.Exception("Failed to start daemon");
		  }
		}
		else
		{
		  pg.run();
		}
	  }
	  catch (System.Exception ex)
	  {
		std::cerr << "Fatal error: " << ex.Message << std::endl;
		return 1;
	  }

	}


	public static void changeDirectory(string path)
	{
	  if (chdir(path))
	  {
		throw new System.Exception("Couldn't change directory to \'" + path + "\': " + strerror(errno));
	  }
	}

	public static void stopSignalHandler(PaymentGateService pg)
	{
	  pg.stop();
	}


	public static std::error_code make_error_code(CryptoNote.error.WalletServiceErrorCode e)
	{
	  return std::error_code((int)e, CryptoNote.error.WalletServiceErrorCategory.INSTANCE);
	}




	public static string getAddressBookName(AddressBook addressBook)
	{
		while (true)
		{
			string friendlyName;

			Console.Write(InformationMsg("What friendly name do you want to "));
			Console.Write(InformationMsg("give this address book entry?: "));

			friendlyName = Console.ReadLine();
			trim(friendlyName);

			var it = std::find(addressBook.begin(), addressBook.end(), AddressBookEntry(friendlyName));

			if (it != addressBook.end())
			{
				Console.Write(WarningMsg("An address book entry with this "));
				Console.Write(WarningMsg("name already exists!"));
				Console.Write("\n");
				Console.Write("\n");

				continue;
			}

			return friendlyName;
		}
	}

	public static Maybe<string> getAddressBookPaymentID()
	{
		std::stringstream msg = new std::stringstream();

		msg << std::endl << "Does this address book entry have a payment ID associated with it?" << std::endl;

		return getPaymentID(msg.str());
	}

	public static void addToAddressBook()
	{
		Console.Write(InformationMsg("Note: You can type cancel at any time to " + "cancel adding someone to your address book"));
		Console.Write("\n");
		Console.Write("\n");

		var addressBook = getAddressBook();

		string friendlyName = getAddressBookName(new AddressBook(addressBook));

		if (friendlyName == "cancel")
		{
			Console.Write(WarningMsg("Cancelling addition to address book."));
			Console.Write("\n");
			return;
		}

		var maybeAddress = getAddress("\nWhat address does this user have? ");

		if (!maybeAddress.isJust)
		{
			Console.Write(WarningMsg("Cancelling addition to address book."));
			Console.Write("\n");
			return;
		}

		string address = maybeAddress.x.second;
		string paymentID = "";

		bool integratedAddress = maybeAddress.x.first == IntegratedAddress;

		if (!integratedAddress)
		{
			var maybePaymentID = getAddressBookPaymentID();

			if (!maybePaymentID.isJust)
			{
				Console.Write(WarningMsg("Cancelling addition to address book."));
				Console.Write("\n");

				return;
			}

			paymentID = maybePaymentID.x;
		}

		addressBook.emplace_back(friendlyName, address, paymentID, integratedAddress);

		if (saveAddressBook(new AddressBook(addressBook)))
		{
			Console.Write("\n");
			Console.Write(SuccessMsg("A new entry has been added to your address "));
			Console.Write(SuccessMsg("book!"));
			Console.Write("\n");
		}
	}

	public static Maybe< AddressBookEntry> getAddressBookEntry(AddressBook addressBook)
	{
		while (true)
		{
			string friendlyName;

			Console.Write(InformationMsg("Who do you want to send to from your "));
			Console.Write(InformationMsg("address book?: "));

			friendlyName = Console.ReadLine();
			trim(friendlyName);

			if (friendlyName == "cancel")
			{
				return Nothing<const AddressBookEntry>();
			}

			var it = std::find(addressBook.begin(), addressBook.end(), AddressBookEntry(friendlyName));

			if (it != addressBook.end())
			{
				return Just<const AddressBookEntry>(*it);
			}

			Console.Write("\n");
			Console.Write(WarningMsg("Could not find a user with the name of "));
			Console.Write(InformationMsg(friendlyName));
			Console.Write(WarningMsg(" in your address book!"));
			Console.Write("\n");
			Console.Write("\n");

			bool list = confirm("Would you like to list everyone in your " + "address book?");

			Console.Write("\n");

			if (list)
			{
				listAddressBook();
			}
		}
	}

	public static void sendFromAddressBook(WalletInfo walletInfo, uint height, string feeAddress, uint feeAmount)
	{
		var addressBook = getAddressBook();

		if (isAddressBookEmpty(new AddressBook(addressBook)))
		{
			return;
		}

		Console.Write(InformationMsg("Note: You can type cancel at any time to "));
		Console.Write(InformationMsg("cancel the transaction"));
		Console.Write("\n");
		Console.Write("\n");

		var maybeAddressBookEntry = getAddressBookEntry(new AddressBook(addressBook));

		if (!maybeAddressBookEntry.isJust)
		{
			Console.Write(WarningMsg("Cancelling transaction."));
			Console.Write("\n");
			return;
		}

		var addressBookEntry = maybeAddressBookEntry.x;

		var maybeAmount = getTransferAmount();

		if (!maybeAmount.isJust)
		{
			Console.Write(WarningMsg("Cancelling transction."));
			Console.Write("\n");
			return;
		}

		/* Originally entered address, so we can preserve the correct integrated
		   address for confirmation screen */
		var originalAddress = addressBookEntry.address;
		var address = originalAddress;
		var amount = maybeAmount.x;
		var fee = WalletConfig.defaultFee;
		var extra = getExtraFromPaymentID(addressBookEntry.paymentID);
		var mixin = CryptoNote.getDefaultMixinByHeight(height);
		var integrated = addressBookEntry.integratedAddress;

		if (integrated)
		{
			var addrPaymentIDPair = extractIntegratedAddress(address);
			address = addrPaymentIDPair.x.first;
			extra = getExtraFromPaymentID(addrPaymentIDPair.x.second);
		}

		doTransfer(address, amount, fee, extra, walletInfo, height, integrated, mixin, feeAddress, feeAmount, originalAddress);
	}

	public static bool isAddressBookEmpty(AddressBook addressBook)
	{
		if (addressBook.empty())
		{
			Console.Write(WarningMsg("Your address book is empty! Add some people "));
			Console.Write(WarningMsg("to it first."));
			Console.Write("\n");

			return true;
		}

		return false;
	}

	public static void deleteFromAddressBook()
	{
		var addressBook = getAddressBook();

		if (isAddressBookEmpty(new AddressBook(addressBook)))
		{
			return;
		}

		while (true)
		{
			Console.Write(InformationMsg("Note: You can type cancel at any time "));
			Console.Write(InformationMsg("to cancel the deletion"));
			Console.Write("\n");
			Console.Write("\n");

			string friendlyName;

			Console.Write(InformationMsg("What address book entry do you want to "));
			Console.Write(InformationMsg("delete?: "));

			friendlyName = Console.ReadLine();
			trim(friendlyName);

			if (friendlyName == "cancel")
			{
				Console.Write(WarningMsg("Cancelling deletion."));
				Console.Write("\n");
				return;
			}

			var it = std::find(addressBook.begin(), addressBook.end(), AddressBookEntry(friendlyName));

			if (it != addressBook.end())
			{
				addressBook.erase(it);

				if (saveAddressBook(new AddressBook(addressBook)))
				{
					Console.Write("\n");
					Console.Write(SuccessMsg("This entry has been deleted from "));
					Console.Write(SuccessMsg("your address book!"));
					Console.Write("\n");
				}

				return;
			}

			Console.Write("\n");
			Console.Write(WarningMsg("Could not find a user with the name of "));
			Console.Write(InformationMsg(friendlyName));
			Console.Write(WarningMsg(" in your address book!"));
			Console.Write("\n");
			Console.Write("\n");

			bool list = confirm("Would you like to list everyone in your " + "address book?");

			Console.Write("\n");

			if (list)
			{
				listAddressBook();
			}
		}
	}

	public static void listAddressBook()
	{
		var addressBook = getAddressBook();

		if (isAddressBookEmpty(new AddressBook(addressBook)))
		{
			return;
		}

		int index = 1;

		foreach (var i in addressBook)
		{
			Console.Write(InformationMsg("Address Book Entry #"));
			Console.Write(InformationMsg(Convert.ToString(index)));
			Console.Write(InformationMsg(":"));
			Console.Write("\n");
			Console.Write("\n");
			Console.Write(InformationMsg("Friendly Name: "));
			Console.Write("\n");
			Console.Write(SuccessMsg(i.friendlyName));
			Console.Write("\n");
			Console.Write("\n");
			Console.Write(InformationMsg("Address: "));
			Console.Write("\n");
			Console.Write(SuccessMsg(i.address));
			Console.Write("\n");
			Console.Write("\n");

			if (i.paymentID != "")
			{
				Console.Write(InformationMsg("Payment ID: "));
				Console.Write("\n");
				Console.Write(SuccessMsg(i.paymentID));
				Console.Write("\n");
				Console.Write("\n");
				Console.Write("\n");
			}
			else
			{
				Console.Write("\n");
			}

			index++;
		}
	}

	public static AddressBook getAddressBook()
	{
		AddressBook addressBook = new AddressBook();

		std::ifstream input = new std::ifstream(WalletConfig.addressBookFilename);

		/* If file exists, read current values */
		if (input != null)
		{
			std::stringstream buffer = new std::stringstream();
			buffer << input.rdbuf();
			input.close();

			CryptoNote.loadFromJson(addressBook, buffer.str());
		}

		return addressBook;
	}

	public static bool saveAddressBook(AddressBook addressBook)
	{
		string jsonString = CryptoNote.storeToJson(addressBook);

		std::ofstream output = new std::ofstream(WalletConfig.addressBookFilename);

		if (output != null)
		{
			output << jsonString;
		}
		else
		{
			Console.Write(WarningMsg("Failed to save address book to disk!"));
			Console.Write("\n");
			Console.Write(WarningMsg("Check you are able to write files to your "));
			Console.Write(WarningMsg("current directory."));
			Console.Write("\n");

			return false;
		}

		output.close();

		return true;
	}

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.

	////////////////////////////////////////
	////////////////////////////////////////


	public static bool handleCommand(string command, WalletInfo walletInfo, CryptoNote.INode node)
	{
		/* Basic commands */
		if (command == "advanced")
		{
			advanced(walletInfo);
		}
		else if (command == "address")
		{
			Console.Write(SuccessMsg(walletInfo.walletAddress));
			Console.Write("\n");
		}
		else if (command == "balance")
		{
			balance(node, walletInfo.wallet, walletInfo.viewWallet);
		}
		else if (command == "backup")
		{
			exportKeys(walletInfo);
		}
		else if (command == "exit")
		{
			return false;
		}
		else if (command == "help")
		{
			help(walletInfo);
		}
		else if (command == "transfer")
		{
			transfer(walletInfo, node.getLastKnownBlockHeight(), false, node.feeAddress(), node.feeAmount());
		}
		/* Advanced commands */
		else if (command == "ab_add")
		{
			addToAddressBook();
		}
		else if (command == "ab_delete")
		{
			deleteFromAddressBook();
		}
		else if (command == "ab_list")
		{
			listAddressBook();
		}
		else if (command == "ab_send")
		{
			sendFromAddressBook(walletInfo, node.getLastKnownBlockHeight(), node.feeAddress(), node.feeAmount());
		}
		else if (command == "change_password")
		{
			changePassword(walletInfo);
		}
		else if (command == "make_integrated_address")
		{
			createIntegratedAddress();
		}
		else if (command == "incoming_transfers")
		{
			listTransfers(true, false, walletInfo.wallet, node);
		}
		else if (command == "list_transfers")
		{
			listTransfers(true, true, walletInfo.wallet, node);
		}
		else if (command == "optimize")
		{
			fullOptimize(walletInfo.wallet, node.getLastKnownBlockHeight());
		}
		else if (command == "outgoing_transfers")
		{
			listTransfers(false, true, walletInfo.wallet, node);
		}
		else if (command == "reset")
		{
			reset(node, walletInfo);
		}
		else if (command == "save")
		{
			save(walletInfo.wallet);
		}
		else if (command == "save_csv")
		{
			saveCSV(walletInfo.wallet, node);
		}
		else if (command == "send_all")
		{
			transfer(walletInfo, node.getLastKnownBlockHeight(), true, node.feeAddress(), node.feeAmount());
		}
		else if (command == "status")
		{
			status(node, walletInfo.wallet);
		}
		/* This should never happen */
		else
		{
			throw new System.Exception("Command was defined but not hooked up!");
		}

		return true;
	}

	public static WalletInfo handleLaunchCommand(CryptoNote.WalletGreen wallet, string launchCommand, Config config)
	{
		if (launchCommand == "create")
		{
			return generateWallet(wallet);
		}
		else if (launchCommand == "open")
		{
			return openWallet(wallet, config);
		}
		else if (launchCommand == "seed_restore")
		{
			return mnemonicImportWallet(wallet);
		}
		else if (launchCommand == "key_restore")
		{
			return importWallet(wallet);
		}
		else if (launchCommand == "view_wallet")
		{
			return createViewWallet(wallet);
		}
		/* This should never happen */
		else
		{
			throw new System.Exception("Command was defined but not hooked up!");
		}
	}




	public static void changePassword(WalletInfo walletInfo)
	{
		/* Check the user knows the current password */
		confirmPassword(walletInfo.walletPass, "Confirm your current password: ");

		/* Get a new password for the wallet */
		string newPassword = getWalletPassword(true, "Enter your new password: ");

		/* Change the wallet password */
		walletInfo.wallet.changePassword(walletInfo.walletPass, newPassword);

		/* Change the stored wallet metadata */
		walletInfo.walletPass = newPassword;

		/* Make sure we save with the new password */
		walletInfo.wallet.save();

		Console.Write(SuccessMsg("Your password has been changed!"));
		Console.Write("\n");
	}

	public static void exportKeys(WalletInfo walletInfo)
	{
		confirmPassword(walletInfo.walletPass);
		printPrivateKeys(walletInfo.wallet, walletInfo.viewWallet);
	}

	public static void printPrivateKeys(CryptoNote.WalletGreen wallet, bool viewWallet)
	{
		Crypto.SecretKey privateViewKey = wallet.getViewKey().secretKey;

		if (viewWallet)
		{
			Console.Write(SuccessMsg("Private view key:"));
			Console.Write("\n");
			Console.Write(SuccessMsg(Common.podToHex(privateViewKey)));
			Console.Write("\n");
			return;
		}

		Crypto.SecretKey privateSpendKey = wallet.getAddressSpendKey(0).secretKey;

		Crypto.SecretKey derivedPrivateViewKey = new Crypto.SecretKey();

		CryptoNote.AccountBase.generateViewFromSpend(privateSpendKey, derivedPrivateViewKey);

		bool deterministicPrivateKeys = derivedPrivateViewKey == privateViewKey;

		Console.Write(SuccessMsg("Private spend key:"));
		Console.Write("\n");
		Console.Write(SuccessMsg(Common.podToHex(privateSpendKey)));
		Console.Write("\n");
		Console.Write("\n");
		Console.Write(SuccessMsg("Private view key:"));
		Console.Write("\n");
		Console.Write(SuccessMsg(Common.podToHex(privateViewKey)));
		Console.Write("\n");

		if (deterministicPrivateKeys)
		{
			Console.Write("\n");
			Console.Write(SuccessMsg("Mnemonic seed:"));
			Console.Write("\n");
			Console.Write(SuccessMsg(Mnemonics.PrivateKeyToMnemonic(privateSpendKey)));
			Console.Write("\n");
		}
	}

	public static void balance(CryptoNote.INode node, CryptoNote.WalletGreen wallet, bool viewWallet)
	{
		ulong unconfirmedBalance = wallet.getPendingBalance();
		ulong confirmedBalance = wallet.getActualBalance();

		uint localHeight = node.getLastLocalBlockHeight();
		uint remoteHeight = node.getLastKnownBlockHeight();
		uint walletHeight = wallet.getBlockCount();

		/* We can make a better approximation of the view wallet balance if we
		   ignore fusion transactions.
		   See https://github.com/turtlecoin/turtlecoin/issues/531 */
		if (viewWallet)
		{
			/* Not sure how to verify if a transaction is unlocked or not via
			   the WalletTransaction type, so this is technically not correct,
			   we might be including locked balance. */
			confirmedBalance = 0;

			uint numTransactions = wallet.getTransactionCount();

			for (uint i = 0; i < numTransactions; i++)
			{
				CryptoNote.WalletTransaction t = wallet.getTransaction(i);

				/* Fusion transactions are zero fee, skip them. Coinbase
				   transactions are also zero fee, include them. */
				if (t.fee != 0 || t.isBase)
				{
					confirmedBalance += t.totalAmount;
				}
			}
		}

		ulong totalBalance = unconfirmedBalance + confirmedBalance;

		Console.Write("Available balance: ");
		Console.Write(SuccessMsg(formatAmount(confirmedBalance)));
		Console.Write("\n");
		Console.Write("Locked (unconfirmed) balance: ");
		Console.Write(WarningMsg(formatAmount(unconfirmedBalance)));
		Console.Write("\n");
		Console.Write("Total balance: ");
		Console.Write(InformationMsg(formatAmount(totalBalance)));
		Console.Write("\n");

		if (viewWallet)
		{
			Console.Write("\n");
			Console.Write(InformationMsg("Please note that view only wallets " + "can only track incoming transactions,"));
			Console.Write("\n");
			Console.Write(InformationMsg("and so your wallet balance may appear " + "inflated."));
			Console.Write("\n");
		}

		if (localHeight < remoteHeight)
		{
			Console.Write("\n");
			Console.Write(InformationMsg("Your daemon is not fully synced with " + "the network!"));
			Console.Write("\n");
			Console.Write("Your balance may be incorrect until you are fully ");
			Console.Write("synced!");
			Console.Write("\n");
		}
		/* Small buffer because wallet height doesn't update instantly like node
		   height does */
		else if (walletHeight + 1000 < remoteHeight)
		{
			Console.Write("\n");
			Console.Write(InformationMsg("The blockchain is still being scanned for " + "your transactions."));
			Console.Write("\n");
			Console.Write("Balances might be incorrect whilst this is ongoing.");
			Console.Write("\n");
		}
	}

	public static void printHeights(uint localHeight, uint remoteHeight, uint walletHeight)
	{
		/* This is the height that the wallet has been scanned to. The blockchain
		   can be fully updated, but we have to walk the chain to find our
		   transactions, and this number indicates that progress. */
		Console.Write("Wallet blockchain height: ");

		/* Small buffer because wallet height doesn't update instantly like node
		   height does */
		if (walletHeight + 1000 > remoteHeight)
		{
			Console.Write(SuccessMsg(Convert.ToString(walletHeight)));
		}
		else
		{
			Console.Write(WarningMsg(Convert.ToString(walletHeight)));
		}

		Console.Write("\n");
		Console.Write("Local blockchain height: ");

		if (localHeight == remoteHeight)
		{
			Console.Write(SuccessMsg(Convert.ToString(localHeight)));
		}
		else
		{
			Console.Write(WarningMsg(Convert.ToString(localHeight)));
		}

		Console.Write("\n");
		Console.Write("Network blockchain height: ");
		Console.Write(SuccessMsg(Convert.ToString(remoteHeight)));
		Console.Write("\n");
	}

	public static void printSyncStatus(uint localHeight, uint remoteHeight, uint walletHeight)
	{
		string networkSyncPercentage = Common.get_sync_percentage(localHeight, remoteHeight) + "%";

		string walletSyncPercentage = Common.get_sync_percentage(walletHeight, remoteHeight) + "%";

		Console.Write("Network sync status: ");

		if (localHeight == remoteHeight)
		{
			Console.Write(SuccessMsg(networkSyncPercentage));
			Console.Write("\n");
		}
		else
		{
			Console.Write(WarningMsg(networkSyncPercentage));
			Console.Write("\n");
		}

		Console.Write("Wallet sync status: ");

		/* Small buffer because wallet height is not always completely accurate */
		if (walletHeight + 1000 > remoteHeight)
		{
			Console.Write(SuccessMsg(walletSyncPercentage));
			Console.Write("\n");
		}
		else
		{
			Console.Write(WarningMsg(walletSyncPercentage));
			Console.Write("\n");
		}
	}

	public static void printSyncSummary(uint localHeight, uint remoteHeight, uint walletHeight)
	{
		if (localHeight == 0 && remoteHeight == 0)
		{
			Console.Write(WarningMsg("Uh oh, it looks like you don't have "));
			Console.Write(WarningMsg(WalletConfig.daemonName));
			Console.Write(WarningMsg(" open!"));
			Console.Write("\n");
		}
		else if (walletHeight + 1000 < remoteHeight && localHeight == remoteHeight)
		{
			Console.Write(InformationMsg("You are synced with the network, but the " + "blockchain is still being scanned for " + "your transactions."));
			Console.Write("\n");
			Console.Write("Balances might be incorrect whilst this is ongoing.");
			Console.Write("\n");
		}
		else if (localHeight == remoteHeight)
		{
			Console.Write(SuccessMsg("Yay! You are synced!"));
			Console.Write("\n");
		}
		else
		{
			Console.Write(WarningMsg("Be patient, you are still syncing with the " + "network!"));
			Console.Write("\n");
		}
	}

	public static void printPeerCount(uint peerCount)
	{
		Console.Write("Peers: ");
		Console.Write(SuccessMsg(Convert.ToString(peerCount)));
		Console.Write("\n");
	}

	public static void printHashrate(ulong difficulty)
	{
		/* Offline node / not responding */
		if (difficulty == 0)
		{
			return;
		}

		/* Hashrate is difficulty divided by block target time */
		uint hashrate = (uint)Math.Round(difficulty / CryptoNote.parameters.DIFFICULTY_TARGET);

		Console.Write("Network hashrate: ");
		Console.Write(SuccessMsg(Common.get_mining_speed(hashrate)));
		Console.Write(" (Based on the last local block)");
		Console.Write("\n");
	}

	/* This makes sure to call functions on the node which only return cached
	   data. This ensures it returns promptly, and doesn't hang waiting for a
	   response when the node is having issues. */
	public static void status(CryptoNote.INode node, CryptoNote.WalletGreen wallet)
	{
		uint localHeight = node.getLastLocalBlockHeight();
		uint remoteHeight = node.getLastKnownBlockHeight();
		uint walletHeight = wallet.getBlockCount();

		/* Print the heights of local, remote, and wallet */
		printHeights(localHeight, remoteHeight, walletHeight);

		Console.Write("\n");

		/* Print the network and wallet sync status in percentage */
		printSyncStatus(localHeight, remoteHeight, walletHeight);

		Console.Write("\n");

		/* Print the network hashrate, based on the last local block */
		printHashrate(node.getLastLocalBlockHeaderInfo().difficulty);

		/* Print the amount of peers we have */
		printPeerCount(node.getPeerCount());

		Console.Write("\n");

		/* Print a summary of the sync status */
		printSyncSummary(localHeight, remoteHeight, walletHeight);
	}

	public static void reset(CryptoNote.INode node, WalletInfo walletInfo)
	{
		ulong scanHeight = getScanHeight();

		Console.Write("\n");
		Console.Write(InformationMsg("This process may take some time to complete."));
		Console.Write("\n");
		Console.Write(InformationMsg("You can't make any transactions during the "));
		Console.Write(InformationMsg("process."));
		Console.Write("\n");
		Console.Write("\n");

		if (!confirm("Are you sure?"))
		{
			return;
		}

		Console.Write(InformationMsg("Resetting wallet..."));
		Console.Write("\n");

		walletInfo.wallet.reset(scanHeight);

		syncWallet(node, walletInfo);
	}

	public static void saveCSV(CryptoNote.WalletGreen wallet, CryptoNote.INode node)
	{
		uint numTransactions = wallet.getTransactionCount();

		std::ofstream csv = new std::ofstream();
		csv.open(WalletConfig.csvFilename);

		if (csv == null)
		{
			Console.Write(WarningMsg("Couldn't open transactions.csv file for " + "saving!"));
			Console.Write("\n");
			Console.Write(WarningMsg("Ensure it is not open in any other " + "application."));
			Console.Write("\n");
			return;
		}

		Console.Write(InformationMsg("Saving CSV file..."));
		Console.Write("\n");

		/* Create CSV header */
		csv << "Timestamp,Block Height,Hash,Amount,In/Out" << std::endl;

		/* Loop through transactions */
		for (uint i = 0; i < numTransactions; i++)
		{
			CryptoNote.WalletTransaction t = wallet.getTransaction(i);

			/* Ignore fusion transactions */
			if (t.totalAmount == 0)
			{
				continue;
			}

			string amount = formatAmountBasic(Math.Abs(t.totalAmount));

			string direction = t.totalAmount > 0 ? "IN" : "OUT";

			csv << unixTimeToDate(t.timestamp) << "," << t.blockHeight << "," << Common.podToHex(t.hash) << "," << amount << "," << direction << std::endl;
		}

		csv.close();

		Console.Write(SuccessMsg("CSV successfully written to "));
		Console.Write(SuccessMsg(WalletConfig.csvFilename));
		Console.Write(SuccessMsg("!"));
		Console.Write("\n");
	}

	public static void printOutgoingTransfer(CryptoNote.WalletTransaction t, CryptoNote.INode node)
	{
		Console.Write(WarningMsg("Outgoing transfer:"));
		Console.Write("\n");
		Console.Write(WarningMsg("Hash: " + Common.podToHex(t.hash)));
		Console.Write("\n");

		if (t.timestamp != 0)
		{
			Console.Write(WarningMsg("Block height: "));
			Console.Write(WarningMsg(Convert.ToString(t.blockHeight)));
			Console.Write("\n");
			Console.Write(WarningMsg("Timestamp: "));
			Console.Write(WarningMsg(unixTimeToDate(t.timestamp)));
			Console.Write("\n");
		}

		Console.Write(WarningMsg("Spent: " + formatAmount(-t.totalAmount - t.fee)));
		Console.Write("\n");
		Console.Write(WarningMsg("Fee: " + formatAmount(t.fee)));
		Console.Write("\n");
		Console.Write(WarningMsg("Total Spent: " + formatAmount(-t.totalAmount)));
		Console.Write("\n");

		string paymentID = getPaymentIDFromExtra(t.extra);

		if (paymentID != "")
		{
			Console.Write(WarningMsg("Payment ID: " + paymentID));
			Console.Write("\n");
		}

		Console.Write("\n");
	}

	public static void printIncomingTransfer(CryptoNote.WalletTransaction t, CryptoNote.INode node)
	{
		Console.Write(SuccessMsg("Incoming transfer:"));
		Console.Write("\n");
		Console.Write(SuccessMsg("Hash: " + Common.podToHex(t.hash)));
		Console.Write("\n");

		if (t.timestamp != 0)
		{
			Console.Write(SuccessMsg("Block height: "));
			Console.Write(SuccessMsg(Convert.ToString(t.blockHeight)));
			Console.Write("\n");
			Console.Write(SuccessMsg("Timestamp: "));
			Console.Write(SuccessMsg(unixTimeToDate(t.timestamp)));
			Console.Write("\n");
		}


		Console.Write(SuccessMsg("Amount: " + formatAmount(t.totalAmount)));
		Console.Write("\n");

		string paymentID = getPaymentIDFromExtra(t.extra);

		if (paymentID != "")
		{
			Console.Write(SuccessMsg("Payment ID: " + paymentID));
			Console.Write("\n");
		}

		Console.Write("\n");
	}

	public static void listTransfers(bool incoming, bool outgoing, CryptoNote.WalletGreen wallet, CryptoNote.INode node)
	{
		uint numTransactions = wallet.getTransactionCount();

		long totalSpent = 0;
		long totalReceived = 0;

		for (uint i = 0; i < numTransactions; i++)
		{
			CryptoNote.WalletTransaction t = wallet.getTransaction(i);

			/* Is a fusion transaction (on a view only wallet). It appears to have
			   an incoming amount, because we can't detract the outputs (can't
			   decrypt them) */
			if (t.fee == 0 && !t.isBase)
			{
				continue;
			}

			if (t.totalAmount < 0 && outgoing)
			{
				printOutgoingTransfer(new CryptoNote.WalletTransaction(t), node);
				totalSpent += -t.totalAmount;
			}
			else if (t.totalAmount > 0 && incoming)
			{
				printIncomingTransfer(new CryptoNote.WalletTransaction(t), node);
				totalReceived += t.totalAmount;
			}
		}

		if (incoming)
		{
			Console.Write(SuccessMsg("Total received: " + formatAmount(totalReceived)));
			Console.Write("\n");
		}

		if (outgoing)
		{
			Console.Write(WarningMsg("Total spent: " + formatAmount(totalSpent)));
			Console.Write("\n");
		}
	}

	public static void save(CryptoNote.WalletGreen wallet)
	{
		Console.Write(InformationMsg("Saving."));
		Console.Write("\n");
		wallet.save();
		Console.Write(InformationMsg("Saved."));
		Console.Write("\n");
	}

	public static void createIntegratedAddress()
	{
		Console.Write(InformationMsg("Creating an integrated address from an "));
		Console.Write(InformationMsg("address and payment ID pair..."));
		Console.Write("\n");
		Console.Write("\n");

		string address;
		string paymentID;

		while (true)
		{
			Console.Write(InformationMsg("Address: "));

			address = Console.ReadLine();
			trim(address);

			Console.Write("\n");

			if (parseStandardAddress(address, true))
			{
				break;
			}
		}

		while (true)
		{
			Console.Write(InformationMsg("Payment ID: "));

			paymentID = Console.ReadLine();
			trim(paymentID);

			List<byte> extra = new List<byte>();

			Console.Write("\n");

			if (!CryptoNote.createTxExtraWithPaymentId(paymentID, extra))
			{
				Console.Write(WarningMsg("Failed to parse! Payment ID's are 64 " + "character hexadecimal strings."));
				Console.Write("\n");
				Console.Write("\n");

				continue;
			}

			break;
		}

		Console.Write(InformationMsg(createIntegratedAddress(address, paymentID)));
		Console.Write("\n");
	}

	public static void help(WalletInfo wallet)
	{
		if (wallet.viewWallet)
		{
			printCommands(basicViewWalletCommands());
		}
		else
		{
			printCommands(basicCommands());
		}
	}

	public static void advanced(WalletInfo wallet)
	{
		/* We pass the offset of the command to know what index to print for
		   command numbers */
		if (wallet.viewWallet)
		{
			printCommands(advancedViewWalletCommands(), basicViewWalletCommands().size());
		}
		else
		{
			printCommands(advancedCommands(), basicCommands().size());
		}
	}

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.

	////////////////////////////////
	////////////////////////////////


	public static List<Command> startupCommands()
	{
		return new List<Command>() {Command("open", "Open a wallet already on your system"), Command("create", "Create a new wallet"), Command("seed_restore", "Restore a wallet using a seed phrase of words"), Command("key_restore", "Restore a wallet using a view and spend key"), Command("view_wallet", "Import a view only wallet"), Command("exit", "Exit the program")};
	}

	public static List<Command> nodeDownCommands()
	{
		return new List<Command>() {Command("try_again", "Try to connect to the node again"), Command("continue", "Continue to the wallet interface regardless"), Command("exit", "Exit the program")};
	}

	public static List<AdvancedCommand> allCommands()
	{
		return new List<AdvancedCommand>() {AdvancedCommand("advanced", "List available advanced commands", true, false), AdvancedCommand("address", "Display your payment address", true, false), AdvancedCommand("balance", "Display how much " + WalletConfig.ticker + " you have", true, false), AdvancedCommand("backup", "Backup your private keys and/or seed", true, false), AdvancedCommand("exit", "Exit and save your wallet", true, false), AdvancedCommand("help", "List this help message", true, false), AdvancedCommand("transfer", "Send " + WalletConfig.ticker + " to someone", false, false), AdvancedCommand("ab_add", "Add a person to your address book", true, true), AdvancedCommand("ab_delete", "Delete a person in your address book", true, true), AdvancedCommand("ab_list", "List everyone in your address book", true, true), AdvancedCommand("ab_send", "Send " + WalletConfig.ticker + " to someone in your address book", false, true), AdvancedCommand("change_password", "Change your wallet password", true, true), AdvancedCommand("make_integrated_address", "Make a combined address + payment ID", true, true), AdvancedCommand("incoming_transfers", "Show incoming transfers", true, true), AdvancedCommand("list_transfers", "Show all transfers", false, true), AdvancedCommand("optimize", "Optimize your wallet to send large amounts", false, true), AdvancedCommand("outgoing_transfers", "Show outgoing transfers", false, true), AdvancedCommand("reset", "Recheck the chain from zero for transactions", true, true), AdvancedCommand("save", "Save your wallet state", true, true), AdvancedCommand("save_csv", "Save all wallet transactions to a CSV file", true, true), AdvancedCommand("send_all", "Send all your balance to someone", false, true), AdvancedCommand("status", "Display sync status and network hashrate", true, true)};
	}

	public static List<AdvancedCommand> basicCommands()
	{
	return filter(allCommands(), (AdvancedCommand c) =>
	{
		return !c.advanced;
	});
	}

	public static List<AdvancedCommand> advancedCommands()
	{
	return filter(allCommands(), (AdvancedCommand c) =>
	{
		return c.advanced;
	});
	}

	public static List<AdvancedCommand> basicViewWalletCommands()
	{
	return filter(basicCommands(), (AdvancedCommand c) =>
	{
		return c.viewWalletSupport;
	});
	}

	public static List<AdvancedCommand> advancedViewWalletCommands()
	{
	return filter(advancedCommands(), (AdvancedCommand c) =>
	{
		return c.viewWalletSupport;
	});
	}

	public static List<AdvancedCommand> allViewWalletCommands()
	{
	return filter(allCommands(), (AdvancedCommand c) =>
	{
		return c.viewWalletSupport;
	});
	}

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.

	/////////////////////////////
	/////////////////////////////




	public static uint makeFusionTransaction(CryptoNote.WalletGreen wallet, ulong threshold, ulong height)
	{
		ulong bestThreshold = threshold;
		uint optimizable = 0;

		/* Find the best threshold by starting at threshold and decreasing by
		   half till we get to the minimum amount, storing the threshold that
		   gave us the most amount of optimizable amounts */
		while (threshold > WalletConfig.minimumSend)
		{
			var fusionReadyCount = wallet.estimate(threshold).fusionReadyCount;

			if (fusionReadyCount > optimizable)
			{
				optimizable = fusionReadyCount;
				bestThreshold = threshold;
			}

			threshold /= 2;
		}

		/* Can't optimize */
		if (optimizable == 0)
		{
			return CryptoNote.WALLET_INVALID_TRANSACTION_ID;
		}

		try
		{
			return wallet.createFusionTransaction(bestThreshold, CryptoNote.getDefaultMixinByHeight(height), {}, wallet.getAddress(0));
		}
		catch (System.Exception e)
		{
			Console.Write(WarningMsg("Failed to send fusion transaction: "));
			Console.Write(WarningMsg(e.Message));
			Console.Write("\n");

			return CryptoNote.WALLET_INVALID_TRANSACTION_ID;
		}
	}

	public static void fullOptimize(CryptoNote.WalletGreen wallet, ulong height)
	{
		Console.Write("Attempting to optimize your wallet to allow you to ");
		Console.Write("send large amounts at once. ");
		Console.Write("\n");
		Console.Write(WarningMsg("This may take a very long time!"));
		Console.Write("\n");

		if (!confirm("Do you want to proceed?"))
		{
			Console.Write(WarningMsg("Cancelling optimization."));
			Console.Write("\n");
			return;
		}

		for (int i = 1;;i++)
		{
			Console.Write(InformationMsg("Running optimization round " + Convert.ToString(i) + "..."));
			Console.Write("\n");

			/* Optimize as many times as possible until optimization is no longer
			   possible. */
			if (!optimize(wallet, wallet.getActualBalance(), height))
			{
				break;
			}
		}

		Console.Write(SuccessMsg("Full optimization completed!"));
		Console.Write("\n");
	}

	public static bool optimize(CryptoNote.WalletGreen wallet, ulong threshold, ulong height)
	{
		List<Crypto.Hash> fusionTransactionHashes = new List<Crypto.Hash>();

		while (true)
		{
			/* Create as many fusion transactions until we can't send anymore,
			   either because balance is locked too much or we can no longer
			   optimize anymore transactions */
			uint tmpFusionTxID = makeFusionTransaction(wallet, threshold, height);

			if (tmpFusionTxID == CryptoNote.WALLET_INVALID_TRANSACTION_ID)
			{
				break;
			}
			else
			{
				CryptoNote.WalletTransaction w = wallet.getTransaction(tmpFusionTxID);

				fusionTransactionHashes.Add(w.hash);

				if (fusionTransactionHashes.Count == 1)
				{
					Console.Write(SuccessMsg("Created 1 fusion transaction!"));
					Console.Write("\n");
				}
				else
				{
					Console.Write(SuccessMsg("Created " + Convert.ToString(fusionTransactionHashes.Count) + " fusion transactions!"));
					Console.Write("\n");
				}
			}
		}

		if (fusionTransactionHashes.Count == 0)
		{
			return false;
		}

		/* Hurr durr grammar */
		if (fusionTransactionHashes.Count == 1)
		{
			Console.Write(SuccessMsg("1 fusion transaction has been sent, waiting " + "for balance to return and unlock"));
			Console.Write("\n");
			Console.Write("\n");
		}
		else
		{
			Console.Write(SuccessMsg(Convert.ToString(fusionTransactionHashes.Count) + " fusion transactions have been sent, waiting " + "for balance to return and unlock"));
			Console.Write("\n");
			Console.Write("\n");
		}

		wallet.updateInternalCache();

		/* Short sleep to ensure it's in the transaction pool when we poll it */
		std::this_thread.sleep_for(std::chrono.seconds(1));

		while (true)
		{
			List<CryptoNote.WalletTransactionWithTransfers> unconfirmedTransactions = wallet.getUnconfirmedTransactions();

			List<Crypto.Hash> unconfirmedTxHashes = new List<Crypto.Hash>();

			foreach (var t in unconfirmedTransactions)
			{
				unconfirmedTxHashes.Add(t.transaction.hash);
			}

			bool fusionCompleted = true;

			/* Is our fusion transaction still unconfirmed? We can't gain the
			   benefits of fusioning if the balance hasn't unlocked, so we can
			   send this new optimized balance */
			foreach (var tx in fusionTransactionHashes)
			{
				/* If the fusion transaction hash is present in the unconfirmed
				   transactions pool, we need to wait for it to complete. */
				if (unconfirmedTxHashes.Contains(tx))
				{
					fusionCompleted = false;
				}
				else
				{
					/* We can't find this transaction in the unconfirmed
					   transaction pool anymore, so it has been confirmed. Remove
					   it so we both have to check less transactions each time,
					   and we can easily update the transactions left to confirm
					   output message */
//C++ TO C# CONVERTER TODO TASK: There is no direct equivalent to the STL vector 'erase' method in C#:
					fusionTransactionHashes.erase(std::remove(fusionTransactionHashes.GetEnumerator(), fusionTransactionHashes.end(), tx), fusionTransactionHashes.end());
				}
			}

			if (!fusionCompleted)
			{
				Console.Write(WarningMsg("Balance is still locked, " + Convert.ToString(fusionTransactionHashes.Count)));

				/* More grammar... */
				if (fusionTransactionHashes.Count == 1)
				{
					Console.Write(WarningMsg(" fusion transaction still to be " + "confirmed."));
				}
				else
				{
					Console.Write(WarningMsg(" fusion transactions still to be " + "confirmed."));
				}

				Console.Write("\n");
				Console.Write(SuccessMsg("Will try again in 15 seconds..."));
				Console.Write("\n");

				std::this_thread.sleep_for(std::chrono.seconds(15));

				wallet.updateInternalCache();
			}
			else
			{
				Console.Write(SuccessMsg("All fusion transactions confirmed!"));
				Console.Write("\n");
				break;
			}
		}

		return true;
	}

	public static bool fusionTX(CryptoNote.WalletGreen wallet, CryptoNote.TransactionParameters p, ulong height)
	{
		Console.Write(WarningMsg("Your transaction is too large to be accepted by " + "the network!"));
		Console.Write("\n");
		Console.Write("We're attempting to optimize your ");
		Console.Write("wallet, which hopefully will make the transaction small ");
		Console.Write("enough to fit in a block.");
		Console.Write("\n");
		Console.Write("Please wait, this will take some time...");
		Console.Write("\n");
		Console.Write("\n");

		/* We could check if optimization succeeded, but it's not really needed
		   because we then check if the transaction is too large... it could have
		   potentially become valid because another payment came in. */
		optimize(wallet, p.destinations[0].amount + p.fee, height);

		var startTime = std::chrono.system_clock.now();

		while (wallet.getActualBalance() < p.destinations[0].amount + p.fee)
		{
			/* Break after a minute just in case something has gone wrong */
			if ((std::chrono.system_clock.now() - startTime) > std::chrono.minutes(5))
			{
				Console.Write(WarningMsg("Fusion transactions have " + "completed, however available " + "balance is less than transfer " + "amount specified."));
				Console.Write("\n");
				Console.Write(WarningMsg("Transfer aborted, please review " + "and start a new transfer."));
				Console.Write("\n");

				return false;
			}

			Console.Write(WarningMsg("Optimization completed, but balance " + "is not fully unlocked yet!"));
			Console.Write("\n");
			Console.Write(SuccessMsg("Will try again in 5 seconds..."));
			Console.Write("\n");

			std::this_thread.sleep_for(std::chrono.seconds(5));
		}

		return true;
	}





	/* Note: this is not portable, it only works with terminals that support ANSI
	   codes (e.g., not Windows) - however! due to the way linenoise-cpp works,
	   it will actually convert these codes for us to the windows equivalent. <3 */
	public static string yellowANSIMsg(string msg)
	{
		const string CYELLOW = "\x001B[1;33m";
		const string RESET = "\x001B[0m";
		return CYELLOW + msg + RESET;
	}

	public static string getPrompt(WalletInfo walletInfo)
	{
		const int promptLength = 20;
		const string extension = ".wallet";

		string walletName = walletInfo.walletFileName;

		/* Filename ends in .wallet, remove extension */
		if (std::equal(extension.rbegin(), extension.rend(), walletInfo.walletFileName.rbegin()))
		{
			uint extPos = walletInfo.walletFileName.find_last_of('.');

			walletName = walletInfo.walletFileName.substr(0, extPos);
		}

		string shortName = walletName.Substring(0, promptLength);

		return "[" + WalletConfig.ticker + " " + shortName + "]: ";
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static string getInputAndWorkInBackground<T>(List<T> availableCommands, string prompt, bool backgroundRefresh, WalletInfo walletInfo)
	{
		/* If we are in the main program, we need to check for transactions in
		   the background. Unfortunately, we have to do this on the main thread,
		   so the best way to do it, is to check whilst waiting for an input on
		   another thread. */
		if (backgroundRefresh)
		{
			var lastUpdated = std::chrono.system_clock.now();

		std::future<string> inputGetter = std::async(std::launch.async, () =>
		{
			return getInput(availableCommands, prompt);
		});


			while (true)
			{
				/* Check if the user has inputted something yet
				   (Wait for zero seconds to instantly return) */
				std::future_status status = inputGetter.wait_for(std::chrono.seconds(0));

				/* User has inputted, get what they inputted and return it */
				if (status == std::future_status.ready)
				{
					return inputGetter.get();
				}

				var currentTime = std::chrono.system_clock.now();

				/* Otherwise check if we need to update the wallet cache */
				if ((currentTime - lastUpdated) > std::chrono.seconds(5))
				{
					lastUpdated = currentTime;
					checkForNewTransactions(walletInfo);
				}

				/* Sleep for enough for it to not be noticeable when the user
				   enters something, but enough that we're not starving the CPU */
				std::this_thread.sleep_for(std::chrono.milliseconds(50));
			}
		}
		else
		{
			return getInput(availableCommands, prompt);
		}
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static string getInput<T>(List<T> availableCommands, string prompt)
	{
//C++ TO C# CONVERTER TODO TASK: Only lambda expressions having all locals passed by reference can be converted to C#:
//ORIGINAL LINE: linenoise::SetCompletionCallback([availableCommands](const char *input, ClassicVector<string> &completions)
	linenoise.GlobalMembers.SetCompletionCallback((string input, List<string> completions) =>
	{
		/* Convert to std::string */
		string c = input;

		foreach (var command in availableCommands)
		{
			/* Does command begin with input? */
			if (command.commandName.compare(0, c.Length, c) == 0)
			{
				completions.Add(command.commandName);
			}
		}
	});

		/* Linenoise is printing this out, so we can't write colours to the stream
		   like we normally would - have to include the escape characters directly
		   in the string. Obviously this is not platform dependent - but linenoise
		   doesn't work on windows, so it's fine. */
		string promptMsg = yellowANSIMsg(prompt);

		/* 256 max commands in the wallet command history */
		linenoise.GlobalMembers.SetHistoryMaxLen(256);

		/* The inputted command */
		string command;

		bool quit = linenoise.GlobalMembers.Readline(promptMsg, command);

		/* Remove any whitespace */
		trim(command);

		if (command != "")
		{
			linenoise.GlobalMembers.AddHistory(command);
		}

		/* Ctrl-C, Ctrl-D, etc */
		if (quit)
		{
			return "exit";
		}

		return command;
	}

	/* Template instantations that we are going to use - this allows us to have
	   the template implementation in the .cpp file. */
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//template string getInput(ClassicVector<Command> availableCommands, string prompt);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//template string getInput(ClassicVector<AdvancedCommand> availableCommands, string prompt);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//template string getInputAndWorkInBackground(ClassicVector<Command> availableCommands, string prompt, bool backgroundRefresh, WalletInfo walletInfo);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//template string getInputAndWorkInBackground(ClassicVector<AdvancedCommand> availableCommands, string prompt, bool backgroundRefresh, WalletInfo walletInfo);

	public static string parseCommand<T>(List<T> printableCommands, List<T> availableCommands, string prompt, bool backgroundRefresh, WalletInfo walletInfo)
	{
		while (true)
		{
			/* Get the input, and refresh the wallet in the background if desired
			   (This will be done on the main screen, but not the launch screen) */
			string selection = getInputAndWorkInBackground(availableCommands, prompt, backgroundRefresh, walletInfo);

			/* Convert to lower case */
			std::transform(selection.GetEnumerator(), selection.end(), selection.GetEnumerator(), global::tolower);

			/* \n == no-op */
			if (selection == "")
			{
				continue;
			}

			try
			{
				int selectionNum = Convert.ToInt32(selection);

				/* Input is in 1 based indexing, we need 0 based indexing */
				selectionNum--;

				int numCommands = (int)availableCommands.Count;

				/* Must be in the bounds of the vector */
				if (selectionNum < 0 || selectionNum >= numCommands)
				{
					Console.Write(WarningMsg("Bad input, expected a command name, "));
					Console.Write(WarningMsg("or number from "));
					Console.Write(InformationMsg("1"));
					Console.Write(WarningMsg(" to "));
					Console.Write(InformationMsg(Convert.ToString(numCommands)));
					Console.Write("\n");

					/* Print the available commands again if the input is bad */
					printCommands(printableCommands);

					continue;
				}

				selection = availableCommands[selectionNum].commandName;
			}
			/* Input ain't a number */
			catch (System.ArgumentException)
			{
				/* Iterator pointing to the command, if it exists */
//C++ TO C# CONVERTER TODO TASK: Lambda expressions cannot be assigned to 'var':
			var it = std::find_if(availableCommands.GetEnumerator(), availableCommands.end(), (Command c) =>
			{
									   return c.commandName == selection;
			});

				/* Command doesn't exist in availableCommands */
				if (it == availableCommands.end())
				{
					Console.Write("Unknown command: ");
					Console.Write(WarningMsg(selection));
					Console.Write("\n");

					/* Print the available commands again if the input is bad */
					printCommands(printableCommands);

					continue;
				}
			}

			/* All good */
			return selection;
		}
	}

	public static Tuple<bool, WalletInfo> selectionScreen(Config config, CryptoNote.WalletGreen wallet, CryptoNote.INode node)
	{
		while (true)
		{
			/* Get the users action */
			string launchCommand = getAction(config);

			/* User wants to exit */
			if (launchCommand == "exit")
			{
				return new Tuple<bool, WalletInfo>(true, null);
			}

			/* Handle the user input */
			WalletInfo walletInfo = handleLaunchCommand(wallet, launchCommand, config);

			/* Action failed, for example wallet file is corrupted. */
			if (walletInfo == null)
			{
				Console.Write(InformationMsg("Returning to selection screen..."));
				Console.Write("\n");

				continue;
			}

			/* Node is down, user wants to exit */
			if (!checkNodeStatus(node))
			{
				return new Tuple<bool, WalletInfo>(true, null);
			}

			/* If we're creating a wallet, don't print the lengthy sync process */
			if (launchCommand == "create")
			{
				std::stringstream str = new std::stringstream();

				str << std::endl << "Your wallet is syncing with the network in the background." << std::endl << "Until this is completed new transactions might not show " << "up." << std::endl << "Use the status command to check the progress." << std::endl;

				Console.Write(InformationMsg(str.str()));
			}
			else
			{
				/* Need another signal handler here, in case the user does
				   ctrl+c whilst syncing, to save the wallet. The walletInfo
				   ptr will be null in the parent scope, since we haven't returned
				   it yet. */
				bool alreadyShuttingDown = false;

			Tools.SignalHandler.install(() =>
			{
				if (shutdown(walletInfo, node, alreadyShuttingDown))
				{
					Environment.Exit(0);
				}
			});

				syncWallet(node, walletInfo);
			}

			/* Return the wallet info */
			return new Tuple<bool, WalletInfo>(false, walletInfo);
		}
	}

	public static bool checkNodeStatus(CryptoNote.INode node)
	{
		while (node.getLastKnownBlockHeight() == 0)
		{
			std::stringstream msg = new std::stringstream();

			msg << "It looks like " << WalletConfig.daemonName << " isn't open!" << std::endl << std::endl << "Ensure " << WalletConfig.daemonName << " is open and has finished initializing." << std::endl << "If it's still not working, try restarting " << WalletConfig.daemonName << "." << "The daemon sometimes gets stuck." << std::endl << "Alternatively, perhaps " << WalletConfig.daemonName << " can't communicate with any peers." << std::endl << std::endl << "The wallet can't function fully until it can communicate with " << "the network.";

			Console.Write(WarningMsg(msg.str()));
			Console.Write("\n");

			/* Print the commands */
			printCommands(nodeDownCommands());

			/* See what the user wants to do */
			string command = parseCommand(nodeDownCommands(), nodeDownCommands(), "What would you like to do?: ", false, null);

			/* If they want to try again, check the node height again */
			if (command == "try_again")
			{
				continue;
			}
			/* If they want to exit, exit */
			else if (command == "exit")
			{
				return false;
			}
			/* If they want to continue, proceed to the menu screen */
			else if (command == "continue")
			{
				return true;
			}
		}

		return true;
	}

	public static string getAction(Config config)
	{
		if (config.walletGiven || config.passGiven)
		{
			return "open";
		}

		printCommands(startupCommands());

		return parseCommand(startupCommands(), startupCommands(), "What would you like to do?: ", false, null);
	}

	public static void mainLoop(WalletInfo walletInfo, CryptoNote.INode node)
	{
		if (walletInfo.viewWallet)
		{
			printCommands(basicViewWalletCommands());
		}
		else
		{
			printCommands(basicCommands());
		}

		while (true)
		{
			string command;

			if (walletInfo.viewWallet)
			{
				command = parseCommand(basicViewWalletCommands(), allViewWalletCommands(), getPrompt(walletInfo), true, walletInfo);
			}
			else
			{
				command = parseCommand(basicCommands(), allCommands(), getPrompt(walletInfo), true, walletInfo);
			}

			/* User exited */
			if (!handleCommand(command, walletInfo, node))
			{
				return;
			}
		}
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static void printCommands<T>(List<T> commands, uint offset)
	{
		uint i = 1 + offset;

		Console.Write("\n");

		foreach (var command in commands)
		{
			Console.Write(InformationMsg(" "));
			Console.Write(InformationMsg(Convert.ToString(i)));
			Console.Write("\t");
			Console.Write(SuccessMsg(command.commandName, 25));
			Console.Write(command.description);
			Console.Write("\n");

			i++;
		}

		Console.Write("\n");
	}

	/* Template instantations that we are going to use - this allows us to have
	   the template implementation in the .cpp file. */
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//template string parseCommand(ClassicVector<Command> printableCommands, ClassicVector<Command> availableCommands, string prompt, bool backgroundRefresh, WalletInfo walletInfo);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//template string parseCommand(ClassicVector<AdvancedCommand> printableCommands, ClassicVector<AdvancedCommand> availableCommands, string prompt, bool backgroundRefresh, WalletInfo walletInfo);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//template void printCommands(ClassicVector<Command> commands, uint offset);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//template void printCommands(ClassicVector<AdvancedCommand> commands, uint offset);

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.

	///////////////////////////
	///////////////////////////





	public static WalletInfo createViewWallet(CryptoNote.WalletGreen wallet)
	{
		Console.Write(WarningMsg("View wallets are only for viewing incoming "));
		Console.Write(WarningMsg("transactions, and cannot make transfers."));
		Console.Write("\n");

		bool create = confirm("Is this OK?");

		Console.Write("\n");

		if (!create)
		{
			return null;
		}

		Crypto.SecretKey privateViewKey = getPrivateKey("Private View Key: ");

		string address;

		while (true)
		{
			Console.Write(InformationMsg("Enter your public "));
			Console.Write(InformationMsg(WalletConfig.ticker));
			Console.Write(InformationMsg(" address: "));

			address = Console.ReadLine();
			trim(address);

			if (parseStandardAddress(address, true))
			{
				break;
			}
		}

		string walletFileName = getNewWalletFileName();

		const string msg = "Give your new wallet a password: ";

		string walletPass = getWalletPassword(true, msg);

		ulong scanHeight = getScanHeight();

		wallet.createViewWallet(walletFileName, walletPass, address, privateViewKey, scanHeight, false);

		Console.Write("\n");
		Console.Write(InformationMsg("Your view wallet "));
		Console.Write(InformationMsg(address));
		Console.Write(InformationMsg(" has been successfully imported!"));
		Console.Write("\n");
		Console.Write("\n");

		viewWalletMsg();

		return new WalletInfo(walletFileName, walletPass, address, true, wallet);
	}

	public static WalletInfo importWallet(CryptoNote.WalletGreen wallet)
	{
		Crypto.SecretKey privateSpendKey = getPrivateKey("Enter your private spend key: ");

		Crypto.SecretKey privateViewKey = getPrivateKey("Enter your private view key: ");

		return importFromKeys(wallet, new Crypto.SecretKey(privateSpendKey), new Crypto.SecretKey(privateViewKey));
	}

	public static WalletInfo mnemonicImportWallet(CryptoNote.WalletGreen wallet)
	{
		while (true)
		{
			Console.Write(InformationMsg("Enter your mnemonic phrase (25 words): "));

			string mnemonicPhrase;

			mnemonicPhrase = Console.ReadLine();

			trim(mnemonicPhrase);

			var (error, privateSpendKey) = Mnemonics.MnemonicToPrivateKey(mnemonicPhrase);

			if (!error.empty())
			{
				Console.Write("\n");
				Console.Write(WarningMsg(error));
				Console.Write("\n");
				Console.Write("\n");
			}
			else
			{
				Crypto.SecretKey privateViewKey = new Crypto.SecretKey();

				CryptoNote.AccountBase.generateViewFromSpend(privateSpendKey, privateViewKey);

				return importFromKeys(wallet, privateSpendKey, new Crypto.SecretKey(privateViewKey));
			}
		}
	}

	public static WalletInfo importFromKeys(CryptoNote.WalletGreen wallet, Crypto.SecretKey privateSpendKey, Crypto.SecretKey privateViewKey)
	{
		string walletFileName = getNewWalletFileName();

		const string msg = "Give your new wallet a password: ";

		string walletPass = getWalletPassword(true, msg);

		ulong scanHeight = getScanHeight();

		connectingMsg();

		wallet.initializeWithViewKey(walletFileName, walletPass, privateViewKey, scanHeight, false);

		string walletAddress = wallet.createAddress(privateSpendKey, scanHeight, false);

		Console.Write("\n");
		Console.Write(InformationMsg("Your wallet "));
		Console.Write(InformationMsg(walletAddress));
		Console.Write(InformationMsg(" has been successfully imported!"));
		Console.Write("\n");
		Console.Write("\n");

		return new WalletInfo(walletFileName, walletPass, walletAddress, false, wallet);
	}

	public static WalletInfo generateWallet(CryptoNote.WalletGreen wallet)
	{
		string walletFileName = getNewWalletFileName();

		const string msg = "Give your new wallet a password: ";

		string walletPass = getWalletPassword(true, msg);

		CryptoNote.KeyPair spendKey = new CryptoNote.KeyPair();
		Crypto.SecretKey privateViewKey = new Crypto.SecretKey();

		Crypto.generate_keys(spendKey.publicKey, spendKey.secretKey);

		CryptoNote.AccountBase.generateViewFromSpend(spendKey.secretKey, privateViewKey);

		wallet.initializeWithViewKey(walletFileName, walletPass, privateViewKey, 0, true);

		string walletAddress = wallet.createAddress(spendKey.secretKey, 0, true);

		promptSaveKeys(wallet);

		Console.Write(WarningMsg("If you lose these your wallet cannot be "));
		Console.Write(WarningMsg("recreated!"));
		Console.Write("\n");
		Console.Write("\n");

		return new WalletInfo(walletFileName, walletPass, walletAddress, false, wallet);
	}

	public static WalletInfo openWallet(CryptoNote.WalletGreen wallet, Config config)
	{
		string walletFileName = getExistingWalletFileName(config);

		bool initial = true;

		while (true)
		{
			string walletPass;

			/* Only use the command line pass once, otherwise we will infinite
			   loop if it is incorrect */
			if (initial && config.passGiven)
			{
				walletPass = config.walletPass;
			}
			else
			{
				walletPass = getWalletPassword(false, "Enter password: ");
			}

			initial = false;

			connectingMsg();

			try
			{
				wallet.load(walletFileName, walletPass);

				string walletAddress = wallet.getAddress(0);

				Crypto.SecretKey privateSpendKey = wallet.getAddressSpendKey(0).secretKey;

				bool viewWallet = false;

				if (privateSpendKey == CryptoNote.NULL_SECRET_KEY)
				{
					Console.Write("\n");
					Console.Write(InformationMsg("Your view only wallet "));
					Console.Write(InformationMsg(walletAddress));
					Console.Write(InformationMsg(" has been successfully opened!"));
					Console.Write("\n");
					Console.Write("\n");

					viewWalletMsg();

					viewWallet = true;

				}
				else
				{
					Console.Write("\n");
					Console.Write(InformationMsg("Your wallet "));
					Console.Write(InformationMsg(walletAddress));
					Console.Write(InformationMsg(" has been successfully opened!"));
					Console.Write("\n");
					Console.Write("\n");
				}

				return new WalletInfo(walletFileName, walletPass, walletAddress, viewWallet, wallet);

			}
			catch (std::system_error e)
			{
				bool handled = false;

				switch (e.code().value())
				{
					case CryptoNote.error.WRONG_PASSWORD:
					{
						Console.Write("\n");
						Console.Write(WarningMsg("Incorrect password! Try again."));
						Console.Write("\n");
						Console.Write("\n");

						handled = true;

						break;
					}
					case CryptoNote.error.WRONG_VERSION:
					{
						std::stringstream msg = new std::stringstream();

						msg << "Could not open wallet file! It doesn't appear " << "to be a valid wallet!" << std::endl << "Ensure you are opening a wallet file, and the " << "file has not gotten corrupted." << std::endl << "Try reimporting via keys, and always close " << WalletConfig.walletName << " with the exit " << "command to prevent corruption." << std::endl;

						Console.Write(WarningMsg(msg.str()));
						Console.Write("\n");

						return null;
					}
				}

				if (handled)
				{
					continue;
				}

				const string alreadyOpenMsg = "MemoryMappedFile::open: The process cannot access the file " + "because it is being used by another process.";

				string errorMsg = e.what();

				/* The message actually has a \r\n on the end but I'd prefer to
				   keep just the raw string in the source so check if it starts
				   with the message instead */
				if (startsWith(errorMsg, alreadyOpenMsg))
				{
					Console.Write(WarningMsg("Could not open wallet! It is already " + "open in another process."));
					Console.Write("\n");
					Console.Write(WarningMsg("Check with a task manager that you " + "don't have "));
					Console.Write(WalletConfig.walletName);
					Console.Write(WarningMsg(" open twice."));
					Console.Write("\n");
					Console.Write(WarningMsg("Also check you don't have another " + "wallet program open, such as a GUI " + "wallet or "));
					Console.Write(WarningMsg(WalletConfig.walletdName));
					Console.Write(WarningMsg("."));
					Console.Write("\n");
					Console.Write("\n");

					return null;
				}
				else
				{
					Console.Write("Unexpected error: ");
					Console.Write(errorMsg);
					Console.Write("\n");
					Console.Write("Please report this error message and what ");
					Console.Write("you did to cause it.");
					Console.Write("\n");
					Console.Write("\n");

					wallet.shutdown();
					return null;
				}
			}
		}
	}

	public static Crypto.SecretKey getPrivateKey(string msg)
	{
		const ulong privateKeyLen = 64;
		ulong size;

		string privateKeyString;
		Crypto.Hash privateKeyHash = new Crypto.Hash();
		Crypto.SecretKey privateKey = new Crypto.SecretKey();
		Crypto.PublicKey publicKey = new Crypto.PublicKey();

		while (true)
		{
			Console.Write(InformationMsg(msg));

			privateKeyString = Console.ReadLine();
			trim(privateKeyString);

			if (privateKeyString.Length != privateKeyLen)
			{
				Console.Write("\n");
				Console.Write(WarningMsg("Invalid private key, should be 64 "));
				Console.Write(WarningMsg("characters! Try again."));
				Console.Write("\n");
				Console.Write("\n");

				continue;
			}
			else if (!Common.fromHex(privateKeyString, privateKeyHash, sizeof(Crypto.Hash), size) || size != sizeof(Crypto.Hash))
			{
				Console.Write(WarningMsg("Invalid private key, it is not a valid "));
				Console.Write(WarningMsg("hex string! Try again."));
				Console.Write("\n");
				Console.Write("\n");

				continue;
			}

			privateKey = (Crypto.SecretKey) privateKeyHash;

			/* Just used for verification purposes before we pass it to
			   walletgreen */
			if (!Crypto.secret_key_to_public_key(privateKey, publicKey))
			{
				Console.Write("\n");
				Console.Write(WarningMsg("Invalid private key, is not on the "));
				Console.Write(WarningMsg("ed25519 curve!"));
				Console.Write("\n");
				Console.Write(WarningMsg("Probably a typo - ensure you entered "));
				Console.Write(WarningMsg("it correctly."));
				Console.Write("\n");
				Console.Write("\n");

				continue;
			}

			return privateKey;
		}
	}

	public static string getExistingWalletFileName(Config config)
	{
		bool initial = true;

		string walletName;

		while (true)
		{
			/* Only use wallet file once in case it is incorrect */
			if (config.walletGiven && initial)
			{
				walletName = config.walletFile;
			}
			else
			{
				Console.Write(InformationMsg("What is the name of the wallet "));
				Console.Write(InformationMsg("you want to open?: "));

				walletName = Console.ReadLine();
			}

			initial = false;

			string walletFileName = walletName + ".wallet";

			if (walletName == "")
			{
				Console.Write("\n");
				Console.Write(WarningMsg("Wallet name can't be blank! Try again."));
				Console.Write("\n");
				Console.Write("\n");
			}
			/* Allow people to enter wallet name with or without file extension */
			else if (fileExists(walletName))
			{
				return walletName;
			}
			else if (fileExists(walletFileName))
			{
				return walletFileName;
			}
			else
			{
				Console.Write("\n");
				Console.Write(WarningMsg("A wallet with the filename "));
				Console.Write(InformationMsg(walletName));
				Console.Write(WarningMsg(" or "));
				Console.Write(InformationMsg(walletFileName));
				Console.Write(WarningMsg(" doesn't exist!"));
				Console.Write("\n");
				Console.Write("Ensure you entered your wallet name correctly.");
				Console.Write("\n");
				Console.Write("\n");
			}
		}
	}

	public static string getNewWalletFileName()
	{
		string walletName;

		while (true)
		{
			Console.Write(InformationMsg("What would you like to call your "));
			Console.Write(InformationMsg("new wallet?: "));

			walletName = Console.ReadLine();

			string walletFileName = walletName + ".wallet";

			if (fileExists(walletFileName))
			{
				Console.Write("\n");
				Console.Write(WarningMsg("A wallet with the filename "));
				Console.Write(InformationMsg(walletFileName));
				Console.Write(WarningMsg(" already exists!"));
				Console.Write("\n");
				Console.Write("Try another name.");
				Console.Write("\n");
				Console.Write("\n");
			}
			else if (walletName == "")
			{
				Console.Write("\n");
				Console.Write(WarningMsg("Wallet name can't be blank! Try again."));
				Console.Write("\n");
				Console.Write("\n");
			}
			else
			{
				return walletFileName;
			}
		}
	}

	public static string getWalletPassword(bool verifyPwd, string msg)
	{
		Tools.PasswordContainer pwdContainer = new Tools.PasswordContainer();
		pwdContainer.read_password(verifyPwd, msg);
		return pwdContainer.password();
	}

	public static void viewWalletMsg()
	{
		Console.Write(InformationMsg("Please remember that when using a view wallet " + "you can only view incoming transactions!"));
		Console.Write("\n");
		Console.Write(InformationMsg("Therefore, if you have recieved transactions "));
		Console.Write(InformationMsg("which you then spent, your balance will "));
		Console.Write(InformationMsg("appear inflated."));
		Console.Write("\n");
	}

	public static void connectingMsg()
	{
		Console.Write("\n");
		Console.Write("Making initial contact with ");
		Console.Write(WalletConfig.daemonName);
		Console.Write(".");
		Console.Write("\n");
		Console.Write("Please wait, this sometimes can take a long time...");
		Console.Write("\n");
		Console.Write("\n");
	}

	public static void promptSaveKeys(CryptoNote.WalletGreen wallet)
	{
		Console.Write("Welcome to your new wallet, here is your payment address:");
		Console.Write("\n");
		Console.Write(InformationMsg(wallet.getAddress(0)));
		Console.Write("\n");
		Console.Write("\n");
		Console.Write("Please copy your secret keys and mnemonic seed and store ");
		Console.Write("them in a secure location: ");
		Console.Write("\n");

		printPrivateKeys(wallet, false);

		Console.Write("\n");
	}

	// Copyright (c) 2018, The TurtleCoin Developers
	//
	// Please see the included LICENSE file for more information.

	/////////////////////////////////////
	/////////////////////////////////////

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define __ROCKSDB_MAJOR__ ROCKSDB_MAJOR
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define __ROCKSDB_MINOR__ ROCKSDB_MINOR
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define __ROCKSDB_PATCH__ ROCKSDB_PATCH

	public static Config parseArguments(int argc, string[] argv)
	{
		Config config = new Config();

		std::stringstream defaultRemoteDaemon = new std::stringstream();
		defaultRemoteDaemon << config.host << ":" << config.port;

		cxxopts.Options options = new cxxopts.Options(argv[0], CryptoNote.getProjectCLIHeader());

		bool help;
		bool version;
		string remoteDaemon;

		options.add_options("Core")("h,help", "Display this help message", cxxopts.value<bool>(help).implicit_value("true"))("v,version", "Output software version information", cxxopts.value<bool>(version).default_value("false").implicit_value("true"))("debug", "Enable " + WalletConfig.walletdName + " debugging to " + WalletConfig.walletName + ".log", cxxopts.value<bool>(config.debug).default_value("false").implicit_value("true"));

		options.add_options("Daemon")("r,remote-daemon", "The daemon <host:port> combination to use for node operations.", cxxopts.value<string>(remoteDaemon).default_value(defaultRemoteDaemon.str()), "<host:port>");

		options.add_options("Wallet")("w,wallet-file", "Open the wallet <file>", cxxopts.value<string>(config.walletFile), "<file>")("p,password", "Use the password <pass> to open the wallet", cxxopts.value<string>(config.walletPass), "<pass>");

		try
		{
			var result = options.parse(argc, argv);
		}
		catch (cxxopts.OptionException e)
		{
			Console.Write("Error: Unable to parse command line argument options: ");
			Console.Write(e.what());
			Console.Write("\n");
			Console.Write("\n");
			Console.Write(options.help({}));
			Console.Write("\n");
			Environment.Exit(1);
		}

		if (help) // Do we want to display the help message?
		{
			Console.Write(options.help({}));
			Console.Write("\n");
			Environment.Exit(0);
		}
		else if (version) // Do we want to display the software version?
		{
			Console.Write(CryptoNote.getProjectCLIHeader());
			Console.Write("\n");
			Environment.Exit(0);
		}

		if (!config.walletFile.empty())
		{
			config.walletGiven = true;
		}

		if (!config.walletPass.empty())
		{
			config.passGiven = true;
		}

		if (!string.IsNullOrEmpty(remoteDaemon))
		{
			if (!parseDaemonAddressFromString(config.host, config.port, remoteDaemon))
			{
				Console.Write("There was an error parsing the --remote-daemon you specified");
				Console.Write("\n");
				Environment.Exit(1);
			}
		}

		return config;
	}
	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.

	///////////////////////////
	///////////////////////////



	public static void checkForNewTransactions(WalletInfo walletInfo)
	{
		walletInfo.wallet.updateInternalCache();

		uint newTransactionCount = walletInfo.wallet.getTransactionCount();

		if (newTransactionCount != walletInfo.knownTransactionCount)
		{
			for (uint i = walletInfo.knownTransactionCount; i < newTransactionCount; i++)
			{
				CryptoNote.WalletTransaction t = walletInfo.wallet.getTransaction(i);

				/* Don't print outgoing or fusion transfers */
				if (t.totalAmount > 0 && t.fee != 0)
				{
//C++ TO C# CONVERTER TODO TASK: The cout 'flush' manipulator is not converted by C++ to C# Converter:
//ORIGINAL LINE: std::cout << std::endl << InformationMsg("New transaction found!") << std::endl << SuccessMsg("Incoming transfer:") << std::endl << SuccessMsg("Hash: " + Common::podToHex(t.hash)) << std::endl << SuccessMsg("Amount: " + formatAmount(t.totalAmount)) << std::endl << InformationMsg(getPrompt(walletInfo)) << std::flush;
					Console.Write("\n");
					Console.Write(InformationMsg("New transaction found!"));
					Console.Write("\n");
					Console.Write(SuccessMsg("Incoming transfer:"));
					Console.Write("\n");
					Console.Write(SuccessMsg("Hash: " + Common.podToHex(t.hash)));
					Console.Write("\n");
					Console.Write(SuccessMsg("Amount: " + formatAmount(t.totalAmount)));
					Console.Write("\n");
					Console.Write(InformationMsg(getPrompt(walletInfo)));
				}
			}

			walletInfo.knownTransactionCount = newTransactionCount;
		}
	}

	public static void syncWallet(CryptoNote.INode node, WalletInfo walletInfo)
	{
		uint localHeight = node.getLastLocalBlockHeight();
		uint walletHeight = walletInfo.wallet.getBlockCount();
		uint remoteHeight = node.getLastKnownBlockHeight();

		uint transactionCount = walletInfo.wallet.getTransactionCount();

		int stuckCounter = 0;

		if (localHeight != remoteHeight)
		{
			Console.Write("Your ");
			Console.Write(WalletConfig.daemonName);
			Console.Write(" isn't fully ");
			Console.Write("synced yet!");
			Console.Write("\n");
			Console.Write("Until you are fully synced, you won't be able to send ");
			Console.Write("transactions,");
			Console.Write("\n");
			Console.Write("and your balance may be missing or ");
			Console.Write("incorrect!");
			Console.Write("\n");
			Console.Write("\n");
		}

		/* If we open a legacy wallet then it will load the transactions but not
		   have the walletHeight == transaction height. Lets just throw away the
		   transactions and rescan. */
		if (walletHeight == 1 && transactionCount != 0)
		{
			Console.Write("Upgrading your wallet from an older version of the ");
			Console.Write("software...");
			Console.Write("\n");
			Console.Write("Unfortunately, we have ");
			Console.Write("to rescan the chain to find your transactions.");
			Console.Write("\n");

			transactionCount = 0;

			walletInfo.wallet.clearCaches(true, false);
		}

		if (walletHeight == 1)
		{
			Console.Write("Scanning through the blockchain to find transactions ");
			Console.Write("that belong to you.");
			Console.Write("\n");
			Console.Write("Please wait, this will take some time.");
			Console.Write("\n");
			Console.Write("\n");
		}
		else
		{
			Console.Write("Scanning through the blockchain to find any new ");
			Console.Write("transactions you received");
			Console.Write("\n");
			Console.Write("whilst your wallet wasn't open.");
			Console.Write("\n");
			Console.Write("Please wait, this may take some time.");
			Console.Write("\n");
			Console.Write("\n");
		}

		int counter = 1;

		while (walletHeight < localHeight)
		{
			/* This MUST be called on the main thread! */
			walletInfo.wallet.updateInternalCache();

			localHeight = node.getLastLocalBlockHeight();
			remoteHeight = node.getLastKnownBlockHeight();
			Console.Write(SuccessMsg(Convert.ToString(walletHeight)));
			Console.Write(" of ");
			Console.Write(InformationMsg(Convert.ToString(localHeight)));
			Console.Write("\n");

			uint tmpWalletHeight = walletInfo.wallet.getBlockCount();

			int waitSeconds = 1;

			/* Save periodically so if someone closes before completion they don't
			   lose all their progress. Saving is actually quite slow with big
			   wallets so lets do it every 10 minutes */
			if (counter % 600 == 0)
			{
				Console.Write("\n");
				Console.Write(InformationMsg("Saving current progress..."));
				Console.Write("\n");
				Console.Write("\n");

				walletInfo.wallet.save();
			}

			if (tmpWalletHeight == walletHeight)
			{
				stuckCounter++;
				waitSeconds = 3;

				if (stuckCounter > 20)
				{
					Console.Write(WarningMsg("Syncing may be stuck. Try restarting "));
					Console.Write(WarningMsg(WalletConfig.daemonName));
					Console.Write(WarningMsg("."));
					Console.Write("\n");
					Console.Write(WarningMsg("If this persists, visit "));
					Console.Write(WarningMsg(WalletConfig.contactLink));
					Console.Write(WarningMsg(" for support."));
					Console.Write("\n");
				}
				else if (stuckCounter > 19)
				{
					/*
					   Calling save has the side-effect of starting
					   and stopping blockchainSynchronizer, which seems
					   to sometimes force the sync to resume properly.
					   So we'll try this before warning the user.
					*/
					walletInfo.wallet.save();
					waitSeconds = 5;
				}
			}
			else
			{
				stuckCounter = 0;
				walletHeight = tmpWalletHeight;

				uint tmpTransactionCount = walletInfo.wallet.getTransactionCount();

				if (tmpTransactionCount != transactionCount)
				{
					for (uint i = transactionCount; i < tmpTransactionCount; i++)
					{
						CryptoNote.WalletTransaction t = walletInfo.wallet.getTransaction(i);

						/* Don't print out fusion transactions */
						if (t.totalAmount != 0)
						{
							Console.Write("\n");
							Console.Write(InformationMsg("New transaction found!"));
							Console.Write("\n");
							Console.Write("\n");

							if (t.totalAmount < 0)
							{
								printOutgoingTransfer(t, node);
							}
							else
							{
								printIncomingTransfer(t, node);
							}
						}
					}

					transactionCount = tmpTransactionCount;
				}
			}

			counter++;

			std::this_thread.sleep_for(std::chrono.seconds(waitSeconds));
		}

		Console.Write("\n");
		Console.Write(SuccessMsg("Finished scanning blockchain!"));
		Console.Write("\n");

		/* In case the user force closes, we don't want them to have to rescan
		   the whole chain. */
		walletInfo.wallet.save();

		walletInfo.knownTransactionCount = transactionCount;
	}

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.

	////////////////////////////
	////////////////////////////







	public static void confirmPassword(string walletPass, string msg)
	{
		/* Password container requires an rvalue, we don't want to wipe our current
		   pass so copy it into a tmp string and std::move that instead */
		string tmpString = walletPass;
		Tools.PasswordContainer pwdContainer = new Tools.PasswordContainer(std::move(tmpString));

		while (!pwdContainer.read_and_validate(msg))
		{
			Console.Write(WarningMsg("Incorrect password! Try again."));
			Console.Write("\n");
		}
	}

	/* Get the amount we need to divide to convert from atomic to pretty print,
	   e.g. 100 for 2 decimal places */
	public static ulong getDivisor()
	{
		return (ulong)Math.Pow(10, WalletConfig.numDecimalPlaces);
	}

	public static string formatAmount(ulong amount)
	{
		ulong divisor = getDivisor();
		ulong dollars = amount / divisor;
		ulong cents = amount % divisor;

		return formatDollars(dollars) + "." + formatCents(cents) + " " = new return();
			 + WalletConfig.ticker;
	}

	public static string formatAmountBasic(ulong amount)
	{
		ulong divisor = getDivisor();
		ulong dollars = amount / divisor;
		ulong cents = amount % divisor;

		return Convert.ToString(dollars) + "." + formatCents(cents);
	}

	public static string formatDollars(ulong amount)
	{
		/* We want to format our number with comma separators so it's easier to
		   use. Now, we could use the nice print_money() function to do this.
		   However, whilst this initially looks pretty handy, if we have a locale
		   such as ja_JP.utf8, 1 TRTL will actually be formatted as 100 TRTL, which
		   is terrible, and could really screw over users.
	
		   So, easy solution right? Just use en_US.utf8! Sure, it's not very
		   international, but it'll work! Unfortunately, no. The user has to have
		   the locale installed, and if they don't, we get a nasty error at
		   runtime.
	
		   Annoyingly, there's no easy way to comma separate numbers outside of
		   using the locale method, without writing a pretty long boiler plate
		   function. So, instead, we define our own locale, which just returns
		   the values we want.
		   
		   It's less internationally friendly than we would potentially like
		   but that would require a ton of scrutinization which if not done could
		   land us with quite a few issues and rightfully angry users.
		   Furthermore, we'd still have to hack around cases like JP locale
		   formatting things incorrectly, and it makes reading in inputs harder
		   too. */

		/* Thanks to https://stackoverflow.com/a/7277333/8737306 for this neat
		   workaround */
//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//	class comma_numpunct : public std::numpunct<char>
	//	{
	//	  protected:
	//		virtual char do_thousands_sep() const
	//		{
	//			return ',';
	//		}
	//
	//		virtual string do_grouping() const
	//		{
	//			return "\x0003";
	//		}
	//	};

		std::locale comma_locale = new std::locale(std::locale(), new comma_numpunct());
		std::stringstream stream = new std::stringstream();
		stream.imbue(comma_locale);
		stream << (int)amount;
		return stream.str();
	}

	/* Pad to the amount of decimal spaces, e.g. with 2 decimal spaces 5 becomes
	   05, 50 remains 50 */
	public static string formatCents(ulong amount)
	{
		std::stringstream stream = new std::stringstream();
		stream << std::setfill('0') << std::setw(WalletConfig.numDecimalPlaces) << (int)amount;
		return stream.str();
	}

	public static bool confirm(string msg)
	{
		return confirm(msg, true);
	}

	/* defaultReturn = what value we return on hitting enter, i.e. the "expected"
	   workflow */
	public static bool confirm(string msg, bool defaultReturn)
	{
		/* In unix programs, the upper case letter indicates the default, for
		   example when you hit enter */
		string prompt = " (Y/n): ";

		/* Yes, I know I can do !defaultReturn. It doesn't make as much sense
		   though. If someone deletes this comment to make me look stupid I'll be
		   mad >:( */
		if (defaultReturn == false)
		{
			prompt = " (y/N): ";
		}

		while (true)
		{
			Console.Write(InformationMsg(msg + prompt));

			string answer;
			answer = Console.ReadLine();

			char c = global::tolower(answer[0]);

			switch (c)
			{
				/* Lets people spam enter / choose default value */
				case '\0':
					return defaultReturn;
				case 'y':
					return true;
				case 'n':
					return false;
			}

			Console.Write(WarningMsg("Bad input: "));
			Console.Write(InformationMsg(answer));
			Console.Write(WarningMsg(" - please enter either Y or N."));
			Console.Write("\n");
		}
	}

	public static string getPaymentIDFromExtra(string extra)
	{
		string paymentID;

		if (extra.Length > 0)
		{
			List<byte> vecExtra = new List<byte>();

			foreach (var it in extra)
			{
				vecExtra.Add((byte)it);
			}

			Crypto.Hash paymentIdHash = new Crypto.Hash();

			if (CryptoNote.getPaymentIdFromTxExtra(vecExtra, paymentIdHash))
			{
				return Common.podToHex(paymentIdHash);
			}
		}

		return paymentID;
	}

	public static string unixTimeToDate(ulong timestamp)
	{
		std::time_t time = timestamp;
		string buffer = new string(new char[100]);
		std::strftime(buffer, sizeof(char), "%F %R", std::localtime(time));
		return (string)buffer;
	}

	public static string createIntegratedAddress(string address, string paymentID)
	{
		ulong prefix;

		CryptoNote.AccountPublicAddress addr = new CryptoNote.AccountPublicAddress();

		/* Get the private + public key from the address */
		CryptoNote.parseAccountAddressString(prefix, addr, address);

		/* Pack as a binary array */
		CryptoNote.BinaryArray ba = new CryptoNote.BinaryArray();
		CryptoNote.toBinaryArray(addr, ba);
		string keys = Common.asString(ba);

		/* Encode prefix + paymentID + keys as an address */
		return Tools.Base58.encode_addr(CryptoNote.parameters.CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX, paymentID + keys);
	}

	public static ulong getScanHeight()
	{
		while (true)
		{
			Console.Write(InformationMsg("What height would you like to begin "));
			Console.Write(InformationMsg("scanning your wallet from?"));
			Console.Write("\n");
			Console.Write("\n");
			Console.Write("This can greatly speed up the initial wallet ");
			Console.Write("scanning process.");
			Console.Write("\n");
			Console.Write("\n");
			Console.Write("If you do not know the exact height, ");
			Console.Write("err on the side of caution so transactions do not ");
			Console.Write("get missed.");
			Console.Write("\n");
			Console.Write("\n");
			Console.Write(InformationMsg("Hit enter for the sub-optimal default "));
			Console.Write(InformationMsg("of zero: "));

			string stringHeight;

			stringHeight = Console.ReadLine();

			/* Remove commas so user can enter height as e.g. 200,000 */
			removeCharFromString(stringHeight, ',');

			if (stringHeight == "")
			{
				return 0;
			}

			try
			{
				return Convert.ToInt32(stringHeight);
			}
			catch (System.ArgumentException)
			{
				Console.Write(WarningMsg("Failed to parse height - input is not "));
				Console.Write(WarningMsg("a number!"));
				Console.Write("\n");
				Console.Write("\n");
			}
		}
	}

	/* Erases all instances of c from the string. E.g. 2,000,000 becomes 2000000 */
	public static void removeCharFromString(string str, char c)
	{
		str = str.Remove(std::remove(str.GetEnumerator(), str.end(), c), str.end());
	}

	/* Trims any whitespace from left and right */
	public static void trim(string str)
	{
		rightTrim(str);
		leftTrim(str);
	}

	public static void leftTrim(string str)
	{
		string whitespace = " \t\n\r\f\v";

		str = str.Remove(0, str.find_first_not_of(whitespace));
	}

	public static void rightTrim(string str)
	{
		string whitespace = " \t\n\r\f\v";

		str = str.erase(str.find_last_not_of(whitespace) + 1);
	}

	/* Checks if str begins with substring */
	public static bool startsWith(string str, string substring)
	{
		return str.LastIndexOf(substring, 0) == 0;
	}

	/* Does the given filename exist on disk? */
	public static bool fileExists(string filename)
	{
		/* Bool conversion needs an explicit cast */
		return (bool)std::ifstream(filename);
	}

	public static bool shutdown(WalletInfo walletInfo, CryptoNote.INode node, ref bool alreadyShuttingDown)
	{
		if (alreadyShuttingDown)
		{
			Console.Write("Patience little turtle, we're already shutting down!");
			Console.Write("\n");

			return false;
		}

		Console.Write(InformationMsg("Shutting down..."));
		Console.Write("\n");

		alreadyShuttingDown = true;

		bool finishedShutdown = false;

	std::thread timelyShutdown(() =>
	{
		var startTime = std::chrono.system_clock.now();

		/* Has shutdown finished? */
		while (!finishedShutdown)
		{
			var currentTime = std::chrono.system_clock.now();

			/* If not, wait for a max of 20 seconds then force exit. */
			if ((currentTime - startTime) > std::chrono.seconds(20))
			{
				Console.Write(WarningMsg("Wallet took too long to save! " + "Force closing."));
				Console.Write("\n");
				Console.Write("Bye.");
				Console.Write("\n");
				Environment.Exit(0);
			}

			std::this_thread.sleep_for(std::chrono.seconds(1));
		}
	});

		if (walletInfo != null)
		{
			Console.Write(InformationMsg("Saving wallet file..."));
			Console.Write("\n");

			walletInfo.wallet.save();

			Console.Write(InformationMsg("Shutting down wallet interface..."));
			Console.Write("\n");

			walletInfo.wallet.shutdown();
		}

		Console.Write(InformationMsg("Shutting down node connection..."));
		Console.Write("\n");

		node.shutdown();

		finishedShutdown = true;

		/* Wait for shutdown watcher to finish */
		timelyShutdown.join();

		Console.Write("Bye.");
		Console.Write("\n");

		return true;
	}

	public static List<string> split(string str, char delim = ' ')
	{
		List<string> cont = new List<string>();
		std::stringstream ss = new std::stringstream(str);
		string token;
		while (getline(ss, token, delim))
		{
			cont.Add(token);
		}
		return cont;
	}

	public static bool parseDaemonAddressFromString(ref string host, ref int port, string address)
	{
		List<string> parts = split(address, ':');

		if (parts.Count == 0)
		{
			return false;
		}
		else if (parts.Count >= 2)
		{
			try
			{
				host = parts[0];
				port = Convert.ToInt32(parts[1]);
				return true;
			}
			catch (System.ArgumentException)
			{
			  return false;
			}
		}

		host = parts[0];
		port = CryptoNote.RPC_DEFAULT_PORT;
		return true;
	}



	public static bool parseAmount(string strAmount, ref ulong amount)
	{
		/* Trim any whitespace */
		trim(strAmount);

		/* If the user entered thousand separators, remove them */
		removeCharFromString(strAmount, ',');

		uint pointIndex = strAmount.IndexOfAny((Convert.ToString('.')).ToCharArray());
		uint numDecimalPlaces = WalletConfig.numDecimalPlaces;

		uint fractionSize;

		if (-1 != pointIndex)
		{
			fractionSize = strAmount.Length - pointIndex - 1;

			while (numDecimalPlaces < fractionSize && '0' == strAmount.back())
			{
				strAmount = strAmount.Remove(strAmount.Length - 1, 1);
				fractionSize--;
			}

			if (numDecimalPlaces < fractionSize)
			{
				return false;
			}

			strAmount = strAmount.Remove(pointIndex, 1);
		}
		else
		{
			fractionSize = 0;
		}

		if (string.IsNullOrEmpty(strAmount))
		{
			return false;
		}

		if (!std::all_of(strAmount.GetEnumerator(), strAmount.end(), global::isdigit))
		{
			return false;
		}

		if (fractionSize < numDecimalPlaces)
		{
			strAmount.append(numDecimalPlaces - fractionSize, '0');
		}

		bool success = Common.fromString(strAmount, amount);

		if (!success)
		{
			return false;
		}

		return amount >= WalletConfig.minimumSend;
	}

	public static bool confirmTransaction(CryptoNote.TransactionParameters t, WalletInfo walletInfo, bool integratedAddress, uint nodeFee, string originalAddress)
	{
		Console.Write("\n");
		Console.Write(InformationMsg("Confirm Transaction?"));
		Console.Write("\n");

		Console.Write("You are sending ");
		Console.Write(SuccessMsg(formatAmount(t.destinations[0].amount)));
		Console.Write(", with a network fee of ");
		Console.Write(SuccessMsg(formatAmount(t.fee)));
		Console.Write(",");
		Console.Write("\n");
		Console.Write("and a node fee of ");
		Console.Write(SuccessMsg(formatAmount(nodeFee)));

		string paymentID = getPaymentIDFromExtra(t.extra);

		/* Lets not split the integrated address out into its address and
		   payment ID combo. It'll confused users. */
		if (paymentID != "" && !integratedAddress)
		{
			Console.Write(", ");
			Console.Write("\n");
			Console.Write("and a Payment ID of ");
			Console.Write(SuccessMsg(paymentID));
		}
		else
		{
			Console.Write(".");
		}

		Console.Write("\n");
		Console.Write("\n");
		Console.Write("FROM: ");
		Console.Write(SuccessMsg(walletInfo.walletFileName));
		Console.Write("\n");
		Console.Write("TO: ");
		Console.Write(SuccessMsg(originalAddress));
		Console.Write("\n");
		Console.Write("\n");

		if (confirm("Is this correct?"))
		{
			confirmPassword(walletInfo.walletPass);
			return true;
		}

		return false;
	}

	/* Note that the originalTXParams, and thus the splitTXParams already has the
	   node transfer added */
	public static void splitTX(CryptoNote.WalletGreen wallet, CryptoNote.TransactionParameters originalTXParams, uint nodeFee)
	{
		Console.Write("Transaction is still too large to send, splitting into ");
		Console.Write("multiple chunks.");
		Console.Write("\n");
		Console.Write("It will slightly raise the fee you have to pay,");
		Console.Write("\n");
		Console.Write("and hence reduce the total amount you can send if");
		Console.Write("\n");
		Console.Write("your balance cannot cover it.");
		Console.Write("\n");

		if (!confirm("Is this OK?"))
		{
			Console.Write(WarningMsg("Cancelling transaction."));
			Console.Write("\n");
			return;
		}

		ulong balance = wallet.getActualBalance();

		ulong totalAmount = originalTXParams.destinations[0].amount;
		ulong sentAmount = 0;
		ulong remainder = totalAmount - sentAmount;

		/* How much to split the remaining balance to be sent into each individual
		   transaction. If it's 1, then we'll attempt to send the full amount,
		   if it's 2, we'll send half, and so on. */
		ulong amountDivider = 1;

		int txNumber = 1;

		while (true)
		{
			var splitTXParams = originalTXParams;

			splitTXParams.destinations[0].amount = totalAmount / amountDivider;

			/* If we have odd numbers, we can have an amount that is smaller
			   than the remainder to send, but the remainder is less than
			   2 * amount.
			   So, we include this amount in our current transaction to prevent
			   this change not being sent.
			   If we're trying to send more than the remaining amount, set to
			   the remaining amount. */
			if ((splitTXParams.destinations[0].amount != remainder && remainder < (splitTXParams.destinations[0].amount * 2)) || (splitTXParams.destinations[0].amount > remainder))
			{
				splitTXParams.destinations[0].amount = remainder;
			}
			else if (splitTXParams.destinations[0].amount + splitTXParams.fee + nodeFee > balance)
			{
				splitTXParams.destinations[0].amount = balance - splitTXParams.fee - nodeFee;
			}

			if (splitTXParams.destinations[0].amount < WalletConfig.minimumSend)
			{
				Console.Write(WarningMsg("Failed to split up transaction, sorry."));
				Console.Write("\n");

				return;
			}

			ulong totalNeeded = splitTXParams.destinations[0].amount + splitTXParams.fee + nodeFee;

			/* Need to update before checking intially */
			wallet.updateInternalCache();

			/* Balance is going to get locked as we send, wait for it to unlock
			   and then send */
			while (wallet.getActualBalance() < totalNeeded)
			{
				Console.Write(WarningMsg("Waiting for balance to unlock to send "));
				Console.Write(WarningMsg("next transaction."));
				Console.Write("\n");
				Console.Write(WarningMsg("Will try again in 15 seconds..."));
				Console.Write("\n");
				Console.Write("\n");

				std::this_thread.sleep_for(std::chrono.seconds(15));

				wallet.updateInternalCache();
			}

			var preparedTransaction = wallet.formTransaction(splitTXParams);

			/* Still too large, increase divider and try again */
			if (wallet.txIsTooLarge(preparedTransaction))
			{
				amountDivider++;

				/* This can take quite a long time getting mixins each time
				   so let them know it's not frozen */
				Console.Write(InformationMsg("Working..."));
				Console.Write("\n");

				continue;
			}

			Console.Write(InformationMsg("Sending transaction number "));
			Console.Write(InformationMsg(Convert.ToString(txNumber)));
			Console.Write(InformationMsg("..."));
			Console.Write("\n");

			uint id = wallet.transfer(preparedTransaction);
			var hash = wallet.getTransaction(id).hash;

			std::stringstream stream = new std::stringstream();

			stream << "Transaction has been sent!" << std::endl << "Hash: " << Common.podToHex(hash) << std::endl << "Amount: " << formatAmount(splitTXParams.destinations[0].amount) << std::endl << std::endl;

			Console.Write(SuccessMsg(stream.str()));
			Console.Write("\n");

			txNumber++;

			sentAmount += splitTXParams.destinations[0].amount;

			/* Remember to remove the fee and node fee as well from balance */
			balance -= splitTXParams.destinations[0].amount - splitTXParams.fee - nodeFee;

			remainder = totalAmount - sentAmount;

			/* We've sent the full amount required now */
			if (sentAmount == totalAmount)
			{
				Console.Write(InformationMsg("All transactions have been sent!"));
				Console.Write("\n");

				return;
			}

			/* Went well, lets restart, trying to send the max amount */
			amountDivider = 1;
		}
	}

	public static void transfer(WalletInfo walletInfo, uint height, bool sendAll, string nodeAddress, uint nodeFee)
	{
		Console.Write(InformationMsg("Note: You can type cancel at any time to " + "cancel the transaction"));
		Console.Write("\n");
		Console.Write("\n");

		ulong balance = walletInfo.wallet.getActualBalance();

		ulong balanceNoDust = walletInfo.wallet.getBalanceMinusDust({walletInfo.walletAddress});

		var maybeAddress = getAddress("What address do you want to transfer" + " to?: ");

		if (!maybeAddress.isJust)
		{
			Console.Write(WarningMsg("Cancelling transaction."));
			Console.Write("\n");
			return;
		}

		/* We keep around the original entered address since we can't get back
		   the original integratedAddress from extra, since payment ID's can
		   be upper, lower, or mixed case, but they're only stored as lower in
		   extra. We want this for the confirmation screen. */
		string originalAddress = maybeAddress.x.second;

		string address = originalAddress;

		string extra;

		bool integratedAddress = maybeAddress.x.first == IntegratedAddress;

		/* It's an integrated address, so lets extract out the true address and
		   payment ID from the pair */
		if (integratedAddress)
		{
			var addrPaymentIDPair = extractIntegratedAddress(maybeAddress.x.second);
			address = addrPaymentIDPair.x.first;
			extra = getExtraFromPaymentID(addrPaymentIDPair.x.second);
		}

		/* Don't need to prompt for payment ID if they used an integrated
		   address */
		if (!integratedAddress)
		{
			var maybeExtra = getExtra();

			if (!maybeExtra.isJust)
			{
				Console.Write(WarningMsg("Cancelling transaction."));
				Console.Write("\n");
				return;
			}

			extra = maybeExtra.x;
		}

		/* Make sure we set this later if we're sending everything by deducting
		   the fee from full balance */
		ulong amount = 0;

		ulong mixin = CryptoNote.getDefaultMixinByHeight(height);

		/* If we're sending everything, obviously we don't need to ask them how
		   much to send */
		if (!sendAll)
		{
			var maybeAmount = getTransferAmount();

			if (!maybeAmount.isJust)
			{
				Console.Write(WarningMsg("Cancelling transaction."));
				Console.Write("\n");
				return;
			}

			amount = maybeAmount.x;

			switch (doWeHaveEnoughBalance(amount, WalletConfig.defaultFee, walletInfo, height, nodeFee))
			{
				case NotEnoughBalance:
				{
					Console.Write(WarningMsg("Cancelling transaction."));
					Console.Write("\n");
					return;
				}
				case SetMixinToZero:
				{
					mixin = 0;
					break;
				}
				default:
				{
					break;
				}
			}
		}

		var maybeFee = getFee();

		if (!maybeFee.isJust)
		{
			Console.Write(WarningMsg("Cancelling transaction."));
			Console.Write("\n");
			return;
		}

		ulong fee = maybeFee.x;

		switch (doWeHaveEnoughBalance(amount, fee, walletInfo, height, nodeFee))
		{
			case NotEnoughBalance:
			{
				Console.Write(WarningMsg("Cancelling transaction."));
				Console.Write("\n");
				return;
			}
			case SetMixinToZero:
			{
				mixin = 0;
				break;
			}
			default:
			{
				break;
			}
		}

		/* This doesn't account for dust. We should probably make a function to
		   check for balance minus dust */
		if (sendAll)
		{
			if (CryptoNote.getDefaultMixinByHeight(height) != 0 && balance != balanceNoDust)
			{
				ulong unsendable = balance - balanceNoDust;

				amount = balanceNoDust - fee - nodeFee;

				Console.Write(WarningMsg("Due to dust inputs, we are unable to "));
				Console.Write(WarningMsg("send "));
				Console.Write(InformationMsg(formatAmount(unsendable)));
				Console.Write(WarningMsg("of your balance."));
				Console.Write("\n");

				if (!WalletConfig.mixinZeroDisabled || height < WalletConfig.mixinZeroDisabledHeight)
				{
					Console.Write("Alternatively, you can set the mixin count to ");
					Console.Write("zero to send it all.");
					Console.Write("\n");

					if (confirm("Set mixin to 0 so we can send your whole balance? " + "This will compromise privacy."))
					{
						mixin = 0;
						amount = balance - fee - nodeFee;
					}
				}
				else
				{
					Console.Write("Sorry.");
					Console.Write("\n");
				}
			}
			else
			{
				amount = balance - fee - nodeFee;
			}
		}

		doTransfer(address, amount, fee, extra, walletInfo, height, integratedAddress, mixin, nodeAddress, nodeFee, originalAddress);
	}

	public static BalanceInfo doWeHaveEnoughBalance(ulong amount, ulong fee, WalletInfo walletInfo, ulong height, uint nodeFee)
	{
		ulong balance = walletInfo.wallet.getActualBalance();

		ulong balanceNoDust = walletInfo.wallet.getBalanceMinusDust({walletInfo.walletAddress});

		/* They have to include at least a fee of this large */
		if (balance < amount + fee + nodeFee)
		{
			Console.Write("\n");
			Console.Write(WarningMsg("You don't have enough funds to cover "));
			Console.Write(WarningMsg("this transaction!"));
			Console.Write("\n");
			Console.Write("\n");
			Console.Write("Funds needed: ");
			Console.Write(InformationMsg(formatAmount(amount + fee + nodeFee)));
			Console.Write(" (Includes a network fee of ");
			Console.Write(InformationMsg(formatAmount(fee)));
			Console.Write(" and a node fee of ");
			Console.Write(InformationMsg(formatAmount(nodeFee)));
			Console.Write(")");
			Console.Write("\n");
			Console.Write("Funds available: ");
			Console.Write(SuccessMsg(formatAmount(balance)));
			Console.Write("\n");
			Console.Write("\n");

			return NotEnoughBalance;
		}
		else if (CryptoNote.getDefaultMixinByHeight(height) != 0 && balanceNoDust < amount + WalletConfig.minimumFee + nodeFee)
		{
			Console.Write("\n");
			Console.Write(WarningMsg("This transaction is unable to be sent "));
			Console.Write(WarningMsg("due to dust inputs."));
			Console.Write("\n");
			Console.Write("You can send ");
			Console.Write(InformationMsg(formatAmount(balanceNoDust)));
			Console.Write(" without issues (includes a network fee of ");
			Console.Write(InformationMsg(formatAmount(fee)));
			Console.Write(" and ");
			Console.Write(" a node fee of ");
			Console.Write(InformationMsg(formatAmount(nodeFee)));
			Console.Write(")");
			Console.Write("\n");

			if (!WalletConfig.mixinZeroDisabled || height < WalletConfig.mixinZeroDisabledHeight)
			{
				Console.Write("Alternatively, you can sent the mixin ");
				Console.Write("count to 0.");
				Console.Write("\n");

				if (confirm("Set mixin to 0? This will compromise privacy."))
				{
					return SetMixinToZero;
				}
			}
		}
		else
		{
			return EnoughBalance;
		}

		return NotEnoughBalance;
	}

	public static void doTransfer(string address, ulong amount, ulong fee, string extra, WalletInfo walletInfo, uint height, bool integratedAddress, ulong mixin, string nodeAddress, uint nodeFee, string originalAddress)
	{
		ulong balance = walletInfo.wallet.getActualBalance();

		if (balance < amount + fee + nodeFee)
		{
			Console.Write(WarningMsg("You don't have enough funds to cover this "));
			Console.Write(WarningMsg("transaction!"));
			Console.Write("\n");
			Console.Write(InformationMsg("Funds needed: "));
			Console.Write(InformationMsg(formatAmount(amount + fee + nodeFee)));
			Console.Write("\n");
			Console.Write(SuccessMsg("Funds available: " + formatAmount(balance)));
			Console.Write("\n");
			return;
		}

		CryptoNote.TransactionParameters p = new CryptoNote.TransactionParameters();

		p.destinations = new List<CryptoNote.WalletOrder> ()
		{
			{address, amount}
		};

		if (!string.IsNullOrEmpty(nodeAddress) && nodeFee != 0)
		{
			p.destinations.Add({nodeAddress, nodeFee});
		}

		p.fee = fee;
		p.mixIn = (ushort)mixin;
		p.extra = extra;
		p.changeDestination = walletInfo.walletAddress;

//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: if (!confirmTransaction(p, walletInfo, integratedAddress, nodeFee, originalAddress))
		if (!confirmTransaction(new CryptoNote.TransactionParameters(p), walletInfo, integratedAddress, nodeFee, originalAddress))
		{
			Console.Write(WarningMsg("Cancelling transaction."));
			Console.Write("\n");
			return;
		}

//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: sendTX(walletInfo, p, height, false, nodeFee);
		sendTX(walletInfo, new CryptoNote.TransactionParameters(p), height, false, nodeFee);
	}

	public static void sendTX(WalletInfo walletInfo, CryptoNote.TransactionParameters p, uint height, bool retried, uint nodeFee)
	{
		try
		{
			var tx = walletInfo.wallet.formTransaction(p);

			/* Transaction is too large. Lets try and perform fusion to let us
			   send more at once */
			if (walletInfo.wallet.txIsTooLarge(tx))
			{
				/* If the fusion transactions didn't completely unlock, abort tx */
				if (!fusionTX(walletInfo.wallet, p, height))
				{
					return;
				}

				/* Reform with the optimized inputs */
				tx = walletInfo.wallet.formTransaction(p);

				/* If the transaction is still too large, lets split it up into 
				   smaller chunks */
				if (walletInfo.wallet.txIsTooLarge(tx))
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: splitTX(walletInfo->wallet, p, nodeFee);
					splitTX(walletInfo.wallet, new CryptoNote.TransactionParameters(p), nodeFee);
					return;
				}
			}

			uint id = walletInfo.wallet.transfer(tx);
			var hash = walletInfo.wallet.getTransaction(id).hash;

			Console.Write(SuccessMsg("Transaction has been sent!"));
			Console.Write("\n");
			Console.Write(SuccessMsg("Hash: "));
			Console.Write(SuccessMsg(Common.podToHex(hash)));
			Console.Write("\n");
		}
		/* Lets handle the error and possibly resend the transaction */
		catch (std::system_error e)
		{
			bool setMixinToZero = handleTransferError(e, retried, height);

			if (setMixinToZero)
			{
				p.mixIn = 0;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: sendTX(walletInfo, p, height, true, nodeFee);
				sendTX(walletInfo, new CryptoNote.TransactionParameters(p), height, true, nodeFee);
			}
		}
	}

	public static bool handleTransferError(std::system_error e, bool retried, uint height)
	{
		if (retried)
		{
			Console.Write(WarningMsg("Failed to send transaction!"));
			Console.Write("\n");
			Console.Write("Error message: ");
			Console.Write(e.what());
			Console.Write("\n");

			return false;
		}

		bool wrongAmount = false;

		switch (e.code().value())
		{
			case WalletErrors.CryptoNote.error.WRONG_AMOUNT:
			{
				wrongAmount = true;
	//C++ TO C# CONVERTER TODO TASK: C++11 attributes are not converted to C#:
	//ORIGINAL LINE: [[fallthrough]];
			   ;
			}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			case WalletErrors.CryptoNote.error.MIXIN_COUNT_TOO_BIG:
			case NodeErrors.CryptoNote.error.INTERNAL_NODE_ERROR:
			{

				if (wrongAmount)
				{
					Console.Write(WarningMsg("Failed to send transaction " + "- not enough funds!"));
					Console.Write("\n");
					Console.Write("Unable to send dust inputs.");
					Console.Write("\n");
				}
				else
				{
					Console.Write(WarningMsg("Failed to send transaction!"));
					Console.Write("\n");
					Console.Write("Unable to find enough outputs to ");
					Console.Write("mix with.");
					Console.Write("\n");
				}

				Console.Write("Try lowering the amount you are sending ");
				Console.Write("in one transaction.");
				Console.Write("\n");

				/* If a mixin of zero is allowed, or we are below the
				   fork height when it's banned, ask them to resend with
				   zero */
				if (!WalletConfig.mixinZeroDisabled || height < WalletConfig.mixinZeroDisabledHeight)
				{
					Console.Write("Alternatively, you can set the mixin ");
					Console.Write("count to 0.");
					Console.Write("\n");

					if (confirm("Retry transaction with mixin of 0? " + "This will compromise privacy."))
					{
						return true;
					}
				}

				Console.Write(WarningMsg("Cancelling transaction."));
				Console.Write("\n");

				break;
			}
			case NodeErrors.CryptoNote.error.NETWORK_ERROR:
			case NodeErrors.CryptoNote.error.CONNECT_ERROR:
			{
				Console.Write(WarningMsg("Couldn't connect to the network " + "to send the transaction!"));
				Console.Write("\n");
				Console.Write("Ensure ");
				Console.Write(WalletConfig.daemonName);
				Console.Write(" or the remote node you are using is open ");
				Console.Write("and functioning.");
				Console.Write("\n");
				break;
			}
			default:
			{
				/* Some errors don't have an associated value, just an
				   error string */
				string msg = e.what();

				if (msg == "Failed add key input: key image already spent")
				{
					Console.Write(WarningMsg("Failed to send transaction - " + "wallet is not synced yet!"));
					Console.Write("\n");
					Console.Write("Use the ");
					Console.Write(InformationMsg("bc_height"));
					Console.Write(" command to view the wallet sync status.");
					Console.Write("\n");

					break;
				}

				Console.Write(WarningMsg("Failed to send transaction!"));
				Console.Write("\n");
				Console.Write("Error message: ");
				Console.Write(msg);
				Console.Write("\n");
				Console.Write("Please report what you were doing to cause ");
				Console.Write("this error so we can fix it! :)");
				Console.Write("\n");
				break;
			}
		}

		return false;
	}

	public static Maybe<string> getPaymentID(string msg)
	{
		while (true)
		{
			string paymentID;

			Console.Write(InformationMsg(msg));
			Console.Write(WarningMsg("Warning: If you were given a payment ID,"));
			Console.Write("\n");
			Console.Write(WarningMsg("you MUST use it, or your funds may be lost!"));
			Console.Write("\n");
			Console.Write("Hit enter for the default of no payment ID: ");

			paymentID = Console.ReadLine();

			if (paymentID == "")
			{
				return Just<string>(paymentID);
			}

			if (paymentID == "cancel")
			{
				return Nothing<string>();
			}

			List<byte> extra = new List<byte>();

			/* Convert the payment ID into an "extra" */
			if (!CryptoNote.createTxExtraWithPaymentId(paymentID, extra))
			{
				Console.Write(WarningMsg("Failed to parse! Payment ID's are 64 " + "character hexadecimal strings."));
				Console.Write("\n");
				continue;
			}

			return Just<string>(paymentID);
		}
	}

	public static string getExtraFromPaymentID(string paymentID)
	{
		if (paymentID == "")
		{
			return paymentID;
		}

		List<byte> extra = new List<byte>();

		/* Convert the payment ID into an "extra" */
		CryptoNote.createTxExtraWithPaymentId(paymentID, extra);

		/* Then convert the "extra" back into a string so we can pass
		   the argument that walletgreen expects. Note this string is not
		   the same as the original paymentID string! */
		string extraString;

		foreach (var i in extra)
		{
			extraString += (char)i;
		}

		return extraString;
	}

	public static Maybe<string> getExtra()
	{
		std::stringstream msg = new std::stringstream();

		msg << std::endl << "What payment ID do you want to use?" << std::endl << "These are usually used for sending to exchanges." << std::endl;

		var maybePaymentID = getPaymentID(msg.str());

		if (!maybePaymentID.isJust)
		{
			return maybePaymentID;
		}

		if (maybePaymentID.x == "")
		{
			return maybePaymentID;
		}

		return Just<string>(getExtraFromPaymentID(maybePaymentID.x));
	}

	public static Maybe<ulong> getFee()
	{
		while (true)
		{
			string stringAmount;
			Console.Write("\n");
			Console.Write(InformationMsg("What fee do you want to use?"));
			Console.Write("\n");
			Console.Write("Hit enter for the default fee of ");
			Console.Write(formatAmount(WalletConfig.defaultFee));
			Console.Write(": ");

			stringAmount = Console.ReadLine();

			if (stringAmount == "")
			{
				return Just<ulong>(WalletConfig.defaultFee);
			}

			if (stringAmount == "cancel")
			{
				return Nothing<ulong>();
			}

			ulong amount;

			if (parseFee(stringAmount))
			{
				parseAmount(stringAmount, ref amount);
				return Just<ulong>(amount);
			}
		}
	}

	public static Maybe<ulong> getTransferAmount()
	{
		while (true)
		{
			string stringAmount;

			Console.Write("\n");
			Console.Write(InformationMsg("How much "));
			Console.Write(InformationMsg(WalletConfig.ticker));
			Console.Write(InformationMsg(" do you want to send?: "));

			stringAmount = Console.ReadLine();

			if (stringAmount == "cancel")
			{
				return Nothing<ulong>();
			}

			ulong amount;

			if (parseAmount(stringAmount))
			{
				parseAmount(stringAmount, ref amount);
				return Just<ulong>(amount);
			}
		}
	}

	public static bool parseFee(string feeString)
	{
		ulong fee;

		if (!parseAmount(feeString, ref fee))
		{
			Console.Write(WarningMsg("Failed to parse fee! Ensure you entered the " + "value correctly."));
			Console.Write("\n");
			Console.Write("Please note, you can only use ");
			Console.Write(WalletConfig.numDecimalPlaces);
			Console.Write(" decimal places.");
			Console.Write("\n");

			return false;
		}
		else if (fee < WalletConfig.minimumFee)
		{
			Console.Write(WarningMsg("Fee must be at least "));
			Console.Write(formatAmount(WalletConfig.minimumFee));
			Console.Write("!");
			Console.Write("\n");

			return false;
		}

		return true;
	}

	public static Maybe<Tuple<string, string>> extractIntegratedAddress(string integratedAddress)
	{
		if (integratedAddress.Length != WalletConfig.integratedAddressLength)
		{
			return Nothing<Tuple<string, string>>();
		}

		string decoded;
		ulong prefix;

		/* Need to be able to decode the string as an address */
		if (!Tools.Base58.decode_addr(integratedAddress, prefix, decoded))
		{
			return Nothing<Tuple<string, string>>();
		}

		/* The prefix needs to be the same as the base58 prefix */
		if (prefix != CryptoNote.parameters.CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX)
		{
			return Nothing<Tuple<string, string>>();
		}

		const ulong paymentIDLen = 64;

		/* Grab the payment ID from the decoded address */
		string paymentID = decoded.Substring(0, paymentIDLen);

		/* The binary array encoded keys are the rest of the address */
		string keys = decoded.Substring(paymentIDLen, -1);

		CryptoNote.AccountPublicAddress addr = new CryptoNote.AccountPublicAddress();
		List<byte> ba = Common.asBinaryArray(keys);

		if (!CryptoNote.fromBinaryArray(addr, ba))
		{
			return Nothing<Tuple<string, string>>();
		}

		/* Parse the AccountPublicAddress into a standard wallet address */
		/* Use the calculated prefix from earlier for less typing :p */
		string address = CryptoNote.getAccountAddressAsStr(prefix, addr);

		/* The address out should of course be a valid address */
		if (!parseStandardAddress(address))
		{
			return Nothing<Tuple<string, string>>();
		}

		List<byte> extra = new List<byte>();

		/* And the payment ID out should be valid as well! */
		if (!CryptoNote.createTxExtraWithPaymentId(paymentID, extra))
		{
			return Nothing<Tuple<string, string>>();
		}

		return Just<Tuple<string, string>>({address, paymentID});
	}

	public static Maybe<Tuple<AddressType, string>> getAddress(string msg)
	{
		while (true)
		{
			string address;

			Console.Write(InformationMsg(msg));

			address = Console.ReadLine();
			trim(address);

			if (address == "cancel")
			{
				return Nothing<Tuple<AddressType, string>>();
			}

			var addressType = parseAddress(address);

			if (addressType != NotAnAddress)
			{
				return Just<Tuple<AddressType, string>> ({addressType, address});
			}
		}
	}

	public static AddressType parseAddress(string address)
	{
		if (parseStandardAddress(address))
		{
			return StandardAddress;
		}

		if (parseIntegratedAddress(address))
		{
			return IntegratedAddress;
		}

		/* Failed to parse, lets try and diagnose a more accurate failure message */

		if (address.Length != WalletConfig.standardAddressLength && address.Length != WalletConfig.integratedAddressLength)
		{
			Console.Write(WarningMsg("Address is wrong length!"));
			Console.Write("\n");
			Console.Write("It should be ");
			Console.Write(WalletConfig.standardAddressLength);
			Console.Write(" or ");
			Console.Write(WalletConfig.integratedAddressLength);
			Console.Write(" characters long, but it is ");
			Console.Write(address.Length);
			Console.Write(" characters long!");
			Console.Write("\n");
			Console.Write("\n");

			return NotAnAddress;
		}

		if (address.Substring(0, WalletConfig.addressPrefix.length()) != WalletConfig.addressPrefix)
		{
			Console.Write(WarningMsg("Invalid address! It should start with "));
			Console.Write(WarningMsg(WalletConfig.addressPrefix));
			Console.Write(WarningMsg("!"));
			Console.Write("\n");
			Console.Write("\n");

			return NotAnAddress;
		}

		Console.Write(WarningMsg("Failed to parse address, address is not a "));
		Console.Write(WarningMsg("valid "));
		Console.Write(WarningMsg(WalletConfig.ticker));
		Console.Write(WarningMsg(" address!"));
		Console.Write("\n");
		Console.Write("\n");

		return NotAnAddress;
	}

	public static bool parseIntegratedAddress(string integratedAddress)
	{
		return extractIntegratedAddress(integratedAddress).isJust;
	}

	public static bool parseStandardAddress(string address, bool printErrors)
	{
		ulong prefix;

		CryptoNote.AccountPublicAddress addr = new CryptoNote.AccountPublicAddress();

		bool valid = CryptoNote.parseAccountAddressString(prefix, addr, address);

		if (address.Length != WalletConfig.standardAddressLength)
		{
			if (printErrors)
			{
				Console.Write(WarningMsg("Address is wrong length!"));
				Console.Write("\n");
				Console.Write("It should be ");
				Console.Write(WalletConfig.standardAddressLength);
				Console.Write(" characters long, but it is ");
				Console.Write(address.Length);
				Console.Write(" characters long!");
				Console.Write("\n");
				Console.Write("\n");
			}

			return false;
		}
		/* We can't get the actual prefix if the address is invalid for other
		   reasons. To work around this, we can just check that the address starts
		   with TRTL, as long as the prefix is the TRTL prefix. This keeps it
		   working on testnets with different prefixes. */
		else if (address.Substring(0, WalletConfig.addressPrefix.length()) != WalletConfig.addressPrefix)
		{
			if (printErrors)
			{
				Console.Write(WarningMsg("Invalid address! It should start with "));
				Console.Write(WarningMsg(WalletConfig.addressPrefix));
				Console.Write(WarningMsg("!"));
				Console.Write("\n");
				Console.Write("\n");
			}

			return false;
		}
		/* We can return earlier by checking the value of valid, but then we don't
		   get to give more detailed error messages about the address */
		else if (!valid)
		{
			if (printErrors)
			{
				Console.Write(WarningMsg("Failed to parse address, address is not a "));
				Console.Write(WarningMsg("valid "));
				Console.Write(WarningMsg(WalletConfig.ticker));
				Console.Write(WarningMsg(" address!"));
				Console.Write("\n");
				Console.Write("\n");
			}

			return false;
		}

		return true;
	}

	public static bool parseAmount(string amountString)
	{
		ulong amount;

		if (!parseAmount(amountString, ref amount))
		{
			Console.Write(WarningMsg("Failed to parse amount! Ensure you entered " + "the value correctly."));
			Console.Write("\n");
			Console.Write("Please note, the minimum you can send is ");
			Console.Write(formatAmount(WalletConfig.minimumSend));
			Console.Write(",");
			Console.Write("\n");
			Console.Write("and you can only use ");
			Console.Write(WalletConfig.numDecimalPlaces);
			Console.Write(" decimal places.");
			Console.Write("\n");

			return false;
		}

		return true;
	}



	static void Main(int argc, string[] args)
	{
		/* On ctrl+c the program seems to throw "zedwallet.exe has stopped
		   working" when calling exit(0)... I'm not sure why, this is a bit of
		   a hack, it disables that - possibly some deconstructers calling
		   terminate() */
		#if _WIN32
		SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
		#endif

		Config config = parseArguments(argc, args);

		Console.Write(InformationMsg(CryptoNote.getProjectCLIHeader()));
		Console.Write("\n");

		Logging.LoggerManager logManager = new Logging.LoggerManager();

		/* We'd like these lines to be in the below if(), but because some genius
		   thought it was a good idea to pass everything by reference and then
		   use them after the functions lifetime they go out of scope and break
		   stuff */
		logManager.setMaxLevel(Logging.DEBUGGING);

		Logging.FileLogger fileLogger = new Logging.FileLogger();

		if (config.debug)
		{
			fileLogger.init(WalletConfig.walletName + ".log");
			logManager.addLogger(fileLogger);
		}

		Logging.LoggerRef logger = new Logging.LoggerRef(logManager, WalletConfig.walletName);

		/* Currency contains our coin parameters, such as decimal places, supply */
		CryptoNote.Currency currency = CryptoNote.CurrencyBuilder(logManager).currency();

		System.Dispatcher localDispatcher = new System.Dispatcher();
		System.Dispatcher dispatcher = localDispatcher;

		/* Our connection to turtlecoind */
		std::unique_ptr<CryptoNote.INode> node = new std::unique_ptr<CryptoNote.INode>(new CryptoNote.NodeRpcProxy(config.host, config.port, logger.getLogger()));

		std::promise<std::error_code> errorPromise = new std::promise<std::error_code>();

		/* Once the function is complete, set the error value from the promise */
//C++ TO C# CONVERTER TODO TASK: Lambda expressions cannot be assigned to 'var':
	var callback = (std::error_code e) =>
	{
		errorPromise.set_value(e);
	};

		/* Get the future of the result */
		var initNode = errorPromise.get_future();

		node.init(callback);

		/* Connection took to long to remote node, let program continue regardless
		   as they could perform functions like export_keys without being
		   connected */
		if (initNode.wait_for(std::chrono.seconds(20)) != std::future_status.ready)
		{
			if (config.host != "127.0.0.1")
			{
				Console.Write(WarningMsg("Unable to connect to remote node, " + "connection timed out."));
				Console.Write("\n");
				Console.Write(WarningMsg("Confirm the remote node is functioning, " + "or try a different remote node."));
				Console.Write("\n");
				Console.Write("\n");
			}
			else
			{
				Console.Write(WarningMsg("Unable to connect to node, " + "connection timed out."));
				Console.Write("\n");
				Console.Write("\n");
			}
		}

		/*
		  This will check to see if the node responded to /feeinfo and actually
		  returned something that it expects us to use for convenience charges
		  for using that node to send transactions.
		*/
		if (node.feeAmount() != 0 && !node.feeAddress().empty())
		{
		  std::stringstream feemsg = new std::stringstream();

		  feemsg << std::endl << "You have connected to a node that charges " << "a fee to send transactions." << std::endl << std::endl << "The fee for sending transactions is: " << formatAmount(node.feeAmount()) << " per transaction." << std::endl << std::endl << "If you don't want to pay the node fee, please " << "relaunch " << WalletConfig.walletName << " and specify a different node or run your own." << std::endl;

		  Console.Write(WarningMsg(feemsg.str()));
		  Console.Write("\n");
		}

		/* Create the wallet instance */
		CryptoNote.WalletGreen wallet = new CryptoNote.WalletGreen(dispatcher, currency, *node, logger.getLogger());

		/* Run the interactive wallet interface */
		run(wallet, *node, config);
	}

	public static void run(CryptoNote.WalletGreen wallet, CryptoNote.INode node, Config config)
	{
		var (quit, walletInfo) = selectionScreen(config, wallet, node);

		bool alreadyShuttingDown = false;

		if (!quit)
		{
			/* Call shutdown on ctrl+c */
			/* walletInfo = walletInfo - workaround for
			   https://stackoverflow.com/a/46115028/8737306 - standard &
			   capture works in newer compilers. */
		Tools.SignalHandler.install(() =>
		{
			/* If we're already shutting down let control flow continue
			   as normal */
			if (shutdown(walletInfo, node, alreadyShuttingDown))
			{
				Environment.Exit(0);
			}
		});

			mainLoop(walletInfo, node);
		}

		shutdown(walletInfo, node, alreadyShuttingDown);
	}

	// Copyright (c) 2018, The TurtleCoin Developers
	//
	// Please see the included LICENSE file for more information


	public static readonly string windowsAsciiArt = "\n _______         _   _       _____      _        \n" + "|__   __|       | | | |     / ____|    (_)      \n" + "   | |_   _ _ __| |_| | ___| |     ___  _ _ __  \n" + "   | | | | | '__| __| |/ _ \\ |    / _ \\| | '_ \\ \n" + "   | | |_| | |  | |_| |  __/ |___| (_) | | | | |\n" + "   |_|\\__ _|_|   \\__|_|\\___|\\_____\\___/|_|_| |_|\n";

	public static readonly string nonWindowsAsciiArt = "\n                                                                            \n" + "████████╗██╗  ██╗██████╗ ████████╗██╗    ██████╗ █████╗ █████╗ ██╗███╗   ██╗\n" + "╚══██╔══╝██║  ██║██╔══██╗╚══██╔══╝██║    ██╔═══╝██╔═══╝██╔══██╗██║████╗  ██║\n" + "   ██║   ██║  ██║██████╔╝   ██║   ██║    ████╗  ██║    ██║  ██║██║██╔██╗ ██║\n" + "   ██║   ██║  ██║██╔══██╗   ██║   ██║    ██╔═╝  ██║    ██║  ██║██║██║╚██╗██║\n" + "   ██║   ╚█████╔╝██║  ██║   ██║   ██████╗██████╗╚█████╗╚█████╔╝██║██║ ╚████║\n" + "   ╚═╝    ╚════╝ ╚═╝  ╚═╝   ╚═╝   ╚═════╝╚═════╝ ╚════╝ ╚════╝ ╚═╝╚═╝  ╚═══╝\n";

	/* Windows has some characters it won't display in a terminal. If your ascii
	   art works fine on Windows and Linux terminals, just replace 'asciiArt' with
	   the art itself, and remove these two #ifdefs and above ascii arts */
	#if _WIN32
	public static readonly string asciiArt = windowsAsciiArt;
	#else
	public static readonly string asciiArt = nonWindowsAsciiArt;
	#endif

	public static readonly uint[] T = {0xa5f432c6, 0xc6a597f4, 0x84976ff8, 0xf884eb97, 0x99b05eee, 0xee99c7b0, 0x8d8c7af6, 0xf68df78c, 0xd17e8ff, 0xff0de517, 0xbddc0ad6, 0xd6bdb7dc, 0xb1c816de, 0xdeb1a7c8, 0x54fc6d91, 0x915439fc, 0x50f09060, 0x6050c0f0, 0x3050702, 0x2030405, 0xa9e02ece, 0xcea987e0, 0x7d87d156, 0x567dac87, 0x192bcce7, 0xe719d52b, 0x62a613b5, 0xb56271a6, 0xe6317c4d, 0x4de69a31, 0x9ab559ec, 0xec9ac3b5, 0x45cf408f, 0x8f4505cf, 0x9dbca31f, 0x1f9d3ebc, 0x40c04989, 0x894009c0, 0x879268fa, 0xfa87ef92, 0x153fd0ef, 0xef15c53f, 0xeb2694b2, 0xb2eb7f26, 0xc940ce8e, 0x8ec90740, 0xb1de6fb, 0xfb0bed1d, 0xec2f6e41, 0x41ec822f, 0x67a91ab3, 0xb3677da9, 0xfd1c435f, 0x5ffdbe1c, 0xea256045, 0x45ea8a25, 0xbfdaf923, 0x23bf46da, 0xf7025153, 0x53f7a602, 0x96a145e4, 0xe496d3a1, 0x5bed769b, 0x9b5b2ded, 0xc25d2875, 0x75c2ea5d, 0x1c24c5e1, 0xe11cd924, 0xaee9d43d, 0x3dae7ae9, 0x6abef24c, 0x4c6a98be, 0x5aee826c, 0x6c5ad8ee, 0x41c3bd7e, 0x7e41fcc3, 0x206f3f5, 0xf502f106, 0x4fd15283, 0x834f1dd1, 0x5ce48c68, 0x685cd0e4, 0xf4075651, 0x51f4a207, 0x345c8dd1, 0xd134b95c, 0x818e1f9, 0xf908e918, 0x93ae4ce2, 0xe293dfae, 0x73953eab, 0xab734d95, 0x53f59762, 0x6253c4f5, 0x3f416b2a, 0x2a3f5441, 0xc141c08, 0x80c1014, 0x52f66395, 0x955231f6, 0x65afe946, 0x46658caf, 0x5ee27f9d, 0x9d5e21e2, 0x28784830, 0x30286078, 0xa1f8cf37, 0x37a16ef8, 0xf111b0a, 0xa0f1411, 0xb5c4eb2f, 0x2fb55ec4, 0x91b150e, 0xe091c1b, 0x365a7e24, 0x2436485a, 0x9bb6ad1b, 0x1b9b36b6, 0x3d4798df, 0xdf3da547, 0x266aa7cd, 0xcd26816a, 0x69bbf54e, 0x4e699cbb, 0xcd4c337f, 0x7fcdfe4c, 0x9fba50ea, 0xea9fcfba, 0x1b2d3f12, 0x121b242d, 0x9eb9a41d, 0x1d9e3ab9, 0x749cc458, 0x5874b09c, 0x2e724634, 0x342e6872, 0x2d774136, 0x362d6c77, 0xb2cd11dc, 0xdcb2a3cd, 0xee299db4, 0xb4ee7329, 0xfb164d5b, 0x5bfbb616, 0xf601a5a4, 0xa4f65301, 0x4dd7a176, 0x764decd7, 0x61a314b7, 0xb76175a3, 0xce49347d, 0x7dcefa49, 0x7b8ddf52, 0x527ba48d, 0x3e429fdd, 0xdd3ea142, 0x7193cd5e, 0x5e71bc93, 0x97a2b113, 0x139726a2, 0xf504a2a6, 0xa6f55704, 0x68b801b9, 0xb96869b8, 0x0, 0x0, 0x2c74b5c1, 0xc12c9974, 0x60a0e040, 0x406080a0, 0x1f21c2e3, 0xe31fdd21, 0xc8433a79, 0x79c8f243, 0xed2c9ab6, 0xb6ed772c, 0xbed90dd4, 0xd4beb3d9, 0x46ca478d, 0x8d4601ca, 0xd9701767, 0x67d9ce70, 0x4bddaf72, 0x724be4dd, 0xde79ed94, 0x94de3379, 0xd467ff98, 0x98d42b67, 0xe82393b0, 0xb0e87b23, 0x4ade5b85, 0x854a11de, 0x6bbd06bb, 0xbb6b6dbd, 0x2a7ebbc5, 0xc52a917e, 0xe5347b4f, 0x4fe59e34, 0x163ad7ed, 0xed16c13a, 0xc554d286, 0x86c51754, 0xd762f89a, 0x9ad72f62, 0x55ff9966, 0x6655ccff, 0x94a7b611, 0x119422a7, 0xcf4ac08a, 0x8acf0f4a, 0x1030d9e9, 0xe910c930, 0x60a0e04, 0x406080a, 0x819866fe, 0xfe81e798, 0xf00baba0, 0xa0f05b0b, 0x44ccb478, 0x7844f0cc, 0xbad5f025, 0x25ba4ad5, 0xe33e754b, 0x4be3963e, 0xf30eaca2, 0xa2f35f0e, 0xfe19445d, 0x5dfeba19, 0xc05bdb80, 0x80c01b5b, 0x8a858005, 0x58a0a85, 0xadecd33f, 0x3fad7eec, 0xbcdffe21, 0x21bc42df, 0x48d8a870, 0x7048e0d8, 0x40cfdf1, 0xf104f90c, 0xdf7a1963, 0x63dfc67a, 0xc1582f77, 0x77c1ee58, 0x759f30af, 0xaf75459f, 0x63a5e742, 0x426384a5, 0x30507020, 0x20304050, 0x1a2ecbe5, 0xe51ad12e, 0xe12effd, 0xfd0ee112, 0x6db708bf, 0xbf6d65b7, 0x4cd45581, 0x814c19d4, 0x143c2418, 0x1814303c, 0x355f7926, 0x26354c5f, 0x2f71b2c3, 0xc32f9d71, 0xe13886be, 0xbee16738, 0xa2fdc835, 0x35a26afd, 0xcc4fc788, 0x88cc0b4f, 0x394b652e, 0x2e395c4b, 0x57f96a93, 0x93573df9, 0xf20d5855, 0x55f2aa0d, 0x829d61fc, 0xfc82e39d, 0x47c9b37a, 0x7a47f4c9, 0xacef27c8, 0xc8ac8bef, 0xe73288ba, 0xbae76f32, 0x2b7d4f32, 0x322b647d, 0x95a442e6, 0xe695d7a4, 0xa0fb3bc0, 0xc0a09bfb, 0x98b3aa19, 0x199832b3, 0xd168f69e, 0x9ed12768, 0x7f8122a3, 0xa37f5d81, 0x66aaee44, 0x446688aa, 0x7e82d654, 0x547ea882, 0xabe6dd3b, 0x3bab76e6, 0x839e950b, 0xb83169e, 0xca45c98c, 0x8cca0345, 0x297bbcc7, 0xc729957b, 0xd36e056b, 0x6bd3d66e, 0x3c446c28, 0x283c5044, 0x798b2ca7, 0xa779558b, 0xe23d81bc, 0xbce2633d, 0x1d273116, 0x161d2c27, 0x769a37ad, 0xad76419a, 0x3b4d96db, 0xdb3bad4d, 0x56fa9e64, 0x6456c8fa, 0x4ed2a674, 0x744ee8d2, 0x1e223614, 0x141e2822, 0xdb76e492, 0x92db3f76, 0xa1e120c, 0xc0a181e, 0x6cb4fc48, 0x486c90b4, 0xe4378fb8, 0xb8e46b37, 0x5de7789f, 0x9f5d25e7, 0x6eb20fbd, 0xbd6e61b2, 0xef2a6943, 0x43ef862a, 0xa6f135c4, 0xc4a693f1, 0xa8e3da39, 0x39a872e3, 0xa4f7c631, 0x31a462f7, 0x37598ad3, 0xd337bd59, 0x8b8674f2, 0xf28bff86, 0x325683d5, 0xd532b156, 0x43c54e8b, 0x8b430dc5, 0x59eb856e, 0x6e59dceb, 0xb7c218da, 0xdab7afc2, 0x8c8f8e01, 0x18c028f, 0x64ac1db1, 0xb16479ac, 0xd26df19c, 0x9cd2236d, 0xe03b7249, 0x49e0923b, 0xb4c71fd8, 0xd8b4abc7, 0xfa15b9ac, 0xacfa4315, 0x709faf3, 0xf307fd09, 0x256fa0cf, 0xcf25856f, 0xafea20ca, 0xcaaf8fea, 0x8e897df4, 0xf48ef389, 0xe9206747, 0x47e98e20, 0x18283810, 0x10182028, 0xd5640b6f, 0x6fd5de64, 0x888373f0, 0xf088fb83, 0x6fb1fb4a, 0x4a6f94b1, 0x7296ca5c, 0x5c72b896, 0x246c5438, 0x3824706c, 0xf1085f57, 0x57f1ae08, 0xc7522173, 0x73c7e652, 0x51f36497, 0x975135f3, 0x2365aecb, 0xcb238d65, 0x7c8425a1, 0xa17c5984, 0x9cbf57e8, 0xe89ccbbf, 0x21635d3e, 0x3e217c63, 0xdd7cea96, 0x96dd377c, 0xdc7f1e61, 0x61dcc27f, 0x86919c0d, 0xd861a91, 0x85949b0f, 0xf851e94, 0x90ab4be0, 0xe090dbab, 0x42c6ba7c, 0x7c42f8c6, 0xc4572671, 0x71c4e257, 0xaae529cc, 0xccaa83e5, 0xd873e390, 0x90d83b73, 0x50f0906, 0x6050c0f, 0x103f4f7, 0xf701f503, 0x12362a1c, 0x1c123836, 0xa3fe3cc2, 0xc2a39ffe, 0x5fe18b6a, 0x6a5fd4e1, 0xf910beae, 0xaef94710, 0xd06b0269, 0x69d0d26b, 0x91a8bf17, 0x17912ea8, 0x58e87199, 0x995829e8, 0x2769533a, 0x3a277469, 0xb9d0f727, 0x27b94ed0, 0x384891d9, 0xd938a948, 0x1335deeb, 0xeb13cd35, 0xb3cee52b, 0x2bb356ce, 0x33557722, 0x22334455, 0xbbd604d2, 0xd2bbbfd6, 0x709039a9, 0xa9704990, 0x89808707, 0x7890e80, 0xa7f2c133, 0x33a766f2, 0xb6c1ec2d, 0x2db65ac1, 0x22665a3c, 0x3c227866, 0x92adb815, 0x15922aad, 0x2060a9c9, 0xc9208960, 0x49db5c87, 0x874915db, 0xff1ab0aa, 0xaaff4f1a, 0x7888d850, 0x5078a088, 0x7a8e2ba5, 0xa57a518e, 0x8f8a8903, 0x38f068a, 0xf8134a59, 0x59f8b213, 0x809b9209, 0x980129b, 0x1739231a, 0x1a173439, 0xda751065, 0x65daca75, 0x315384d7, 0xd731b553, 0xc651d584, 0x84c61351, 0xb8d303d0, 0xd0b8bbd3, 0xc35edc82, 0x82c31f5e, 0xb0cbe229, 0x29b052cb, 0x7799c35a, 0x5a77b499, 0x11332d1e, 0x1e113c33, 0xcb463d7b, 0x7bcbf646, 0xfc1fb7a8, 0xa8fc4b1f, 0xd6610c6d, 0x6dd6da61, 0x3a4e622c, 0x2c3a584e};



	public static bool operator < (NetworkAddress a, NetworkAddress b)
	{
		return std::tie(a.ip, a.port) < std::tie(b.ip, b.port);
	}

	public static bool operator == (NetworkAddress a, NetworkAddress b)
	{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
		return memcmp(a, b, sizeof(NetworkAddress)) == 0;
	}

	public static std::ostream operator << (std::ostream s, NetworkAddress na)
	{
		return s << Common.ipAddressToString(na.ip) << ":" << Convert.ToString(na.port);
	}

	public static uint hostToNetwork(uint n)
	{
		return (n << 24) | (n & 0xff00) << 8 | (n & 0xff0000) >> 8 | (n >> 24);
	}

	public static uint networkToHost(uint n)
	{
		return hostToNetwork(n); // the same
	}
	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.


//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void addToAddressBook();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void sendFromAddressBook(WalletInfo walletInfo, uint height, string nodeAddress, uint nodeFee);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void deleteFromAddressBook();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void listAddressBook();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//Maybe<string> getAddressBookPaymentID();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//Maybe< string> getAddressBookAddress();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//Maybe< AddressBookEntry> getAddressBookEntry(AddressBook addressBook);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string getAddressBookName(AddressBook addressBook);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//AddressBook getAddressBook();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool saveAddressBook(AddressBook addressBook);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool isAddressBookEmpty(AddressBook addressBook);

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.



//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool handleCommand(string command, WalletInfo walletInfo, CryptoNote::INode node);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//WalletInfo handleLaunchCommand(CryptoNote::WalletGreen wallet, string launchCommand, Config config);

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.




//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool handleCommand(string command, WalletInfo walletInfo, CryptoNote::INode node);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void changePassword(WalletInfo walletInfo);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void printPrivateKeys(CryptoNote::WalletGreen wallet, bool viewWallet);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void reset(CryptoNote::INode node, WalletInfo walletInfo);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void status(CryptoNote::INode node, CryptoNote::WalletGreen wallet);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void printHeights(uint localHeight, uint remoteHeight, uint walletHeight);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void printSyncStatus(uint localHeight, uint remoteHeight, uint walletHeight);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void printSyncSummary(uint localHeight, uint remoteHeight, uint walletHeight);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void printPeerCount(uint peerCount);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void printHashrate(ulong difficulty);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void balance(CryptoNote::INode node, CryptoNote::WalletGreen wallet, bool viewWallet);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void exportKeys(WalletInfo walletInfo);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void saveCSV(CryptoNote::WalletGreen wallet, CryptoNote::INode node);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void save(CryptoNote::WalletGreen wallet);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void listTransfers(bool incoming, bool outgoing, CryptoNote::WalletGreen wallet, CryptoNote::INode node);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void printOutgoingTransfer(CryptoNote::WalletTransaction t, CryptoNote::INode node);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void printIncomingTransfer(CryptoNote::WalletTransaction t, CryptoNote::INode node);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void createIntegratedAddress();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void help(WalletInfo wallet);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void advanced(WalletInfo wallet);


//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//ClassicVector<Command> startupCommands();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//ClassicVector<Command> nodeDownCommands();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//ClassicVector<AdvancedCommand> allCommands();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//ClassicVector<AdvancedCommand> basicCommands();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//ClassicVector<AdvancedCommand> advancedCommands();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//ClassicVector<AdvancedCommand> basicViewWalletCommands();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//ClassicVector<AdvancedCommand> advancedViewWalletCommands();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//ClassicVector<AdvancedCommand> allViewWalletCommands();

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.



//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool fusionTX(CryptoNote::WalletGreen wallet, CryptoNote::TransactionParameters p, ulong height);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool optimize(CryptoNote::WalletGreen wallet, ulong threshold, ulong height);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void fullOptimize(CryptoNote::WalletGreen wallet, ulong height);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//uint makeFusionTransaction(CryptoNote::WalletGreen wallet, ulong threshold, ulong height);

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.





//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string yellowANSIMsg(string msg);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string getPrompt(WalletInfo walletInfo);

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string getInputAndWorkInBackground<T>(ClassicVector<T> availableCommands, string prompt, bool backgroundRefresh, WalletInfo walletInfo);

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string getInput<T>(ClassicVector<T> availableCommands, string prompt);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string parseCommand<T>(ClassicVector<T> printableCommands, ClassicVector<T> availableCommands, string prompt, bool backgroundRefresh, WalletInfo walletInfo);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//System.Tuple<bool, WalletInfo> selectionScreen<T>(Config config, CryptoNote::WalletGreen wallet, CryptoNote::INode node);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool checkNodeStatus<T>(CryptoNote::INode node);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string getAction<T>(Config config);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void mainLoop<T>(WalletInfo walletInfo, CryptoNote::INode node);

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void printCommands<T>(ClassicVector<T> commands, uint offset = 0);

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.



//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//WalletInfo importFromKeys(CryptoNote::WalletGreen wallet, Crypto::SecretKey privateSpendKey, Crypto::SecretKey privateViewKey);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//WalletInfo openWallet(CryptoNote::WalletGreen wallet, Config config);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//WalletInfo createViewWallet(CryptoNote::WalletGreen wallet);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//WalletInfo importWallet(CryptoNote::WalletGreen wallet);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//WalletInfo createViewWallet(CryptoNote::WalletGreen wallet);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//WalletInfo mnemonicImportWallet(CryptoNote::WalletGreen wallet);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//WalletInfo generateWallet(CryptoNote::WalletGreen wallet);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//Crypto::SecretKey getPrivateKey(string outputMsg);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string getNewWalletFileName();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string getExistingWalletFileName(Config config);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string getWalletPassword(bool verifyPwd, string msg);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool isValidMnemonic(string mnemonic_phrase, Crypto::SecretKey private_spend_key);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void logIncorrectMnemonicWords(ClassicVector<string> words);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void viewWalletMsg();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void connectingMsg();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void promptSaveKeys(CryptoNote::WalletGreen wallet);

	// Copyright (c) 2018, The TurtleCoin Developers
	//
	// Please see the included LICENSE file for more information.



//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//Config parseArguments(int argc, string[] argv);

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.



//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void syncWallet(CryptoNote::INode node, WalletInfo walletInfo);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void checkForNewTransactions(WalletInfo walletInfo);

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.








//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void confirmPassword(string walletPass, string msg = "");

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void removeCharFromString(string str, char c);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void trim(string str);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void leftTrim(string str);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void rightTrim(string str);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool confirm(string msg);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool confirm(string msg, bool defaultReturn);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool startsWith(string str, string substring);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool fileExists(string filename);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool shutdown(WalletInfo walletInfo, CryptoNote::INode node, ref bool alreadyShuttingDown);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string formatAmountBasic(ulong amount);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string formatAmount(ulong amount);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string formatDollars(ulong amount);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string formatCents(ulong amount);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string getPaymentIDFromExtra(string extra);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string unixTimeToDate(ulong timestamp);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string createIntegratedAddress(string address, string paymentID);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//ulong getDivisor();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//ulong getScanHeight();

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T, typename Function>
	public static List<T> filter<T, Function>(List<T> input, Function predicate)
	{
		List<T> result = new List<T>();

		std::copy_if(input.GetEnumerator(), input.end(), std::back_inserter(result), predicate);

		return result;
	}

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//ClassicVector<string> split(string str, char delim);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool parseDaemonAddressFromString(string host, ref int port, string address);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void transfer(WalletInfo walletInfo, uint height, bool sendAll = false, string nodeAddress = string(), uint nodeFee = 0);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void doTransfer(string address, ulong amount, ulong fee, string extra, WalletInfo walletInfo, uint height, bool integratedAddress, ulong mixin, string nodeAddress, uint nodeFee, string originalAddress);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void splitTX(CryptoNote::WalletGreen wallet, CryptoNote::TransactionParameters splitTXParams, uint nodeFee);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void sendTX(WalletInfo walletInfo, CryptoNote::TransactionParameters p, uint height, bool retried = false, uint nodeFee = 0);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool confirmTransaction(CryptoNote::TransactionParameters t, WalletInfo walletInfo, bool integratedAddress, uint nodeFee, string originalAddress);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool parseAmount(string amountString);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool parseStandardAddress(string address, bool printErrors = false);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool parseIntegratedAddress(string address);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool parseFee(string feeString);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//bool handleTransferError(std::system_error e, bool retried, uint height);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//AddressType parseAddress(string address);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string getExtraFromPaymentID(string paymentID);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//Maybe<string> getPaymentID(string msg);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//Maybe<string> getExtra();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//Maybe<System.Tuple<AddressType, string>> getAddress(string msg);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//Maybe<ulong> getFee();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//Maybe<ulong> getTransferAmount();

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//Maybe<System.Tuple<string, string>> extractIntegratedAddress(string integratedAddress);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//BalanceInfo doWeHaveEnoughBalance(ulong amount, ulong fee, WalletInfo walletInfo, ulong height, uint nodeFee);

	public static Maybe<X> Just<X>(X x)
	{
		return new Maybe<X>(x);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <class X>
	public static Maybe<X> Nothing<X>()
	{
		return new Maybe<X>();
	}

	// Copyright (c) 2018, The TurtleCoin Developers
	// 
	// Please see the included LICENSE file for more information.




//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//static int Main(int argc, string[] argv);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void run(CryptoNote::WalletGreen wallet, CryptoNote::INode node, Config config);

	}

namespace Tools.Base58
{
	public static class GlobalMembers
	{
		public static string encode(string data)
		{
		  if (string.IsNullOrEmpty(data))
		  {
			return string();
		  }

		  ulong full_block_count = data.Length / GlobalMembers.full_block_size;
		  ulong last_block_size = data.Length % GlobalMembers.full_block_size;
		  ulong res_size = full_block_count * GlobalMembers.full_encoded_block_size + GlobalMembers.encoded_block_sizes[last_block_size];

		  string res = new string(res_size, GlobalMembers.alphabet[0]);
		  for (ulong i = 0; i < full_block_count; ++i)
		  {
			GlobalMembers.encode_block(data.data() + i * GlobalMembers.full_block_size, new ulong(GlobalMembers.full_block_size), ref res[i * GlobalMembers.full_encoded_block_size]);
		  }

		  if (0 < last_block_size)
		  {
			GlobalMembers.encode_block(data.data() + full_block_count * GlobalMembers.full_block_size, new ulong(last_block_size), ref res[full_block_count * GlobalMembers.full_encoded_block_size]);
		  }

		  return res;
		}
		public static bool decode(string enc, string data)
		{
		  if (string.IsNullOrEmpty(enc))
		  {
			data = "";
			return true;
		  }

		  ulong full_block_count = enc.Length / GlobalMembers.full_encoded_block_size;
		  ulong last_block_size = enc.Length % GlobalMembers.full_encoded_block_size;
		  int last_block_decoded_size = decoded_block_sizes.instance(last_block_size);
		  if (last_block_decoded_size < 0)
		  {
			return false; // Invalid enc length
		  }
		  ulong data_size = full_block_count * GlobalMembers.full_block_size + last_block_decoded_size;

		  data.resize(data_size, 0);
		  for (ulong i = 0; i < full_block_count; ++i)
		  {
			if (!GlobalMembers.decode_block(enc.data() + i * GlobalMembers.full_encoded_block_size, new ulong(GlobalMembers.full_encoded_block_size), ref data[i * GlobalMembers.full_block_size]))
			{
			  return false;
			}
		  }

		  if (0 < last_block_size)
		  {
			if (!GlobalMembers.decode_block(enc.data() + full_block_count * GlobalMembers.full_encoded_block_size, new ulong(last_block_size), ref data[full_block_count * GlobalMembers.full_block_size]))
			{
			  return false;
			}
		  }

		  return true;
		}

		public static string encode_addr(ulong tag, string data)
		{
		  string buf = Tools.GlobalMembers.get_varint_data(tag);
		  buf += data;
		  Crypto.Hash hash = Crypto.GlobalMembers.cn_fast_hash(buf.data(), buf.Length);
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const char* hash_data = reinterpret_cast<const char*>(&hash);
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		  char hash_data = reinterpret_cast<const char>(hash);
		  buf.append(hash_data, GlobalMembers.addr_checksum_size);
		  return Base58.GlobalMembers.encode(buf);
		}
		public static bool decode_addr(string addr, ulong tag, ref string data)
		{
		  string addr_data;
		  bool r = Base58.GlobalMembers.decode(addr, addr_data);
		  if (!r)
		  {
			  return false;
		  }
		  if (addr_data.Length <= GlobalMembers.addr_checksum_size)
		  {
			  return false;
		  }

		  string checksum = new string(GlobalMembers.addr_checksum_size, '\0');
		  checksum = addr_data.Substring(addr_data.Length - GlobalMembers.addr_checksum_size);

		  addr_data.resize(addr_data.Length - GlobalMembers.addr_checksum_size);
		  Crypto.Hash hash = Crypto.GlobalMembers.cn_fast_hash(addr_data.data(), addr_data.Length);
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		  string expected_checksum = new string(reinterpret_cast<const char>(hash), GlobalMembers.addr_checksum_size);
		  if (expected_checksum != checksum)
		  {
			  return false;
		  }

		  int read = Tools.GlobalMembers.read_varint(addr_data.GetEnumerator(), addr_data.end(), tag);
		  if (read <= 0)
		  {
			  return false;
		  }

		  data = addr_data.Substring(read);
		  return true;
		}
		  public const string alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
		  public static readonly ulong alphabet_size = sizeof(alphabet) - 1;
		  public static readonly ulong[] encoded_block_sizes = {0, 2, 3, 5, 6, 7, 9, 10, 11};
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: const ulong full_block_size = sizeof(encoded_block_sizes) / sizeof(encoded_block_sizes[0]) - 1;
		  public static readonly ulong full_block_size = encoded_block_sizes.Length - 1;
		  public static readonly ulong full_encoded_block_size = encoded_block_sizes[full_block_size];
		  public static readonly ulong addr_checksum_size = 4;


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'data', so pointers on this parameter are left unchanged:
		  public static ulong uint_8be_to_64(ushort * data, ulong size)
		  {
			Debug.Assert(1 <= size != null && size <= sizeof(ulong));

			ulong res = 0;
			switch (9 - size)
			{
			case 1:
				res |= *data++; // fallthrough
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			case 2:
				res <<= 8;
				res |= *data++; // fallthrough
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			case 3:
				res <<= 8;
				res |= *data++; // fallthrough
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			case 4:
				res <<= 8;
				res |= *data++; // fallthrough
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			case 5:
				res <<= 8;
				res |= *data++; // fallthrough
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			case 6:
				res <<= 8;
				res |= *data++; // fallthrough
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			case 7:
				res <<= 8;
				res |= *data++; // fallthrough
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			case 8:
				res <<= 8;
				res |= *data;
				break;
			default:
				Debug.Assert(false);
			break;
			}

			return res;
		  }

		  public static void uint_64_to_8be(ulong num, ulong size, ushort data)
		  {
			Debug.Assert(1 <= size != null && size <= sizeof(ulong));

			ulong num_be = SWAP64BE(num);
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(data, reinterpret_cast<ushort>(num_be) + sizeof(ulong) - size, size);
		  }

		  public static void encode_block(string block, ulong size, ref string res)
		  {
			Debug.Assert(1 <= size != null && size <= GlobalMembers.full_block_size);

//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
			ulong num = GlobalMembers.uint_8be_to_64(reinterpret_cast<const ushort>(block), new ulong(size));
			int i = (int)GlobalMembers.encoded_block_sizes[size] - 1;
			while (0 < num)
			{
			  ulong remainder = num % GlobalMembers.alphabet_size;
			  num /= GlobalMembers.alphabet_size;
			  res[i] = GlobalMembers.alphabet[remainder];
			  --i;
			}
		  }

		  public static bool decode_block(string block, ulong size, ref string res)
		  {
			Debug.Assert(1 <= size != null && size <= GlobalMembers.full_encoded_block_size);

			int res_size = decoded_block_sizes.instance(size);
			if (res_size <= 0)
			{
			  return false; // Invalid block size
			}

			ulong res_num = 0;
			ulong order = 1;
			for (ulong i = size - 1; i < size; --i)
			{
			  int digit = reverse_alphabet.instance(block[i]);
			  if (digit < 0)
			  {
				return false; // Invalid symbol
			  }

			  ulong product_hi = new ulong();
			  ulong tmp = res_num + GlobalMembers.mul128(new ulong(order), digit, product_hi);
			  if (tmp < res_num || 0 != product_hi)
			  {
				return false; // Overflow
			  }

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: res_num = tmp;
			  res_num.CopyFrom(tmp);
			  order *= GlobalMembers.alphabet_size; // Never overflows, 58^10 < 2^64
			}

			if ((ulong)res_size < GlobalMembers.full_block_size && (UINT64_C(1) << (8 * res_size)) <= res_num)
			{
			  return false; // Overflow
			}

//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
			GlobalMembers.uint_64_to_8be(new ulong(res_num), res_size, reinterpret_cast<ushort>(res));

			return true;
		  }
	}
}

namespace command_line
{
	public static class GlobalMembers
	{
	  public static boost::program_options.typed_value<T, char> make_semantic<T>(arg_descriptor<T, true> UnnamedParameter)
	  {
		return boost::program_options.value<T>().required();
	  }

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	  public static boost::program_options.typed_value<T, char> make_semantic<T>(arg_descriptor<T, false> arg)
	  {
		var semantic = boost::program_options.value<T>();
		if (!arg.not_use_default)
		{
		  semantic.default_value(arg.default_value);
		}
		return semantic;
	  }

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	  public static boost::program_options.typed_value<T, char> make_semantic<T>(arg_descriptor<T, false> arg, T def)
	  {
		var semantic = boost::program_options.value<T>();
		if (!arg.not_use_default)
		{
		  semantic.default_value(def);
		}
		return semantic;
	  }

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	  public static boost::program_options.typed_value<List<T>, char> make_semantic<T>(arg_descriptor<List<T>, false> UnnamedParameter)
	  {
		var semantic = boost::program_options.value< List<T>>();
		semantic.default_value(new List<T>(), "");
		return semantic;
	  }

//C++ TO C# CONVERTER TODO TASK: C++ template specifiers with non-type parameters cannot be converted to C#:
//ORIGINAL LINE: template<typename T, bool required>
	  public static void add_arg<T, bool required>(boost::program_options.options_description description, arg_descriptor<T, required> arg, bool unique = true)
	  {
		if (unique && 0 != description.find_nothrow(arg.name, false))
		{
		  std::cerr << "Argument already exists: " << arg.name << std::endl;
		  return;
		}

		description.add_options()(arg.name, make_semantic(arg), arg.description);
	  }

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	  public static void add_arg<T>(boost::program_options.options_description description, arg_descriptor<T, false> arg, T def, bool unique = true)
	  {
		if (unique && 0 != description.find_nothrow(arg.name, false))
		{
		  std::cerr << "Argument already exists: " << arg.name << std::endl;
		  return;
		}

		description.add_options()(arg.name, make_semantic(arg, def), arg.description);
	  }

	  public static void add_arg(boost::program_options.options_description description, arg_descriptor<bool, false> arg, bool unique)
	  {
		if (unique && 0 != description.find_nothrow(arg.name, false))
		{
		  std::cerr << "Argument already exists: " << arg.name << std::endl;
		  return;
		}

		description.add_options()(arg.name, boost::program_options.bool_switch(), arg.description);
	  }

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename charT>
	  public static boost::program_options.basic_parsed_options<charT> parse_command_line<charT>(int argc, charT[] argv, boost::program_options.options_description desc, bool allow_unregistered = false)
	  {
		var parser = boost::program_options.command_line_parser(argc, argv);
		parser.options(desc);
		if (allow_unregistered)
		{
		  parser.allow_unregistered();
		}
		return parser.run();
	  }

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename F>
	  public static bool handle_error_helper<F>(boost::program_options.options_description desc, F parser)
	  {
		try
		{
		  return parser();
		}
		catch (System.Exception e)
		{
		  std::cerr << "Failed to parse arguments: " << e.Message << std::endl;
		  std::cerr << desc << std::endl;
		  return false;
		}
		catch
		{
		  std::cerr << "Failed to parse arguments: unknown exception" << std::endl;
		  std::cerr << desc << std::endl;
		  return false;
		}
	  }

//C++ TO C# CONVERTER TODO TASK: C++ template specifiers with non-type parameters cannot be converted to C#:
//ORIGINAL LINE: template<typename T, bool required>
	  public static bool has_arg<T, bool required>(boost::program_options.variables_map vm, arg_descriptor<T, required> arg)
	  {
		var value = vm[arg.name];
		return !value.empty();
	  }


//C++ TO C# CONVERTER TODO TASK: C++ template specifiers with non-type parameters cannot be converted to C#:
//ORIGINAL LINE: template<typename T, bool required>
	  public static T get_arg<T, bool required>(boost::program_options.variables_map vm, arg_descriptor<T, required> arg)
	  {
		return vm[arg.name].template @as<T>();
	  }

//C++ TO C# CONVERTER TODO TASK: C++ template specialization was removed by C++ to C# Converter:
//ORIGINAL LINE: inline bool has_arg<bool, false>(const boost::program_options::variables_map& vm, const arg_descriptor<bool, false>& arg)
	  public static bool has_arg(boost::program_options.variables_map vm, arg_descriptor<bool, false> arg)
	  {
		return get_arg<bool, false>(vm, arg);
	  }


//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//  extern const arg_descriptor<bool> arg_help;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//  extern const arg_descriptor<bool> arg_version;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//  extern const arg_descriptor<string> arg_data_dir;
	  public static readonly arg_descriptor<bool> arg_help = new arg_descriptor<bool>("help", "Produce help message");
	  public static readonly arg_descriptor<bool> arg_version = new arg_descriptor<bool>("version", "Output version information");
	  public static readonly arg_descriptor<string> arg_data_dir = new arg_descriptor<string>("data-dir", "Specify data directory");
	}
}

namespace Common.Console
{
	public static class GlobalMembers
	{
//C++ TO C# CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in C#):
private static ushort[] setTextColor_winColors = {FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE, FOREGROUND_BLUE, FOREGROUND_GREEN, FOREGROUND_RED, FOREGROUND_RED | FOREGROUND_GREEN, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE, FOREGROUND_GREEN | FOREGROUND_BLUE, FOREGROUND_RED | FOREGROUND_BLUE, FOREGROUND_BLUE | FOREGROUND_INTENSITY, FOREGROUND_GREEN | FOREGROUND_INTENSITY, FOREGROUND_RED | FOREGROUND_INTENSITY, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY, FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY, FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY};

	public static void setTextColor(Color color)
	{
	  if (!Console.GlobalMembers.isConsoleTty())
	  {
		return;
	  }

	  if (color > Color.BrightMagenta)
	  {
		color = Color.Default;
	  }

	#if _WIN32

	//C++ TO C# CONVERTER NOTE: This static local variable declaration (not allowed in C#) has been moved just prior to the method:
	//  static ushort winColors[] = { FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE, FOREGROUND_BLUE, FOREGROUND_GREEN, FOREGROUND_RED, FOREGROUND_RED | FOREGROUND_GREEN, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE, FOREGROUND_GREEN | FOREGROUND_BLUE, FOREGROUND_RED | FOREGROUND_BLUE, FOREGROUND_BLUE | FOREGROUND_INTENSITY, FOREGROUND_GREEN | FOREGROUND_INTENSITY, FOREGROUND_RED | FOREGROUND_INTENSITY, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY, FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY, FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY };

	  SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), setTextColor_winColors[(ulong)color]);

	#else

	  string[] ansiColors = {"\x001B[0m", "\x001B[0;34m", "\x001B[0;32m", "\x001B[0;31m", "\x001B[0;33m", "\x001B[0;37m", "\x001B[0;36m", "\x001B[0;35m", "\x001B[1;34m", "\x001B[1;32m", "\x001B[1;31m", "\x001B[1;33m", "\x001B[1;37m", "\x001B[1;36m", "\x001B[1;35m"};

	  Console.Write(ansiColors[(ulong)color]);

	#endif

	}
//C++ TO C# CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in C#):
private static bool isConsoleTty_istty = 0 != _isatty(_fileno(stdout));
//C++ TO C# CONVERTER NOTE: This was formerly a static local variable declaration (not allowed in C#):
private static bool isConsoleTty_istty = 0 != isatty(fileno(stdout));
	public static bool isConsoleTty()
	{
	#if WIN32
	//C++ TO C# CONVERTER NOTE: This static local variable declaration (not allowed in C#) has been moved just prior to the method:
	//  static bool istty = 0 != _isatty(_fileno(stdout));
	#else
	//C++ TO C# CONVERTER NOTE: This static local variable declaration (not allowed in C#) has been moved just prior to the method:
	//  static bool istty = 0 != isatty(fileno(stdout));
	#endif
	  return isConsoleTty_istty;
	}
	}
}

namespace Common
{
	public static class GlobalMembers
	{


  //--------------------------------------------------------------------------------
	  public static string get_mining_speed(uint hr)
	  {
		if (hr > 1e9)
		{
			return (boost::format("%.2f GH/s") % (hr / 1e9)).str();
		}
		if (hr > 1e6)
		{
			return (boost::format("%.2f MH/s") % (hr / 1e6)).str();
		}
		if (hr > 1e3)
		{
			return (boost::format("%.2f KH/s") % (hr / 1e3)).str();
		}

		return (boost::format("%.0f H/s") % hr).str();
	  }

  //--------------------------------------------------------------------------------
	  public static string get_sync_percentage(ulong height, ulong target_height)
	  {
		/* Don't divide by zero */
		if (height == 0 || target_height == 0)
		{
		  return "0.00";
		}

		/* So we don't have > 100% */
		if (height > target_height)
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: height = target_height;
			height.CopyFrom(target_height);
		}

		float pc = 100.0f * height / target_height;

		if (height < target_height && pc > 99.99f)
		{
		  pc = 99.99f; // to avoid 100% when not fully synced
		}

		return (boost::format("%.2f") % pc).str();
	  }
	//  string get_upgrade_time(ulong height, ulong upgrade_height);Tangible Method Implementation Not FoundCommon-get_upgrade_time

  //--------------------------------------------------------------------------------
	  public static string get_status_string(CryptoNote.COMMAND_RPC_GET_INFO.response iresp)
	  {
		std::stringstream ss = new std::stringstream();
		std::time_t uptime = std::time(null) - iresp.start_time;
		var forkStatus = get_fork_status(new uint(iresp.network_height), new List<ulong>(iresp.upgrade_heights), new ulong(iresp.supported_height));

		ss << "Height: " << iresp.height << "/" << iresp.network_height << " (" << get_sync_percentage(new ulong(iresp.height), new uint(iresp.network_height)) << "%) " << "on " << (iresp.testnet ? "testnet, " : "mainnet, ") << (iresp.synced ? "synced, " : "syncing, ") << "net hash " << get_mining_speed(new uint(iresp.hashrate)) << ", " << "v" << +iresp.major_version << "," << get_update_status(forkStatus, new uint(iresp.network_height), new List<ulong>(iresp.upgrade_heights)) << ", " << iresp.outgoing_connections_count << "(out)+" << iresp.incoming_connections_count << "(in) connections, " << "uptime " << (uint)Math.Floor(uptime / 60.0 / 60.0 / 24.0) << "d " << (uint)Math.Floor(fmod((uptime / 60.0 / 60.0), 24.0)) << "h " << (uint)Math.Floor(fmod((uptime / 60.0), 60.0)) << "m " << (uint)fmod(uptime, 60.0) << "s";

		if (forkStatus == ForkStatus.OutOfDate)
		{
			ss << std::endl << get_upgrade_info(new ulong(iresp.supported_height), new List<ulong>(iresp.upgrade_heights));
		}

		return ss.str();
	  }

	public static ForkStatus get_fork_status(ulong height, List<ulong> upgrade_heights, ulong supported_height)
	{
		/* Allow fork heights to be empty */
		if (upgrade_heights.Count == 0)
		{
			return ForkStatus.UpToDate;
		}

		ulong next_fork = 0;

		foreach (var upgrade in upgrade_heights)
		{
			/* We have hit an upgrade already that the user cannot support */
			if (height >= upgrade != null && supported_height < upgrade)
			{
				return ForkStatus.OutOfDate;
			}

			/* Get the next fork height */
			if (upgrade > height)
			{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: next_fork = upgrade;
				next_fork.CopyFrom(upgrade);
				break;
			}
		}

		float days = (next_fork - height) / CryptoNote.parameters.EXPECTED_NUMBER_OF_BLOCKS_PER_DAY;

		/* Next fork in < 30 days away */
		if (days < 30F)
		{
			/* Software doesn't support the next fork yet */
			if (supported_height < next_fork)
			{
				return ForkStatus.ForkSoonNotReady;
			}
			else
			{
				return ForkStatus.ForkSoonReady;
			}
		}

		if (height > next_fork)
		{
			return ForkStatus.UpToDate;
		}

		return ForkStatus.ForkLater;
	}

	public static string get_fork_time(ulong height, List<ulong> upgrade_heights)
	{
		ulong next_fork = 0;

		foreach (var upgrade in upgrade_heights)
		{
			/* Get the next fork height */
			if (upgrade > height)
			{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: next_fork = upgrade;
				next_fork.CopyFrom(upgrade);
				break;
			}
		}

		float days = (next_fork - height) / CryptoNote.parameters.EXPECTED_NUMBER_OF_BLOCKS_PER_DAY;

		if (height == next_fork)
		{
			return " (forking now),";
		}
		else if (days < 1F)
		{
			return (boost::format(" (next fork in %.1f hours),") % (days * 24)).str();
		}
		else
		{
			return (boost::format(" (next fork in %.1f days),") % days).str();
		}
	}

	public static string get_update_status(ForkStatus forkStatus, ulong height, List<ulong> upgrade_heights)
	{
		switch (forkStatus)
		{
			case ForkStatus.UpToDate:
			case ForkStatus.ForkLater:
			{
				return " up to date";
			}
			case ForkStatus.ForkSoonReady:
			{
				return get_fork_time(new ulong(height), new List<ulong>(upgrade_heights)) + " up to date";
			}
			case ForkStatus.ForkSoonNotReady:
			{
				return get_fork_time(new ulong(height), new List<ulong>(upgrade_heights)) + " update needed";
			}
			case ForkStatus.OutOfDate:
			{
				return " out of date, likely forked";
			}
			default:
			{
				throw new System.Exception("Unexpected case unhandled");
			}
		}
	}

	//--------------------------------------------------------------------------------
	public static string get_upgrade_info(ulong supported_height, List<ulong> upgrade_heights)
	{
		foreach (var upgrade in upgrade_heights)
		{
			if (upgrade > supported_height)
			{
				return "The network forked at height " + Convert.ToString(upgrade) + ", please update your software: " + CryptoNote.LATEST_VERSION_URL;
			}
		}

		/* This shouldnt happen */
		return string();
	}

//C++ TO C# CONVERTER NOTE: This 'CopyFrom' method was converted from the original copy assignment operator:
//ORIGINAL LINE: JsonValue& JsonValue::operator =(const Array& value)
	public static JsonValue JsonValue.CopyFrom(Array value)
	{
	  if (type != ARRAY)
	  {
		destructValue();
		type = NIL;
		new(valueArray)Array(value);
		type = ARRAY;
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		*reinterpret_cast<Array>(valueArray) = value;
	  }

	  return this;
	}

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static JsonValue JsonValue.operator = (Array && value)
	{
	  if (type != ARRAY)
	  {
		destructValue();
		type = NIL;
		new(valueArray)Array(std::move(value));
		type = ARRAY;
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		*reinterpret_cast<Array>(valueArray) = std::move(value);
	  }

	  return this;
	}

	//JsonValue& JsonValue::operator=(Bool value) {
	//  if (type != BOOL) {
	//    destructValue();
	//    type = BOOL;
	//  }
	//
	//  valueBool = value;
	//  return *this;
	//}

//C++ TO C# CONVERTER NOTE: This 'CopyFrom' method was converted from the original copy assignment operator:
//ORIGINAL LINE: JsonValue& JsonValue::operator =(Integer value)
	public static JsonValue JsonValue.CopyFrom(Integer value)
	{
	  if (type != INTEGER)
	  {
		destructValue();
		type = INTEGER;
	  }

	  valueInteger = value;
	  return this;
	}

//C++ TO C# CONVERTER NOTE: This 'CopyFrom' method was converted from the original copy assignment operator:
//ORIGINAL LINE: JsonValue& JsonValue::operator =(Nil)
	public static JsonValue JsonValue.CopyFrom(Nil UnnamedParameter)
	{
	  if (type != NIL)
	  {
		destructValue();
		type = NIL;
	  }

	  return this;
	}

//C++ TO C# CONVERTER NOTE: This 'CopyFrom' method was converted from the original copy assignment operator:
//ORIGINAL LINE: JsonValue& JsonValue::operator =(const Object& value)
	public static JsonValue JsonValue.CopyFrom(Object value)
	{
	  if (type != OBJECT)
	  {
		destructValue();
		type = NIL;
		new(valueObject)Object(value);
		type = OBJECT;
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		*reinterpret_cast<Object>(valueObject) = value;
	  }

	  return this;
	}

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static JsonValue JsonValue.operator = (Object && value)
	{
	  if (type != OBJECT)
	  {
		destructValue();
		type = NIL;
		new(valueObject)Object(std::move(value));
		type = OBJECT;
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		*reinterpret_cast<Object>(valueObject) = std::move(value);
	  }

	  return this;
	}

//C++ TO C# CONVERTER NOTE: This 'CopyFrom' method was converted from the original copy assignment operator:
//ORIGINAL LINE: JsonValue& JsonValue::operator =(Real value)
	public static JsonValue JsonValue.CopyFrom(Real value)
	{
	  if (type != REAL)
	  {
		destructValue();
		type = REAL;
	  }

	  valueReal = value;
	  return this;
	}

//C++ TO C# CONVERTER NOTE: This 'CopyFrom' method was converted from the original copy assignment operator:
//ORIGINAL LINE: JsonValue& JsonValue::operator =(const String& value)
	public static JsonValue JsonValue.CopyFrom(String value)
	{
	  if (type != STRING)
	  {
		destructValue();
		type = NIL;
		new(valueString)String(value);
		type = STRING;
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		*reinterpret_cast<String>(valueString) = value;
	  }

	  return this;
	}

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static JsonValue JsonValue.operator = (String && value)
	{
	  if (type != STRING)
	  {
		destructValue();
		type = NIL;
		new(valueString)String(std::move(value));
		type = STRING;
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		*reinterpret_cast<String>(valueString) = std::move(value);
	  }

	  return this;
	}

	public static JsonValue JsonValue.operator ()(Key key)
	{
	  return getObject().at(key);
	}

//C++ TO C# CONVERTER WARNING: 'const' methods are not available in C#:
//ORIGINAL LINE: const JsonValue& JsonValue::operator ()(const Key& key) const
	public static JsonValue JsonValue.operator ()(Key key)
	{
	  return getObject().at(key);
	}

	public static char readChar(std::istream in)
	{
	  char c;

	  if ((in >> c) == 0)
	  {
		throw new System.Exception("Unable to parse: unexpected end of stream");
	  }

	  return c;
	}

	public static char readNonWsChar(std::istream in)
	{
	  char c;

	  do
	  {
		c = GlobalMembers.readChar(in);
	  } while (isspace(c));

	  return c;
	}

	public static string readStringToken(std::istream in)
	{
	  char c;
	  string value;

	  while (in != null)
	  {
		c = GlobalMembers.readChar(in);

		if (c == '"')
		{
		  break;
		}

		if (c == '\\')
		{
		  value += c;
		  c = GlobalMembers.readChar(in);
		}

		value += c;
	  }

	  return value;
	}
	public static T medianValue<T>(List<T> v)
	{
	  if (v.Count == 0)
	  {
		return default(T);
	  }

	  if (v.Count == 1)
	  {
		return v[0];
	  }

	  var n = (v.Count) / 2;
	  v.Sort();
	  //nth_element(v.begin(), v.begin()+n-1, v.end());
	  if (v.Count % 2 != 0)
	  { //1, 3, 5...
		return v[n];
	  }
	  else
	  { //2, 4, 6...
		return (v[n - 1] + v[n]) / 2;
	  }
	}

	public static string NativePathToGeneric(string nativePath)
	{
	  if (GlobalMembers.GENERIC_PATH_SEPARATOR == GlobalMembers.NATIVE_PATH_SEPARATOR)
	  {
		return nativePath;
	  }
	  string genericPath = nativePath;
	  std::replace(genericPath.GetEnumerator(), genericPath.end(), GlobalMembers.NATIVE_PATH_SEPARATOR, GlobalMembers.GENERIC_PATH_SEPARATOR);
	  return genericPath;
	}

	public static string GetPathDirectory(string path)
	{
	  var slashPos = path.LastIndexOf(GlobalMembers.GENERIC_PATH_SEPARATOR);
	  if (slashPos == -1)
	  {
		return string();
	  }
	  return path.Substring(0, slashPos);
	}
	public static string GetPathFilename(string path)
	{
	  var slashPos = path.LastIndexOf(GlobalMembers.GENERIC_PATH_SEPARATOR);
	  if (slashPos == -1)
	  {
		return path;
	  }
	  return path.Substring(slashPos + 1);
	}
	public static void SplitPath(string path, ref string directory, ref string filename)
	{
	  directory = GetPathDirectory(path);
	  filename = GetPathFilename(path);
	}

	public static string CombinePath(string path1, string path2)
	{
	  return path1 + GlobalMembers.GENERIC_PATH_SEPARATOR + path2;
	}
	public static string GetExtension(string path)
	{
	  var pos = GlobalMembers.findExtensionPosition(path);
	  if (pos != -1)
	  {
		return path.Substring(pos);
	  }
	  return string();
	}
	public static string RemoveExtension(string filename)
	{
	  var pos = GlobalMembers.findExtensionPosition(filename);

	  if (pos == -1)
	  {
		return filename;
	  }

	  return filename.Substring(0, pos);
	}
	public static string ReplaceExtenstion(string path, string extension)
	{
	  return RemoveExtension(path) + extension;
	}
	public static bool HasParentPath(string path)
	{
	  return path.IndexOf(GlobalMembers.GENERIC_PATH_SEPARATOR) != -1;
	}

	public static void read(IInputStream in, object data, ulong size)
	{
	  while (size > 0)
	  {
		ulong readSize = in.readSome(data, new ulong(size));
		if (readSize == 0)
		{
		  throw new System.Exception("Failed to read from IInputStream");
		}

		data = (ushort)data + readSize;
		size -= readSize;
	  }
	}
	public static void read(IInputStream in, short value)
	{
	  read(in, value, sizeof(short));
	}
	public static void read(IInputStream in, short value)
	{
	  // TODO: Convert from little endian on big endian platforms
	  read(in, value, sizeof(short));
	}
	public static void read(IInputStream in, int value)
	{
	  // TODO: Convert from little endian on big endian platforms
	  read(in, value, sizeof(int));
	}
	public static void read(IInputStream in, long value)
	{
	  // TODO: Convert from little endian on big endian platforms
	  read(in, value, sizeof(long));
	}
	public static void read(IInputStream in, ushort value)
	{
	  read(in, value, sizeof(ushort));
	}
	public static void read(IInputStream in, ushort value)
	{
	  // TODO: Convert from little endian on big endian platforms
	  read(in, value, sizeof(ushort));
	}
	public static void read(IInputStream in, uint value)
	{
	  // TODO: Convert from little endian on big endian platforms
	  read(in, value, sizeof(uint));
	}
	public static T read(IInputStream in, ulong size)
	{
	  T value = new T();
	  read(in, value, new ulong(size));
	  return value;
	}
	public static void read(IInputStream in, List<ushort> data, ulong size)
	{
	  data.Resize(size);
	  read(in, data.data(), new ulong(size));
	}
	public static void read(IInputStream in, string data, ulong size)
	{
	  List<char> temp = new List<char>(size);
	  read(in, temp.data(), new ulong(size));
	  data.assign(temp.data(), size);
	}
	public static void readVarint(IInputStream in, ref ushort value)
	{
	  ushort temp = 0;
	  for (ushort shift = 0;; shift += 7)
	  {
		ushort piece = new ushort();
		read(in, piece);
		if (shift >= sizeof(ushort) * 8 - 7 && piece >= 1 << (sizeof(ushort) * 8 - shift))
		{
		  throw new System.Exception("readVarint, value overflow");
		}

		temp |= (ulong)(piece & 0x7f) << shift;
		if ((piece & 0x80) == 0)
		{
		  if (piece == 0 && shift != 0)
		  {
			throw new System.Exception("readVarint, invalid value representation");
		  }

		  break;
		}
	  }

	  value = temp;
	}
	public static void readVarint(IInputStream in, ref ushort value)
	{
	  ushort temp = 0;
	  for (ushort shift = 0;; shift += 7)
	  {
		ushort piece = new ushort();
		read(in, piece);
		if (shift >= sizeof(ushort) * 8 - 7 && piece >= 1 << (sizeof(ushort) * 8 - shift))
		{
		  throw new System.Exception("readVarint, value overflow");
		}

		temp |= (ulong)(piece & 0x7f) << shift;
		if ((piece & 0x80) == 0)
		{
		  if (piece == 0 && shift != 0)
		  {
			throw new System.Exception("readVarint, invalid value representation");
		  }

		  break;
		}
	  }

	  value = temp;
	}
	public static void readVarint(IInputStream in, ref uint value)
	{
	  uint temp = 0;
	  for (ushort shift = 0;; shift += 7)
	  {
		ushort piece = new ushort();
		read(in, piece);
		if (shift >= sizeof(uint) * 8 - 7 && piece >= 1 << (sizeof(uint) * 8 - shift))
		{
		  throw new System.Exception("readVarint, value overflow");
		}

		temp |= (ulong)(piece & 0x7f) << shift;
		if ((piece & 0x80) == 0)
		{
		  if (piece == 0 && shift != 0)
		  {
			throw new System.Exception("readVarint, invalid value representation");
		  }

		  break;
		}
	  }

	  value = temp;
	}
	public static void readVarint(IInputStream in, ref ulong value)
	{
	  ulong temp = 0;
	  for (ushort shift = 0;; shift += 7)
	  {
		ushort piece = new ushort();
		read(in, piece);
		if (shift >= sizeof(ulong) * 8 - 7 && piece >= 1 << (sizeof(ulong) * 8 - shift))
		{
		  throw new System.Exception("readVarint, value overflow");
		}

		temp |= (ulong)(piece & 0x7f) << shift;
		if ((piece & 0x80) == 0)
		{
		  if (piece == 0 && shift != 0)
		  {
			throw new System.Exception("readVarint, invalid value representation");
		  }

		  break;
		}
	  }

	  value = temp;
	}

	public static void write(IOutputStream @out, object data, ulong size)
	{
	  while (size > 0)
	  {
		ulong writtenSize = @out.writeSome(data, new ulong(size));
		if (writtenSize == 0)
		{
		  throw new System.Exception("Failed to write to IOutputStream");
		}

		data = (ushort)data + writtenSize;
		size -= writtenSize;
	  }
	}
	public static void write(IOutputStream @out, short value)
	{
	  write(@out, value, sizeof(short));
	}
	public static void write(IOutputStream @out, short value)
	{
	  // TODO: Convert to little endian on big endian platforms
	  write(@out, value, sizeof(short));
	}
	public static void write(IOutputStream @out, int value)
	{
	  // TODO: Convert to little endian on big endian platforms
	  write(@out, value, sizeof(int));
	}
	public static void write(IOutputStream @out, long value)
	{
	  // TODO: Convert to little endian on big endian platforms
	  write(@out, value, sizeof(long));
	}
	public static void write(IOutputStream @out, ushort value)
	{
	  write(@out, value, sizeof(ushort));
	}
	public static void write(IOutputStream @out, ushort value)
	{
	  // TODO: Convert to little endian on big endian platforms
	  write(@out, value, sizeof(ushort));
	}
	public static void write(IOutputStream @out, uint value)
	{
	  // TODO: Convert to little endian on big endian platforms
	  write(@out, value, sizeof(uint));
	}
	public static void write(IOutputStream @out, ulong value)
	{
	  // TODO: Convert to little endian on big endian platforms
	  write(@out, value, sizeof(ulong));
	}
	public static void write(IOutputStream @out, List<ushort> data)
	{
	  write(@out, data.data(), data.Count);
	}
	public static void write(IOutputStream @out, string data)
	{
	  write(@out, data.data(), data.Length);
	}
	public static void writeVarint(IOutputStream @out, ulong value)
	{
	  while (value >= 0x80)
	  {
		write(@out, (ushort)(value | 0x80));
		value >>= 7;
	  }

	  write(@out, (ushort)value);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static T read<T>(IInputStream in)
	{
	  T value = new default(T);
	  read(in, value);
	  return value;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static T readVarint<T>(IInputStream in)
	{
	  T value = new default(T);
	  readVarint(in, ref value);
	  return value;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static ContainerFormatter<T> makeContainerFormatter<T>(T container)
	{
	  return new ContainerFormatter<T>(container);
	}

	public static void read(IInputStream in, ulong value)
	{
	  // TODO: Convert from little endian on big endian platforms
	  read(in, value, sizeof(ulong));
	}

	public static void writeVarint(IOutputStream @out, uint value)
	{
	  while (value >= 0x80)
	  {
		write(@out, (ushort)(value | 0x80));
		value >>= 7;
	  }

	  write(@out, (ushort)value);
	}

	public static string asString(object data, ulong size)
	{
	  return (string)((char)data, size);
	}
	public static string asString(List<ushort> data)
	{
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
	  return (string)(reinterpret_cast<const char>(data.data()), data.Count);
	}
	public static List<ushort> asBinaryArray(string data)
	{
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
	  var dataPtr = reinterpret_cast<ushort>(data.data());
	  return new List<ushort>(dataPtr, dataPtr + data.Length);
	}

	public static ushort fromHex(char character)
	{
	  ushort value = GlobalMembers.characterValues[(byte)character];
	  if (value > 0x0f)
	  {
		throw new System.Exception("fromHex: invalid character");
	  }

	  return value;
	}
	public static bool fromHex(char character, ref ushort value)
	{
	  if (GlobalMembers.characterValues[(byte)character] > 0x0f)
	  {
		return false;
	  }

	  value = GlobalMembers.characterValues[(byte)character];
	  return true;
	}
	public static ulong fromHex(string text, object data, ulong bufferSize)
	{
	  if ((text.Length & 1) != 0)
	  {
		throw new System.Exception("fromHex: invalid string size");
	  }

	  if (text.Length >> 1 > bufferSize)
	  {
		throw new System.Exception("fromHex: invalid buffer size");
	  }

	  for (ulong i = 0; i < text.Length >> 1; ++i)
	  {
		(ushort)data[i] = fromHex(text[i << 1]) << 4 | fromHex(text[(i << 1) + 1]);
	  }

	  return text.Length >> 1;
	}
	public static bool fromHex(string text, object data, ulong bufferSize, ref ulong size)
	{
	  if ((text.Length & 1) != 0)
	  {
		return false;
	  }

	  if (text.Length >> 1 > bufferSize)
	  {
		return false;
	  }

	  for (ulong i = 0; i < text.Length >> 1; ++i)
	  {
		ushort value1 = new ushort();
		if (!fromHex(text[i << 1], ref value1))
		{
		  return false;
		}

		ushort value2 = new ushort();
		if (!fromHex(text[(i << 1) + 1], ref value2))
		{
		  return false;
		}

		(ushort)data[i] = value1 << 4 | value2;
	  }

	  size = text.Length >> 1;
	  return true;
	}
	public static List<ushort> fromHex(string text)
	{
	  if ((text.Length & 1) != 0)
	  {
		throw new System.Exception("fromHex: invalid string size");
	  }

	  List<ushort> data = new List<ushort>(text.Length >> 1);
	  for (ulong i = 0; i < data.Count; ++i)
	  {
		data[i] = fromHex(text[i << 1]) << 4 | fromHex(text[(i << 1) + 1]);
	  }

	  return data;
	}
	public static bool fromHex(string text, List<ushort> data)
	{
	  if ((text.Length & 1) != 0)
	  {
		return false;
	  }

	  for (ulong i = 0; i < text.Length >> 1; ++i)
	  {
		ushort value1 = new ushort();
		if (!fromHex(text[i << 1], ref value1))
		{
		  return false;
		}

		ushort value2 = new ushort();
		if (!fromHex(text[(i << 1) + 1], ref value2))
		{
		  return false;
		}

		data.Add(value1 << 4 | value2);
	  }

	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static bool podFromHex<T>(string text, T val)
	{
	  ulong outSize = new ulong();
	  return fromHex(text, val, sizeof(T), ref outSize) && outSize == sizeof(T);
	}

	public static string toHex(object data, ulong size)
	{
	  string text;
	  for (ulong i = 0; i < size; ++i)
	  {
		text += "0123456789abcdef"[(ushort)data[i] >> 4];
		text += "0123456789abcdef"[(ushort)data[i] & 15];
	  }

	  return text;
	}
	public static void toHex(object data, ulong size, string text)
	{
	  for (ulong i = 0; i < size; ++i)
	  {
		text += "0123456789abcdef"[(ushort)data[i] >> 4];
		text += "0123456789abcdef"[(ushort)data[i] & 15];
	  }
	}
	public static string toHex(List<ushort> data)
	{
	  string text;
	  for (ulong i = 0; i < data.Count; ++i)
	  {
		text += "0123456789abcdef"[data[i] >> 4];
		text += "0123456789abcdef"[data[i] & 15];
	  }

	  return text;
	}
	public static void toHex(List<ushort> data, string text)
	{
	  for (ulong i = 0; i < data.Count; ++i)
	  {
		text += "0123456789abcdef"[data[i] >> 4];
		text += "0123456789abcdef"[data[i] & 15];
	  }
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class T>
	public static string podToHex<T>(T s)
	{
	  return toHex(s, sizeof(T));
	}

	public static string extract(ref string text, char delimiter)
	{
	  ulong delimiterPosition = text.IndexOf(delimiter);
	  string subText;
	  if (delimiterPosition != -1)
	  {
		subText = text.Substring(0, delimiterPosition);
		text = text.Substring(delimiterPosition + 1);
	  }
	  else
	  {
		subText.swap(text);
	  }

	  return subText;
	}
	public static string extract(string text, char delimiter, ref ulong offset)
	{
	  ulong delimiterPosition = text.IndexOf(delimiter, offset);
	  if (delimiterPosition != -1)
	  {
		offset = delimiterPosition + 1;
		return text.Substring(offset, delimiterPosition);
	  }
	  else
	  {
		offset = text.Length;
		return text.Substring(offset);
	  }
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static T fromString<T>(string text)
	{ // Throws on error
	  T value = new default(T);
	  std::istringstream stream = new std::istringstream(text);
	  stream >> value;
	  if (stream.fail())
	  {
		throw new System.Exception("fromString: unable to parse value");
	  }

	  return value;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static bool fromString<T>(string text, T value)
	{ // Does not throw
	  std::istringstream stream = new std::istringstream(text);
	  stream >> value;
	  return !stream.fail();
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static List<T> fromDelimitedString<T>(string source, char delimiter)
	{ // Throws on error
	  List<T> data = new List<T>();
	  for (ulong offset = 0; offset != source.Length;)
	  {
		data.emplace_back(fromString<T>(extract(source, delimiter, ref offset)));
	  }

	  return data;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static bool fromDelimitedString<T>(string source, char delimiter, List<T> data)
	{ // Does not throw
	  for (ulong offset = 0; offset != source.Length;)
	  {
		T value = new default(T);
		if (!fromString<T>(extract(source, delimiter, ref offset), value))
		{
		  return false;
		}

		data.emplace_back(value);
	  }

	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static string toString<T>(T value)
	{ // Does not throw
	  std::ostringstream stream = new std::ostringstream();
	  stream << value;
	  return stream.str();
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static void toString<T>(T value, string text)
	{ // Does not throw
	  std::ostringstream stream = new std::ostringstream();
	  stream << value;
	  text += stream.str();
	}

	public static bool loadFileToString(string filepath, string buf)
	{
	  try
	  {
		std::ifstream fstream = new std::ifstream();
		fstream.exceptions(std::ifstream.failbit | std::ifstream.badbit);
		fstream.open(filepath, std::ios_base.binary | std::ios_base.in | std::ios.ate);

		ulong fileSize = (ulong)fstream.tellg();
		buf.resize(fileSize);

		if (fileSize > 0)
		{
		  fstream.seekg(0, std::ios.beg);
		  fstream.read(buf[0], buf.Length);
		}
	  }
	  catch (System.Exception)
	  {
		return false;
	  }

	  return true;
	}
	public static bool saveStringToFile(string filepath, string buf)
	{
	  try
	  {
		std::ofstream fstream = new std::ofstream();
		fstream.exceptions(std::ifstream.failbit | std::ifstream.badbit);
		fstream.open(filepath, std::ios_base.binary | std::ios_base.@out | std::ios_base.trunc);
		fstream << buf;
	  }
	  catch (System.Exception)
	  {
		return false;
	  }

	  return true;
	}


	public static string base64Decode(string encoded_string)
	{
	  ulong in_len = encoded_string.Length;
	  ulong i = 0;
	  ulong j = 0;
	  ulong in_ = 0;
	  byte[] char_array_4 = new byte[4];
	  byte[] char_array_3 = new byte[3];
	  string ret;

	  while (in_len-- && (encoded_string[in_] != '=') && GlobalMembers.is_base64(encoded_string[in_]))
	  {
		char_array_4[i++] = encoded_string[in_];
		in_++;
		if (i == 4)
		{
		  for (i = 0; i < 4; i++)
		  {
			char_array_4[i] = (byte)GlobalMembers.base64chars.IndexOf(char_array_4[i]);
		  }

		  char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
		  char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
		  char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

		  for (i = 0; (i < 3); i++)
		  {
			ret += char_array_3[i];
		  }
		  i = 0;
		}
	  }

	  if (i != null)
	  {
		for (j = i; j < 4; j++)
		{
		  char_array_4[j] = 0;
		}

		for (j = 0; j < 4; j++)
		{
		  char_array_4[j] = (byte)GlobalMembers.base64chars.IndexOf(char_array_4[j]);
		}

		char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
		char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
		char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

		for (j = 0; (j < i - 1); j++)
		{
			ret += char_array_3[j];
		}
	  }

	  return ret;
	}

	public static string ipAddressToString(uint ip)
	{
	  ushort[] bytes = Arrays.InitializeWithDefaultInstances<ushort>(4);
	  bytes[0] = ip & 0xFF;
	  bytes[1] = (ip >> 8) & 0xFF;
	  bytes[2] = (ip >> 16) & 0xFF;
	  bytes[3] = (ip >> 24) & 0xFF;

	  string buf = new string(new char[16]);
	  buf = string.Format("{0:D}.{1:D}.{2:D}.{3:D}", bytes[0], bytes[1], bytes[2], bytes[3]);

	  return (string)buf;
	}
	public static bool parseIpAddressAndPort(ref uint ip, ref uint port, string addr)
	{
	  uint[] v = Arrays.InitializeWithDefaultInstances<uint>(4);
	  uint localPort = new uint();

	  if (sscanf(addr, "%d.%d.%d.%d:%d", v[0], v[1], v[2], v[3], localPort) != 5)
	  {
		return false;
	  }

	  for (int i = 0; i < 4; ++i)
	  {
		if (v[i] > 0xff)
		{
		  return false;
		}
	  }

	  ip = (v[3] << 24) | (v[2] << 16) | (v[1] << 8) | v[0];
	  port = localPort;
	  return true;
	}

	public static string timeIntervalToString(ulong intervalInSeconds)
	{
	  var tail = intervalInSeconds;

	  var days = tail / (60 * 60 * 24);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: tail = tail % (60 * 60 * 24);
	  tail.CopyFrom(tail % (60 * 60 * 24));
	  var hours = tail / (60 * 60);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: tail = tail % (60 * 60);
	  tail.CopyFrom(tail % (60 * 60));
	  var minutes = tail / (60);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: tail = tail % (60);
	  tail.CopyFrom(tail % (60));
	  var seconds = tail;

	  std::stringstream ss = new std::stringstream();
	  ss << "d" << days << std::setfill('0') << ".h" << std::setw(2) << hours << ".m" << std::setw(2) << minutes << ".s" << std::setw(2) << seconds;

	  return ss.str();
	}

	public static readonly ushort[] characterValues = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

	internal const string base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789+/";

	public static bool is_base64(byte c)
	{
	  return (isalnum(c) || (c == (byte)'+') || (c == (byte)'/'));
	}

//C++ TO C# CONVERTER WARNING: 'const' methods are not available in C#:
//ORIGINAL LINE: const char& StringView::operator [](Size index) const
	public static char StringView.this[Size index]
	{
		get
		{
		  Debug.Assert(data != null || size == 0);
		  Debug.Assert(index < size);
		  return *(data + index);
		}
	}
	public static T getValueAs<T>(JsonValue js)
	{
	  return js.functorMethod;
	  //cdstatic_assert(false, "undefined conversion");
	}

//C++ TO C# CONVERTER TODO TASK: C++ template specialization was removed by C++ to C# Converter:
//ORIGINAL LINE: inline string getValueAs<string>(const JsonValue& js)
	public static string getValueAs(JsonValue js)
	{
		return js.getString();
	}

//C++ TO C# CONVERTER TODO TASK: C++ template specialization was removed by C++ to C# Converter:
//ORIGINAL LINE: inline ulong getValueAs<ulong>(const JsonValue& js)
	public static ulong getValueAs(JsonValue js)
	{
		return (ulong)js.getInteger();
	}
//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to templates on variables:
	public static readonly Size ArrayView<Object, Size>.INVALID = Size.MaxValue;
//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class Object, class Size>
//C++ TO C# CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	const ArrayView<Object, Size> ArrayView<Object, Size>.EMPTY(reinterpret_cast<Object*>(1), 0);
//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class Object, class Size>
//C++ TO C# CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	const ArrayView<Object, Size> ArrayView<Object, Size>.NIL(null, 0);
//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to templates on variables:
	public static readonly Size ArrayRef<Object, Size>.INVALID = Size.MaxValue;
//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class Object, class Size>
//C++ TO C# CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	const ArrayRef<Object, Size> ArrayRef<Object, Size>.EMPTY(reinterpret_cast<Object*>(1), 0);
//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class Object, class Size>
//C++ TO C# CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	const ArrayRef<Object, Size> ArrayRef<Object, Size>.NIL(null, 0);
	//C++ TO C# CONVERTER TODO TASK: The typedef 'Size' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to templates on variables:
	public static readonly typename StringBuffer<MAXIMUM_SIZE>.Size StringBuffer<MAXIMUM_SIZE>.INVALID = typename StringBuffer<MAXIMUM_SIZE>.Size.MaxValue;
	}
}

namespace Tools
{
	public static class GlobalMembers
	{
	  public static string getDefaultDataDirectory()
	  {
		//namespace fs = boost::filesystem;
		// Windows < Vista: C:\Documents and Settings\Username\Application Data\CRYPTONOTE_NAME
		// Windows >= Vista: C:\Users\Username\AppData\Roaming\CRYPTONOTE_NAME
		// Mac: ~/Library/Application Support/CRYPTONOTE_NAME
		// Unix: ~/.CRYPTONOTE_NAME
		string config_folder;
	#if WIN32
		// Windows
		config_folder = get_special_folder_path(CSIDL_APPDATA, true) + "/" + CryptoNote.CRYPTONOTE_NAME;
	#else
		string pathRet;
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: char* pszHome = getenv("HOME");
		char pszHome = getenv("HOME");
		if (pszHome == null || pszHome.Length == 0)
		{
		  pathRet = "/";
		}
		else
		{
		  pathRet = pszHome;
		}
	#if MAC_OSX
		// Mac
		pathRet /= "Library/Application Support";
		config_folder = (pathRet + "/" + CryptoNote.CRYPTONOTE_NAME);
	#else
		// Unix
		config_folder = (pathRet + "/." + CryptoNote.CRYPTONOTE_NAME);
	#endif
	#endif

		return config_folder;
	  }
	  public static string getDefaultCacheFile(string dataDir)
	  {
		const string name = "cache_file";

		namespace bf = boost::filesystem;
		bf.path dir = dataDir;

		if (!bf.exists(dir))
		{
		  throw new System.Exception("Directory \"" + dir.string() + "\" doesn't exist");
		}

		if (!bf.exists(dir / name))
		{
		  throw new System.Exception("File \"" + boost::filesystem.path(dir / name).string() + "\" doesn't exist");
		}

		return boost::filesystem.path(dir / name).string();
	  }
	  public static string get_os_version_string()
	  {
	#if WIN32
		return get_windows_version_display_string();
	#else
		return get_nix_version_display_string();
	#endif
	  }
	  public static bool create_directories_if_necessary(string path)
	  {
		namespace fs = boost::filesystem;
		boost::system.error_code ec = new boost::system.error_code();
		fs.path fs_path = new fs.path(path);
		if (fs.is_directory(fs_path, ec))
		{
		  return true;
		}

		return fs.create_directories(fs_path, ec);
	  }
	  public static std::error_code replace_file(string replacement_name, string replaced_name)
	  {
		int code;
	#if WIN32
		// Maximizing chances for success
		uint attributes = global::GetFileAttributes(replaced_name);
		if (INVALID_FILE_ATTRIBUTES != attributes)
		{
		  global::SetFileAttributes(replaced_name, attributes & (~FILE_ATTRIBUTE_READONLY));
		}

		bool ok = 0 != global::MoveFileEx(replacement_name, replaced_name, MOVEFILE_REPLACE_EXISTING);
		code = ok ? 0 : (int)global::GetLastError();
	#else
		bool ok = 0 == std::rename(replacement_name, replaced_name);
		code = ok ? 0 : errno;
	#endif
		return std::error_code(code, std::system_category());
	  }
	  public static bool directoryExists(string path)
	  {
		boost::system.error_code ec = new boost::system.error_code();
		return boost::filesystem.is_directory(path, ec);
	  }
	#if WIN32
	  public static string get_windows_version_display_string()
	  {
	#define BUFSIZE

		char[] pszOS = {0};
		OSVERSIONINFOEX osvi = new OSVERSIONINFOEX();
		SYSTEM_INFO si = new SYSTEM_INFO();
		PGNSI pGNSI = new PGNSI();
		PGPI pGPI = new PGPI();
		int bOsVersionInfoEx;
		uint dwType;

		ZeroMemory(si, sizeof(SYSTEM_INFO));
		ZeroMemory(osvi, sizeof(OSVERSIONINFOEX));

		osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
		bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO) osvi);

		if (bOsVersionInfoEx == 0)
		{
			return pszOS;
		}

		// Call GetNativeSystemInfo if supported or GetSystemInfo otherwise.

		pGNSI = GetNativeSystemInfo;
		if (null != pGNSI)
		{
		  pGNSI(si);
		}
		else
		{
			GetSystemInfo(si);
		}

		if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4)
		{
		  StringCchCopy(pszOS, DefineConstants.BUFSIZE, "Microsoft ");

		  // Test for the specific product.

		  if (osvi.dwMajorVersion == 6)
		  {
			if (osvi.dwMinorVersion == 0)
			{
			  if (osvi.wProductType == VER_NT_WORKSTATION)
			  {
				StringCchCat(pszOS, DefineConstants.BUFSIZE, "Windows Vista ");
			  }
			  else
			  {
				  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Windows Server 2008 ");
			  }
			}

			if (osvi.dwMinorVersion == 1)
			{
			  if (osvi.wProductType == VER_NT_WORKSTATION)
			  {
				StringCchCat(pszOS, DefineConstants.BUFSIZE, "Windows 7 ");
			  }
			  else
			  {
				  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Windows Server 2008 R2 ");
			  }
			}

			pGPI = GetProductInfo;

			pGPI(osvi.dwMajorVersion, osvi.dwMinorVersion, 0, 0, dwType);

			switch (dwType)
			{
			case PRODUCT_ULTIMATE:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Ultimate Edition");
			  break;
			case PRODUCT_PROFESSIONAL:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Professional");
			  break;
			case PRODUCT_HOME_PREMIUM:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Home Premium Edition");
			  break;
			case PRODUCT_HOME_BASIC:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Home Basic Edition");
			  break;
			case PRODUCT_ENTERPRISE:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Enterprise Edition");
			  break;
			case PRODUCT_BUSINESS:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Business Edition");
			  break;
			case PRODUCT_STARTER:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Starter Edition");
			  break;
			case PRODUCT_CLUSTER_SERVER:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Cluster Server Edition");
			  break;
			case PRODUCT_DATACENTER_SERVER:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Datacenter Edition");
			  break;
			case PRODUCT_DATACENTER_SERVER_CORE:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Datacenter Edition (core installation)");
			  break;
			case PRODUCT_ENTERPRISE_SERVER:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Enterprise Edition");
			  break;
			case PRODUCT_ENTERPRISE_SERVER_CORE:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Enterprise Edition (core installation)");
			  break;
			case PRODUCT_ENTERPRISE_SERVER_IA64:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Enterprise Edition for Itanium-based Systems");
			  break;
			case PRODUCT_SMALLBUSINESS_SERVER:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Small Business Server");
			  break;
			case PRODUCT_SMALLBUSINESS_SERVER_PREMIUM:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Small Business Server Premium Edition");
			  break;
			case PRODUCT_STANDARD_SERVER:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Standard Edition");
			  break;
			case PRODUCT_STANDARD_SERVER_CORE:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Standard Edition (core installation)");
			  break;
			case PRODUCT_WEB_SERVER:
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Web Server Edition");
			  break;
			}
		  }

		  if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2)
		  {
			if (GetSystemMetrics(SM_SERVERR2))
			{
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Windows Server 2003 R2, ");
			}
			else if (osvi.wSuiteMask & VER_SUITE_STORAGE_SERVER)
			{
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Windows Storage Server 2003");
			}
			else if (osvi.wSuiteMask & VER_SUITE_WH_SERVER)
			{
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Windows Home Server");
			}
			else if (osvi.wProductType == VER_NT_WORKSTATION && si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
			{
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Windows XP Professional x64 Edition");
			}
			else
			{
				StringCchCat(pszOS, DefineConstants.BUFSIZE, "Windows Server 2003, ");
			}

			// Test for the server type.
			if (osvi.wProductType != VER_NT_WORKSTATION)
			{
			  if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)
			  {
				if ((osvi.wSuiteMask & VER_SUITE_DATACENTER) != 0)
				{
				  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Datacenter Edition for Itanium-based Systems");
				}
				else if (osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
				{
				  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Enterprise Edition for Itanium-based Systems");
				}
			  }

			  else if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
			  {
				if ((osvi.wSuiteMask & VER_SUITE_DATACENTER) != 0)
				{
				  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Datacenter x64 Edition");
				}
				else if (osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
				{
				  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Enterprise x64 Edition");
				}
				else
				{
					StringCchCat(pszOS, DefineConstants.BUFSIZE, "Standard x64 Edition");
				}
			  }

			  else
			  {
				if ((osvi.wSuiteMask & VER_SUITE_COMPUTE_SERVER) != 0)
				{
				  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Compute Cluster Edition");
				}
				else if (osvi.wSuiteMask & VER_SUITE_DATACENTER)
				{
				  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Datacenter Edition");
				}
				else if (osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
				{
				  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Enterprise Edition");
				}
				else if (osvi.wSuiteMask & VER_SUITE_BLADE)
				{
				  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Web Edition");
				}
				else
				{
					StringCchCat(pszOS, DefineConstants.BUFSIZE, "Standard Edition");
				}
			  }
			}
		  }

		  if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
		  {
			StringCchCat(pszOS, DefineConstants.BUFSIZE, "Windows XP ");
			if ((osvi.wSuiteMask & VER_SUITE_PERSONAL) != 0)
			{
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Home Edition");
			}
			else
			{
				StringCchCat(pszOS, DefineConstants.BUFSIZE, "Professional");
			}
		  }

		  if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
		  {
			StringCchCat(pszOS, DefineConstants.BUFSIZE, "Windows 2000 ");

			if (osvi.wProductType == VER_NT_WORKSTATION)
			{
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Professional");
			}
			else
			{
			  if ((osvi.wSuiteMask & VER_SUITE_DATACENTER) != 0)
			  {
				StringCchCat(pszOS, DefineConstants.BUFSIZE, "Datacenter Server");
			  }
			  else if (osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
			  {
				StringCchCat(pszOS, DefineConstants.BUFSIZE, "Advanced Server");
			  }
			  else
			  {
				  StringCchCat(pszOS, DefineConstants.BUFSIZE, "Server");
			  }
			}
		  }

		  // Include service pack (if any) and build number.

		  if (osvi.szCSDVersion.Length > 0)
		  {
			StringCchCat(pszOS, DefineConstants.BUFSIZE, " ");
			StringCchCat(pszOS, DefineConstants.BUFSIZE, osvi.szCSDVersion);
		  }

		  string buf = new string(new char[80]);

		  StringCchPrintf(buf, 80, " (build %d)", osvi.dwBuildNumber);
		  StringCchCat(pszOS, DefineConstants.BUFSIZE, buf);

		  if (osvi.dwMajorVersion >= 6)
		  {
			if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
			{
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, ", 64-bit");
			}
			else if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
			{
			  StringCchCat(pszOS, DefineConstants.BUFSIZE, ", 32-bit");
			}
		  }

		  return pszOS;
		}
		else
		{
		  Console.Write("This sample does not support this version of Windows.\n");
		  return pszOS;
		}
	  }

	  public delegate void PGNSI(LPSYSTEM_INFO UnnamedParameter);

	  public delegate int PGPI(uint UnnamedParameter, uint UnnamedParameter2, uint UnnamedParameter3, uint UnnamedParameter4, ref uint UnnamedParameter5);
	#else
	public static string get_nix_version_display_string()
	{
	  utsname un = new utsname();

	  if (uname(un) < 0)
	  {
		return "*nix: failed to get os version";
	  }
	  return string() + un.sysname + " " + un.version + " " + un.release;
	}
	#endif



	#if WIN32
	  public static string get_special_folder_path(int nfolder, bool iscreate)
	  {
		namespace fs = boost::filesystem;
		const string psz_path = "";

		if (SHGetSpecialFolderPathA(null, psz_path, nfolder, iscreate))
		{
		  return psz_path;
		}

		return "";
	  }
	#endif
		public static bool is_cin_tty()
		{
		  return 0 != _isatty(_fileno(stdin));
		}
		public static bool is_cin_tty()
		{
		  return 0 != isatty(fileno(stdin));
		}

		public static int getch()
		{
		  termios tty_old = new termios();
		  tcgetattr(STDIN_FILENO, tty_old);

		  termios tty_new = new termios();
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: tty_new = tty_old;
		  tty_new.CopyFrom(tty_old);
		  tty_new.c_lflag &= ~(ICANON | ECHO);
		  tcsetattr(STDIN_FILENO, TCSANOW, tty_new);

		  int ch = Console.Read();

		  tcsetattr(STDIN_FILENO, TCSANOW, tty_old);

		  return ch;
		}
//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
		public static std::enable_if<std::is_integral<T>.value && std::is_unsigned<T>.value>.type write_varint<OutputIt, T>(OutputIt && dest, T i)
		{
			while (i >= 0x80)
			{
				*dest++= ((char)i & 0x7f) | 0x80;
				i >>= 7;
			}
			*dest++= (char)i;
		}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename t_type>
		public static string get_varint_data<t_type>(t_type v)
		{
		  std::stringstream ss = new std::stringstream();
		  write_varint(std::ostreambuf_iterator<char>(ss), v);
		  return ss.str();
		}

//C++ TO C# CONVERTER TODO TASK: C++ template specifiers with non-type parameters cannot be converted to C#:
//ORIGINAL LINE: template<int bits, typename InputIt, typename T>
//C++ TO C# CONVERTER TODO TASK: The following method format was not recognized, possibly due to an unrecognized macro:
		typename std::enable_if < std::is_integral<T>.value && std::is_unsigned<T>.value && 0 <= bits && bits <= std::numeric_limits<T>.digits, int>.type read_varint(InputIt && first, InputIt && last, T & i)
		{
			int read = 0;
			i = 0;
			for (int shift = 0;; shift += 7)
			{
				if (first == last)
				{
					return read; // End of input.
				}
				byte @byte = first++;
				++read;
				if (shift + 7 >= bits && @byte >= 1 << (bits - shift))
				{
					return -1; // Overflow.
				}
				if (@byte == 0 && shift != 0)
				{
					return -2; // Non-canonical representation.
				}
				i |= (T)(byte & 0x7f) << shift;
				if ((byte & 0x80) == 0)
				{
					break;
				}
			}
			return read;
		}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename InputIt, typename T>
//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
		public static int read_varint<InputIt, T>(InputIt && first, InputIt && last, T i)
		{
			return read_varint<numeric_limits<T>.digits, InputIt, T>(std::move(first), std::move(last), i);
		}
	}
}

namespace Crypto
{
	public static class GlobalMembers
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'cipher', so pointers on this parameter are left unchanged:
		public static void chacha8(object data, size_t length, ushort key, ushort iv, char * cipher)
		{
		  uint x0 = new uint();
		  uint x1 = new uint();
		  uint x2 = new uint();
		  uint x3 = new uint();
		  uint x4 = new uint();
		  uint x5 = new uint();
		  uint x6 = new uint();
		  uint x7 = new uint();
		  uint x8 = new uint();
		  uint x9 = new uint();
		  uint x10 = new uint();
		  uint x11 = new uint();
		  uint x12 = new uint();
		  uint x13 = new uint();
		  uint x14 = new uint();
		  uint x15 = new uint();
		  uint j0 = new uint();
		  uint j1 = new uint();
		  uint j2 = new uint();
		  uint j3 = new uint();
		  uint j4 = new uint();
		  uint j5 = new uint();
		  uint j6 = new uint();
		  uint j7 = new uint();
		  uint j8 = new uint();
		  uint j9 = new uint();
		  uint j10 = new uint();
		  uint j11 = new uint();
		  uint j12 = new uint();
		  uint j13 = new uint();
		  uint j14 = new uint();
		  uint j15 = new uint();
		  string ctarget = null;
		  string tmp = new string(new char[64]);
		  int i;

		  if (length == null)
		  {
			  return;
		  }

		  j0 = SWAP32LE(((uint)(GlobalMembers.sigma.Substring(0)))[0]);
		  j1 = SWAP32LE(((uint)(GlobalMembers.sigma.Substring(4)))[0]);
		  j2 = SWAP32LE(((uint)(GlobalMembers.sigma.Substring(8)))[0]);
		  j3 = SWAP32LE(((uint)(GlobalMembers.sigma.Substring(12)))[0]);
		  j4 = SWAP32LE(((uint)(key + 0))[0]);
		  j5 = SWAP32LE(((uint)(key + 4))[0]);
		  j6 = SWAP32LE(((uint)(key + 8))[0]);
		  j7 = SWAP32LE(((uint)(key + 12))[0]);
		  j8 = SWAP32LE(((uint)(key + 16))[0]);
		  j9 = SWAP32LE(((uint)(key + 20))[0]);
		  j10 = SWAP32LE(((uint)(key + 24))[0]);
		  j11 = SWAP32LE(((uint)(key + 28))[0]);
		  j12 = 0;
		  j13 = 0;
		  j14 = SWAP32LE(((uint)(iv + 0))[0]);
		  j15 = SWAP32LE(((uint)(iv + 4))[0]);

		  for (;;)
		  {
			if (length < 64)
			{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			  memcpy(tmp, data, length);
			  data = tmp;
			  ctarget = cipher;
			  cipher = tmp;
			}
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x0 = j0;
			x0.CopyFrom(j0);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x1 = j1;
			x1.CopyFrom(j1);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x2 = j2;
			x2.CopyFrom(j2);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x3 = j3;
			x3.CopyFrom(j3);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x4 = j4;
			x4.CopyFrom(j4);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x5 = j5;
			x5.CopyFrom(j5);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x6 = j6;
			x6.CopyFrom(j6);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x7 = j7;
			x7.CopyFrom(j7);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x8 = j8;
			x8.CopyFrom(j8);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x9 = j9;
			x9.CopyFrom(j9);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x10 = j10;
			x10.CopyFrom(j10);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x11 = j11;
			x11.CopyFrom(j11);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x12 = j12;
			x12.CopyFrom(j12);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x13 = j13;
			x13.CopyFrom(j13);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x14 = j14;
			x14.CopyFrom(j14);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x15 = j15;
			x15.CopyFrom(j15);
			for (i = 8;i > 0;i -= 2)
			{
			  x0 = (((uint)((x0) + (x4)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x12 = (rol32(((x12) ^ (x0)),16));
			  x12.CopyFrom(GlobalMembers.rol32(((x12) ^ (x0)), 16));
			  x8 = (((uint)((x8) + (x12)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x4 = (rol32(((x4) ^ (x8)),12));
			  x4.CopyFrom(GlobalMembers.rol32(((x4) ^ (x8)), 12));
			  x0 = (((uint)((x0) + (x4)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x12 = (rol32(((x12) ^ (x0)),8));
			  x12.CopyFrom(GlobalMembers.rol32(((x12) ^ (x0)), 8));
			  x8 = (((uint)((x8) + (x12)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x4 = (rol32(((x4) ^ (x8)),7));
			  x4.CopyFrom(GlobalMembers.rol32(((x4) ^ (x8)), 7));
			  x1 = (((uint)((x1) + (x5)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x13 = (rol32(((x13) ^ (x1)),16));
			  x13.CopyFrom(GlobalMembers.rol32(((x13) ^ (x1)), 16));
			  x9 = (((uint)((x9) + (x13)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x5 = (rol32(((x5) ^ (x9)),12));
			  x5.CopyFrom(GlobalMembers.rol32(((x5) ^ (x9)), 12));
			  x1 = (((uint)((x1) + (x5)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x13 = (rol32(((x13) ^ (x1)),8));
			  x13.CopyFrom(GlobalMembers.rol32(((x13) ^ (x1)), 8));
			  x9 = (((uint)((x9) + (x13)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x5 = (rol32(((x5) ^ (x9)),7));
			  x5.CopyFrom(GlobalMembers.rol32(((x5) ^ (x9)), 7));
			  x2 = (((uint)((x2) + (x6)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x14 = (rol32(((x14) ^ (x2)),16));
			  x14.CopyFrom(GlobalMembers.rol32(((x14) ^ (x2)), 16));
			  x10 = (((uint)((x10) + (x14)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x6 = (rol32(((x6) ^ (x10)),12));
			  x6.CopyFrom(GlobalMembers.rol32(((x6) ^ (x10)), 12));
			  x2 = (((uint)((x2) + (x6)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x14 = (rol32(((x14) ^ (x2)),8));
			  x14.CopyFrom(GlobalMembers.rol32(((x14) ^ (x2)), 8));
			  x10 = (((uint)((x10) + (x14)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x6 = (rol32(((x6) ^ (x10)),7));
			  x6.CopyFrom(GlobalMembers.rol32(((x6) ^ (x10)), 7));
			  x3 = (((uint)((x3) + (x7)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x15 = (rol32(((x15) ^ (x3)),16));
			  x15.CopyFrom(GlobalMembers.rol32(((x15) ^ (x3)), 16));
			  x11 = (((uint)((x11) + (x15)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x7 = (rol32(((x7) ^ (x11)),12));
			  x7.CopyFrom(GlobalMembers.rol32(((x7) ^ (x11)), 12));
			  x3 = (((uint)((x3) + (x7)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x15 = (rol32(((x15) ^ (x3)),8));
			  x15.CopyFrom(GlobalMembers.rol32(((x15) ^ (x3)), 8));
			  x11 = (((uint)((x11) + (x15)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x7 = (rol32(((x7) ^ (x11)),7));
			  x7.CopyFrom(GlobalMembers.rol32(((x7) ^ (x11)), 7));
			  x0 = (((uint)((x0) + (x5)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x15 = (rol32(((x15) ^ (x0)),16));
			  x15.CopyFrom(GlobalMembers.rol32(((x15) ^ (x0)), 16));
			  x10 = (((uint)((x10) + (x15)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x5 = (rol32(((x5) ^ (x10)),12));
			  x5.CopyFrom(GlobalMembers.rol32(((x5) ^ (x10)), 12));
			  x0 = (((uint)((x0) + (x5)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x15 = (rol32(((x15) ^ (x0)),8));
			  x15.CopyFrom(GlobalMembers.rol32(((x15) ^ (x0)), 8));
			  x10 = (((uint)((x10) + (x15)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x5 = (rol32(((x5) ^ (x10)),7));
			  x5.CopyFrom(GlobalMembers.rol32(((x5) ^ (x10)), 7));
			  x1 = (((uint)((x1) + (x6)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x12 = (rol32(((x12) ^ (x1)),16));
			  x12.CopyFrom(GlobalMembers.rol32(((x12) ^ (x1)), 16));
			  x11 = (((uint)((x11) + (x12)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x6 = (rol32(((x6) ^ (x11)),12));
			  x6.CopyFrom(GlobalMembers.rol32(((x6) ^ (x11)), 12));
			  x1 = (((uint)((x1) + (x6)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x12 = (rol32(((x12) ^ (x1)),8));
			  x12.CopyFrom(GlobalMembers.rol32(((x12) ^ (x1)), 8));
			  x11 = (((uint)((x11) + (x12)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x6 = (rol32(((x6) ^ (x11)),7));
			  x6.CopyFrom(GlobalMembers.rol32(((x6) ^ (x11)), 7));
			  x2 = (((uint)((x2) + (x7)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x13 = (rol32(((x13) ^ (x2)),16));
			  x13.CopyFrom(GlobalMembers.rol32(((x13) ^ (x2)), 16));
			  x8 = (((uint)((x8) + (x13)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x7 = (rol32(((x7) ^ (x8)),12));
			  x7.CopyFrom(GlobalMembers.rol32(((x7) ^ (x8)), 12));
			  x2 = (((uint)((x2) + (x7)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x13 = (rol32(((x13) ^ (x2)),8));
			  x13.CopyFrom(GlobalMembers.rol32(((x13) ^ (x2)), 8));
			  x8 = (((uint)((x8) + (x13)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x7 = (rol32(((x7) ^ (x8)),7));
			  x7.CopyFrom(GlobalMembers.rol32(((x7) ^ (x8)), 7));
			  x3 = (((uint)((x3) + (x4)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x14 = (rol32(((x14) ^ (x3)),16));
			  x14.CopyFrom(GlobalMembers.rol32(((x14) ^ (x3)), 16));
			  x9 = (((uint)((x9) + (x14)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x4 = (rol32(((x4) ^ (x9)),12));
			  x4.CopyFrom(GlobalMembers.rol32(((x4) ^ (x9)), 12));
			  x3 = (((uint)((x3) + (x4)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x14 = (rol32(((x14) ^ (x3)),8));
			  x14.CopyFrom(GlobalMembers.rol32(((x14) ^ (x3)), 8));
			  x9 = (((uint)((x9) + (x14)) & UINT32_C(0xFFFFFFFF)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x4 = (rol32(((x4) ^ (x9)),7));
			  x4.CopyFrom(GlobalMembers.rol32(((x4) ^ (x9)), 7));
			}
			x0 = (((uint)((x0) + (j0)) & UINT32_C(0xFFFFFFFF)));
			x1 = (((uint)((x1) + (j1)) & UINT32_C(0xFFFFFFFF)));
			x2 = (((uint)((x2) + (j2)) & UINT32_C(0xFFFFFFFF)));
			x3 = (((uint)((x3) + (j3)) & UINT32_C(0xFFFFFFFF)));
			x4 = (((uint)((x4) + (j4)) & UINT32_C(0xFFFFFFFF)));
			x5 = (((uint)((x5) + (j5)) & UINT32_C(0xFFFFFFFF)));
			x6 = (((uint)((x6) + (j6)) & UINT32_C(0xFFFFFFFF)));
			x7 = (((uint)((x7) + (j7)) & UINT32_C(0xFFFFFFFF)));
			x8 = (((uint)((x8) + (j8)) & UINT32_C(0xFFFFFFFF)));
			x9 = (((uint)((x9) + (j9)) & UINT32_C(0xFFFFFFFF)));
			x10 = (((uint)((x10) + (j10)) & UINT32_C(0xFFFFFFFF)));
			x11 = (((uint)((x11) + (j11)) & UINT32_C(0xFFFFFFFF)));
			x12 = (((uint)((x12) + (j12)) & UINT32_C(0xFFFFFFFF)));
			x13 = (((uint)((x13) + (j13)) & UINT32_C(0xFFFFFFFF)));
			x14 = (((uint)((x14) + (j14)) & UINT32_C(0xFFFFFFFF)));
			x15 = (((uint)((x15) + (j15)) & UINT32_C(0xFFFFFFFF)));

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x0 = ((x0) ^ (SWAP32LE(((uint*)((ushort*)data + 0))[0])));
			x0.CopyFrom(((x0) ^ (SWAP32LE(((uint)((ushort)data + 0))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x1 = ((x1) ^ (SWAP32LE(((uint*)((ushort*)data + 4))[0])));
			x1.CopyFrom(((x1) ^ (SWAP32LE(((uint)((ushort)data + 4))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x2 = ((x2) ^ (SWAP32LE(((uint*)((ushort*)data + 8))[0])));
			x2.CopyFrom(((x2) ^ (SWAP32LE(((uint)((ushort)data + 8))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x3 = ((x3) ^ (SWAP32LE(((uint*)((ushort*)data + 12))[0])));
			x3.CopyFrom(((x3) ^ (SWAP32LE(((uint)((ushort)data + 12))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x4 = ((x4) ^ (SWAP32LE(((uint*)((ushort*)data + 16))[0])));
			x4.CopyFrom(((x4) ^ (SWAP32LE(((uint)((ushort)data + 16))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x5 = ((x5) ^ (SWAP32LE(((uint*)((ushort*)data + 20))[0])));
			x5.CopyFrom(((x5) ^ (SWAP32LE(((uint)((ushort)data + 20))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x6 = ((x6) ^ (SWAP32LE(((uint*)((ushort*)data + 24))[0])));
			x6.CopyFrom(((x6) ^ (SWAP32LE(((uint)((ushort)data + 24))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x7 = ((x7) ^ (SWAP32LE(((uint*)((ushort*)data + 28))[0])));
			x7.CopyFrom(((x7) ^ (SWAP32LE(((uint)((ushort)data + 28))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x8 = ((x8) ^ (SWAP32LE(((uint*)((ushort*)data + 32))[0])));
			x8.CopyFrom(((x8) ^ (SWAP32LE(((uint)((ushort)data + 32))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x9 = ((x9) ^ (SWAP32LE(((uint*)((ushort*)data + 36))[0])));
			x9.CopyFrom(((x9) ^ (SWAP32LE(((uint)((ushort)data + 36))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x10 = ((x10) ^ (SWAP32LE(((uint*)((ushort*)data + 40))[0])));
			x10.CopyFrom(((x10) ^ (SWAP32LE(((uint)((ushort)data + 40))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x11 = ((x11) ^ (SWAP32LE(((uint*)((ushort*)data + 44))[0])));
			x11.CopyFrom(((x11) ^ (SWAP32LE(((uint)((ushort)data + 44))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x12 = ((x12) ^ (SWAP32LE(((uint*)((ushort*)data + 48))[0])));
			x12.CopyFrom(((x12) ^ (SWAP32LE(((uint)((ushort)data + 48))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x13 = ((x13) ^ (SWAP32LE(((uint*)((ushort*)data + 52))[0])));
			x13.CopyFrom(((x13) ^ (SWAP32LE(((uint)((ushort)data + 52))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x14 = ((x14) ^ (SWAP32LE(((uint*)((ushort*)data + 56))[0])));
			x14.CopyFrom(((x14) ^ (SWAP32LE(((uint)((ushort)data + 56))[0]))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: x15 = ((x15) ^ (SWAP32LE(((uint*)((ushort*)data + 60))[0])));
			x15.CopyFrom(((x15) ^ (SWAP32LE(((uint)((ushort)data + 60))[0]))));

			j12 = ((((uint)(((j12)) + (1)) & UINT32_C(0xFFFFFFFF))));
			if (j12 == null)
			{
			  j13 = ((((uint)(((j13)) + (1)) & UINT32_C(0xFFFFFFFF))));
			  /* stopping at 2^70 bytes per iv is user's responsibility */
			}

			(((uint)(cipher.Substring(0)))[0] = SWAP32LE(x0));
			(((uint)(cipher.Substring(4)))[0] = SWAP32LE(x1));
			(((uint)(cipher.Substring(8)))[0] = SWAP32LE(x2));
			(((uint)(cipher.Substring(12)))[0] = SWAP32LE(x3));
			(((uint)(cipher.Substring(16)))[0] = SWAP32LE(x4));
			(((uint)(cipher.Substring(20)))[0] = SWAP32LE(x5));
			(((uint)(cipher.Substring(24)))[0] = SWAP32LE(x6));
			(((uint)(cipher.Substring(28)))[0] = SWAP32LE(x7));
			(((uint)(cipher.Substring(32)))[0] = SWAP32LE(x8));
			(((uint)(cipher.Substring(36)))[0] = SWAP32LE(x9));
			(((uint)(cipher.Substring(40)))[0] = SWAP32LE(x10));
			(((uint)(cipher.Substring(44)))[0] = SWAP32LE(x11));
			(((uint)(cipher.Substring(48)))[0] = SWAP32LE(x12));
			(((uint)(cipher.Substring(52)))[0] = SWAP32LE(x13));
			(((uint)(cipher.Substring(56)))[0] = SWAP32LE(x14));
			(((uint)(cipher.Substring(60)))[0] = SWAP32LE(x15));

			if (length <= 64)
			{
			  if (length < 64)
			  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(ctarget, cipher, length);
			  }
			  return;
			}
			length -= 64;
			cipher += 64;
			data = (ushort)data + 64;
		  }
		}
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent to most C++ 'pragma' directives in C#:
	//#pragma pack(pop)

	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//  static_assert(sizeof(chacha8_key) == DefineConstants.CHACHA8_KEY_SIZE && sizeof(chacha8_iv) == DefineConstants.CHACHA8_IV_SIZE, "Invalid structure size");

	  public static void chacha8(object data, size_t length, chacha8_key key, chacha8_iv iv, ref string cipher)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		chacha8(data, new size_t(length), reinterpret_cast<const ushort>(key), reinterpret_cast<const ushort>(iv), ref cipher);
	  }

	  public static void generate_chacha8_key(string password, chacha8_key key)
	  {
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//	static_assert(sizeof(chacha8_key) <= sizeof(Hash), "Size of hash must be at least that of chacha8_key");
		Hash pwd_hash = new Hash();
		cn_slow_hash_v0(password.data(), password.Length, pwd_hash);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(key, pwd_hash, sizeof(Crypto.chacha8_key));
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
		memset(pwd_hash, 0, sizeof(Hash));
	  }


//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//  extern object random_lock;
	  public static std::enable_if<std::is_pod<T>.value, T>.type rand<T>()
	  {
		std::remove_cv<T>.type res = new std::remove_cv<T>.type();
		lock (random_lock)
		{
			generate_random_bytes(sizeof(T), res);
		}
		return res;
	  }

	  /* Random number engine based on Crypto::rand()
	   */
//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>

	  public static void derive_secret_key(KeyDerivation derivation, uint output_index, SecretKey @base, ushort prefix, size_t prefixLength, SecretKey derived_key)
	  {
		crypto_ops.derive_secret_key(derivation, output_index, @base, prefix, prefixLength, derived_key);
	  }

	  public static void derive_secret_key(KeyDerivation derivation, uint output_index, SecretKey @base, SecretKey derived_key)
	  {
		crypto_ops.derive_secret_key(derivation, output_index, @base, derived_key);
	  }

	  public static void generate_ring_signature(Hash prefix_hash, KeyImage image, PublicKey[] pubs, uint pubs_count, SecretKey sec, uint sec_index, Signature sig)
	  {
		crypto_ops.generate_ring_signature(prefix_hash, image, pubs, pubs_count, sec, sec_index, sig);
	  }

	  /* Variants with vector<const PublicKey *> parameters.
	   */
	  public static void generate_ring_signature(Hash prefix_hash, KeyImage image, List<const PublicKey > pubs, SecretKey sec, size_t sec_index, Signature sig)
	  {
		generate_ring_signature(prefix_hash, image, pubs.data(), pubs.Count, sec, new size_t(sec_index), sig);
	  }
	  public static bool check_ring_signature(Hash prefix_hash, KeyImage image, List<const PublicKey > pubs, Signature sig, bool checkKeyImage)
	  {
		return check_ring_signature(prefix_hash, image, pubs.data(), pubs.Count, sig, checkKeyImage);
	  }
		public static bool operator == (PublicKey _v1, PublicKey _v2)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
			return memcmp(_v1, _v2, sizeof(PublicKey)) == 0;
		}
		public static bool operator != (PublicKey _v1, PublicKey _v2)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
			return memcmp(_v1, _v2, sizeof(PublicKey)) != 0;
		}
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//	static_assert(sizeof(size_t) <= sizeof(PublicKey), "Size of " "PublicKey" " must be at least that of size_t");
		public static size_t hash_value(PublicKey _v)
		{
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
			return reinterpret_cast<const size_t &>(_v);
		}
		public static bool operator == (KeyImage _v1, KeyImage _v2)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
			return memcmp(_v1, _v2, sizeof(KeyImage)) == 0;
		}
		public static bool operator != (KeyImage _v1, KeyImage _v2)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
			return memcmp(_v1, _v2, sizeof(KeyImage)) != 0;
		}
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//	static_assert(sizeof(size_t) <= sizeof(KeyImage), "Size of " "KeyImage" " must be at least that of size_t");
		public static size_t hash_value(KeyImage _v)
		{
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
			return reinterpret_cast<const size_t &>(_v);
		}
		public static bool operator == (Signature _v1, Signature _v2)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
			return memcmp(_v1, _v2, sizeof(Signature)) == 0;
		}
		public static bool operator != (Signature _v1, Signature _v2)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
			return memcmp(_v1, _v2, sizeof(Signature)) != 0;
		}
		public static bool operator == (SecretKey _v1, SecretKey _v2)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
			return memcmp(_v1, _v2, sizeof(SecretKey)) == 0;
		}
		public static bool operator != (SecretKey _v1, SecretKey _v2)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
			return memcmp(_v1, _v2, sizeof(SecretKey)) != 0;
		}


	  public static mutex random_lock = new mutex();

	  internal static void random_scalar(EllipticCurveScalar res)
	  {
		byte[] tmp = new byte[64];
		generate_random_bytes(64, tmp);
		sc_reduce(tmp);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(res, tmp, 32);
	  }

	  internal static void hash_to_scalar(object data, size_t length, EllipticCurveScalar res)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		cn_fast_hash(data, new size_t(length), reinterpret_cast<Hash &>(res));
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		sc_reduce32(reinterpret_cast<byte>(res));
	  }

	  internal static void derivation_to_scalar(KeyDerivation derivation, size_t output_index, EllipticCurveScalar res)
	  {
//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//	struct
	//	{
	//	  KeyDerivation derivation;
	//	  char output_index[(sizeof(size_t) * 8 + 6) / 7];
	//	}
	//	buf;
		string end = buf.output_index;
		buf.derivation = derivation;
		Tools.GlobalMembers.write_varint(end, new size_t(output_index));
		Debug.Assert(end <= buf.output_index + sizeof (buf.output_index));
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		hash_to_scalar(buf, end - reinterpret_cast<char>(buf), res);
	  }

	  internal static void derivation_to_scalar(KeyDerivation derivation, size_t output_index, ushort suffix, size_t suffixLength, EllipticCurveScalar res)
	  {
		Debug.Assert(suffixLength <= 32);
//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//	struct
	//	{
	//	  KeyDerivation derivation;
	//	  char output_index[(sizeof(size_t) * 8 + 6) / 7 + 32];
	//	}
	//	buf;
		string end = buf.output_index;
		buf.derivation = derivation;
		Tools.GlobalMembers.write_varint(end, new size_t(output_index));
		Debug.Assert(end <= buf.output_index + sizeof (buf.output_index));
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		size_t bufSize = end - reinterpret_cast<char>(buf);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(end, suffix, suffixLength);
		hash_to_scalar(buf, bufSize + suffixLength, res);
	  }

	  internal static void hash_to_ec(PublicKey key, ge_p3 res)
	  {
		Hash h = new Hash();
		ge_p2 point = new ge_p2();
		ge_p1p1 point2 = new ge_p1p1();
		cn_fast_hash(std::addressof(key), sizeof(PublicKey), h);
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		ge_fromfe_frombytes_vartime(point, reinterpret_cast<const byte>(h));
		ge_mul8(point2, point);
		ge_p1p1_to_p3(res, point2);
	  }

	#if _MSC_VER
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent to most C++ 'pragma' directives in C#:
	//#pragma warning(disable: 4200)
	#endif

	  internal static size_t rs_comm_size(size_t pubs_count)
	  {
		return sizeof(rs_comm) + pubs_count * sizeof(Crypto.rs_comm.AnonymousClass);
	  }
	  public static std::ostream operator << (std::ostream o, Crypto.PublicKey v)
	  {
		  return GlobalMembers.print256(o, v);
	  }
	  public static std::ostream operator << (std::ostream o, Crypto.SecretKey v)
	  {
		  return GlobalMembers.print256(o, v);
	  }
	  public static std::ostream operator << (std::ostream o, Crypto.KeyDerivation v)
	  {
		  return GlobalMembers.print256(o, v);
	  }
	  public static std::ostream operator << (std::ostream o, Crypto.KeyImage v)
	  {
		  return GlobalMembers.print256(o, v);
	  }
	  public static std::ostream operator << (std::ostream o, Crypto.Signature v)
	  {
		  return GlobalMembers.print256(o, v);
	  }
	  public static std::ostream operator << (std::ostream o, Crypto.Hash v)
	  {
		  return GlobalMembers.print256(o, v);
	  }

	public static bool serialize(PublicKey pubKey, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return GlobalMembers.serializePod(pubKey, new Common.StringView(name), serializer.functorMethod);
	}
	public static bool serialize(SecretKey secKey, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return GlobalMembers.serializePod(secKey, new Common.StringView(name), serializer.functorMethod);
	}
	public static bool serialize(Hash h, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return GlobalMembers.serializePod(h, new Common.StringView(name), serializer.functorMethod);
	}
	public static bool serialize(chacha8_iv chacha, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return GlobalMembers.serializePod(chacha, new Common.StringView(name), serializer.functorMethod);
	}
	public static bool serialize(KeyImage keyImage, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return GlobalMembers.serializePod(keyImage, new Common.StringView(name), serializer.functorMethod);
	}
	public static bool serialize(Signature sig, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return GlobalMembers.serializePod(sig, new Common.StringView(name), serializer.functorMethod);
	}
	public static bool serialize(EllipticCurveScalar ecScalar, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return GlobalMembers.serializePod(ecScalar, new Common.StringView(name), serializer.functorMethod);
	}
	public static bool serialize(EllipticCurvePoint ecPoint, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return GlobalMembers.serializePod(ecPoint, new Common.StringView(name), serializer.functorMethod);
	}


	  /*
	    Cryptonight hash functions
	  */

	  public static void cn_fast_hash(object data, uint length, Hash hash)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		cn_fast_hash(data, length, reinterpret_cast<char>(hash));
	  }

	  public static Hash cn_fast_hash(object data, uint length)
	  {
		Hash h = new Hash();
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		cn_fast_hash(data, length, reinterpret_cast<char>(h));
		return h;
	  }

	  // Standard CryptoNight
	  public static void cn_slow_hash_v0(object data, uint length, Hash hash)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		cn_slow_hash(data, length, reinterpret_cast<char>(hash), 0, 0, 0, DefineConstants.CN_PAGE_SIZE, DefineConstants.CN_SCRATCHPAD, DefineConstants.CN_ITERATIONS);
	  }

	  public static void cn_slow_hash_v1(object data, uint length, Hash hash)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		cn_slow_hash(data, length, reinterpret_cast<char>(hash), 0, 1, 0, DefineConstants.CN_PAGE_SIZE, DefineConstants.CN_SCRATCHPAD, DefineConstants.CN_ITERATIONS);
	  }

	  public static void cn_slow_hash_v2(object data, uint length, Hash hash)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		cn_slow_hash(data, length, reinterpret_cast<char>(hash), 0, 2, 0, DefineConstants.CN_PAGE_SIZE, DefineConstants.CN_SCRATCHPAD, DefineConstants.CN_ITERATIONS);
	  }

	  // Standard CryptoNight Lite
	  public static void cn_lite_slow_hash_v0(object data, uint length, Hash hash)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		cn_slow_hash(data, length, reinterpret_cast<char>(hash), 1, 0, 0, DefineConstants.CN_LITE_PAGE_SIZE, DefineConstants.CN_LITE_SCRATCHPAD, DefineConstants.CN_LITE_ITERATIONS);
	  }

	  public static void cn_lite_slow_hash_v1(object data, uint length, Hash hash)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		cn_slow_hash(data, length, reinterpret_cast<char>(hash), 1, 1, 0, DefineConstants.CN_LITE_PAGE_SIZE, DefineConstants.CN_LITE_SCRATCHPAD, DefineConstants.CN_LITE_ITERATIONS);
	  }

	  public static void cn_lite_slow_hash_v2(object data, uint length, Hash hash)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		cn_slow_hash(data, length, reinterpret_cast<char>(hash), 1, 2, 0, DefineConstants.CN_LITE_PAGE_SIZE, DefineConstants.CN_LITE_SCRATCHPAD, DefineConstants.CN_LITE_ITERATIONS);
	  }

	  // CryptoNight Soft Shell
	  public static void cn_soft_shell_slow_hash_v0(object data, uint length, Hash hash, uint height)
	  {
		uint base_offset = (height % DefineConstants.CN_SOFT_SHELL_WINDOW);
		int offset = (height % (DefineConstants.CN_SOFT_SHELL_WINDOW * 2)) - (base_offset * 2);
		if (offset < 0)
		{
		  offset = base_offset;
		}

		uint scratchpad = DefineConstants.CN_SOFT_SHELL_MEMORY + ((uint)offset * (DefineConstants.CN_SOFT_SHELL_WINDOW / DefineConstants.CN_SOFT_SHELL_MULTIPLIER));
		uint iterations = (DefineConstants.CN_SOFT_SHELL_MEMORY / 2) + ((uint)offset * ((DefineConstants.CN_SOFT_SHELL_WINDOW / DefineConstants.CN_SOFT_SHELL_MULTIPLIER) / 2));
		uint pagesize = scratchpad;

//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		cn_slow_hash(data, length, reinterpret_cast<char>(hash), 1, 0, 0, pagesize, scratchpad, iterations);
	  }

	  public static void cn_soft_shell_slow_hash_v1(object data, uint length, Hash hash, uint height)
	  {
		uint base_offset = (height % DefineConstants.CN_SOFT_SHELL_WINDOW);
		int offset = (height % (DefineConstants.CN_SOFT_SHELL_WINDOW * 2)) - (base_offset * 2);
		if (offset < 0)
		{
		  offset = base_offset;
		}

		uint scratchpad = DefineConstants.CN_SOFT_SHELL_MEMORY + ((uint)offset * (DefineConstants.CN_SOFT_SHELL_WINDOW / DefineConstants.CN_SOFT_SHELL_MULTIPLIER));
		uint iterations = (DefineConstants.CN_SOFT_SHELL_MEMORY / 2) + ((uint)offset * ((DefineConstants.CN_SOFT_SHELL_WINDOW / DefineConstants.CN_SOFT_SHELL_MULTIPLIER) / 2));
		uint pagesize = scratchpad;

//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		cn_slow_hash(data, length, reinterpret_cast<char>(hash), 1, 1, 0, pagesize, scratchpad, iterations);
	  }

	  public static void cn_soft_shell_slow_hash_v2(object data, uint length, Hash hash, uint height)
	  {
		uint base_offset = (height % DefineConstants.CN_SOFT_SHELL_WINDOW);
		int offset = (height % (DefineConstants.CN_SOFT_SHELL_WINDOW * 2)) - (base_offset * 2);
		if (offset < 0)
		{
		  offset = base_offset;
		}

		uint scratchpad = DefineConstants.CN_SOFT_SHELL_MEMORY + ((uint)offset * (DefineConstants.CN_SOFT_SHELL_WINDOW / DefineConstants.CN_SOFT_SHELL_MULTIPLIER));
		uint iterations = (DefineConstants.CN_SOFT_SHELL_MEMORY / 2) + ((uint)offset * ((DefineConstants.CN_SOFT_SHELL_WINDOW / DefineConstants.CN_SOFT_SHELL_MULTIPLIER) / 2));
		uint pagesize = scratchpad;

//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		cn_slow_hash(data, length, reinterpret_cast<char>(hash), 1, 2, 0, pagesize, scratchpad, iterations);
	  }

	  public static void tree_hash(Hash hashes, uint count, Hash root_hash)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		tree_hash(reinterpret_cast<const char(*)[HASH_SIZE]>(hashes), count, reinterpret_cast<char>(root_hash));
	  }

	  public static void tree_branch(Hash hashes, uint count, Hash branch)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		tree_branch(reinterpret_cast<const char(*)[HASH_SIZE]>(hashes), count, reinterpret_cast<char(*)[HASH_SIZE]>(branch));
	  }

	  public static void tree_hash_from_branch(Hash branch, uint depth, Hash leaf, object path, Hash root_hash)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		tree_hash_from_branch(reinterpret_cast<const char(*)[HASH_SIZE]>(branch), depth, reinterpret_cast<const char>(leaf), path, reinterpret_cast<char>(root_hash));
	  }
	}
}

namespace CryptoNote.error
{
	public static class GlobalMembers
	{
	public static std::error_condition make_error_condition(AddBlockErrorCondition e)
	{
	  return std::error_condition((int)e, AddBlockErrorConditionCategory.INSTANCE);
	}

	public static std::error_code make_error_code(CryptoNote.error.AddBlockErrorCode e)
	{
	  return std::error_code((int)e, CryptoNote.error.AddBlockErrorCategory.INSTANCE);
	}

	public static std::error_code make_error_code(CryptoNote.error.BlockValidationError e)
	{
	  return std::error_code((int)e, CryptoNote.error.BlockValidationErrorCategory.INSTANCE);
	}

	public static std::error_code make_error_code(CryptoNote.error.CoreErrorCode e)
	{
	  return std::error_code((int)e, CryptoNote.error.CoreErrorCategory.INSTANCE);
	}

	public static std::error_code make_error_code(CryptoNote.error.TransactionValidationError e)
	{
	  return std::error_code((int)e, CryptoNote.error.TransactionValidationErrorCategory.INSTANCE);
	}
	}
}

namespace CryptoNote
{
	public static class GlobalMembers
	{
	public static bool serialize(PackedOutIndex value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return serializer.functorMethod(value.packedValue, name);
	}

//C++ TO C# CONVERTER NOTE: C# has no need of forward class declarations:
	//class DatabaseBlockchainCache;

	public static UseGenesis addGenesisBlock = new UseGenesis(true);
	public static UseGenesis skipGenesisBlock = new UseGenesis(false);

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <class T, class F>
	public static void splitGlobalIndexes<T, F>(T sourceContainer, T destinationContainer, uint splitBlockIndex, F lowerBoundFunction)
	{
	  for (var it = sourceContainer.begin(); it != sourceContainer.end();)
	  {
		var newCacheOutputsIteratorStart = lowerBoundFunction(it.second.outputs.begin(), it.second.outputs.end(), splitBlockIndex);

		auto indexesForAmount = destinationContainer[it.first];
		var newCacheOutputsCount = (uint)std::distance(newCacheOutputsIteratorStart, it.second.outputs.end());
		indexesForAmount.outputs.reserve(newCacheOutputsCount);

		indexesForAmount.startIndex = it.second.startIndex + (uint)it.second.outputs.size() - newCacheOutputsCount;

		std::move(newCacheOutputsIteratorStart, it.second.outputs.end(), std::back_inserter(indexesForAmount.outputs));
		it.second.outputs.erase(newCacheOutputsIteratorStart, it.second.outputs.end());

		if (indexesForAmount.outputs.empty())
		{
		  destinationContainer.erase(it.first);
		}

		if (it.second.outputs.empty())
		{
		  // if we gave all of our outputs we don't need this amount entry any more
		  it = sourceContainer.erase(it);
		}
		else
		{
		  ++it;
		}
	  }
	}

	// factory functions
//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
	public static BlockchainMessage makeChainSwitchMessage(uint index, List<Crypto.Hash>&& hashes)
	{
	  return BlockchainMessage
	  {
		  Messages.ChainSwitch{index, std::move(hashes)}
	  };
	}
	public static BlockchainMessage makeNewAlternativeBlockMessage(uint index, Crypto.Hash hash)
	{
	  return BlockchainMessage
	  {
		  Messages.NewAlternativeBlock{index, std::move(hash)}
	  };
	}
	public static BlockchainMessage makeNewBlockMessage(uint index, Crypto.Hash hash)
	{
	  return BlockchainMessage
	  {
		  Messages.NewBlock{index, std::move(hash)}
	  };
	}
//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
	public static BlockchainMessage makeAddTransactionMessage(List<Crypto.Hash>&& hashes)
	{
	  return BlockchainMessage
	  {
		  Messages.AddTransaction{std::move(hashes)}
	  };
	}
//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
	public static BlockchainMessage makeDelTransactionMessage(List<Crypto.Hash>&& hashes, Messages.DeleteTransaction.Reason reason)
	{
	  return BlockchainMessage
	  {
		  Messages.DeleteTransaction{std::move(hashes), reason}
	  };
	}
	public static bool check_hash(Crypto.Hash hash, ulong difficulty)
	{
	  ulong low = new ulong();
	  ulong high = new ulong();
	  ulong top = new ulong();
	  ulong cur = new ulong();
	  // First check the highest word, this will most likely fail for a random hash.
	  mul(swap64le(((ulong) hash)[3]), new ulong(difficulty), ref top, ref high);
	  if (high != 0)
	  {
		return false;
	  }
	  mul(swap64le(((ulong) hash)[0]), new ulong(difficulty), ref low, ref cur);
	  mul(swap64le(((ulong) hash)[1]), new ulong(difficulty), ref low, ref high);
	  bool carry = cadd(new ulong(cur), new ulong(low));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: cur = high;
	  cur.CopyFrom(high);
	  mul(swap64le(((ulong) hash)[2]), new ulong(difficulty), ref low, ref high);
	  carry = cadc(new ulong(cur), new ulong(low), carry);
	  carry = cadc(new ulong(high), new ulong(top), carry);
	  return !carry;
	}

	#if __SIZEOF_INT128__

	  internal static void mul(ulong a, ulong b, ref ulong low, ref ulong high)
	  {
	//C++ TO C# CONVERTER TODO TASK: Typedefs defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//	typedef uint __int128 uint128_t;
		uint __int128 res = (uint __int128) a * (uint __int128) b;
		low = (ulong) res;
		high = (ulong)(res >> 64);
	  }

	#else

	  internal static void mul(ulong a, ulong b, ref ulong low, ulong high)
	  {
		low = GlobalMembers.mul128(new ulong(a), new ulong(b), high);
	  }

	#endif

	  internal static bool cadd(ulong a, ulong b)
	  {
		return a + b < a;
	  }

	  internal static bool cadc(ulong a, ulong b, bool c)
	  {
		return a + b < a || (c && a + b == (ulong) - 1);
	  }
	public static List<T> preallocateVector<T>(size_t elements)
	{
	  List<T> vect = new List<T>();
	  vect.Capacity = elements;
	  return vect;
	}
	public static UseGenesis addGenesisBlock = new UseGenesis(true);

	public static IBlockchainCache findIndexInChain(IBlockchainCache blockSegment, Crypto.Hash blockHash)
	{
	  Debug.Assert(blockSegment != null);
	  while (blockSegment != null)
	  {
		if (blockSegment.hasBlock(blockHash))
		{
		  return blockSegment;
		}

		blockSegment = blockSegment.getParent();
	  }

	  return null;
	}

	public static IBlockchainCache findIndexInChain(IBlockchainCache blockSegment, uint blockIndex)
	{
	  Debug.Assert(blockSegment != null);
	  while (blockSegment != null)
	  {
		if (blockIndex >= blockSegment.getStartBlockIndex() != null && blockIndex < blockSegment.getStartBlockIndex() + blockSegment.getBlockCount())
		{
		  return blockSegment;
		}

		blockSegment = blockSegment.getParent();
	  }

	  return null;
	}

	public static size_t getMaximumTransactionAllowedSize(size_t blockSizeMedian, Currency currency)
	{
	  Debug.Assert(blockSizeMedian * 2 > currency.minerTxBlobReservedSize());

	  return blockSizeMedian * 2 - currency.minerTxBlobReservedSize();
	}

	public static BlockTemplate extractBlockTemplate(RawBlock block)
	{
	  BlockTemplate blockTemplate = new BlockTemplate();
	  if (!fromBinaryArray(ref blockTemplate, block.block))
	  {
		throw std::system_error(error.GlobalMembers.make_error_code(error.AddBlockErrorCode.DESERIALIZATION_FAILED));
	  }

	  return blockTemplate;
	}

	public static Crypto.Hash getBlockHash(RawBlock block)
	{
	  BlockTemplate blockTemplate = GlobalMembers.extractBlockTemplate(block);
	  return new CachedBlock(blockTemplate).getBlockHash();
	}

	public static TransactionValidatorState extractSpentOutputs(CachedTransaction transaction)
	{
	  TransactionValidatorState spentOutputs = new TransactionValidatorState();
	  auto cryptonoteTransaction = transaction.getTransaction();

	  foreach (var input in cryptonoteTransaction.inputs)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (input.type() == typeid(KeyInput))
		{
		  KeyInput in = boost::get<KeyInput>(input);
		  bool r = spentOutputs.spentKeyImages.Add(in.keyImage).second;
		  if (r)
		  {
		  }
		  Debug.Assert(r);
		}
		else
		{
		  Debug.Assert(false);
		}
	  }

	  return spentOutputs;
	}

	public static TransactionValidatorState extractSpentOutputs(List<CachedTransaction> transactions)
	{
	  TransactionValidatorState resultOutputs = new TransactionValidatorState();
	  foreach (var transaction in transactions)
	  {
		var transactionOutputs = GlobalMembers.extractSpentOutputs(transaction);
		mergeStates(resultOutputs, transactionOutputs);
	  }

	  return resultOutputs;
	}

	public static long getEmissionChange(Currency currency, IBlockchainCache segment, uint previousBlockIndex, CachedBlock cachedBlock, ulong cumulativeSize, ulong cumulativeFee)
	{

	  ulong reward = 0;
	  long emissionChange = 0;
	  var alreadyGeneratedCoins = segment.getAlreadyGeneratedCoins(new uint(previousBlockIndex));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: auto lastBlocksSizes = segment.getLastBlocksSizes(currency.rewardBlocksWindow(), previousBlockIndex, addGenesisBlock);
	  var lastBlocksSizes = segment.getLastBlocksSizes(currency.rewardBlocksWindow(), new uint(previousBlockIndex), new CryptoNote.UseGenesis(GlobalMembers.addGenesisBlock));
	  var blocksSizeMedian = Common.GlobalMembers.medianValue(lastBlocksSizes);
	  if (!currency.getBlockReward(new ushort(cachedBlock.getBlock().majorVersion), blocksSizeMedian, new ulong(cumulativeSize), new ulong(alreadyGeneratedCoins), new ulong(cumulativeFee), reward, emissionChange))
	  {
		throw std::system_error(error.GlobalMembers.make_error_code(error.BlockValidationError.CUMULATIVE_BLOCK_SIZE_TOO_BIG));
	  }

	  return emissionChange;
	}

	public static uint findCommonRoot(IMainChainStorage storage, IBlockchainCache rootSegment)
	{
	  Debug.Assert(storage.getBlockCount());
	  Debug.Assert(rootSegment.getBlockCount());
	  Debug.Assert(rootSegment.getStartBlockIndex() == 0);
	  Debug.Assert(GlobalMembers.getBlockHash(storage.getBlockByIndex(0)) == rootSegment.getBlockHash(0));

	  uint left = 0;
	  uint right = Math.Min(storage.getBlockCount() - 1, rootSegment.getBlockCount() - 1);
	  while (left != right)
	  {
		Debug.Assert(right >= left);
		uint checkElement = left + (right - left) / 2 + 1;
		if (GlobalMembers.getBlockHash(storage.getBlockByIndex(new uint(checkElement))) == rootSegment.getBlockHash(new uint(checkElement)))
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: left = checkElement;
		  left.CopyFrom(checkElement);
		}
		else
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: right = checkElement - 1;
		  right.CopyFrom(checkElement - 1);
		}
	  }

	  return left;
	}

	public static readonly std::chrono.seconds OUTDATED_TRANSACTION_POLLING_INTERVAL = new std::chrono.seconds(60);
	  public static readonly Crypto.Hash NULL_HASH = boost::value_initialized<Crypto.Hash>();
	  public static readonly Crypto.PublicKey NULL_PUBLIC_KEY = boost::value_initialized<Crypto.PublicKey>();
	  public static readonly Crypto.SecretKey NULL_SECRET_KEY = boost::value_initialized<Crypto.SecretKey>();

	  public static KeyPair generateKeyPair()
	  {
		KeyPair k = new KeyPair();
		Crypto.generate_keys(k.publicKey, k.secretKey);
		return k;
	  }

	  public static ParentBlockSerializer makeParentBlockSerializer(BlockTemplate b, bool hashingSerialization, bool headerOnly)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		BlockTemplate blockRef = const_cast<BlockTemplate&>(b);
		return new ParentBlockSerializer(blockRef.parentBlock, blockRef.timestamp, blockRef.nonce, hashingSerialization, headerOnly);
	  }

  /************************************************************************/
  /* CryptoNote helper functions                                          */
  /************************************************************************/
  //-----------------------------------------------------------------------------------------------
	  /************************************************************************/
	  /* CryptoNote helper functions                                          */
	  /************************************************************************/
	  public static ulong getPenalizedAmount(ulong amount, size_t medianSize, size_t currentBlockSize)
	  {
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//	static_assert(sizeof(size_t) >= sizeof(uint), "size_t is too small");
		Debug.Assert(currentBlockSize <= 2 * medianSize);
		Debug.Assert(medianSize <= uint.MaxValue);
		Debug.Assert(currentBlockSize <= uint.MaxValue);

		if (amount == 0)
		{
		  return 0;
		}

		if (currentBlockSize <= medianSize)
		{
		  return amount;
		}

		ulong productHi = new ulong();
		ulong productLo = GlobalMembers.mul128(new ulong(amount), currentBlockSize * (UINT64_C(2) * medianSize - currentBlockSize), productHi);

		ulong penalizedAmountHi = new ulong();
		ulong penalizedAmountLo = new ulong();
		GlobalMembers.div128_32(new ulong(productHi), new ulong(productLo), (uint)medianSize, penalizedAmountHi, penalizedAmountLo);
		GlobalMembers.div128_32(new ulong(penalizedAmountHi), new ulong(penalizedAmountLo), (uint)medianSize, penalizedAmountHi, penalizedAmountLo);

		Debug.Assert(0 == penalizedAmountHi);
		Debug.Assert(penalizedAmountLo < amount);

		return penalizedAmountLo;
	  }
  //-----------------------------------------------------------------------
	  public static string getAccountAddressAsStr(ulong prefix, AccountPublicAddress adr)
	  {
		BinaryArray ba = new BinaryArray();
		bool r = toBinaryArray(adr, ref ba);
		if (r)
		{
		}
		Debug.Assert(r);
		return Tools.Base58.encode_addr(prefix, Common.asString(ba));
	  }
  //-----------------------------------------------------------------------
	  public static bool parseAccountAddressString(ulong prefix, AccountPublicAddress adr, string str)
	  {
		string data;

		return Tools.Base58.decode_addr(str, prefix, data) && fromBinaryArray(ref adr, asBinaryArray(data)) && check_key(adr.spendPublicKey) && check_key(adr.viewPublicKey);
	  }
  //-----------------------------------------------------------------------
	  public static bool is_coinbase(Transaction tx)
	  {
		if (tx.inputs.size() != 1)
		{
		  return false;
		}

//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (tx.inputs[0].type() != typeid(BaseInput))
		{
		  return false;
		}

		return true;
	  }

//std::string print_money(ulong amount, unsigned int decimal_point)
//{
//	/*if (decimal_point == (unsigned int)-1)
//		decimal_point = default_decimal_point;*/
//	if (decimal_point == (unsigned int)-1)
//		decimal_point = 2;
//	std::string s = std::to_string(amount);
//	if (s.size() < decimal_point + 1)
//	{
//		s.insert(0, decimal_point + 1 - s.size(), '0');
//	}
//	if (decimal_point > 0)
//		s.insert(s.size() - decimal_point, ".");
//	return s;
//}

	//std::string print_money(ulong amount, unsigned int decimal_point = -1);

	public static bool parseAndValidateTransactionFromBinaryArray(BinaryArray tx_blob, Transaction tx, Hash tx_hash, Hash tx_prefix_hash)
	{
	  if (!fromBinaryArray(ref tx, tx_blob))
	  {
		return false;
	  }

	  //TODO: validate tx
	  Crypto.GlobalMembers.cn_fast_hash(tx_blob.data(), tx_blob.size(), tx_hash);
	  getObjectHash(*(TransactionPrefix)tx, ref tx_prefix_hash);
	  return true;
	}


	public static bool constructTransaction(AccountKeys sender_account_keys, List<TransactionSourceEntry> sources, List<TransactionDestinationEntry> destinations, List<ushort> extra, Transaction tx, ulong unlock_time, Logging.ILogger log)
	{
	  LoggerRef logger = new LoggerRef(log, "construct_tx");

	  tx.inputs.clear();
	  tx.outputs.clear();
	  tx.signatures.clear();

	  tx.version = CURRENT_TRANSACTION_VERSION;
	  tx.unlockTime = unlock_time;

	  tx.extra = extra;
	  KeyPair txkey = generateKeyPair();
	  addTransactionPublicKeyToExtra(tx.extra, txkey.publicKey);

//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//  struct input_generation_context_data
	//  {
	//	KeyPair in_ephemeral;
	//  };

	  List<input_generation_context_data> in_contexts = new List<input_generation_context_data>();
	  ulong summary_inputs_money = 0;
	  //fill inputs
	  foreach (TransactionSourceEntry src_entr in sources)
	  {
		if (src_entr.realOutput >= src_entr.outputs.Count)
		{
		  logger(ERROR) << "real_output index (" << src_entr.realOutput << ")bigger than output_keys.size()=" << src_entr.outputs.Count;
		  return false;
		}
		summary_inputs_money += src_entr.amount;

		//KeyDerivation recv_derivation;
		in_contexts.Add(input_generation_context_data());
		KeyPair in_ephemeral = in_contexts[in_contexts.Count - 1].in_ephemeral;
		KeyImage img = new KeyImage();
		if (!generate_key_image_helper(sender_account_keys, src_entr.realTransactionPublicKey, new size_t(src_entr.realOutputIndexInTransaction), in_ephemeral, img))
		{
		  return false;
		}

		//check that derived key is equal with real output key
		if (!(in_ephemeral.publicKey == src_entr.outputs[src_entr.realOutput].Item2))
		{
		  logger(ERROR) << "derived public key mismatch with output public key! " << ENDL << "derived_key:" << Common.GlobalMembers.podToHex(in_ephemeral.publicKey) << ENDL << "real output_public_key:" << Common.GlobalMembers.podToHex(src_entr.outputs[src_entr.realOutput].Item2);
		  return false;
		}

		//put key image into tx input
		KeyInput input_to_key = new KeyInput();
		input_to_key.amount = src_entr.amount;
		input_to_key.keyImage = img;

		//fill outputs array and use relative offsets
		foreach (Tuple <uint in :PublicKey>& out_entry : src_entr.outputs)
		Tuple Crypto = new Tuple();
		{
		  input_to_key.outputIndexes.push_back(out_entry.first);
		}

		input_to_key.outputIndexes = absolute_output_offsets_to_relative(input_to_key.outputIndexes);
		tx.inputs.push_back(input_to_key);
	  }

	  // "Shuffle" outs
	  List<TransactionDestinationEntry> shuffled_dsts = new List<TransactionDestinationEntry>(destinations);
//C++ TO C# CONVERTER TODO TASK: The 'Compare' parameter of std::sort produces a boolean value, while the .NET Comparison parameter produces a tri-state result:
//ORIGINAL LINE: std::sort(shuffled_dsts.begin(), shuffled_dsts.end(), [](const TransactionDestinationEntry& de1, const TransactionDestinationEntry& de2)
  shuffled_dsts.Sort((TransactionDestinationEntry de1, TransactionDestinationEntry de2) =>
  {
	  return de1.amount < de2.amount;
  });

	  ulong summary_outs_money = 0;
	  //fill outputs
	  size_t output_index = 0;
	  foreach (TransactionDestinationEntry dst_entr in shuffled_dsts)
	  {
		if (!(dst_entr.amount > 0))
		{
		  logger(ERROR, BRIGHT_RED) << "Destination with wrong amount: " << dst_entr.amount;
		  return false;
		}
		KeyDerivation derivation = new KeyDerivation();
		PublicKey out_eph_public_key = new PublicKey();
		bool r = generate_key_derivation(dst_entr.addr.viewPublicKey, txkey.secretKey, derivation);

		if (!(r))
		{
		  logger(ERROR, BRIGHT_RED) << "at creation outs: failed to generate_key_derivation(" << dst_entr.addr.viewPublicKey << ", " << txkey.secretKey << ")";
		  return false;
		}

		r = derive_public_key(derivation, output_index, dst_entr.addr.spendPublicKey, out_eph_public_key);
		if (!(r))
		{
		  logger(ERROR, BRIGHT_RED) << "at creation outs: failed to derive_public_key(" << derivation << ", " << output_index << ", " << dst_entr.addr.spendPublicKey << ")";
		  return false;
		}

		TransactionOutput @out = new TransactionOutput();
		@out.amount = dst_entr.amount;
		KeyOutput tk = new KeyOutput();
		tk.key = out_eph_public_key;
		@out.target = tk;
		tx.outputs.push_back(@out);
		output_index++;
		summary_outs_money += dst_entr.amount;
	  }

	  //check money
	  if (summary_outs_money > summary_inputs_money)
	  {
		logger(ERROR) << "Transaction inputs money (" << summary_inputs_money << ") less than outputs money (" << summary_outs_money << ")";
		return false;
	  }

	  //generate ring signatures
	  Hash tx_prefix_hash = new Hash();
	  getObjectHash(*(TransactionPrefix)tx, ref tx_prefix_hash);

	  size_t i = 0;
	  foreach (TransactionSourceEntry src_entr in sources)
	  {
		List<PublicKey> keys_ptrs = new List<PublicKey>();
		foreach (Tuple <uint in :PublicKey>& o : src_entr.outputs)
		Tuple Crypto = new Tuple();
		{
		  keys_ptrs.Add(o.second);
		}

		tx.signatures.push_back(new List<Signature>());
		List<Signature> sigs = tx.signatures.back();
		sigs.Resize(src_entr.outputs.Count);
		Crypto.GlobalMembers.generate_ring_signature(tx_prefix_hash, boost::get<KeyInput>(tx.inputs[i]).keyImage, keys_ptrs, in_contexts[i].in_ephemeral.secretKey, new size_t(src_entr.realOutput), sigs.data());
		i++;
	  }

	  return true;
	}


	public static bool is_out_to_acc(AccountKeys acc, KeyOutput out_key, PublicKey tx_pub_key, size_t keyIndex)
	{
	  KeyDerivation derivation = new KeyDerivation();
	  generate_key_derivation(tx_pub_key, acc.viewSecretKey, derivation);
	  return is_out_to_acc(acc, out_key, derivation, new size_t(keyIndex));
	}
	public static bool is_out_to_acc(AccountKeys acc, KeyOutput out_key, KeyDerivation derivation, size_t keyIndex)
	{
	  PublicKey pk = new PublicKey();
	  derive_public_key(derivation, keyIndex, acc.address.spendPublicKey, pk);
	  return pk == out_key.key;
	}
	public static bool lookup_acc_outs(AccountKeys acc, Transaction tx, PublicKey tx_pub_key, List<size_t> outs, ref ulong money_transfered)
	{
	  money_transfered = 0;
	  size_t keyIndex = 0;
	  size_t outputIndex = 0;

	  KeyDerivation derivation = new KeyDerivation();
	  generate_key_derivation(tx_pub_key, acc.viewSecretKey, derivation);

	  foreach (TransactionOutput o in tx.outputs)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		Debug.Assert(o.target.type() == typeid(KeyOutput));
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (o.target.type() == typeid(KeyOutput))
		{
		  if (is_out_to_acc(acc, boost::get<KeyOutput>(o.target), derivation, new size_t(keyIndex)))
		  {
			outs.Add(outputIndex);
			money_transfered += o.amount;
		  }

		  ++keyIndex;
		}

		++outputIndex;
	  }
	  return true;
	}
	public static bool lookup_acc_outs(AccountKeys acc, Transaction tx, List<size_t> outs, ulong money_transfered)
	{
	  PublicKey transactionPublicKey = getTransactionPublicKeyFromExtra(tx.extra);
	  if (transactionPublicKey == NULL_PUBLIC_KEY)
	  {
		return false;
	  }
	  return lookup_acc_outs(acc, tx, transactionPublicKey, outs, ref money_transfered);
	}
	public static bool get_tx_fee(Transaction tx, ref ulong fee)
	{
	  ulong amount_in = 0;
	  ulong amount_out = 0;

	  foreach (var in in tx.inputs)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (in.type() == typeid(KeyInput))
		{
		  amount_in += boost::get<KeyInput>(in).amount;
		}
	  }

	  foreach (var o in tx.outputs)
	  {
		amount_out += o.amount;
	  }

	  if (!(amount_in >= amount_out))
	  {
		return false;
	  }

	  fee = amount_in - amount_out;
	  return true;
	}
	public static ulong get_tx_fee(Transaction tx)
	{
	  ulong r = 0;
	  if (!get_tx_fee(tx, ref r))
	  {
		return 0;
	  }
	  return r;
	}
	public static bool generate_key_image_helper(AccountKeys ack, PublicKey tx_public_key, size_t real_output_index, KeyPair in_ephemeral, KeyImage ki)
	{
	  KeyDerivation recv_derivation = new KeyDerivation();
	  bool r = generate_key_derivation(tx_public_key, ack.viewSecretKey, recv_derivation);

	  Debug.Assert(r && "key image helper: failed to generate_key_derivation");

	  if (!r)
	  {
		return false;
	  }

	  r = derive_public_key(recv_derivation, real_output_index, ack.address.spendPublicKey, in_ephemeral.publicKey);

	  Debug.Assert(r && "key image helper: failed to derive_public_key");

	  if (!r)
	  {
		return false;
	  }

	  Crypto.GlobalMembers.derive_secret_key(recv_derivation, new size_t(real_output_index), ack.spendSecretKey, in_ephemeral.secretKey);
	  generate_key_image(in_ephemeral.publicKey, in_ephemeral.secretKey, ki);
	  return true;
	}
	public static bool getInputsMoneyAmount(Transaction tx, ref ulong money)
	{
	  money = 0;

	  foreach (var in in tx.inputs)
	  {
		ulong amount = 0;

//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (in.type() == typeid(KeyInput))
		{
		  amount = boost::get<KeyInput>(in).amount;
		}

		money += amount;
	  }
	  return true;
	}
	public static bool checkInputTypesSupported(TransactionPrefix tx)
	{
	  foreach (var in in tx.inputs)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (in.type() != typeid(KeyInput))
		{
		  return false;
		}
	  }

	  return true;
	}
	public static bool checkOutsValid(TransactionPrefix tx, string error = null)
	{
	  foreach (TransactionOutput @out in tx.outputs)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (@out.target.type() == typeid(KeyOutput))
		{
		  if (@out.amount == 0)
		  {
			if (error != null)
			{
			  error = "Zero amount ouput";
			}
			return false;
		  }

		  if (!check_key(boost::get<KeyOutput>(@out.target).key))
		  {
			if (error != null)
			{
			  error = "Output with invalid key";
			}
			return false;
		  }
		}
		else
		{
		  if (error != null)
		  {
			error = "Output with invalid type";
		  }
		  return false;
		}
	  }

	  return true;
	}
	public static bool checkMoneyOverflow(TransactionPrefix tx)
	{
	  return checkInputsOverflow(tx) && checkOutsOverflow(tx);
	}
	public static bool checkInputsOverflow(TransactionPrefix tx)
	{
	  ulong money = 0;

	  foreach (var in in tx.inputs)
	  {
		ulong amount = 0;

//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (in.type() == typeid(KeyInput))
		{
		  amount = boost::get<KeyInput>(in).amount;
		}

		if (money > amount + money)
		{
		  return false;
		}

		money += amount;
	  }
	  return true;
	}
	public static bool checkOutsOverflow(TransactionPrefix tx)
	{
	  ulong money = 0;
	  foreach (var o in tx.outputs)
	  {
		if (money > o.amount + money)
		{
		  return false;
		}
		money += o.amount;
	  }
	  return true;
	}
	public static ulong get_outs_money_amount(Transaction tx)
	{
	  ulong outputs_amount = 0;
	  foreach (var o in tx.outputs)
	  {
		outputs_amount += o.amount;
	  }
	  return outputs_amount;
	}
	public static string short_hash_str(Hash h)
	{
	  string res = Common.GlobalMembers.podToHex(h);

	  if (res.Length == 64)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to the standard string 'erase' method in C# if it's used as an rvalue:
		var erased_pos = res.erase(8, 48);
		res = res.Insert(8, "....");
	  }

	  return res;
	}

	public static List<uint> relativeOutputOffsetsToAbsolute(List<uint> off)
	{
	  List<uint> res = new List(off);
	  for (size_t i = 1; i < res.Count; i++)
	  {
		res[i] += res[i - 1];
	  }
	  return res;
	}
	public static List<uint> absolute_output_offsets_to_relative(List<uint> off)
	{
	  if (off.Count == 0)
	  {
		  return new List<uint>();
	  }
	  var copy = off;
	  for (size_t i = 1; i < copy.Count; ++i)
	  {
		copy[i] = off[i] - off[i - 1];
	  }
	  return copy;
	}


	// 62387455827 -> 455827 + 7000000 + 80000000 + 300000000 + 2000000000 + 60000000000, where 455827 <= dust_threshold
//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename chunk_handler_t, typename dust_handler_t>
	public static void decompose_amount_into_digits<chunk_handler_t, dust_handler_t>(ulong amount, ulong dust_threshold, chunk_handler_t chunk_handler, dust_handler_t dust_handler)
	{
	  if (0 == amount)
	  {
		return;
	  }

	  bool is_dust_handled = false;
	  ulong dust = 0;
	  ulong order = 1;
	  while (0 != amount)
	  {
		ulong chunk = (amount % 10) * order;
		amount /= 10;
		order *= 10;

		if (dust + chunk <= dust_threshold != null)
		{
		  dust += chunk;
		}
		else
		{
		  if (!is_dust_handled && 0 != dust)
		  {
			dust_handler(dust);
			is_dust_handled = true;
		  }
		  if (0 != chunk)
		  {
			chunk_handler(chunk);
		  }
		}
	  }

	  if (!is_dust_handled && 0 != dust)
	  {
		dust_handler(dust);
	  }
	}

	public static ulong power_integral(ulong a, ulong b)
	{
	  if (b == 0)
	  {
		return 1;
	  }
	  ulong total = new ulong(a);
	  for (ulong i = 1; i != b; i++)
	  {
		total *= a;
	  }
	  return total;
	}

	public static void serialize(TransactionPrefix txP, ISerializer serializer)
	{
	  serializer.functorMethod(txP.version, "version");

	  if (CURRENT_TRANSACTION_VERSION < txP.version && serializer.type() == ISerializer.INPUT)
	  {
		throw new System.Exception("Wrong transaction version");
	  }

	  serializer.functorMethod(txP.unlockTime, "unlock_time");
	  serializer.functorMethod(txP.inputs, "vin");
	  serializer.functorMethod(txP.outputs, "vout");
	  serializeAsBinary(txP.extra, "extra", serializer.functorMethod);
	}
	public static void serialize(Transaction tx, ISerializer serializer)
	{
	  serialize((TransactionPrefix)tx, serializer.functorMethod);

	  ulong sigSize = tx.inputs.size();
	  //TODO: make arrays without sizes
	//  serializer.beginArray(sigSize, "signatures");

	  // ignore base transaction
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
	  if (serializer.type() == ISerializer.INPUT && !(sigSize == 1 && tx.inputs[0].type() == typeid(BaseInput)))
	  {
		tx.signatures.resize(sigSize);
	  }

	  bool signaturesNotExpected = tx.signatures.empty();
	  if (!signaturesNotExpected && tx.inputs.size() != tx.signatures.size())
	  {
		throw new System.Exception("Serialization error: unexpected signatures size");
	  }

	  for (ulong i = 0; i < tx.inputs.size(); ++i)
	  {
		ulong signatureSize = GlobalMembers.getSignaturesCount(tx.inputs[i]);
		if (signaturesNotExpected)
		{
		  if (signatureSize == 0)
		  {
			continue;
		  }
		  else
		  {
			throw new System.Exception("Serialization error: signatures are not expected");
		  }
		}

		if (serializer.type() == ISerializer.OUTPUT)
		{
		  if (signatureSize != tx.signatures[i].size())
		  {
			throw new System.Exception("Serialization error: unexpected signatures size");
		  }

		  foreach (Crypto  in :Signature & sig : tx.signatures[i])
		  {
			GlobalMembers.serializePod(sig, "", serializer.functorMethod);
		  }

		}
		else
		{
		  List<Crypto.Signature> signatures = new List<Crypto.Signature>(signatureSize);
		  foreach (Crypto  in :Signature & sig : signatures)
		  {
			GlobalMembers.serializePod(sig, "", serializer.functorMethod);
		  }

		  tx.signatures[i] = std::move(signatures);
		}
	  }
	//  serializer.endArray();
	}
	public static void serialize(BaseTransaction tx, ISerializer serializer)
	{
	  serializer.functorMethod(tx.version, "version");
	  serializer.functorMethod(tx.unlockTime, "unlock_time");
	  serializer.functorMethod(tx.inputs, "vin");
	  serializer.functorMethod(tx.outputs, "vout");
	  serializeAsBinary(tx.extra, "extra", serializer.functorMethod);

	  if (tx.version >= TRANSACTION_VERSION_2)
	  {
		ulong ignored = 0;
		serializer.functorMethod(ignored, "ignored");
	  }
	}
	public static void serialize(TransactionInput in, ISerializer serializer)
	{
	  if (serializer.type() == ISerializer.OUTPUT)
	  {
		BinaryVariantTagGetter tagGetter = new BinaryVariantTagGetter();
		ushort tag = boost::apply_visitor(tagGetter.functorMethod, in);
		serializer.binary(tag, sizeof(ushort), "type");

		VariantSerializer visitor = new VariantSerializer(serializer.functorMethod, "value");
		boost::apply_visitor(visitor.functorMethod, in);
	  }
	  else
	  {
		ushort tag = new ushort();
		serializer.binary(tag, sizeof(ushort), "type");

		GlobalMembers.getVariantValue(serializer.functorMethod, new ushort(tag), ref in);
	  }
	}
	public static void serialize(TransactionOutput output, ISerializer serializer)
	{
	  serializer.functorMethod(output.amount, "amount");
	  serializer.functorMethod(output.target, "target");
	}

	public static void serialize(BaseInput gen, ISerializer serializer)
	{
	  serializer.functorMethod(gen.blockIndex, "height");
	}
	public static void serialize(KeyInput key, ISerializer serializer)
	{
	  serializer.functorMethod(key.amount, "amount");
	  GlobalMembers.serializeVarintVector(key.outputIndexes, serializer.functorMethod, "key_offsets");
	  serializer.functorMethod(key.keyImage, "k_image");
	}

	//void serialize(TransactionOutput output, ISerializer serializer);Tangible Method Implementation Not FoundCryptoNote-serialize
	public static void serialize(TransactionOutputTarget output, ISerializer serializer)
	{
	  if (serializer.type() == ISerializer.OUTPUT)
	  {
		BinaryVariantTagGetter tagGetter = new BinaryVariantTagGetter();
		ushort tag = boost::apply_visitor(tagGetter.functorMethod, output);
		serializer.binary(tag, sizeof(ushort), "type");

		VariantSerializer visitor = new VariantSerializer(serializer.functorMethod, "data");
		boost::apply_visitor(visitor.functorMethod, output);
	  }
	  else
	  {
		ushort tag = new ushort();
		serializer.binary(tag, sizeof(ushort), "type");

		GlobalMembers.getVariantValue(serializer.functorMethod, new ushort(tag), ref output);
	  }
	}
	public static void serialize(KeyOutput key, ISerializer serializer)
	{
	  serializer.functorMethod(key.key, "key");
	}

	public static void serialize(BlockHeader header, ISerializer serializer)
	{
	  serializeBlockHeader(header, serializer.functorMethod);
	}
	public static void serialize(BlockTemplate block, ISerializer serializer)
	{
	  serializeBlockHeader(block, serializer.functorMethod);

	  if (block.majorVersion >= BLOCK_MAJOR_VERSION_2)
	  {
		var parentBlockSerializer = makeParentBlockSerializer(block, false, false);
		serializer.functorMethod(parentBlockSerializer, "parent_block");
	  }

	  serializer.functorMethod(block.baseTransaction, "miner_tx");
	  serializer.functorMethod(block.transactionHashes, "tx_hashes");
	}
	public static void serialize(ParentBlockSerializer pbs, ISerializer serializer)
	{
	  serializer.functorMethod(pbs.m_parentBlock.majorVersion, "majorVersion");

	  serializer.functorMethod(pbs.m_parentBlock.minorVersion, "minorVersion");
	  serializer.functorMethod(pbs.m_timestamp, "timestamp");
	  serializer.functorMethod(pbs.m_parentBlock.previousBlockHash, "prevId");
	  serializer.binary(pbs.m_nonce, sizeof(uint), "nonce");

	  if (pbs.m_hashingSerialization)
	  {
		Crypto.Hash minerTxHash = new Crypto.Hash();
		if (!getBaseTransactionHash(pbs.m_parentBlock.baseTransaction, ref minerTxHash))
		{
		  throw new System.Exception("Get transaction hash error");
		}

		Crypto.Hash merkleRoot = new Crypto.Hash();
		Crypto.GlobalMembers.tree_hash_from_branch(pbs.m_parentBlock.baseTransactionBranch.data(), pbs.m_parentBlock.baseTransactionBranch.size(), minerTxHash, 0, merkleRoot);

		serializer.functorMethod(merkleRoot, "merkleRoot");
	  }

	  ulong txNum = (ulong)pbs.m_parentBlock.transactionCount;
	  serializer.functorMethod(txNum, "numberOfTransactions");
	  pbs.m_parentBlock.transactionCount = (ushort)txNum;
	  if (pbs.m_parentBlock.transactionCount < 1)
	  {
		throw new System.Exception("Wrong transactions number");
	  }

	  if (pbs.m_headerOnly)
	  {
		return;
	  }

	  ulong branchSize = Crypto.tree_depth(pbs.m_parentBlock.transactionCount);
	  if (serializer.type() == ISerializer.OUTPUT)
	  {
		if (pbs.m_parentBlock.baseTransactionBranch.size() != branchSize)
		{
		  throw new System.Exception("Wrong miner transaction branch size");
		}
	  }
	  else
	  {
		pbs.m_parentBlock.baseTransactionBranch.resize(branchSize);
	  }

	//  serializer(m_parentBlock.baseTransactionBranch, "baseTransactionBranch");
	  //TODO: Make arrays with computable size! This code won't work with json serialization!
	  foreach (Crypto  in :Hash & hash: pbs.m_parentBlock.baseTransactionBranch)
	  {
		serializer.functorMethod(hash, "");
	  }

	  serializer.functorMethod(pbs.m_parentBlock.baseTransaction, "minerTx");

	  TransactionExtraMergeMiningTag mmTag = new TransactionExtraMergeMiningTag();
	  if (!getMergeMiningTagFromExtra(pbs.m_parentBlock.baseTransaction.extra, mmTag))
	  {
		throw new System.Exception("Can't get extra merge mining tag");
	  }

	  if (mmTag.depth > 8 * sizeof(Crypto.Hash))
	  {
		throw new System.Exception("Wrong merge mining tag depth");
	  }

	  if (serializer.type() == ISerializer.OUTPUT)
	  {
		if (mmTag.depth != pbs.m_parentBlock.blockchainBranch.size())
		{
		  throw new System.Exception("Blockchain branch size must be equal to merge mining tag depth");
		}
	  }
	  else
	  {
		pbs.m_parentBlock.blockchainBranch.resize(mmTag.depth);
	  }

	//  serializer(m_parentBlock.blockchainBranch, "blockchainBranch");
	  //TODO: Make arrays with computable size! This code won't work with json serialization!
	  foreach (Crypto  in :Hash & hash: pbs.m_parentBlock.blockchainBranch)
	  {
		serializer.functorMethod(hash, "");
	  }
	}
	public static void serialize(TransactionExtraMergeMiningTag tag, ISerializer serializer)
	{
	  if (serializer.type() == ISerializer.OUTPUT)
	  {
		string field;
		StringOutputStream os = new StringOutputStream(field);
		BinaryOutputStreamSerializer output = new BinaryOutputStreamSerializer(os);
		doSerialize(tag, output.functorMethod);
		serializer.functorMethod(field, "");
	  }
	  else
	  {
		string field;
		serializer.functorMethod(field, "mm_tag");
		MemoryInputStream stream = new MemoryInputStream(field.data(), field.Length);
		BinaryInputStreamSerializer input = new BinaryInputStreamSerializer(stream);
		doSerialize(tag, input.functorMethod);
	  }
	}

	public static void serialize(AccountPublicAddress address, ISerializer serializer)
	{
	  serializer.functorMethod(address.spendPublicKey, "m_spend_public_key");
	  serializer.functorMethod(address.viewPublicKey, "m_view_public_key");
	}
	public static void serialize(AccountKeys keys, ISerializer s)
	{
	  s.functorMethod(keys.address, "m_account_address");
	  s.functorMethod(keys.spendSecretKey, "m_spend_secret_key");
	  s.functorMethod(keys.viewSecretKey, "m_view_secret_key");
	}

	public static void serialize(KeyPair keyPair, ISerializer serializer)
	{
	  serializer.functorMethod(keyPair.secretKey, "secret_key");
	  serializer.functorMethod(keyPair.publicKey, "public_key");
	}

// unpack to strings to maintain protocol compatibility with older versions
	public static void serialize(RawBlock rawBlock, ISerializer serializer)
	{
	  if (serializer.type() == ISerializer.INPUT)
	  {
		ulong blockSize = new ulong();
		serializer.functorMethod(blockSize, "block_size");
		rawBlock.block.resize((ulong)blockSize);
	  }
	  else
	  {
		ulong blockSize = rawBlock.block.size();
		serializer.functorMethod(blockSize, "block_size");
	  }

	  serializer.binary(rawBlock.block.data(), rawBlock.block.size(), "block");

	  if (serializer.type() == ISerializer.INPUT)
	  {
		ulong txCount = new ulong();
		serializer.functorMethod(txCount, "tx_count");
		rawBlock.transactions.resize((ulong)txCount);

		foreach (var txBlob in rawBlock.transactions)
		{
		  ulong txSize = new ulong();
		  serializer.functorMethod(txSize, "tx_size");
		  txBlob.resize(txSize);
		  serializer.binary(txBlob.data(), txBlob.size(), "transaction");
		}
	  }
	  else
	  {
		ulong txCount = rawBlock.transactions.size();
		serializer.functorMethod(txCount, "tx_count");

		foreach (var txBlob in rawBlock.transactions)
		{
		  ulong txSize = txBlob.size();
		  serializer.functorMethod(txSize, "tx_size");
		  serializer.binary(txBlob.data(), txBlob.size(), "transaction");
		}
	  }
	}

	public static void serializeBlockHeader(BlockHeader header, ISerializer serializer)
	{
	  serializer.functorMethod(header.majorVersion, "major_version");
	  if (header.majorVersion > BLOCK_MAJOR_VERSION_4)
	  {
		throw new System.Exception("Wrong major version");
	  }

	  serializer.functorMethod(header.minorVersion, "minor_version");
	  if (header.majorVersion == BLOCK_MAJOR_VERSION_1)
	  {
		serializer.functorMethod(header.timestamp, "timestamp");
		serializer.functorMethod(header.previousBlockHash, "prev_id");
		serializer.binary(header.nonce, sizeof(header.nonce), "nonce");
	  }
	  else if (header.majorVersion >= BLOCK_MAJOR_VERSION_2)
	  {
		serializer.functorMethod(header.previousBlockHash, "prev_id");
	  }
	  else
	  {
		throw new System.Exception("Wrong major version");
	  }
	}

	public static void doSerialize(TransactionExtraMergeMiningTag tag, ISerializer serializer)
	{
	  ulong depth = (ulong)tag.depth;
	  serializer.functorMethod(depth, "depth");
	  tag.depth = (ulong)depth;
	  serializer.functorMethod(tag.merkleRoot, "merkle_root");
	}

	public static void getBinaryArrayHash(BinaryArray binaryArray, Crypto.Hash hash)
	{
	  Crypto.GlobalMembers.cn_fast_hash(binaryArray.data(), binaryArray.size(), hash);
	}
	public static Crypto.Hash getBinaryArrayHash(BinaryArray binaryArray)
	{
	  Crypto.Hash hash = new Crypto.Hash();
	  getBinaryArrayHash(binaryArray, hash);
	  return hash;
	}

	// noexcept
//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class T>
	public static bool toBinaryArray<T>(T @object, ref BinaryArray binaryArray)
	{
	  try
	  {
		binaryArray = toBinaryArray(@object);
	  }
	  catch (System.Exception)
	  {
		return false;
	  }

	  return true;
	}

	public static bool toBinaryArray(BinaryArray @object, BinaryArray binaryArray)
	{
	  try
	  {
		Common.VectorOutputStream stream = new Common.VectorOutputStream(binaryArray);
		BinaryOutputStreamSerializer serializer = new BinaryOutputStreamSerializer(stream);
		string oldBlob = Common.asString(@object);
		serializer.functorMethod(oldBlob, "");
	  }
	  catch (System.Exception)
	  {
		return false;
	  }

	  return true;
	}

	// throws exception if serialization failed
//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class T>
	public static BinaryArray toBinaryArray<T>(T @object)
	{
	  BinaryArray ba = new BinaryArray();
	  global::Common.VectorOutputStream stream = new global::Common.VectorOutputStream(ba);
	  BinaryOutputStreamSerializer serializer = new BinaryOutputStreamSerializer(stream);
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
	  serialize(const_cast<T&>(@object), serializer.functorMethod);
	  return ba;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class T>
	public static T fromBinaryArray<T>(BinaryArray binaryArray)
	{
	  T @object = new default(T);
	  Common.MemoryInputStream stream = new Common.MemoryInputStream(binaryArray.data(), binaryArray.size());
	  BinaryInputStreamSerializer serializer = new BinaryInputStreamSerializer(stream);
	  serialize(@object, serializer.functorMethod);
	  if (!stream.endOfStream())
	  { // check that all data was consumed
		throw new System.Exception("failed to unpack type");
	  }

	  return @object;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class T>
	public static bool fromBinaryArray<T>(ref T @object, BinaryArray binaryArray)
	{
	  try
	  {
		@object = fromBinaryArray<T>(binaryArray);
	  }
	  catch (System.Exception)
	  {
		return false;
	  }

	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class T>
	public static bool getObjectBinarySize<T>(T @object, ref size_t size)
	{
	  BinaryArray ba = new BinaryArray();
	  if (!toBinaryArray(@object, ref ba))
	  {
		size = (numeric_limits<size_t>.max)();
		return false;
	  }

	  size = ba.size();
	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class T>
	public static size_t getObjectBinarySize<T>(T @object)
	{
	  size_t size = new size_t();
	  getObjectBinarySize(@object, ref size);
	  return size;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class T>
	public static bool getObjectHash<T>(T @object, ref Crypto.Hash hash)
	{
	  BinaryArray ba = new BinaryArray();
	  if (!toBinaryArray(@object, ref ba))
	  {
		hash = NULL_HASH;
		return false;
	  }

	  hash = getBinaryArrayHash(ba);
	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class T>
	public static bool getObjectHash<T>(T @object, ref Crypto.Hash hash, ref size_t size)
	{
	  BinaryArray ba = new BinaryArray();
	  if (!toBinaryArray(@object, ref ba))
	  {
		hash = NULL_HASH;
		size = (numeric_limits<size_t>.max)();
		return false;
	  }

	  size = ba.size();
	  hash = getBinaryArrayHash(ba);
	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class T>
	public static Crypto.Hash getObjectHash<T>(T @object)
	{
	  Crypto.Hash hash = new Crypto.Hash();
	  getObjectHash(@object, ref hash);
	  return hash;
	}

	public static bool getBaseTransactionHash(BaseTransaction tx, ref Crypto.Hash hash)
	{
	  if (tx.version < TRANSACTION_VERSION_2)
	  {
		return getObjectHash(tx, ref hash);
	  }
	  else
	  {
		BinaryArray data = new BinaryArray({0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x36, 0x78, 0x9e, 0x7a, 0x1e, 0x28, 0x14, 0x36, 0x46, 0x42, 0x29, 0x82, 0x8f, 0x81, 0x7d, 0x66, 0x12, 0xf7, 0xb4, 0x77, 0xd6, 0x65, 0x91, 0xff, 0x96, 0xa9, 0xe0, 0x64, 0xbc, 0xc9, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00});
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		if (getObjectHash((TransactionPrefix)tx, ref * reinterpret_cast<Crypto.Hash>(data.data())))
		{
		  hash = getBinaryArrayHash(data);
		  return true;
		}
		else
		{
		  return false;
		}
	  }
	}

	public static ulong getInputAmount(Transaction transaction)
	{
	  ulong amount = 0;
	  foreach (var input in transaction.inputs)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (input.type() == typeid(KeyInput))
		{
		  amount += boost::get<KeyInput>(input).amount;
		}
	  }

	  return amount;
	}
	public static List<ulong> getInputsAmounts(Transaction transaction)
	{
	  List<ulong> inputsAmounts = new List<ulong>();
	  inputsAmounts.Capacity = transaction.inputs.size();

	  foreach (var input in transaction.inputs)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (input.type() == typeid(KeyInput))
		{
		  inputsAmounts.Add(boost::get<KeyInput>(input).amount);
		}
	  }

	  return inputsAmounts;
	}
	public static ulong getOutputAmount(Transaction transaction)
	{
	  ulong amount = 0;
	  foreach (var output in transaction.outputs)
	  {
		amount += output.amount;
	  }

	  return amount;
	}
	public static void decomposeAmount(ulong amount, ulong dustThreshold, List<ulong> decomposedAmounts)
	{
  decompose_amount_into_digits(new ulong(amount), new ulong(dustThreshold), (ulong amount) =>
  {
	decomposedAmounts.Add(amount);
  }, (ulong dust) =>
  {
	decomposedAmounts.Add(dust);
  });
	}

	public static readonly List<ulong> Currency.PRETTY_AMOUNTS = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000, 1000000, 2000000, 3000000, 4000000, 5000000, 6000000, 7000000, 8000000, 9000000, 10000000, 20000000, 30000000, 40000000, 50000000, 60000000, 70000000, 80000000, 90000000, 100000000, 200000000, 300000000, 400000000, 500000000, 600000000, 700000000, 800000000, 900000000, 1000000000, 2000000000, 3000000000, 4000000000, 5000000000, 6000000000, 7000000000, 8000000000, 9000000000, 10000000000, 20000000000, 30000000000, 40000000000, 50000000000, 60000000000, 70000000000, 80000000000, 90000000000, 100000000000, 200000000000, 300000000000, 400000000000, 500000000000, 600000000000, 700000000000, 800000000000, 900000000000, 1000000000000, 2000000000000, 3000000000000, 4000000000000, 5000000000000, 6000000000000, 7000000000000, 8000000000000, 9000000000000, 10000000000000, 20000000000000, 30000000000000, 40000000000000, 50000000000000, 60000000000000, 70000000000000, 80000000000000, 90000000000000, 100000000000000, 200000000000000, 300000000000000, 400000000000000, 500000000000000, 600000000000000, 700000000000000, 800000000000000, 900000000000000, 1000000000000000, 2000000000000000, 3000000000000000, 4000000000000000, 5000000000000000, 6000000000000000, 7000000000000000, 8000000000000000, 9000000000000000, 10000000000000000, 20000000000000000, 30000000000000000, 40000000000000000, 50000000000000000, 60000000000000000, 70000000000000000, 80000000000000000, 90000000000000000, 100000000000000000, 200000000000000000, 300000000000000000, 400000000000000000, 500000000000000000, 600000000000000000, 700000000000000000, 800000000000000000, 900000000000000000, 1000000000000000000, 2000000000000000000, 3000000000000000000, 4000000000000000000, 5000000000000000000, 6000000000000000000, 7000000000000000000, 8000000000000000000, 9000000000000000000, 10000000000000000000Ul};
	public static bool findTransactionExtraFieldByType<T>(List<boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag>> tx_extra_fields, ref T field)
	{
//C++ TO C# CONVERTER TODO TASK: Lambda expressions cannot be assigned to 'var':
  var it = std::find_if(tx_extra_fields.GetEnumerator(), tx_extra_fields.end(), (boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag> f) =>
  {
	  return typeid(T) == f.type();
  });

	  if (tx_extra_fields.end() == it)
	  {
		return false;
	  }

	  field = boost::get<T>(*it);
	  return true;
	}

	//bool parseTransactionExtra(ClassicVector<ushort> tx_extra, ClassicVector<boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag>> tx_extra_fields);Tangible Method Implementation Not FoundCryptoNote-parseTransactionExtra
	//bool writeTransactionExtra(ClassicVector<ushort> tx_extra, ClassicVector<boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag>> tx_extra_fields);Tangible Method Implementation Not FoundCryptoNote-writeTransactionExtra

	//Crypto::PublicKey getTransactionPublicKeyFromExtra(ClassicVector<ushort> tx_extra);Tangible Method Implementation Not FoundCryptoNote-getTransactionPublicKeyFromExtra
	//bool addTransactionPublicKeyToExtra(ClassicVector<ushort> tx_extra, Crypto::PublicKey tx_pub_key);Tangible Method Implementation Not FoundCryptoNote-addTransactionPublicKeyToExtra
	//bool addExtraNonceToTransactionExtra(ClassicVector<ushort> tx_extra, ClassicVector<ushort> extra_nonce);Tangible Method Implementation Not FoundCryptoNote-addExtraNonceToTransactionExtra
	//void setPaymentIdToTransactionExtraNonce(ClassicVector<ushort> extra_nonce, Crypto::Hash payment_id);Tangible Method Implementation Not FoundCryptoNote-setPaymentIdToTransactionExtraNonce
	//bool getPaymentIdFromTransactionExtraNonce(ClassicVector<ushort> extra_nonce, Crypto::Hash payment_id);Tangible Method Implementation Not FoundCryptoNote-getPaymentIdFromTransactionExtraNonce
	//bool appendMergeMiningTagToExtra(ClassicVector<ushort> tx_extra, TransactionExtraMergeMiningTag mm_tag);Tangible Method Implementation Not FoundCryptoNote-appendMergeMiningTagToExtra
	//bool getMergeMiningTagFromExtra(ClassicVector<ushort> tx_extra, TransactionExtraMergeMiningTag mm_tag);Tangible Method Implementation Not FoundCryptoNote-getMergeMiningTagFromExtra

	//bool createTxExtraWithPaymentId(string paymentIdString, ClassicVector<ushort> extra);Tangible Method Implementation Not FoundCryptoNote-createTxExtraWithPaymentId
	//returns false if payment id is not found or parse error
	//bool getPaymentIdFromTxExtra(ClassicVector<ushort> extra, Crypto::Hash paymentId);Tangible Method Implementation Not FoundCryptoNote-getPaymentIdFromTxExtra
	//bool parsePaymentId(string paymentIdString, Crypto::Hash paymentId);Tangible Method Implementation Not FoundCryptoNote-parsePaymentId

	public static readonly uint ONE_DAY_SECONDS = 60 * 60 * 24;
	public static readonly CachedBlockInfo NULL_CACHED_BLOCK_INFO = new CachedBlockInfo(NULL_HASH, 0, 0, 0, 0, 0);

	public static bool requestPackedOutputs(IBlockchainCache.Amount amount, Common.ArrayView<uint> globalIndexes, IDataBase database, List<PackedOutIndex> result)
	{
	  BlockchainReadBatch readBatch = new BlockchainReadBatch();
	  result.Capacity = result.Count + globalIndexes.getSize();

	  foreach (var globalIndex in globalIndexes)
	  {
		readBatch.requestKeyOutputGlobalIndexForAmount(amount, globalIndex);
	  }

	  var dbResult = database.read(readBatch);
	  if (dbResult)
	  {
		return false;
	  }

	  try
	  {
		var readResult = readBatch.extractResult();
		auto packedOutsMap = readResult.getKeyOutputGlobalIndexesForAmounts();
		foreach (var globalIndex in globalIndexes)
		{
		  result.Add(packedOutsMap.at(Tuple.Create(amount, globalIndex)));
		}
	  }
	  catch (System.Exception)
	  {
		return false;
	  }

	  return true;
	}

	public static bool requestTransactionHashesForGlobalOutputIndexes(List<PackedOutIndex> packedOuts, IDataBase database, List<Crypto.Hash> transactionHashes)
	{
	  BlockchainReadBatch readHashesBatch = new BlockchainReadBatch();

	  SortedSet<uint> blockIndexes = new SortedSet<uint>();
  packedOuts.ForEach((PackedOutIndex @out) =>
  {
	  blockIndexes.Add(@out.blockIndex);
  });
  blockIndexes.ForEach((uint blockIndex) =>
  {
	  readHashesBatch.requestTransactionHashesByBlock(blockIndex);
  });

	  var dbResult = database.read(readHashesBatch);
	  if (dbResult)
	  {
		return false;
	  }

	  var readResult = readHashesBatch.extractResult();
	  auto transactionHashesMap = readResult.getTransactionHashesByBlocks();

	  if (transactionHashesMap.size() != blockIndexes.Count)
	  {
		return false;
	  }

	  transactionHashes.Capacity = transactionHashes.Count + packedOuts.Count;
	  foreach (var output in packedOuts)
	  {
		if (output.transactionIndex >= transactionHashesMap.at(output.blockIndex).size())
		{
		  return false;
		}

		transactionHashes.Add(transactionHashesMap.at(output.blockIndex)[output.transactionIndex]);
	  }

	  return true;
	}

	public static bool requestCachedTransactionInfos(List<Crypto.Hash> transactionHashes, IDataBase database, List<CachedTransactionInfo> result)
	{
	  result.Capacity = result.Count + transactionHashes.Count;

	  BlockchainReadBatch transactionsBatch = new BlockchainReadBatch();
  transactionHashes.ForEach((Crypto.Hash hash) =>
  {
	  transactionsBatch.requestCachedTransaction(hash);
  });
	  var dbResult = database.read(transactionsBatch);
	  if (dbResult)
	  {
		return false;
	  }

	  var readResult = transactionsBatch.extractResult();
	  auto transactions = readResult.getCachedTransactions();
	  if (transactions.size() != transactionHashes.Count)
	  {
		return false;
	  }

	  foreach (var hash in transactionHashes)
	  {
		result.Add(transactions.at(hash));
	  }

	  return true;
	}

	//returns CachedTransactionInfos in the same or as packedOuts are
	/*
	bool requestCachedTransactionInfos(const std::vector<PackedOutIndex>& packedOuts, IDataBase& database, std::vector<CachedTransactionInfo>& result) {
	  std::vector<Crypto::Hash> transactionHashes;
	  if (!requestTransactionHashesForGlobalOutputIndexes(packedOuts, database, transactionHashes)) {
	    return false;
	  }
	
	  return requestCachedTransactionInfos(transactionHashes, database, result);
	}
	*/

	public static bool requestExtendedTransactionInfos(List<Crypto.Hash> transactionHashes, IDataBase database, List<ExtendedTransactionInfo> result)
	{
	  result.Capacity = result.Count + transactionHashes.Count;

	  BlockchainReadBatch transactionsBatch = new BlockchainReadBatch();
  transactionHashes.ForEach((Crypto.Hash hash) =>
  {
	  transactionsBatch.requestCachedTransaction(hash);
  });
	  var dbResult = database.read(transactionsBatch);
	  if (dbResult)
	  {
		return false;
	  }

	  var readResult = transactionsBatch.extractResult();
	  auto transactions = readResult.getCachedTransactions();

	  HashSet<Crypto.Hash> uniqueTransactionHashes = new HashSet<Crypto.Hash>(transactionHashes.GetEnumerator(), transactionHashes.end());
	  if (transactions.size() != uniqueTransactionHashes.Count)
	  {
		return false;
	  }

	  foreach (var hash in transactionHashes)
	  {
		result.Add(transactions.at(hash));
	  }

	  return true;
	}

	//returns ExtendedTransactionInfos in the same order as packedOuts are
	public static bool requestExtendedTransactionInfos(List<PackedOutIndex> packedOuts, IDataBase database, List<ExtendedTransactionInfo> result)
	{
	  List<Crypto.Hash> transactionHashes = new List<Crypto.Hash>();
	  if (!GlobalMembers.requestTransactionHashesForGlobalOutputIndexes(packedOuts, database, transactionHashes))
	  {
		return false;
	  }

	  return GlobalMembers.requestExtendedTransactionInfos(transactionHashes, database, result);
	}

	public static ulong roundToMidnight(ulong timestamp)
	{
	  if (timestamp > (ulong)(time_t.MaxValue))
	  {
		throw new System.Exception("Timestamp is too big");
	  }

	  return (ulong)((timestamp / GlobalMembers.ONE_DAY_SECONDS) * GlobalMembers.ONE_DAY_SECONDS);
	}

	public static Tuple<boost.optional<uint>, bool> requestClosestBlockIndexByTimestamp(ulong timestamp, IDataBase database)
	{
	  Tuple<boost.optional<uint>, bool> result = new Tuple<boost.optional<uint>, bool>({}, false);

	  BlockchainReadBatch readBatch = new BlockchainReadBatch();
	  readBatch.requestClosestTimestampBlockIndex(timestamp);
	  var dbResult = database.read(readBatch);
	  if (dbResult)
	  {
		return result;
	  }

	  result.Item2 = true;
	  var readResult = readBatch.extractResult();
	  if (readResult.getClosestTimestampBlockIndex().count(timestamp))
	  {
		result.Item1 = readResult.getClosestTimestampBlockIndex().at(timestamp);
	  }

	  return result;
	}

	public static bool requestRawBlock(IDataBase database, uint blockIndex, ref RawBlock block)
	{
	  var batch = BlockchainReadBatch().requestRawBlock(blockIndex);

	  var error = database.read(batch);
	  if (error)
	  {
		//may be throw in all similiar functions???
		return false;
	  }

	  var result = batch.extractResult();
	  if (result.getRawBlocks().count(blockIndex) == 0)
	  {
		return false;
	  }

	  block = result.getRawBlocks().at(blockIndex);
	  return true;
	}

	public static Transaction extractTransaction(RawBlock block, uint transactionIndex)
	{
	  Debug.Assert(transactionIndex < block.transactions.Count + 1);

	  if (transactionIndex != 0)
	  {
		Transaction transaction = new Transaction();
		bool r = fromBinaryArray(ref transaction, block.transactions[transactionIndex - 1]);
		if (r)
		{
		}
		Debug.Assert(r);

		return transaction;
	  }

	  BlockTemplate blockTemplate = new BlockTemplate();
	  bool r = fromBinaryArray(ref blockTemplate, block.block);
	  if (r)
	  {
	  }
	  Debug.Assert(r);

	  return blockTemplate.baseTransaction;
	}

	public static size_t requestPaymentIdTransactionsCount(IDataBase database, Crypto.Hash paymentId)
	{
	  var batch = BlockchainReadBatch().requestTransactionCountByPaymentId(paymentId);
	  var error = database.read(batch);
	  if (error)
	  {
		throw std::system_error(error, "Error while reading transactions count by payment id");
	  }

	  var result = batch.extractResult();
	  if (result.getTransactionCountByPaymentIds().count(paymentId) == 0)
	  {
		return 0;
	  }

	  return result.getTransactionCountByPaymentIds().at(paymentId);
	}

	public static bool requestPaymentId(IDataBase database, Crypto.Hash transactionHash, Crypto.Hash paymentId)
	{
	  List<CachedTransactionInfo> cachedTransactions = new List<CachedTransactionInfo>();

	  if (!GlobalMembers.requestCachedTransactionInfos(new List<Crypto.Hash>() {transactionHash}, database, cachedTransactions))
	  {
		return false;
	  }

	  if (cachedTransactions.Count == 0)
	  {
		return false;
	  }

	  RawBlock block = new RawBlock();
	  if (!GlobalMembers.requestRawBlock(database, cachedTransactions[0].blockIndex, ref block))
	  {
		return false;
	  }

	  Transaction transaction = GlobalMembers.extractTransaction(block, cachedTransactions[0].transactionIndex);
	  return getPaymentIdFromTxExtra(transaction.extra, paymentId);
	}

	public static uint requestKeyOutputGlobalIndexesCountForAmount(IBlockchainCache.Amount amount, IDataBase database)
	{
	  var batch = BlockchainReadBatch().requestKeyOutputGlobalIndexesCountForAmount(amount);
	  var dbError = database.read(batch);
	  if (dbError)
	  {
		throw std::system_error(dbError, "Cannot perform requestKeyOutputGlobalIndexesCountForAmount query");
	  }

	  var result = batch.extractResult();

	  if (result.getKeyOutputGlobalIndexesCountForAmounts().count(amount) != 0)
	  {
		return result.getKeyOutputGlobalIndexesCountForAmounts().at(amount);
	  }
	  else
	  {
		return 0;
	  }
	}

	public static PackedOutIndex retrieveKeyOutput(IBlockchainCache.Amount amount, uint globalOutputIndex, IDataBase database)
	{
	  BlockchainReadBatch batch = new BlockchainReadBatch();
	  var dbError = database.read(batch.requestKeyOutputGlobalIndexForAmount(amount, globalOutputIndex));
	  if (dbError)
	  {
		throw std::system_error(dbError, "Error during retrieving key output by global output index");
	  }

	  var result = batch.extractResult();

	  try
	  {
		return result.getKeyOutputGlobalIndexesForAmounts().at(Tuple.Create(amount, globalOutputIndex));
	  }
	  catch (System.Exception)
	  {
		Debug.Assert(false);
		throw new System.Exception("Couldn't find key output for amount " + Convert.ToString(amount) + " with global output index " + Convert.ToString(globalOutputIndex));
	  }
	}

	public static SortedDictionary<IBlockchainCache.Amount, IBlockchainCache.GlobalOutputIndex> getMinGlobalIndexesByAmount(SortedDictionary<IBlockchainCache.Amount, List<IBlockchainCache.GlobalOutputIndex>> outputIndexes)
	{

	  SortedDictionary<IBlockchainCache.Amount, IBlockchainCache.GlobalOutputIndex> minIndexes = new SortedDictionary<IBlockchainCache.Amount, IBlockchainCache.GlobalOutputIndex>();
	  foreach (var kv in outputIndexes)
	  {
		var min = std::min_element(kv.second.begin(), kv.second.end());
		if (min == kv.second.end())
		{
		  continue;
		}

		minIndexes.Add(kv.first, *min);
	  }

	  return minIndexes;
	}

	public static void mergeOutputsSplitBoundaries(SortedDictionary<IBlockchainCache.Amount, IBlockchainCache.GlobalOutputIndex> dest, SortedDictionary<IBlockchainCache.Amount, IBlockchainCache.GlobalOutputIndex> src)
	{
	  foreach (var elem in src)
	  {
		var it = dest.find(elem.first);
		if (it == dest.end())
		{
		  dest.Add(elem.first, elem.second);
		  continue;
		}

//C++ TO C# CONVERTER TODO TASK: Iterators are only converted within the context of 'while' and 'for' loops:
		if (it.second > elem.second)
		{
//C++ TO C# CONVERTER TODO TASK: Iterators are only converted within the context of 'while' and 'for' loops:
		  it.second = elem.second;
		}
	  }
	}

	public static void cutTail(LinkedList<CachedBlockInfo> cache, size_t count)
	{
	  if (count >= cache.Count)
	  {
		cache.Clear();
		return;
	  }

//C++ TO C# CONVERTER TODO TASK: There is no direct equivalent to the STL list 'erase' method in C#:
	  cache.erase(std::next(cache.GetEnumerator(), cache.Count - count), cache.end());
	}

	public static readonly string DB_VERSION_KEY = "db_scheme_version";

	public static readonly uint CURRENT_DB_SCHEME_VERSION = 2;

	public static std::unique_ptr<IMainChainStorage> createSwappedMainChainStorage(string dataDir, Currency currency)
	{
	  boost::filesystem.path blocksFilename = boost::filesystem.path(dataDir) / currency.blocksFileName();
	  boost::filesystem.path indexesFilename = boost::filesystem.path(dataDir) / currency.blockIndexesFileName();

	  std::unique_ptr<IMainChainStorage> storage = new std::unique_ptr<IMainChainStorage>(new MainChainStorage(blocksFilename.string(), indexesFilename.string()));
	  if (storage.getBlockCount() == 0)
	  {
		RawBlock genesis = new RawBlock();
		genesis.block = toBinaryArray(currency.genesisBlock());
		storage.pushBlock(genesis);
	  }

	  return storage;
	}

	public static readonly size_t STORAGE_CACHE_SIZE = 100;

	//bool checkInputsKeyimagesDiff(CryptoNote::TransactionPrefix tx);Tangible Method Implementation Not FoundCryptoNote-checkInputsKeyimagesDiff

	// TransactionInput helper functions
	//size_t getRequiredSignaturesCount(boost::variant<BaseInput, KeyInput> in);Tangible Method Implementation Not FoundCryptoNote-getRequiredSignaturesCount
	//ulong getTransactionInputAmount(boost::variant<BaseInput, KeyInput> in);Tangible Method Implementation Not FoundCryptoNote-getTransactionInputAmount
	//TransactionTypes::InputType getTransactionInputType(boost::variant<BaseInput, KeyInput> in);Tangible Method Implementation Not FoundCryptoNote-getTransactionInputType
	//boost::variant<BaseInput, KeyInput> getInputChecked(CryptoNote::TransactionPrefix transaction, size_t index);Tangible Method Implementation Not FoundCryptoNote-getInputChecked
	//boost::variant<BaseInput, KeyInput> getInputChecked(CryptoNote::TransactionPrefix transaction, size_t index, TransactionTypes::InputType type);Tangible Method Implementation Not FoundCryptoNote-getInputChecked

	//bool isOutToKey(Crypto::PublicKey spendPublicKey, Crypto::PublicKey outKey, Crypto::KeyDerivation derivation, size_t keyIndex);Tangible Method Implementation Not FoundCryptoNote-isOutToKey

	// TransactionOutput helper functions
	//TransactionTypes::OutputType getTransactionOutputType(boost::variant<KeyOutput> @out);Tangible Method Implementation Not FoundCryptoNote-getTransactionOutputType
	//TransactionOutput getOutputChecked(CryptoNote::TransactionPrefix transaction, size_t index);Tangible Method Implementation Not FoundCryptoNote-getOutputChecked
	//TransactionOutput getOutputChecked(CryptoNote::TransactionPrefix transaction, size_t index, TransactionTypes::OutputType type);Tangible Method Implementation Not FoundCryptoNote-getOutputChecked

	//bool findOutputsToAccount(CryptoNote::TransactionPrefix transaction, AccountPublicAddress addr, Crypto::SecretKey viewSecretKey, ClassicVector<uint> @out, ulong amount);Tangible Method Implementation Not FoundCryptoNote-findOutputsToAccount


	  ////////////////////////////////////////////////////////////////////////
	  // class Transaction implementation
	  ////////////////////////////////////////////////////////////////////////

	  public static std::unique_ptr<ITransaction> createTransaction()
	  {
		return std::unique_ptr<ITransaction>(new TransactionImpl());
	  }

	  public static std::unique_ptr<ITransaction> createTransaction(List<ushort> transactionBlob)
	  {
		return std::unique_ptr<ITransaction>(new TransactionImpl(transactionBlob));
	  }

	  public static std::unique_ptr<ITransaction> createTransaction(CryptoNote.Transaction tx)
	  {
		return std::unique_ptr<ITransaction>(new TransactionImpl(tx));
	  }
	public static bool findTransactionExtraFieldByType<T>(List<boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag>> tx_extra_fields, ref T field)
	{
//C++ TO C# CONVERTER TODO TASK: Lambda expressions cannot be assigned to 'var':
  var it = std::find_if(tx_extra_fields.GetEnumerator(), tx_extra_fields.end(), (boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag> f) =>
  {
	  return typeid(T) == f.type();
  });

	  if (tx_extra_fields.end() == it)
	  {
		return false;
	  }

	  field = boost::get<T>(*it);
	  return true;
	}

	public static bool parseTransactionExtra(List<ushort> transactionExtra, List<boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag>> transactionExtraFields)
	{
	  transactionExtraFields.Clear();

	  if (transactionExtra.Count == 0)
	  {
		return true;
	  }

	  bool seen_tx_extra_tag_padding = false;
	  bool seen_tx_extra_tag_pubkey = false;
	  bool seen_tx_extra_nonce = false;
	  bool seen_tx_extra_merge_mining_tag = false;

	  try
	  {
		MemoryInputStream iss = new MemoryInputStream(transactionExtra.data(), transactionExtra.Count);
		BinaryInputStreamSerializer ar = new BinaryInputStreamSerializer(iss);

		int c = 0;

		while (!iss.endOfStream())
		{
		  c = Common.GlobalMembers.read<ushort>(iss);
		  switch (c)
		  {
		  case DefineConstants.TX_EXTRA_TAG_PADDING:
		  {
			if (seen_tx_extra_tag_padding)
			{
				return true;
			}

			seen_tx_extra_tag_padding = true;

			size_t size = 1;
			for (; !iss.endOfStream() && size <= DefineConstants.TX_EXTRA_PADDING_MAX_COUNT; ++size)
			{
			  if (Common.GlobalMembers.read<ushort>(iss) != 0)
			  {
				return false; // all bytes should be zero
			  }
			}

			if (size > DefineConstants.TX_EXTRA_PADDING_MAX_COUNT)
			{
			  return false;
			}

			transactionExtraFields.Add(new TransactionExtraPadding({size}));
			break;
		  }

		  case DefineConstants.TX_EXTRA_TAG_PUBKEY:
		  {
			if (seen_tx_extra_tag_pubkey)
			{
				return true;
			}

			seen_tx_extra_tag_pubkey = true;

			TransactionExtraPublicKey extraPk = new TransactionExtraPublicKey();
			ar.functorMethod(extraPk.publicKey, "public_key");
			transactionExtraFields.Add(extraPk);
			break;
		  }

		  case DefineConstants.TX_EXTRA_NONCE:
		  {
			if (seen_tx_extra_nonce)
			{
				return true;
			}

			seen_tx_extra_nonce = true;

			TransactionExtraNonce extraNonce = new TransactionExtraNonce();
			ushort size = Common.GlobalMembers.read<ushort>(iss);
			if (size > 0)
			{
			  extraNonce.nonce.Resize(size);
			  read(iss, extraNonce.nonce.data(), extraNonce.nonce.Count);
			}

			transactionExtraFields.Add(extraNonce);
			break;
		  }

		  case DefineConstants.TX_EXTRA_MERGE_MINING_TAG:
		  {
			if (seen_tx_extra_merge_mining_tag)
			{
				break;
			}

			seen_tx_extra_merge_mining_tag = true;

			TransactionExtraMergeMiningTag mmTag = new TransactionExtraMergeMiningTag();
			ar.functorMethod(mmTag, "mm_tag");
			transactionExtraFields.Add(mmTag);
			break;
		  }
		  }
		}
	  }
	  catch (System.Exception)
	  {
		return false;
	  }

	  return true;
	}
	public static bool writeTransactionExtra(List<ushort> tx_extra, List<boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag>> tx_extra_fields)
	{
	  ExtraSerializerVisitor visitor = new ExtraSerializerVisitor(tx_extra);

	  foreach (var tag in tx_extra_fields)
	  {
		if (!boost::apply_visitor(visitor.functorMethod, tag))
		{
		  return false;
		}
	  }

	  return true;
	}

	public static PublicKey getTransactionPublicKeyFromExtra(List<ushort> tx_extra)
	{
	  List<boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag>> tx_extra_fields = new List<boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag>>();
	  parseTransactionExtra(tx_extra, tx_extra_fields);

	  TransactionExtraPublicKey pub_key_field = new TransactionExtraPublicKey();
	  if (!findTransactionExtraFieldByType(tx_extra_fields, ref pub_key_field))
	  {
		return boost::value_initialized<PublicKey>();
	  }

	  return pub_key_field.publicKey;
	}
	public static bool addTransactionPublicKeyToExtra(List<ushort> tx_extra, PublicKey tx_pub_key)
	{
	  tx_extra.Resize(tx_extra.Count + 1 + sizeof(PublicKey));
	  tx_extra[tx_extra.Count - 1 - sizeof(PublicKey)] = DefineConstants.TX_EXTRA_TAG_PUBKEY;
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
	  *reinterpret_cast<PublicKey>(tx_extra[tx_extra.Count - sizeof(PublicKey)]) = tx_pub_key;
	  return true;
	}
	public static bool addExtraNonceToTransactionExtra(List<ushort> tx_extra, BinaryArray extra_nonce)
	{
	  if (extra_nonce.size() > DefineConstants.TX_EXTRA_NONCE_MAX_COUNT)
	  {
		return false;
	  }

	  size_t start_pos = tx_extra.Count;
	  tx_extra.Resize(tx_extra.Count + 2 + extra_nonce.size());
	  //write tag
	  tx_extra[start_pos] = DefineConstants.TX_EXTRA_NONCE;
	  //write len
	  ++start_pos;
	  tx_extra[start_pos] = (ushort)extra_nonce.size();
	  //write data
	  ++start_pos;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(tx_extra[start_pos], extra_nonce.data(), extra_nonce.size());
	  return true;
	}
	//void setPaymentIdToTransactionExtraNonce(BinaryArray extra_nonce, Crypto::Hash payment_id);Tangible Method Implementation Not FoundCryptoNote-setPaymentIdToTransactionExtraNonce
	//bool getPaymentIdFromTransactionExtraNonce(BinaryArray extra_nonce, Crypto::Hash payment_id);Tangible Method Implementation Not FoundCryptoNote-getPaymentIdFromTransactionExtraNonce
	public static bool appendMergeMiningTagToExtra(List<ushort> tx_extra, TransactionExtraMergeMiningTag mm_tag)
	{
	  BinaryArray blob = new BinaryArray();
	  if (!toBinaryArray(mm_tag, ref blob))
	  {
		return false;
	  }

	  tx_extra.Add(DefineConstants.TX_EXTRA_MERGE_MINING_TAG);
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
	  std::copy(reinterpret_cast<const ushort>(blob.data()), reinterpret_cast<const ushort>(blob.data() + blob.size()), std::back_inserter(tx_extra));
	  return true;
	}
	public static bool getMergeMiningTagFromExtra(List<ushort> tx_extra, TransactionExtraMergeMiningTag mm_tag)
	{
	  List<boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag>> tx_extra_fields = new List<boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag>>();
	  parseTransactionExtra(tx_extra, tx_extra_fields);

	  return findTransactionExtraFieldByType(tx_extra_fields, ref mm_tag);
	}

	public static bool createTxExtraWithPaymentId(string paymentIdString, List<ushort> extra)
	{
	  Hash paymentIdBin = new Hash();

	  if (!parsePaymentId(paymentIdString, paymentIdBin))
	  {
		return false;
	  }

	  List<ushort> extraNonce = new List<ushort>();
	  CryptoNote.GlobalMembers.setPaymentIdToTransactionExtraNonce(extraNonce, paymentIdBin);

	  if (!CryptoNote.GlobalMembers.addExtraNonceToTransactionExtra(extra, extraNonce))
	  {
		return false;
	  }

	  return true;
	}
	//returns false if payment id is not found or parse error
	public static bool getPaymentIdFromTxExtra(List<ushort> extra, Hash paymentId)
	{
	  List<boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag>> tx_extra_fields = new List<boost::variant<TransactionExtraPadding, TransactionExtraPublicKey, TransactionExtraNonce, TransactionExtraMergeMiningTag>>();
	  if (!parseTransactionExtra(extra, tx_extra_fields))
	  {
		return false;
	  }

	  TransactionExtraNonce extra_nonce = new TransactionExtraNonce();
	  if (findTransactionExtraFieldByType(tx_extra_fields, ref extra_nonce))
	  {
		if (!getPaymentIdFromTransactionExtraNonce(extra_nonce.nonce, ref paymentId))
		{
		  return false;
		}
	  }
	  else
	  {
		return false;
	  }

	  return true;
	}
	public static bool parsePaymentId(string paymentIdString, Hash paymentId)
	{
	  return Common.GlobalMembers.podFromHex(paymentIdString, paymentId);
	}

	public static void setPaymentIdToTransactionExtraNonce(List<ushort> extra_nonce, Hash payment_id)
	{
	  extra_nonce.Clear();
	  extra_nonce.Add(DefineConstants.TX_EXTRA_NONCE_PAYMENT_ID);
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
	  ushort payment_id_ptr = reinterpret_cast<const ushort>(payment_id);
	  std::copy(payment_id_ptr, payment_id_ptr + sizeof(Hash), std::back_inserter(extra_nonce));
	}

	public static bool getPaymentIdFromTransactionExtraNonce(List<ushort> extra_nonce, ref Hash payment_id)
	{
	  if (sizeof(Hash) + 1 != extra_nonce.Count)
	  {
		return false;
	  }
	  if (DefineConstants.TX_EXTRA_NONCE_PAYMENT_ID != extra_nonce[0])
	  {
		return false;
	  }
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
	  payment_id = reinterpret_cast<const Hash>(extra_nonce.data() + 1);
	  return true;
	}

	public static TransactionPoolMessage makeAddTransaction(Crypto.Hash hash)
	{
	  return TransactionPoolMessage
	  {
		  AddTransaction{hash}
	  };
	}

	public static TransactionPoolMessage makeDelTransaction(Crypto.Hash hash)
	{
	  return TransactionPoolMessage
	  {
		  DeleteTransaction{hash}
	  };
	}


	public static std::unique_ptr<ITransactionReader> createTransactionPrefix(TransactionPrefix prefix, Hash transactionHash)
	{
	  return std::unique_ptr<ITransactionReader> (new TransactionPrefixImpl(prefix, transactionHash));
	}

	public static std::unique_ptr<ITransactionReader> createTransactionPrefix(Transaction fullTransaction)
	{
	  return std::unique_ptr<ITransactionReader> (new TransactionPrefixImpl(fullTransaction, getObjectHash(fullTransaction)));
	}

	public static bool checkInputsKeyimagesDiff(CryptoNote.TransactionPrefix tx)
	{
	  HashSet<Crypto.KeyImage> ki = new HashSet<Crypto.KeyImage>();
	  foreach (var in in tx.inputs)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (in.type() == typeid(KeyInput))
		{
		  if (!ki.Add(boost::get<KeyInput>(in).keyImage).second)
		  {
			return false;
		  }
		}
	  }

	  return true;
	}

// TransactionInput helper functions


	// TransactionInput helper functions
	public static size_t getRequiredSignaturesCount(boost::variant<BaseInput, KeyInput> in)
	{
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
	  if (in.type() == typeid(KeyInput))
	  {
		return boost::get<KeyInput>(in).outputIndexes.size();
	  }

	  return 0;
	}
	public static ulong getTransactionInputAmount(boost::variant<BaseInput, KeyInput> in)
	{
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
	  if (in.type() == typeid(KeyInput))
	  {
		return boost::get<KeyInput>(in).amount;
	  }

	  return 0;
	}
	public static TransactionTypes.InputType getTransactionInputType(boost::variant<BaseInput, KeyInput> in)
	{
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
	  if (in.type() == typeid(KeyInput))
	  {
		return TransactionTypes.InputType.Key;
	  }

//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
	  if (in.type() == typeid(BaseInput))
	  {
		return TransactionTypes.InputType.Generating;
	  }

	  return TransactionTypes.InputType.Invalid;
	}
	public static boost::variant<BaseInput, KeyInput> getInputChecked(CryptoNote.TransactionPrefix transaction, size_t index)
	{
	  if (transaction.inputs.Count <= index)
	  {
		throw new System.Exception("Transaction input index out of range");
	  }

	  return transaction.inputs[index];
	}
	public static boost::variant<BaseInput, KeyInput> getInputChecked(CryptoNote.TransactionPrefix transaction, size_t index, TransactionTypes.InputType type)
	{
	  auto input = getInputChecked(transaction, new size_t(index));
	  if (getTransactionInputType(input) != type)
	  {
		throw new System.Exception("Unexpected transaction input type");
	  }

	  return input;
	}

	public static bool isOutToKey(Crypto.PublicKey spendPublicKey, Crypto.PublicKey outKey, Crypto.KeyDerivation derivation, size_t keyIndex)
	{
	  Crypto.PublicKey pk = new Crypto.PublicKey();
	  derive_public_key(derivation, keyIndex, spendPublicKey, pk);
	  return pk == outKey;
	}

// TransactionOutput helper functions


	// TransactionOutput helper functions
	public static TransactionTypes.OutputType getTransactionOutputType(boost::variant<KeyOutput> @out)
	{
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
	  if (@out.type() == typeid(KeyOutput))
	  {
		return TransactionTypes.OutputType.Key;
	  }

	  return TransactionTypes.OutputType.Invalid;
	}
	public static TransactionOutput getOutputChecked(CryptoNote.TransactionPrefix transaction, size_t index)
	{
	  if (transaction.outputs.Count <= index)
	  {
		throw new System.Exception("Transaction output index out of range");
	  }

	  return transaction.outputs[index];
	}
	public static TransactionOutput getOutputChecked(CryptoNote.TransactionPrefix transaction, size_t index, TransactionTypes.OutputType type)
	{
	  auto output = getOutputChecked(transaction, new size_t(index));
	  if (getTransactionOutputType(output.target) != type)
	  {
		throw new System.Exception("Unexpected transaction output target type");
	  }

	  return output;
	}

	public static bool findOutputsToAccount(CryptoNote.TransactionPrefix transaction, AccountPublicAddress addr, SecretKey viewSecretKey, List<uint> @out, ref ulong amount)
	{
	  AccountKeys keys = new AccountKeys();
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: keys.address = addr;
	  keys.address.CopyFrom(addr);
	  // only view secret key is used, spend key is not needed
	  keys.viewSecretKey = viewSecretKey;

	  Crypto.PublicKey txPubKey = getTransactionPublicKeyFromExtra(transaction.extra);

	  amount = 0;
	  size_t keyIndex = 0;
	  uint outputIndex = 0;

	  Crypto.KeyDerivation derivation = new Crypto.KeyDerivation();
	  generate_key_derivation(txPubKey, keys.viewSecretKey, derivation);

	  foreach (TransactionOutput o in transaction.outputs)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		Debug.Assert(o.target.type() == typeid(KeyOutput));
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (o.target.type() == typeid(KeyOutput))
		{
		  if (is_out_to_acc(keys, boost::get<KeyOutput>(o.target), derivation, new size_t(keyIndex)))
		  {
			@out.Add(outputIndex);
			amount += o.amount;
		  }

		  ++keyIndex;
		}

		++outputIndex;
	  }

	  return true;
	}

	public static void mergeStates(TransactionValidatorState destination, TransactionValidatorState source)
	{
	  destination.spentKeyImages.insert(source.spentKeyImages.GetEnumerator(), source.spentKeyImages.end());
	}
	public static bool hasIntersections(TransactionValidatorState destination, TransactionValidatorState source)
	{
  return std::any_of(source.spentKeyImages.GetEnumerator(), source.spentKeyImages.end(), (Crypto.KeyImage ki) =>
  {
	  return destination.spentKeyImages.count(ki) != 0;
  });
	}
	public static void excludeFromState(TransactionValidatorState state, CachedTransaction cachedTransaction)
	{
	  auto transaction = cachedTransaction.getTransaction();
	  foreach (var input in transaction.inputs)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no C# equivalent to the classic C++ 'typeid' operator:
		if (input.type() == typeid(KeyInput))
		{
		  auto in = boost::get<KeyInput>(input);
		  Debug.Assert(state.spentKeyImages.count(in.keyImage) > 0);
		  state.spentKeyImages.erase(in.keyImage);
		}
		else
		{
		  Debug.Assert(false);
		}
	  }
	}

	public static std::unique_ptr<IUpgradeDetector> makeUpgradeDetector(ushort targetVersion, uint upgradeIndex)
	{
	  return std::unique_ptr<SimpleUpgradeDetector>(new SimpleUpgradeDetector(new ushort(targetVersion), new uint(upgradeIndex)));
	}
	public static bool post_notify<t_parametr>(IP2pEndpoint p2p, t_parametr.request arg, CryptoNoteConnectionContext context)
	{
	  return p2p.invoke_notify_to_peer(t_parametr.ID, LevinProtocol.encode(arg), context);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class t_parametr>
	public static void relay_post_notify<t_parametr>(IP2pEndpoint p2p, t_parametr.request arg, boost::uuids.uuid excludeConnection = null)
	{
	  p2p.externalRelayNotifyToAll(t_parametr.ID, LevinProtocol.encode(arg), excludeConnection);
	}

	public static List<RawBlockLegacy> convertRawBlocksToRawBlocksLegacy(List<RawBlock> rawBlocks)
	{
	  List<RawBlockLegacy> legacy = new List<RawBlockLegacy>();
	  legacy.Capacity = rawBlocks.Count;

	  foreach (var rawBlock in rawBlocks)
	  {
		legacy.emplace_back(new RawBlockLegacy({rawBlock.block, rawBlock.transactions}));
	  }

	  return legacy;
	}

	public static List<RawBlock> convertRawBlocksLegacyToRawBlocks(List<RawBlockLegacy> legacy)
	{
	  List<RawBlock> rawBlocks = new List<RawBlock>();
	  rawBlocks.Capacity = legacy.Count;

	  foreach (var legacyBlock in legacy)
	  {
		rawBlocks.emplace_back(new RawBlock({legacyBlock.block, legacyBlock.transactions}));
	  }

	  return rawBlocks;
	}


	// unpack to strings to maintain protocol compatibility with older versions
	internal static void serialize(RawBlockLegacy rawBlock, ISerializer serializer)
	{
	  string block;
	  List<string> transactions = new List<string>();
	  if (serializer.type() == ISerializer.INPUT)
	  {
		serializer.functorMethod(block, "block");
		serializer.functorMethod(transactions, "txs");
		rawBlock.block.reserve(block.Length);
		rawBlock.transactions.Capacity = transactions.Count;
		std::copy(block.GetEnumerator(), block.end(), std::back_inserter(rawBlock.block));
	std::transform(transactions.GetEnumerator(), transactions.end(), std::back_inserter(rawBlock.transactions), (string s) =>
	{
	  return new List<ushort>(s.GetEnumerator(), s.end());
	});
	  }
	  else
	  {
		block.reserve(rawBlock.block.size());
		transactions.Capacity = rawBlock.transactions.Count;
		std::copy(rawBlock.block.begin(), rawBlock.block.end(), std::back_inserter(block));
	std::transform(rawBlock.transactions.GetEnumerator(), rawBlock.transactions.end(), std::back_inserter(transactions), (List<ushort> s) =>
	{
	  return (string)(s.GetEnumerator(), s.end());
	});
		serializer.functorMethod(block, "block");
		serializer.functorMethod(transactions, "txs");
	  }
	}

	internal static void serialize(NOTIFY_NEW_BLOCK_request request, ISerializer s)
	{
	  s.functorMethod(request.b, "b");
	  s.functorMethod(request.current_blockchain_height, "current_blockchain_height");
	  s.functorMethod(request.hop, "hop");
	}

	// unpack to strings to maintain protocol compatibility with older versions
	internal static void serialize(NOTIFY_NEW_TRANSACTIONS_request request, ISerializer s)
	{
	  List<string> transactions = new List<string>();
	  if (s.type() == ISerializer.INPUT)
	  {
		s.functorMethod(transactions, "txs");
		request.txs.Capacity = transactions.Count;
	std::transform(transactions.GetEnumerator(), transactions.end(), std::back_inserter(request.txs), (string s) =>
	{
	  return new List<ushort>(s.GetEnumerator(), s.end());
	});
	  }
	  else
	  {
		transactions.Capacity = request.txs.Count;
	std::transform(request.txs.GetEnumerator(), request.txs.end(), std::back_inserter(transactions), (List<ushort> s) =>
	{
	  return (string)(s.GetEnumerator(), s.end());
	});
		s(transactions, "txs");
	  }
	}

	internal static void serialize(NOTIFY_RESPONSE_GET_OBJECTS_request request, ISerializer s)
	{
	  s.functorMethod(request.txs, "txs");
	  s.functorMethod(request.blocks, "blocks");
	  serializeAsBinary(request.missed_ids, "missed_ids", s.functorMethod);
	  s.functorMethod(request.current_blockchain_height, "current_blockchain_height");
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Command, typename Handler>
	public static int notifyAdaptor<Command, Handler>(List<ushort> reqBuf, CryptoNoteConnectionContext ctx, Handler handler)
	{

	  int command = Command.ID;

	  Command.request req = boost::value_initialized<typename Command.request>();
	  if (!LevinProtocol.decode(reqBuf, req))
	  {
		throw new System.Exception("Failed to load_from_binary in command " + Convert.ToString(command));
	  }

	  return handler(command, req, ctx);
	}
	public static bool serialize<T>(T value, Common.StringView name, ISerializer serializer)
	{
	  if (!serializer.beginObject(new Common.StringView(name)))
	  {
		return false;
	  }

	  serialize(value, serializer.functorMethod);
	  serializer.endObject();
	  return true;
	}

	/* WARNING: If you get a compiler error pointing to this line, when serializing
	   a ulong, or other numeric type, this is due to your compiler treating some
	   typedef's differently, so it does not correspond to one of the numeric
	   types above. I tried using some template hackery to get around this, but
	   it did not work. I resorted to just using a ulong instead. */
//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static void serialize<T>(T value, ISerializer serializer)
	{
	  value.serialize(serializer.functorMethod);
	}
	public static std::enable_if<std::is_pod<T>.value>.type serializeAsBinary<T>(List<T> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  string blob;
	  if (serializer.type() == ISerializer.INPUT)
	  {
		serializer.binary(blob, new Common.StringView(name));
		value.Resize(blob.Length / sizeof(T));
		if (blob.Length != 0)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		  memcpy(value[0], blob.data(), blob.Length);
		}
	  }
	  else
	  {
		if (value.Count > 0)
		{
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		  blob.assign(reinterpret_cast<const char>(value[0]), value.Count * sizeof(T));
		}
		serializer.binary(blob, new Common.StringView(name));
	  }
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static std::enable_if<std::is_pod<T>.value>.type serializeAsBinary<T>(LinkedList<T> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  string blob;
	  if (serializer.type() == ISerializer.INPUT)
	  {
		serializer.binary(blob, new Common.StringView(name));

		ulong count = blob.Length / sizeof(T);
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		T * ptr = reinterpret_cast<const T>(blob.data());

		while (count-- != null)
		{
		  value.AddLast(*ptr++);
		}
	  }
	  else
	  {
		if (value.Count > 0)
		{
		  blob.resize(value.Count * sizeof(T));
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		  T * ptr = reinterpret_cast<T>(blob[0]);

		  foreach (var item in value)
		  {
			*ptr++= item;
		  }
		}
		serializer.binary(blob, new Common.StringView(name));
	  }
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Cont>
	public static bool serializeContainer<Cont>(Cont value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  ulong size = value.size();
	  if (!serializer.beginArray(size, new Common.StringView(name)))
	  {
		if (serializer.type() == ISerializer.INPUT)
		{
		  value.clear();
		}

		return false;
	  }

	  value.resize(size);

	  foreach (var item in value)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		serializer.functorMethod(const_cast<typename Cont.value_type&>(item), "");
	  }

	  serializer.endArray();
	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename E>
	public static bool serializeEnumClass<E>(ref E value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//  static_assert(std::is_enum<E>::value, "E must be an enum class");


	  if (serializer.type() == CryptoNote.ISerializer.INPUT)
	  {
		std::underlying_type<E>.type numericValue = new std::underlying_type<E>.type();
		serializer.functorMethod(numericValue, name);
		value = (E)numericValue;
	  }
	  else
	  {
		var numericValue = (typename std::underlying_type<E>.type)value;
		serializer.functorMethod(numericValue, name);
	  }

	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static bool serialize<T>(List<T> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return serializeContainer(value, new Common.StringView(name), serializer.functorMethod);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static bool serialize<T>(LinkedList<T> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return serializeContainer(value, new Common.StringView(name), serializer.functorMethod);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename MapT, typename ReserveOp>
	public static bool serializeMap<MapT, ReserveOp>(MapT value, Common.StringView name, CryptoNote.ISerializer serializer, ReserveOp reserve)
	{
	  ulong size = value.size();

	  if (!serializer.beginArray(size, new Common.StringView(name)))
	  {
		if (serializer.type() == ISerializer.INPUT)
		{
		  value.clear();
		}

		return false;
	  }

	  if (serializer.type() == CryptoNote.ISerializer.INPUT)
	  {
		reserve(size);

		for (ulong i = 0; i < size; ++i)
		{
		  MapT.key_type key = new MapT.key_type();
		  MapT.mapped_type v = new MapT.mapped_type();

		  serializer.beginObject("");
		  serializer.functorMethod(key, "key");
		  serializer.functorMethod(v, "value");
		  serializer.endObject();

		  value.insert(Tuple.Create(std::move(key), std::move(v)));
		}
	  }
	  else
	  {
		foreach (var kv in value)
		{
		  serializer.beginObject("");
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		  serializer.functorMethod(const_cast<typename MapT.key_type&>(kv.first), "key");
		  serializer.functorMethod(kv.second, "value");
		  serializer.endObject();
		}
	  }

	  serializer.endArray();
	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename SetT>
	public static bool serializeSet<SetT>(SetT value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  ulong size = value.size();

	  if (!serializer.beginArray(size, new Common.StringView(name)))
	  {
		if (serializer.type() == ISerializer.INPUT)
		{
		  value.clear();
		}

		return false;
	  }

	  if (serializer.type() == CryptoNote.ISerializer.INPUT)
	  {
		for (ulong i = 0; i < size; ++i)
		{
		  SetT.value_type key = new SetT.value_type();
		  serializer.functorMethod(key, "");
		  value.insert(std::move(key));
		}
	  }
	  else
	  {
		foreach (var key in value)
		{
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		  serializer.functorMethod(const_cast<typename SetT.value_type&>(key), "");
		}
	  }

	  serializer.endArray();
	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename K, typename Hash>
	public static bool serialize<K, Hash>(HashSet<K, Hash> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return serializeSet(value, new Common.StringView(name), serializer.functorMethod);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename K, typename Cmp>
	public static bool serialize<K, Cmp>(SortedSet<K, Cmp> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return serializeSet(value, new Common.StringView(name), serializer.functorMethod);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename K, typename V, typename Hash>
	public static bool serialize<K, V, Hash>(Dictionary<K, V, Hash> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
  return serializeMap(value, new Common.StringView(name), serializer.functorMethod, (ulong size) =>
  {
	  value.reserve(size);
  });
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename K, typename V, typename Hash>
	public static bool serialize<K, V, Hash>(std::unordered_multimap<K, V, Hash> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
  return serializeMap(value, new Common.StringView(name), serializer.functorMethod, (ulong size) =>
  {
	  value.reserve(size);
  });
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename K, typename V, typename Hash>
	public static bool serialize<K, V, Hash>(SortedDictionary<K, V, Hash> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
  return serializeMap(value, new Common.StringView(name), serializer.functorMethod, (ulong size) =>
  {
  });
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename K, typename V, typename Hash>
	public static bool serialize<K, V, Hash>(std::multimap<K, V, Hash> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
  return serializeMap(value, new Common.StringView(name), serializer.functorMethod, (ulong size) =>
  {
  });
	}

	//C++ TO C# CONVERTER TODO TASK: C++ 'constraints' are not converted by C++ to C# Converter:
	//ORIGINAL LINE: template<ulong size>
//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename size>
	public static bool serialize<size>(List<ushort> value, Common.StringView name, CryptoNote.ISerializer s)
	{
	  return s.binary(value.data(), value.Count, new Common.StringView(name));
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T1, typename T2>
	public static void serialize<T1, T2>(Tuple<T1, T2> value, ISerializer s)
	{
	  s.functorMethod(value.Item1, "first");
	  s.functorMethod(value.Item2, "second");
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Element, typename Iterator>
	public static void writeSequence<Element, Iterator>(Iterator begin, Iterator end, Common.StringView name, ISerializer s)
	{
	  ulong size = std::distance(begin, end);
	  s.beginArray(size, new Common.StringView(name));
	  for (Iterator i = begin; i != end; ++i)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		s.functorMethod(const_cast<Element&>(*i), "");
	  }
	  s.endArray();
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Element, typename Iterator>
	public static void readSequence<Element, Iterator>(Iterator outputIterator, Common.StringView name, ISerializer s)
	{
	  ulong size = 0;
	  // array of zero size is not written in KVBinaryOutputStreamSerializer
	  if (!s.beginArray(size, new Common.StringView(name)))
	  {
		return;
	  }

	  while (size-- != null)
	  {
		Element e = new default(Element);
		s.functorMethod(e, "");
		*outputIterator++= std::move(e);
	  }

	  s.endArray();
	}

	//convinience function since we change block height type
	//void serializeBlockHeight(ISerializer s, uint blockHeight, Common::StringView name);Tangible Method Implementation Not FoundCryptoNote-serializeBlockHeight

	//convinience function since we change global output index type
	//void serializeGlobalOutputIndex(ISerializer s, uint globalOutputIndex, Common::StringView name);Tangible Method Implementation Not FoundCryptoNote-serializeGlobalOutputIndex

	//void serialize(TransactionOutputDetails output, ISerializer serializer);Tangible Method Implementation Not FoundCryptoNote-serialize
	//void serialize(TransactionOutputReferenceDetails outputReference, ISerializer serializer);Tangible Method Implementation Not FoundCryptoNote-serialize

	//void serialize(BaseInputDetails inputBase, ISerializer serializer);Tangible Method Implementation Not FoundCryptoNote-serialize
	//void serialize(KeyInputDetails inputToKey, ISerializer serializer);Tangible Method Implementation Not FoundCryptoNote-serialize
	//void serialize(boost::variant<BaseInputDetails, KeyInputDetails> input, ISerializer serializer);Tangible Method Implementation Not FoundCryptoNote-serialize

	//void serialize(TransactionExtraDetails extra, ISerializer serializer);Tangible Method Implementation Not FoundCryptoNote-serialize
	//void serialize(TransactionDetails transaction, ISerializer serializer);Tangible Method Implementation Not FoundCryptoNote-serialize

	//void serialize(BlockDetails block, ISerializer serializer);Tangible Method Implementation Not FoundCryptoNote-serialize
	public static Common.JsonValue storeToJsonValue<T>(T v)
	{
	  JsonOutputStreamSerializer s = new JsonOutputStreamSerializer();
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
	  serialize(const_cast<T&>(v), s.functorMethod);
	  return s.getValue.functorMethod();
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static Common.JsonValue storeContainerToJsonValue<T>(T cont)
	{
	  Common.JsonValue js = new Common.JsonValue(Common.JsonValue.ARRAY);
	  foreach (var item in cont)
	  {
		js.pushBack.functorMethod(item);
	  }
	  return js.functorMethod;
	}

	public static Common.JsonValue storeContainerToJsonValue(List<AddressBookEntry> cont)
	{
	  Common.JsonValue js = new Common.JsonValue(Common.JsonValue.ARRAY);
	  foreach (var item in cont)
	  {
		js.pushBack.functorMethod(storeToJsonValue.functorMethod(item));
	  }
	  return js.functorMethod;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static Common.JsonValue storeToJsonValue<T>(List<T> v)
	{
		return storeContainerToJsonValue.functorMethod(v);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static Common.JsonValue storeToJsonValue<T>(LinkedList<T> v)
	{
		return storeContainerToJsonValue.functorMethod(v);
	}

	public static Common.JsonValue storeToJsonValue(string v)
	{
		return new Common.JsonValue(v);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static void loadFromJsonValue<T>(T v, Common.JsonValue js)
	{
	  JsonInputValueSerializer s = new JsonInputValueSerializer(js.functorMethod);
	  serialize(v, s.functorMethod);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static void loadFromJsonValue<T>(List<T> v, Common.JsonValue js)
	{
	  for (ulong i = 0; i < js.size(); ++i)
	  {
		v.Add(Common.GlobalMembers.getValueAs<T>(js.functorMethod[i]));
	  }
	}

	public static void loadFromJsonValue(AddressBook v, Common.JsonValue js)
	{
	  for (ulong i = 0; i < js.size(); ++i)
	  {
		AddressBookEntry type = new AddressBookEntry();
		loadFromJsonValue(type, js.functorMethod[i]);
		v.push_back(type);
	  }
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static void loadFromJsonValue<T>(LinkedList<T> v, Common.JsonValue js)
	{
	  for (ulong i = 0; i < js.size(); ++i)
	  {
		v.AddLast(Common.GlobalMembers.getValueAs<T>(js.functorMethod[i]));
	  }
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static string storeToJson<T>(T v)
	{
	  return storeToJsonValue.functorMethod(v).toString();
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static bool loadFromJson<T>(T v, string buf)
	{
	  try
	  {
		if (string.IsNullOrEmpty(buf))
		{
		  return true;
		}
		var js = Common.JsonValue.fromString.functorMethod(buf);
		loadFromJsonValue(v, js.functorMethod);
	  }
	  catch (System.Exception)
	  {
		return false;
	  }
	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static string storeToBinaryKeyValue<T>(T v)
	{
	  KVBinaryOutputStreamSerializer s = new KVBinaryOutputStreamSerializer();
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
	  serialize(const_cast<T&>(v), s.functorMethod);

	  string result;
	  Common.StringOutputStream stream = new Common.StringOutputStream(result);
	  s.dump(stream);
	  return result;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static bool loadFromBinaryKeyValue<T>(T v, string buf)
	{
	  try
	  {
		Common.MemoryInputStream stream = new Common.MemoryInputStream(buf.data(), buf.Length);
		KVBinaryInputStreamSerializer s = new KVBinaryInputStreamSerializer(stream);
		serialize(v, s);
		return true;
	  }
	  catch (System.Exception)
	  {
		return false;
	  }
	}

	public static readonly int LEVIN_PROTOCOL_RETCODE_SUCCESS = 1;

	public static readonly size_t CONCURRENCY_LEVEL = std::thread.hardware_concurrency();

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <class Container>
	public static void split<Container>(string str, Container cont, char delim = ' ')
	{
		std::stringstream ss = new std::stringstream(str);
		string token;
		while (getline(ss, token, delim))
		{
			cont.push_back(token);
		}
	}

	public static bool parseDaemonAddressFromString(ref string host, ref int port, string address)
	{
	  List<string> parts = new List<string>();
	  GlobalMembers.split(address, parts, ':');

	  if (parts.Count == 0)
	  {
		return false;
	  }
	  else if (parts.Count >= 2)
	  {
		try
		{
		  host = parts[0];
		  port = Convert.ToInt32(parts[1]);
		  return true;
		}
		catch (System.Exception e)
		{
		  return false;
		}
	  }

	  host = parts[0];
	  port = CryptoNote.RPC_DEFAULT_PORT;
	  return true;
	}

	public static std::error_code interpretResponseStatus(string status)
	{
	  if (DefineConstants.CORE_RPC_STATUS_BUSY == status)
	  {
		return GlobalMembers.make_error_code(error.NODE_BUSY);
	  }
	  else if (DefineConstants.CORE_RPC_STATUS_OK != status)
	  {
		return GlobalMembers.make_error_code(error.INTERNAL_NODE_ERROR);
	  }
	  return std::error_code();
	}


	internal static void serialize(COMMAND_RPC_GET_BLOCKS_FAST.response response, ISerializer s)
	{
	  s.functorMethod(response.blocks, "response.blocks");
	  s.functorMethod(response.start_height, "response.start_height");
	  s.functorMethod(response.current_height, "response.current_height");
	  s.functorMethod(response.status, "response.status");
	}

	public static readonly int LEVIN_PROTOCOL_RETCODE_SUCCESS = 1;

	public static readonly command_line.arg_descriptor<string> arg_p2p_bind_ip = new command_line.arg_descriptor<string>("p2p-bind-ip", "Interface for p2p network protocol", "0.0.0.0");
	public static readonly command_line.arg_descriptor<string> arg_p2p_bind_port = new command_line.arg_descriptor<string>("p2p-bind-port", "Port for p2p network protocol", std::to_string(CryptoNote.P2P_DEFAULT_PORT));
	public static readonly command_line.arg_descriptor<uint> arg_p2p_external_port = new command_line.arg_descriptor<uint>("p2p-external-port", "External port for p2p network protocol (if port forwarding used with NAT)", 0);
	public static readonly command_line.arg_descriptor<bool> arg_p2p_allow_local_ip = new command_line.arg_descriptor<bool>("allow-local-ip", "Allow local ip add to peer list, mostly in debug purposes");
	public static readonly command_line.arg_descriptor<List<string>> arg_p2p_add_peer = new command_line.arg_descriptor<List<string>>("add-peer", "Manually add peer to local peerlist");
	public static readonly command_line.arg_descriptor<List<string>> arg_p2p_add_priority_node = new command_line.arg_descriptor<List<string>>("add-priority-node", "Specify list of peers to connect to and attempt to keep the connection open");
	public static readonly command_line.arg_descriptor<List<string>> arg_p2p_add_exclusive_node = new command_line.arg_descriptor<List<string>>("add-exclusive-node", "Specify list of peers to connect to only." " If this option is given the options add-priority-node and seed-node are ignored");
	public static readonly command_line.arg_descriptor<List<string>> arg_p2p_seed_node = new command_line.arg_descriptor<List<string>>("seed-node", "Connect to a node to retrieve peer addresses, and disconnect");
	public static readonly command_line.arg_descriptor<bool> arg_p2p_hide_my_port = new command_line.arg_descriptor<bool>("hide-my-port", "Do not announce yourself as peerlist candidate", false, true);

	public static string print_peerlist_to_string(LinkedList<PeerlistEntry> pl)
	{
	  time_t now_time = 0;
	  time(now_time);
	  std::stringstream ss = new std::stringstream();
	  ss << std::setfill('0') << std::setw(8) << std::hex << std::noshowbase;
	  foreach (var pe in pl)
	  {
		ss << pe.id << "\t" << pe.adr << " \tlast_seen: " << Common.timeIntervalToString(now_time - pe.last_seen) << std::endl;
	  }
	  return ss.str();
	}
	  public static int invokeAdaptor<Command, Handler>(List<ushort> reqBuf, ref List<ushort> resBuf, P2pConnectionContext ctx, Handler handler)
	  {
		int command = Command.ID;

		Command.request req = boost::value_initialized<typename Command.request>();

		if (!LevinProtocol.decode(reqBuf, req))
		{
		  throw new System.Exception("Failed to load_from_binary in command " + Convert.ToString(command));
		}

		Command.response res = boost::value_initialized<typename Command.response>();
		int ret = handler(command, req, res, ctx);
		resBuf = LevinProtocol.encode(res);
		return ret;
	  }

	public static bool parsePeerFromString(NetworkAddress pe, string node_addr)
	{
	  return Common.parseIpAddressAndPort(pe.ip, pe.port, node_addr);
	}

	public static bool parsePeersAndAddToNetworkContainer(List<string> peerList, List<NetworkAddress> container)
	{
	  foreach (string peer in peerList)
	  {
		NetworkAddress networkAddress = new NetworkAddress();
		if (!GlobalMembers.parsePeerFromString(networkAddress, peer))
		{
		  return false;
		}
		container.Add(networkAddress);
	  }
	  return true;
	}

	public static bool parsePeersAndAddToPeerListContainer(List<string> peerList, List<PeerlistEntry> container)
	{
	  foreach (string peer in peerList)
	  {
		PeerlistEntry peerListEntry = new PeerlistEntry();
		peerListEntry.id = Crypto.GlobalMembers.rand<ulong>();
		if (!GlobalMembers.parsePeerFromString(peerListEntry.adr, peer))
		{
		  return false;
		}
		container.Add(peerListEntry);
	  }
	  return true;
	}

	public static P2pContext.Message makeReply(uint command, List<ushort> data, uint returnCode)
	{
	  return new P2pContext.Message(new P2pMessage({command, data}), P2pContext.Message.REPLY, new uint(returnCode));
	}
	public static P2pContext.Message makeRequest(uint command, List<ushort> data)
	{
	  return new P2pContext.Message(new P2pMessage({command, data}), P2pContext.Message.REQUEST);
	}

	public static std::ostream operator << (std::ostream s, P2pContext conn)
	{
	  return s << "[" << conn.getRemoteAddress() << "]";
	}

	public static NetworkAddress getRemoteAddress(TcpConnection connection)
	{
	  var addressAndPort = connection.getPeerAddressAndPort();
	  NetworkAddress remoteAddress = new NetworkAddress();
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: remoteAddress.ip = hostToNetwork(addressAndPort.first.getValue());
	  remoteAddress.ip.CopyFrom(GlobalMembers.hostToNetwork(addressAndPort.first.getValue()));
	  remoteAddress.port = addressAndPort.second;
	  return remoteAddress;
	}

	public static void doWithTimeoutAndThrow(System.Dispatcher dispatcher, std::chrono.nanoseconds timeout, Action f)
	{
	  string result;
	  System.ContextGroup cg = new System.ContextGroup(dispatcher);
	  System.ContextGroupTimeout cgTimeout = new System.ContextGroupTimeout(dispatcher, cg, timeout);

  cg.spawn(() =>
  {
	try
	{
	  f();
	}
	catch (System.InterruptedException)
	{
	  result = "Operation timeout";
	}
	catch (System.Exception e)
	{
	  result = e.Message;
	}
  });

	  cg.wait();

	  if (!string.IsNullOrEmpty(result))
	  {
		throw new System.Exception(result);
	  }
	}

	public static LinkedList<PeerlistEntry> fixTimeDelta(LinkedList<PeerlistEntry> peerlist, time_t remoteTime)
	{
	  //fix time delta
	  long delta = time(null) - remoteTime;
	  LinkedList<PeerlistEntry> peerlistCopy = new LinkedList<PeerlistEntry>(peerlist);

	  foreach (PeerlistEntry be in peerlistCopy)
	  {
		if (be.last_seen > ulong(remoteTime))
		{
		  throw new System.Exception("Invalid peerlist entry (time in future)");
		}

		be.last_seen += delta;
	  }

	  return peerlistCopy;
	}

	public static readonly std::chrono.nanoseconds P2P_DEFAULT_CONNECT_INTERVAL = std::chrono.seconds(2);
	public static readonly size_t P2P_DEFAULT_CONNECT_RANGE = 20;
	public static readonly size_t P2P_DEFAULT_PEERLIST_GET_TRY_COUNT = 10;
	public static void invokeJsonCommand<Request, Response>(HttpClient client, string url, Request req, Response res)
	{
	  HttpRequest hreq = new HttpRequest();
	  HttpResponse hres = new HttpResponse();

	  hreq.addHeader("Content-Type", "application/json");
	  hreq.setUrl(url);
	  hreq.setBody(storeToJson(req));
	  client.request(hreq, hres);

	  if (hres.getStatus() != HttpResponse.STATUS_200)
	  {
		throw new System.Exception("HTTP status: " + Convert.ToString(hres.getStatus()));
	  }

	  if (!loadFromJson(res, hres.getBody()))
	  {
		throw new System.Exception("Failed to parse JSON response");
	  }
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Request, typename Response>
	public static void invokeBinaryCommand<Request, Response>(HttpClient client, string url, Request req, Response res)
	{
	  HttpRequest hreq = new HttpRequest();
	  HttpResponse hres = new HttpResponse();

	  hreq.setUrl(url);
	  hreq.setBody(storeToBinaryKeyValue(req));
	  client.request(hreq, hres);

	  if (!loadFromBinaryKeyValue(res, hres.getBody()))
	  {
		throw new System.Exception("Failed to parse binary response");
	  }
	}

	internal static void serialize(COMMAND_RPC_GET_BLOCKS_FAST.response response, ISerializer s)
	{
	  s.functorMethod(response.blocks, "response.blocks");
	  s.functorMethod(response.start_height, "response.start_height");
	  s.functorMethod(response.current_height, "response.current_height");
	  s.functorMethod(response.status, "response.status");
	}

	public static void serialize(BlockFullInfo blockFullInfo, ISerializer s)
	{
	  s.functorMethod(blockFullInfo.block_id, "blockFullInfo.block_id");
	  s.functorMethod(blockFullInfo.block, "blockFullInfo.block");
	  s.functorMethod(blockFullInfo.transactions, "txs");
	}

	public static void serialize(TransactionPrefixInfo transactionPrefixInfo, ISerializer s)
	{
	  s.functorMethod(transactionPrefixInfo.txHash, "transactionPrefixInfo.txHash");
	  s.functorMethod(transactionPrefixInfo.txPrefix, "transactionPrefixInfo.txPrefix");
	}

	public static void serialize(BlockShortInfo blockShortInfo, ISerializer s)
	{
	  s.functorMethod(blockShortInfo.blockId, "blockShortInfo.blockId");
	  s.functorMethod(blockShortInfo.block, "blockShortInfo.block");
	  s.functorMethod(blockShortInfo.txPrefixes, "blockShortInfo.txPrefixes");
	}
private delegate bool handlerDelegate(Command.request UnnamedParameter, Command.response UnnamedParameter2);

	public static RpcServer.HandlerFunction jsonMethod<Command>(handlerDelegate handler)
	{
//C++ TO C# CONVERTER TODO TASK: Only lambda expressions having all locals passed by reference can be converted to C#:
//ORIGINAL LINE: return [handler](RpcServer* obj, const HttpRequest& request, HttpResponse& response)
  return (RpcServer obj, HttpRequest request, HttpResponse response) =>
  {

	boost::value_initialized<typename Command.request> req = new boost::value_initialized<typename Command.request>();
	boost::value_initialized<typename Command.response> res = new boost::value_initialized<typename Command.response>();

	if (!loadFromJson((typename Command.request)req, request.getBody()))
	{
	  return false;
	}

	bool result = handler(req, res);
	foreach (var cors_domain in obj.getCorsDomains())
	{
	  response.addHeader("Access-Control-Allow-Origin", cors_domain);
	}
	response.addHeader("Content-Type", "application/json");
	response.setBody(storeToJson(res.data()));
	return result;
  };
	}



	public static Dictionary<string, RpcServer.RpcHandler<RpcServer.HandlerFunction>> RpcServer.s_handlers =
	{
		{
			"/getinfo", {jsonMethod<COMMAND_RPC_GET_INFO>(RpcServer.on_get_info), true}
		},
		{
			"/getheight", {jsonMethod<COMMAND_RPC_GET_HEIGHT>(RpcServer.on_get_height), true}
		},
		{
			"/feeinfo", {jsonMethod<COMMAND_RPC_GET_FEE_ADDRESS>(RpcServer.on_get_fee_info), true}
		},
		{
			"/getpeers", {jsonMethod<COMMAND_RPC_GET_PEERS>(RpcServer.on_get_peers), true}
		},
		{
			"/info", {jsonMethod<COMMAND_RPC_GET_INFO>(RpcServer.on_get_info), true}
		},
		{
			"/height", {jsonMethod<COMMAND_RPC_GET_HEIGHT>(RpcServer.on_get_height), true}
		},
		{
			"/fee", {jsonMethod<COMMAND_RPC_GET_FEE_ADDRESS>(RpcServer.on_get_fee_info), true}
		},
		{
			"/peers", {jsonMethod<COMMAND_RPC_GET_PEERS>(RpcServer.on_get_peers), true}
		},
		{
			"/gettransactions", {jsonMethod<COMMAND_RPC_GET_TRANSACTIONS>(RpcServer.on_get_transactions), false}
		},
		{
			"/sendrawtransaction", {jsonMethod<COMMAND_RPC_SEND_RAW_TX>(RpcServer.on_send_raw_tx), false}
		},
		{
			"/getblocks", {jsonMethod<COMMAND_RPC_GET_BLOCKS_FAST>(RpcServer.on_get_blocks), false}
		},
		{
			"/queryblocks", {jsonMethod<COMMAND_RPC_QUERY_BLOCKS>(RpcServer.on_query_blocks), false}
		},
		{
			"/queryblockslite", {jsonMethod<COMMAND_RPC_QUERY_BLOCKS_LITE>(RpcServer.on_query_blocks_lite), false}
		},
		{
			"/get_o_indexes", {jsonMethod<COMMAND_RPC_GET_TX_GLOBAL_OUTPUTS_INDEXES>(RpcServer.on_get_indexes), false}
		},
		{
			"/getrandom_outs", {jsonMethod<COMMAND_RPC_GET_RANDOM_OUTPUTS_FOR_AMOUNTS>(RpcServer.on_get_random_outs), false}
		},
		{
			"/get_pool_changes", {jsonMethod<COMMAND_RPC_GET_POOL_CHANGES>(RpcServer.onGetPoolChanges), false}
		},
		{
			"/get_pool_changes_lite", {jsonMethod<COMMAND_RPC_GET_POOL_CHANGES_LITE>(RpcServer.onGetPoolChangesLite), false}
		},
		{
			"/get_block_details_by_height", {jsonMethod<COMMAND_RPC_GET_BLOCK_DETAILS_BY_HEIGHT>(RpcServer.onGetBlockDetailsByHeight), false}
		},
		{
			"/get_blocks_details_by_heights", {jsonMethod<COMMAND_RPC_GET_BLOCKS_DETAILS_BY_HEIGHTS>(RpcServer.onGetBlocksDetailsByHeights), false}
		},
		{
			"/get_blocks_details_by_hashes", {jsonMethod<COMMAND_RPC_GET_BLOCKS_DETAILS_BY_HASHES>(RpcServer.onGetBlocksDetailsByHashes), false}
		},
		{
			"/get_blocks_hashes_by_timestamps", {jsonMethod<COMMAND_RPC_GET_BLOCKS_HASHES_BY_TIMESTAMPS>(RpcServer.onGetBlocksHashesByTimestamps), false}
		},
		{
			"/get_transaction_details_by_hashes", {jsonMethod<COMMAND_RPC_GET_TRANSACTION_DETAILS_BY_HASHES>(RpcServer.onGetTransactionDetailsByHashes), false}
		},
		{
			"/get_transaction_hashes_by_payment_id", {jsonMethod<COMMAND_RPC_GET_TRANSACTION_HASHES_BY_PAYMENT_ID>(RpcServer.onGetTransactionHashesByPaymentId), false}
		},
		{
			"/json_rpc", {std::bind(RpcServer.processJsonRpcRequest, std::placeholders._1, std::placeholders._2, std::placeholders._3), true}
		}
	};
	  public static ulong slow_memmem(object start_buff, size_t buflen, object pat, size_t patlen)
	  {
		object buf = start_buff;
		object end = (string)buf + buflen - patlen;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memchr' has no equivalent in C#:
		while ((buf = memchr(buf, ((string)pat)[0], buflen)))
		{
		  if (buf > end)
		  {
			return 0;
		  }
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
		  if (memcmp(buf, pat, patlen) == 0)
		  {
			return (string)buf - (string)start_buff;
		  }
		  buf = (string)buf + 1;
		}
		return 0;
	  }

	public static ulong get_block_reward(BlockTemplate blk)
	{
	  ulong reward = 0;
	  foreach (TransactionOutput @out in blk.baseTransaction.outputs)
	  {
		reward += @out.amount;
	  }

	  return reward;
	}
	public static void readVarintAs<StorageType, T>(IInputStream s, ref T i)
	{
	  i = (T)(readVarint<StorageType>(s));
	}

//namespace CryptoNote {


	public static void serialize(TransactionOutputDetails output, ISerializer serializer)
	{
	  serializer.functorMethod(output.output, "output");
	  serializer.functorMethod(output.globalIndex, "globalIndex");
	}
	public static void serialize(TransactionOutputReferenceDetails outputReference, ISerializer serializer)
	{
	  GlobalMembers.serializePod(outputReference.transactionHash, "transactionHash", serializer.functorMethod);
	  serializer.functorMethod(outputReference.number, "number");
	}

	public static void serialize(BaseInputDetails inputBase, ISerializer serializer)
	{
	  serializer.functorMethod(inputBase.input, "input");
	  serializer.functorMethod(inputBase.amount, "amount");
	}
	public static void serialize(KeyInputDetails inputToKey, ISerializer serializer)
	{
	  serializer.functorMethod(inputToKey.input, "input");
	  serializer.functorMethod(inputToKey.mixin, "mixin");
	  serializer.functorMethod(inputToKey.output, "output");
	}
	public static void serialize(boost::variant<BaseInputDetails, KeyInputDetails> input, ISerializer serializer)
	{
	  if (serializer.type() == ISerializer.OUTPUT)
	  {
		BinaryVariantTagGetter tagGetter = new BinaryVariantTagGetter();
		ushort tag = boost::apply_visitor(tagGetter.functorMethod, input);
		serializer.binary(tag, sizeof(ushort), "type");

		VariantSerializer visitor = new VariantSerializer(serializer.functorMethod, "data");
		boost::apply_visitor(visitor.functorMethod, input);
	  }
	  else
	  {
		ushort tag = new ushort();
		serializer.binary(tag, sizeof(ushort), "type");

		GlobalMembers.getVariantValue(serializer.functorMethod, new ushort(tag), ref input);
	  }
	}

	public static void serialize(TransactionExtraDetails extra, ISerializer serializer)
	{
	  GlobalMembers.serializePod(extra.publicKey, "publicKey", serializer.functorMethod);
	  serializer.functorMethod(extra.nonce, "nonce");
	  serializeAsBinary(extra.raw, "raw", serializer.functorMethod);
	}
	public static void serialize(TransactionDetails transaction, ISerializer serializer)
	{
	  GlobalMembers.serializePod(transaction.hash, "hash", serializer.functorMethod);
	  serializer.functorMethod(transaction.size, "size");
	  serializer.functorMethod(transaction.fee, "fee");
	  serializer.functorMethod(transaction.totalInputsAmount, "totalInputsAmount");
	  serializer.functorMethod(transaction.totalOutputsAmount, "totalOutputsAmount");
	  serializer.functorMethod(transaction.mixin, "mixin");
	  serializer.functorMethod(transaction.unlockTime, "unlockTime");
	  serializer.functorMethod(transaction.timestamp, "timestamp");
	  GlobalMembers.serializePod(transaction.paymentId, "paymentId", serializer.functorMethod);
	  serializer.functorMethod(transaction.inBlockchain, "inBlockchain");
	  GlobalMembers.serializePod(transaction.blockHash, "blockHash", serializer.functorMethod);
	  serializer.functorMethod(transaction.blockIndex, "blockIndex");
	  serializer.functorMethod(transaction.extra, "extra");
	  serializer.functorMethod(transaction.inputs, "inputs");
	  serializer.functorMethod(transaction.outputs, "outputs");

	  //serializer(transaction.signatures, "signatures");
	  if (serializer.type() == ISerializer.OUTPUT)
	  {
		List<Tuple<ulong, Crypto.Signature>> signaturesForSerialization = new List<Tuple<ulong, Crypto.Signature>>();
		signaturesForSerialization.Capacity = transaction.signatures.Count;
		ulong ctr = 0;
		foreach (var signaturesV in transaction.signatures)
		{
		  foreach (var signature in signaturesV)
		  {
			signaturesForSerialization.emplace_back(ctr, std::move(signature));
		  }
		  ++ctr;
		}
		ulong size = transaction.signatures.Count;
		serializer.functorMethod(size, "signaturesSize");
		serializer.functorMethod(signaturesForSerialization, "signatures");
	  }
	  else
	  {
		ulong size = 0;
		serializer.functorMethod(size, "signaturesSize");
		transaction.signatures.Resize(size);

		List<Tuple<ulong, Crypto.Signature>> signaturesForSerialization = new List<Tuple<ulong, Crypto.Signature>>();
		serializer.functorMethod(signaturesForSerialization, "signatures");

		foreach (var signatureWithIndex in signaturesForSerialization)
		{
		  transaction.signatures[signatureWithIndex.Item1].Add(signatureWithIndex.Item2);
		}
	  }
	}

	public static void serialize(BlockDetails block, ISerializer serializer)
	{
	  serializer.functorMethod(block.majorVersion, "majorVersion");
	  serializer.functorMethod(block.minorVersion, "minorVersion");
	  serializer.functorMethod(block.timestamp, "timestamp");
	  GlobalMembers.serializePod(block.prevBlockHash, "prevBlockHash", serializer.functorMethod);
	  serializer.functorMethod(block.nonce, "nonce");
	  serializer.functorMethod(block.index, "index");
	  GlobalMembers.serializePod(block.hash, "hash", serializer.functorMethod);
	  serializer.functorMethod(block.difficulty, "difficulty");
	  serializer.functorMethod(block.reward, "reward");
	  serializer.functorMethod(block.baseReward, "baseReward");
	  serializer.functorMethod(block.blockSize, "blockSize");
	  serializer.functorMethod(block.transactionsCumulativeSize, "transactionsCumulativeSize");
	  serializer.functorMethod(block.alreadyGeneratedCoins, "alreadyGeneratedCoins");
	  serializer.functorMethod(block.alreadyGeneratedTransactions, "alreadyGeneratedTransactions");
	  serializer.functorMethod(block.sizeMedian, "sizeMedian");
	  /* Some serializers don't support doubles, which causes this to fail and
	     not serialize the whole object
	  serializer(block.penalty, "penalty");
	  */
	  serializer.functorMethod(block.totalFeeAmount, "totalFeeAmount");
	  serializer.functorMethod(block.transactions, "transactions");
	}

	public static void getVariantValue(CryptoNote.ISerializer serializer, ushort tag, ref boost::variant<CryptoNote.BaseInputDetails, CryptoNote.KeyInputDetails> in)
	{
	  switch ((SerializationTag)tag)
	  {
	  case SerializationTag.Base:
	  {
		CryptoNote.BaseInputDetails v = new CryptoNote.BaseInputDetails();
		serializer.functorMethod(v, "data");
		in = v;
		break;
	  }
	  case SerializationTag.Key:
	  {
		CryptoNote.KeyInputDetails v = new CryptoNote.KeyInputDetails();
		serializer.functorMethod(v, "data");
		in = v;
		break;
	  }
	  default:
		throw new System.Exception("Unknown variant tag");
	  }
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static bool serializePod<T>(T v, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return serializer.binary(v, sizeof(T), new Common.StringView(name));
	}

	public static Common.JsonValue getJsonValueFromStreamHelper(std::istream stream)
	{
	  Common.JsonValue value = new Common.JsonValue();
	  stream >> value.functorMethod;
	  return value.functorMethod;
	}
	public static std::enable_if<std::is_pod<T>.value>.type serializeAsBinary<T>(List<T> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  string blob;
	  if (serializer.type() == ISerializer.INPUT)
	  {
		serializer.binary(blob, new Common.StringView(name));
		value.Resize(blob.Length / sizeof(T));
		if (blob.Length != 0)
		{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		  memcpy(value[0], blob.data(), blob.Length);
		}
	  }
	  else
	  {
		if (value.Count > 0)
		{
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		  blob.assign(reinterpret_cast<const char>(value[0]), value.Count * sizeof(T));
		}
		serializer.binary(blob, new Common.StringView(name));
	  }
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static std::enable_if<std::is_pod<T>.value>.type serializeAsBinary<T>(LinkedList<T> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  string blob;
	  if (serializer.type() == ISerializer.INPUT)
	  {
		serializer.binary(blob, new Common.StringView(name));

		ulong count = blob.Length / sizeof(T);
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		T * ptr = reinterpret_cast<const T>(blob.data());

		while (count-- != null)
		{
		  value.AddLast(*ptr++);
		}
	  }
	  else
	  {
		if (value.Count > 0)
		{
		  blob.resize(value.Count * sizeof(T));
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		  T * ptr = reinterpret_cast<T>(blob[0]);

		  foreach (var item in value)
		  {
			*ptr++= item;
		  }
		}
		serializer.binary(blob, new Common.StringView(name));
	  }
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Cont>
	public static bool serializeContainer<Cont>(Cont value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  ulong size = value.size();
	  if (!serializer.beginArray(size, new Common.StringView(name)))
	  {
		if (serializer.type() == ISerializer.INPUT)
		{
		  value.clear();
		}

		return false;
	  }

	  value.resize(size);

	  foreach (var item in value)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		serializer.functorMethod(const_cast<typename Cont.value_type&>(item), "");
	  }

	  serializer.endArray();
	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename E>
	public static bool serializeEnumClass<E>(ref E value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//  static_assert(std::is_enum<E>::value, "E must be an enum class");


	  if (serializer.type() == CryptoNote.ISerializer.INPUT)
	  {
		std::underlying_type<E>.type numericValue = new std::underlying_type<E>.type();
		serializer.functorMethod(numericValue, name);
		value = (E)numericValue;
	  }
	  else
	  {
		var numericValue = (typename std::underlying_type<E>.type)value;
		serializer.functorMethod(numericValue, name);
	  }

	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static bool serialize<T>(List<T> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return serializeContainer(value, new Common.StringView(name), serializer.functorMethod);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename T>
	public static bool serialize<T>(LinkedList<T> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return serializeContainer(value, new Common.StringView(name), serializer.functorMethod);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename MapT, typename ReserveOp>
	public static bool serializeMap<MapT, ReserveOp>(MapT value, Common.StringView name, CryptoNote.ISerializer serializer, ReserveOp reserve)
	{
	  ulong size = value.size();

	  if (!serializer.beginArray(size, new Common.StringView(name)))
	  {
		if (serializer.type() == ISerializer.INPUT)
		{
		  value.clear();
		}

		return false;
	  }

	  if (serializer.type() == CryptoNote.ISerializer.INPUT)
	  {
		reserve(size);

		for (ulong i = 0; i < size; ++i)
		{
		  MapT.key_type key = new MapT.key_type();
		  MapT.mapped_type v = new MapT.mapped_type();

		  serializer.beginObject("");
		  serializer.functorMethod(key, "key");
		  serializer.functorMethod(v, "value");
		  serializer.endObject();

		  value.insert(Tuple.Create(std::move(key), std::move(v)));
		}
	  }
	  else
	  {
		foreach (var kv in value)
		{
		  serializer.beginObject("");
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		  serializer.functorMethod(const_cast<typename MapT.key_type&>(kv.first), "key");
		  serializer.functorMethod(kv.second, "value");
		  serializer.endObject();
		}
	  }

	  serializer.endArray();
	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename SetT>
	public static bool serializeSet<SetT>(SetT value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  ulong size = value.size();

	  if (!serializer.beginArray(size, new Common.StringView(name)))
	  {
		if (serializer.type() == ISerializer.INPUT)
		{
		  value.clear();
		}

		return false;
	  }

	  if (serializer.type() == CryptoNote.ISerializer.INPUT)
	  {
		for (ulong i = 0; i < size; ++i)
		{
		  SetT.value_type key = new SetT.value_type();
		  serializer.functorMethod(key, "");
		  value.insert(std::move(key));
		}
	  }
	  else
	  {
		foreach (var key in value)
		{
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		  serializer.functorMethod(const_cast<typename SetT.value_type&>(key), "");
		}
	  }

	  serializer.endArray();
	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename K, typename Hash>
	public static bool serialize<K, Hash>(HashSet<K, Hash> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return serializeSet(value, new Common.StringView(name), serializer.functorMethod);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename K, typename Cmp>
	public static bool serialize<K, Cmp>(SortedSet<K, Cmp> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
	  return serializeSet(value, new Common.StringView(name), serializer.functorMethod);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename K, typename V, typename Hash>
	public static bool serialize<K, V, Hash>(Dictionary<K, V, Hash> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
  return serializeMap(value, new Common.StringView(name), serializer.functorMethod, (ulong size) =>
  {
	  value.reserve(size);
  });
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename K, typename V, typename Hash>
	public static bool serialize<K, V, Hash>(std::unordered_multimap<K, V, Hash> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
  return serializeMap(value, new Common.StringView(name), serializer.functorMethod, (ulong size) =>
  {
	  value.reserve(size);
  });
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename K, typename V, typename Hash>
	public static bool serialize<K, V, Hash>(SortedDictionary<K, V, Hash> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
  return serializeMap(value, new Common.StringView(name), serializer.functorMethod, (ulong size) =>
  {
  });
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename K, typename V, typename Hash>
	public static bool serialize<K, V, Hash>(std::multimap<K, V, Hash> value, Common.StringView name, CryptoNote.ISerializer serializer)
	{
  return serializeMap(value, new Common.StringView(name), serializer.functorMethod, (ulong size) =>
  {
  });
	}

	//C++ TO C# CONVERTER TODO TASK: C++ 'constraints' are not converted by C++ to C# Converter:
	//ORIGINAL LINE: template<ulong size>
//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<typename size>
	public static bool serialize<size>(List<ushort> value, Common.StringView name, CryptoNote.ISerializer s)
	{
	  return s.binary(value.data(), value.Count, new Common.StringView(name));
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T1, typename T2>
	public static void serialize<T1, T2>(Tuple<T1, T2> value, ISerializer s)
	{
	  s.functorMethod(value.Item1, "first");
	  s.functorMethod(value.Item2, "second");
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Element, typename Iterator>
	public static void writeSequence<Element, Iterator>(Iterator begin, Iterator end, Common.StringView name, ISerializer s)
	{
	  ulong size = std::distance(begin, end);
	  s.beginArray(size, new Common.StringView(name));
	  for (Iterator i = begin; i != end; ++i)
	  {
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		s.functorMethod(const_cast<Element&>(*i), "");
	  }
	  s.endArray();
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Element, typename Iterator>
	public static void readSequence<Element, Iterator>(Iterator outputIterator, Common.StringView name, ISerializer s)
	{
	  ulong size = 0;
	  // array of zero size is not written in KVBinaryOutputStreamSerializer
	  if (!s.beginArray(size, new Common.StringView(name)))
	  {
		return;
	  }

	  while (size-- != null)
	  {
		Element e = new default(Element);
		s.functorMethod(e, "");
		*outputIterator++= std::move(e);
	  }

	  s.endArray();
	}

	//convinience function since we change block height type
	public static void serializeBlockHeight(ISerializer s, ref uint blockHeight, Common.StringView name)
	{
	  if (s.type() == ISerializer.INPUT)
	  {
		ulong height = new ulong();
		s.functorMethod(height, name);

		if (height == ulong.MaxValue)
		{
		  blockHeight = uint.MaxValue;
		}
		else if (height > uint.MaxValue && height < ulong.MaxValue)
		{
		  throw new System.Exception("Deserialization error: wrong value");
		}
		else
		{
		  blockHeight = (uint)height;
		}
	  }
	  else
	  {
		s.functorMethod(blockHeight, name);
	  }
	}

	//convinience function since we change global output index type
	public static void serializeGlobalOutputIndex(ISerializer s, uint globalOutputIndex, Common.StringView name)
	{
	  serializeBlockHeight(s.functorMethod, ref globalOutputIndex, new Common.StringView(name));
	}

	public static std::error_code createTransfers(AccountKeys account, TransactionBlockInfo blockInfo, ITransactionReader tx, List<uint> outputs, List<uint> globalIdxs, List<TransactionOutputInformationIn> transfers, Logging.LoggerRef m_logger)
	{

	  var txPubKey = tx.getTransactionPublicKey();
	  List<PublicKey> temp_keys = new List<PublicKey>();
	  lock (seen_mutex)
	  {
        
		  foreach (var idx in outputs)
		  {
			bool isDuplicate = false;
        
			if (idx >= tx.getOutputCount())
			{
			  return std::make_error_code(std::errc.argument_out_of_domain);
			}
        
			var outType = tx.getOutputType(size_t(idx));
        
			if (outType != CryptoNote.TransactionTypes.OutputType.Key)
			{
			  continue;
			}
        
			TransactionOutputInformationIn info = new TransactionOutputInformationIn();
        
			info.type = outType;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: info.transactionPublicKey = txPubKey;
			info.transactionPublicKey.CopyFrom(txPubKey);
			info.outputInTransaction = idx;
			info.globalOutputIndex = (blockInfo.height == WALLET_UNCONFIRMED_TRANSACTION_HEIGHT) ? UNCONFIRMED_TRANSACTION_GLOBAL_OUTPUT_INDEX : globalIdxs[idx];
        
			if (outType == CryptoNote.TransactionTypes.OutputType.Key)
			{
			  ulong amount;
			  KeyOutput @out = new KeyOutput();
			  tx.getOutput(idx, @out, ref amount);
        
			  CryptoNote.KeyPair in_ephemeral = new CryptoNote.KeyPair();
			  CryptoNote.generate_key_image_helper(account, txPubKey, idx, in_ephemeral, info.keyImage);
        
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
			  Debug.Assert(@out.key == reinterpret_cast<const PublicKey&>(in_ephemeral.publicKey));
        
			  if (GlobalMembers.transactions_hash_seen.find(tx.getTransactionHash()) == GlobalMembers.transactions_hash_seen.end())
			  {
				if (GlobalMembers.public_keys_seen.find(@out.key) != GlobalMembers.public_keys_seen.end())
				{
				  m_logger.functorMethod(WARNING, BRIGHT_RED) << "A duplicate public key was found in " << Common.GlobalMembers.podToHex(tx.getTransactionHash());
				  isDuplicate = true;
				}
				else
				{
				  temp_keys.Add(@out.key);
				}
			  }
        
			  info.amount = amount;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: info.outputKey = out.key;
			  info.outputKey.CopyFrom(@out.key);
			}
        
			if (!isDuplicate)
			{
			  transfers.Add(info);
			}
		  }
	  }

	  GlobalMembers.transactions_hash_seen.Add(tx.getTransactionHash());
	  std::copy(temp_keys.GetEnumerator(), temp_keys.end(), std::inserter(GlobalMembers.public_keys_seen, GlobalMembers.public_keys_seen.end()));
	  return std::error_code();
	}

	public static void serialize(TransactionInformation ti, CryptoNote.ISerializer s)
	{
	  s.functorMethod(ti.transactionHash, "");
	  s.functorMethod(ti.publicKey, "");
	  serializeBlockHeight(s.functorMethod, ref ti.blockHeight, "");
	  s.functorMethod(ti.timestamp, "");
	  s.functorMethod(ti.unlockTime, "");
	  s.functorMethod(ti.totalAmountIn, "");
	  s.functorMethod(ti.totalAmountOut, "");
	  s.functorMethod(ti.extra, "");
	  s.functorMethod(ti.paymentId, "");
	}

	public static readonly uint TRANSFERS_CONTAINER_STORAGE_VERSION = 0;
	  public static TransferIteratorList<TIterator> createTransferIteratorList<TIterator>(Tuple<TIterator, TIterator> itPair)
	  {
		return new TransferIteratorList<TIterator>(itPair.Item1, itPair.Item2);
	  }
	  public static void updateVisibility<C, T>(C collection, T range, bool visible)
	  {
		for (var it = range.first; it != range.second; ++it)
		{
		  var updated = it;
		  updated.visible = visible;
		  collection.replace(it, updated);
		}
	  }

	public static readonly uint TRANSFERS_STORAGE_ARCHIVE_VERSION = 0;
	public static string getObjectState(IStreamSerializable obj)
	{
	  std::stringstream stream = new std::stringstream();
	  obj.save(stream);
	  return stream.str();
	}

	public static void setObjectState(IStreamSerializable obj, string state)
	{
	  std::stringstream stream = new std::stringstream(state);
	  obj.load(stream);
	}

	public static ulong getDefaultMixinByHeight(ulong height)
	{
		if (height >= CryptoNote.parameters.MIXIN_LIMITS_V3_HEIGHT)
		{
			return CryptoNote.parameters.DEFAULT_MIXIN_V3;
		}
		if (height >= CryptoNote.parameters.MIXIN_LIMITS_V2_HEIGHT)
		{
			return CryptoNote.parameters.DEFAULT_MIXIN_V2;
		}
		else if (height >= CryptoNote.parameters.MIXIN_LIMITS_V1_HEIGHT)
		{
			return CryptoNote.parameters.DEFAULT_MIXIN_V1;
		}
		else
		{
			return CryptoNote.parameters.DEFAULT_MIXIN_V0;
		}
	}
	public static void throwIfKeysMismatch(Crypto.SecretKey secretKey, Crypto.PublicKey expectedPublicKey, string message = "")
	{
	  Crypto.PublicKey pub = new Crypto.PublicKey();
	  bool r = Crypto.secret_key_to_public_key(secretKey, pub);
	  if (!r || expectedPublicKey != pub)
	  {
		throw std::system_error(GlobalMembers.make_error_code(CryptoNote.error.WRONG_PASSWORD), message);
	  }
	}
	public static bool validateAddress(string address, CryptoNote.Currency currency)
	{
	  CryptoNote.AccountPublicAddress ignore = new CryptoNote.AccountPublicAddress();
	  return currency.parseAccountAddressString(address, ignore);
	}

	public static std::ostream operator << (std::ostream os, CryptoNote.WalletTransactionState state)
	{
	  switch (state)
	  {
	  case CryptoNote.WalletTransactionState.SUCCEEDED:
		os << "SUCCEEDED";
		break;
	  case CryptoNote.WalletTransactionState.FAILED:
		os << "FAILED";
		break;
	  case CryptoNote.WalletTransactionState.CANCELLED:
		os << "CANCELLED";
		break;
	  case CryptoNote.WalletTransactionState.CREATED:
		os << "CREATED";
		break;
	  case CryptoNote.WalletTransactionState.DELETED:
		os << "DELETED";
		break;
	  default:
		os << "<UNKNOWN>";
	break;
	  }

	  return os << " (" << (int)state << ')';
	}
	public static std::ostream operator << (std::ostream os, CryptoNote.WalletTransferType type)
	{
	  switch (type)
	  {
	  case CryptoNote.WalletTransferType.USUAL:
		os << "USUAL";
		break;
	  case CryptoNote.WalletTransferType.DONATION:
		os << "DONATION";
		break;
	  case CryptoNote.WalletTransferType.CHANGE:
		os << "CHANGE";
		break;
	  default:
		os << "<UNKNOWN>";
	break;
	  }

	  return os << " (" << (int)type << ')';
	}
	public static std::ostream operator << (std::ostream os, CryptoNote.WalletGreen.WalletState state)
	{
	  switch (state)
	  {
	  case CryptoNote.WalletGreen.WalletState.INITIALIZED:
		os << "INITIALIZED";
		break;
	  case CryptoNote.WalletGreen.WalletState.NOT_INITIALIZED:
		os << "NOT_INITIALIZED";
		break;
	  default:
		os << "<UNKNOWN>";
	break;
	  }

	  return os << " (" << (int)state << ')';
	}
	public static std::ostream operator << (std::ostream os, CryptoNote.WalletGreen.WalletTrackingMode mode)
	{
	  switch (mode)
	  {
	  case CryptoNote.WalletGreen.WalletTrackingMode.TRACKING:
		os << "TRACKING";
		break;
	  case CryptoNote.WalletGreen.WalletTrackingMode.NOT_TRACKING:
		os << "NOT_TRACKING";
		break;
	  case CryptoNote.WalletGreen.WalletTrackingMode.NO_ADDRESSES:
		os << "NO_ADDRESSES";
		break;
	  default:
		os << "<UNKNOWN>";
	break;
	  }

	  return os << " (" << (int)mode << ')';
	}

	public static readonly uint WALLET_INVALID_TRANSACTION_ID = uint.MaxValue;
	public static readonly uint WALLET_INVALID_TRANSFER_ID = uint.MaxValue;
	public static readonly uint WALLET_UNCONFIRMED_TRANSACTION_HEIGHT = uint.MaxValue;
	  public static string getProjectCLIHeader()
	  {
		std::stringstream programHeader = new std::stringstream();
		programHeader << std::endl << asciiArt << std::endl << " " << CryptoNote.CRYPTONOTE_NAME << " v" << PROJECT_VERSION_LONG << std::endl << " This software is distributed under the General Public License v3.0" << std::endl << std::endl << " " << PROJECT_COPYRIGHT << std::endl << std::endl << " Additional Copyright(s) may apply, please see the included LICENSE file for more information." << std::endl << " If you did not receive a copy of the LICENSE, please visit:" << std::endl << " " << CryptoNote.LICENSE_URL << std::endl << std::endl;

		return programHeader.str();
	  }

	public static readonly std::initializer_list<CheckpointData> CHECKPOINTS = new std::initializer_list<CheckpointData>({0, "7fb97df81221dd1366051b2d0bc7f49c66c22ac4431d879c895b06d66ef66f4c"}, {5000, "1325029c8be54b9e027f17ec481a0a361e4821381d1d12de1492e92cd38d4c11"}, {10000, "08b25f220656df008499f36c593bc7b875e3598eae0c9c32ff195e735e51ff1d"}, {15000, "8d83bdfde2e42b3be9ef194cd327ad5f893c9cab249395378e03aee8db9d420a"}, {20000, "aed3a0fe6adc5a828e4b9cfa97cea53d2ae565089b583756058e5c71682fde4d"}, {25000, "cd175f1ed7d6b2bf3e0ed7585aacd17c57b4cd708c4bd32183224d45716767c5"}, {30000, "90f91f95ea58a37b98cacd3c024fa2eaaa33e0eadc632aa3b61b061fb06b3efe"}, {35000, "7da853cb5d44abf72f2b2da43c6571e8287eec077a9c9059692f5b5c1ed3f73e"}, {40000, "da9451a44540a96aff987d4046a13b20ffe4bc08a0ac536a0c196f00d24a90ee"}, {45000, "122e4010229f1a2a99ed81ab9c7519a4cd5c23e9754f21a17b4a1e33411caf28"}, {50000, "dd40ba6a33e7c6ff84927d510881e285eba9a17cbde43da587aa6cc41883b852"}, {55000, "0caf8cd5552afc5701cfcc29bf8e8292064a65cbb4ffc26ae24decf7e43838bf"}, {60000, "1e2f5f6c9c4b4b3c44e45ea1bd9aa2893721a44793fb743564e6b105d5f978ba"}, {65000, "b55164b838f342d2a2258aac5b6ce230141f14e9f2472818ac0e4cf0263130ed"}, {70000, "33c5871e424d72525ac351baad3d698f0886e11836eed8db878ae6b436128074"}, {75000, "2425d24ba8bd69f9601430f3a5a545bdc3931ddd30f06f82ceeec2766c9ca74a"}, {80000, "9a62c2b5d8ae89a86019c52964c7f74c8b29504c0088d21d7f1f8484ad103440"}, {85000, "dc2d2e4ecb85c13d28872d875cccaf4f90d7e3ffd5cd134119c53633f802296a"}, {90000, "a123b24e7d1ea23eb610129ffad2b575baefac243c026c1ea7381fefcd1bd743"}, {95000, "04310be9aa0aaa2432c97cfce9db8153c3872942024015132220d95837a7f7df"}, {100000, "0559c2aad34dc8f47b30fefa2652aca9039d6ec0137af3fd0beb16d7c6f91b1d"}, {105000, "feaf9c526496c66efbe237d929fb65e6f102fa9b9158424c97d7ee3736a6b658"}, {110000, "23c14bb24a598df879e154ca745a6610e759765e68e8aa6b9c960f2c621d41f4"}, {115000, "e874317e8308896ee6694eb73159edccabdaacc09981908ec7a06640be6a6a46"}, {120000, "c78efd3fd072f3993bb1fff4bc02998057e749846dac1f63fb57e6b1fa1abb2d"}, {125000, "eb7115cc9701d5757bc9e89c29150cac97115502860c919580ab3e51bf55bc13"}, {130000, "6db14e442b7774e3f240342e4efc56ed73165fb94e3bc9d2798e9e9011a4fa02"}, {135000, "dc90ae322b120f9b34474ff536edf3d16b7c5e9794e14aca5343a22279a803d2"}, {140000, "0138d4b8a46de402691e40e0b912ceb54e1c7894583f6a9177bea18b66d5385a"}, {145000, "3713cd82b49e2300ebd74e359895709a0f9da1ace1903dd1731b66d02b7cc4bb"}, {150000, "ff867db0eb78ada7375656aafc452fe46a364ce998eb9add59399c13fc91accb"}, {155000, "a03383ee6938ab7f2ddbd0a2036c8b41db82e32cc91bb17b1d3d86ae50361170"}, {160000, "ec666aaa200f72c1e928ac9b8b38c43bf0d1c97b7d4020dea3fe94a5a041da4a"}, {165000, "a0899e0fd93a48c3828a472c960012f2f0582d320de7f2ca9b80ff3ee139f1f0"}, {170000, "9453b1bf99e98901949c7d88c9f6db8744b413f8160aa0ac0a467d2375c1f8fd"}, {175000, "d5286be301c0c9f3df317929bae432dec1160baf658c24cace8adc942c62dd44"}, {180000, "195deec0a5dff662f89f6bad28f205ddb3c72d778e7bfe9e0362cf9b244b791d"}, {185000, "d741fcfa4c085a055bc248e56db5ff18d6e0665590d8271e9a445819e50cbed4"}, {190000, "d881cd9e76ca0890bd881e75dd1a611558a44543a68326aeefe33f656db0fb21"}, {195000, "48b5c133876d2cc4d60976501981c0af1057321c4e404531c1fa6e04e3b31c50"}, {200000, "3438412001e186b0de417819353046199ad99c4e05b488e8391d7cc6c80a918e"}, {205000, "43b5199c3af492afcdd22072d3b1a0673dbbf24b892cf9d141612f00244dbfe6"}, {210000, "8c784e294af9694f4d5d817ef6637e561eb4a478d99d942d2da1a3906359a2ff"}, {215000, "98f0ec88e9e9c756808b3a36e1860888f466868ef0fca7de360b82ad26f65c7b"}, {220000, "5e43f24ff1e5e85e1c6f86cd09d1854ea76c605ca6c6ada4ea5fd3873c062cec"}, {225000, "816c3af64da7b26d3d77ee6087e3f5c44652ffe1f66f94902f72afb94f4f44e9"}, {230000, "95b16e0e248c39a7fd26c6f7fac420f317dd6deb9ee9bc541022e4412a9517be"}, {235000, "c629cd44e582f30aab010d071c46297f104ec8f093e798ed5de003faef4c3f0d"}, {240000, "c6617c3d1e873071e217d3970ec5aa56eab3839061ad80b45d3cd137b2c1f3c5"}, {245000, "44a0a64a7817c7b2c56d27cd5a396892418b8c797433c1c3517f3d3425080c01"}, {250000, "2df370f9c7648d158c570344066ce479abd0425162023afb8088109aa311fbe4"}, {255000, "2d6e05ef80ad0a51109e39ead7e9d0ef06f9668c6a7358093497ed12ae5569e0"}, {260000, "de79c513a8ff2408968c813f95e9bacb346dc736fd4db12aa522b6c35b61870b"}, {265000, "a5908d9b7ab9a81fb4788b3297e207a338d3eb95e43d536dbd65ef3416a95a3e"}, {270000, "81025a563355ec4b4cc327b4d22a421ef2b72e2fc80309994ee417ab1e34be04"}, {275000, "9935e59e95b81251b053c9aa1b82eef393a13004e4c0b6efff1e181f5262feca"}, {280000, "0864401ffb378cd03ad45ce3b7f8077dfd1cbe563e56ddf5155a87347ed0cf44"}, {285000, "0281cdc8bb3c7a076cd7244fc7816c8feb1c8eb985869ff859a444cd8c2e9d65"}, {290000, "f571dfd0f9c8e332d1c683953bfe7fc94b5e7344c1df1ccd80909fd746656bc2"}, {295000, "f33b271c9cfeab3dba4957be57fbecf45a4cea52861979a9dd9d8d2b56c48ec0"}, {300000, "a0ad53a2bc6c7ac6fd6f92586ade93994c49bdc4fb269f4c43bcc87ed7d07e66"}, {305000, "33792d85e883f054158ad253285f2ced61798e393135a2d591ccb5ccc60ee724"}, {310000, "5143cea534ef2ba5a5e18c0877c9c8877d469d3ae040406a65cbf23ea06b4585"}, {315000, "7bb70271b257d3cb784b026dd9dea1aacb1e6feb8b31c0151819861226b75e88"}, {320000, "f9f4f51eea457570bf6c1beb599147d03ba4c13c573222fde9454018a0e531f7"}, {325000, "18cc18d052c4b16f3aa415aa860f012d37028cf61c77f0fd4126aed67f0803b3"}, {330000, "d63c41bfb0c5468461c924b3983c05816295f358df2599363db96fd1eb257036"}, {335000, "528ae5c23aee04bee553a963832b59f72bf08903209caac1f84ea4b0056d5464"}, {340000, "8181936abc5edc3b25c3d5f39fce7ef4a63f332d9d310afa507170f793a3dbd8"}, {345000, "89bacab01b987b42af745c67571bf87d3edfd686f3c16f0f1bed0fe99fcfa0d4"}, {350000, "45aaec7312e7b85ae1c05408fbf4fe88ee44a72b85d9c9277f17596a0da84bfd"}, {355000, "139e4926dc3a688f2ec6f043062b8398b605e608befff67aac37eeba7c53e2ef"}, {360000, "e3820a2023ea1c14dc866f1e6c06299da7b823bbd0ddcf00165d30e54ad21e79"}, {365000, "b7f30224ec3ff327bfaecf566e183d91027800f6ea35b1f83fb5e0d8e496b91d"}, {370000, "7a9e8b08ce3eaa8fc41f5367953f23d825db2efa8a1e90870c891a9fe9d85963"}, {375000, "e7b60d984e97f4b2868757acac22592c2f392f691baf22b1c481180b4b8c6c8b"}, {380000, "a22ac5093c02908015f1f5daa75e29bbb8e2a481fc87f3d5b299c7429ebb04ce"}, {385000, "220f6db2928f4e99eb2c23a81d8c713a6fb1e155d6ca213747d7aebbb3d8c088"}, {390000, "cce9f7ce3b2108809cf53a9d950a0b0deaa4554d65b5ec1444cfc8485833934c"}, {395000, "ecab3b211d9f9a56ba2f3f579bc829d54310890bd9559da03541619af75e51a7"}, {400000, "956c87d587448b688ff412804255e5a832b069c25c8d6050c3f70b8db0a68225"}, {405000, "f0e2816a69913b509094b62a13a6091cbd62f55baabf21212cd4f6bba7c59f55"}, {410000, "bae4358d5bab0742e16b2c07a0685b4169da5ef64aa89456168b2d0013e99106"}, {415000, "421570a88b01c7494e48d1be18b82e3d107d69bbb7cbd73a1ba86ad26f7dd8fb"}, {420000, "abdd8c64b6208ba834a1ffbf02dd00a1c68e546fcdc336c9332a48ff78133268"}, {425000, "f7bc310d2f97eba33445c78fc37b7879d6cf836587649d53ffea169f7fd0318a"}, {430000, "6e49d1584c8f858703b9761731948de097244d038b19fb7274e96ccb50dec220"}, {435000, "8070296e0236c616cc2503feb0cf1cb90ae7c673c4053c08f5486d9d0fd73296"}, {440000, "88f5405105d7258ffb061983f3d8cc17adfead8f6348aeb9d23cf16d54935b76"}, {445000, "8abba34d38fe6c2974436c203ea75e43a38e415bb79ecd133af6b860103dbc20"}, {450000, "6660add67afd71598faf36a05e9d1f83025a3486711faf5a1fdb1ef9b611149f"}, {455000, "afd91e635df92abd8e55df11c3d10aee110f5b9d70092257eca8ed40f1ff5dec"}, {460000, "274fe3d3a09977c041b5ec5a870c057af6ce798e68e302962504da10512803fb"}, {465000, "7476451d3a53070372306e76f0a0e1cd35f86440f3a721ea07654efbe542114f"}, {470000, "87ee44fcc68d75c6b82c14e6989097421861fcb8270e18e44f331978e8ce1051"}, {475000, "d7b0a23790b03ef71feefda1c81a98520af66498b4547a3fd3c183a4b744de0f"}, {480000, "0d5eeefb2bd097b1ae2da69f22a6ca327e541745f6ce9cbe5cfcd5e256253be6"}, {485000, "bee7b183804a22f10a758be2bce45ff356546c52d0e985355e461a99dcfeb2b2"}, {490000, "212288303c9bad46584db9dec680f7f9756f448da398b1e1b8c8615637df18fd"}, {495000, "b93aad27a0f70162e26bcd82b299d7b0d5baf6213313615e11be7a0ebf2a1091"}, {500000, "62f0058453292af5e1aa070f8526f7642ab6974c6af2c17088c21b31679c813d"}, {505000, "42fdc7f9e2587f22ca3b65d6ae3eebfe1896fe1296bc4b4195171443b9bca759"}, {510000, "6818d833049dd02ee8b2dccfce6fbc38254f9803738fdc2a9103953977286151"}, {515000, "98bf8d74e1f664e3886e15f3c72a90b816446ae319b5a47e129643c6b8c8d4b9"}, {520000, "4fc64bd70e644ece44751cad91a7b156697c8a4ba1004f28577deae1a06765f3"}, {525000, "b3c708d066435b3781f6945059f620dbf023028ea7a57fdc0a89e2c0c5ccb742"}, {530000, "b2c8e2206b2d8a29d71d8b08da59806662deac36274530b069bda1a609e3cd2a"}, {535000, "bd015d5d0c06f99716d2adf6d64b8269a95dd39761552ba67ce3f021cac515d3"}, {540000, "0a5574e0880cd59dd9a3aaa04ca53c6b7b5bda5754f8c9ed3ab6673eaf5bcb64"}, {545000, "c971e2534ffae5ee9d0e7f9cd2f75fb4d21a0600beedc4fdcbaff9c43aa921ef"}, {550000, "e839382ffc21a54ee43de63c77a38352f85e948c0806e918f94d6cb94af2d74b"}, {555000, "8f26c4a573fb479e009250e906a696ee229e698a2ba4d5d36186da04f9155f68"}, {560000, "609ee1ab220bf00dc88e616f21db9684c1b570db9184799c952a590811d364a4"}, {565000, "66fc9f981bd2f7f1775b5bbc9cdf983623f5dfdcc870e6a38d95c196ba0c677f"}, {570000, "bd281d68772ec430be555dee57e485dfeee0ed106e22aec5e2f1409a1638ed93"}, {575000, "c7efe5a723c854bb81ef77a5a3370e68cd4eadac40f9a4e8e390fe3761db83ef"}, {580000, "445fe4a61f1ca17f6558e61bda6d59cca3d30e0d4837807f4b69d0499e8443fe"}, {585000, "d59efaf1422c5c9dde2ee00942eaedbce567be0b342ccd0227853c52555e404f"}, {590000, "b867144a8df2b85a6cd6426fc053c25d1aa56ea1babb076947d77e03eb6d57b0"}, {595000, "d93adf2255f86caf30460b45dfeea538f36d9fc783e143616bbe6f8dc3a32157"}, {600000, "234266e7a2b03534df7d7a0b9403eeaabad316b86222575076c599f77c812200"}, {605000, "cba35971385cd7e243b645d3e06ab3e5f0430285d257c8390791cedd8840810f"}, {610000, "0fc4afd5f049f7c39ba95b54eaec703da8ea90f3358019079e4a57c411fdf360"}, {615000, "b0d784591bca95488996b017e53f55d71ec757e2c735f90b973fb5d90dcd3eb6"}, {620000, "01883f5bac52d683ea3d4dd56a53a362bd8eada339448428f0d42b125eac9e2d"}, {625000, "32462524739adac6af7afac9e791b7a9e4d2bebab76347c488aaa3b504e90df0"}, {630000, "6650cc9d4546e82dc5ac1faecab83fb2523624f4fce0bbb3050bebec29ab110b"}, {635000, "172e403932f16532a6c0ee8465edd4687914312ca73ccde8cd05fd1334effc4b"}, {640000, "2cbf230b2218d8a0cbc353a861b20d0d7c1c7ed7cfd0a0d912af4a8f8d20c31d"}, {645000, "6bcad95101dc68977b44b7fdf064dd395d922d39ff0e487fe8f57ad9651db7cc"}, {650000, "ca5939a8fd0823c663e199af8657ed9d67f324abf8a2aaf4b58ee565bd6dc1ab"}, {655000, "679e87b0975fae8f1700e4708835f91786de98f543b94304d5b306f9c694b766"}, {660000, "ab1e32754eaba47429f1d5bfff1e7b44e6ca68624eafb9b36c4ecdd65e5d4b2f"}, {665000, "744b56bf373abeb7ebce54427d477eb56859be57bed99d70e72014e48433235d"}, {670000, "3ba7cc34927c9a1edf24dbb05fd7022f782f50067774a6477a8f3baff09da9bc"}, {675000, "1aa8c6029432c29d6a26f1c3e6bd895a9c60e14ac951d7860e8d05e815994d99"}, {680000, "2b4984c2aa62923a80927b158c3b71197e8e95f7cfb2e88115ee47cd1b24cb4b"}, {685000, "8baf7a3c2cb656495b8eed6c12722aff9c61a420b643d0b824683d8c401e5b00"}, {690000, "6d562412e80ba57c9499ad800172d7724cb92537cc378d6d00b2c464b4db966c"}, {695000, "602c4944dd964f42bf934fcfaa2ead2461c383e3f72c8c9a572736bc32bb80b6"}, {700000, "d339790bcff3313b935a3442c9da913f526b6bce8fbaebda54f8858b9c1c5aa9"}, {705000, "4da1513d0a01a026db41316567af7b1616ebca39fea33c6140f8e9cc8cbe2e54"}, {710000, "ff9c3e233f1a8c7c21cd0b6961b1b68a8545c7b54355cd40e7fa1982f828fb76"}, {715000, "3459af0d43678f663b1c28bdbe89417878f447df529f7c2d699acc9cbed013a9"}, {720000, "6db93223babb9499c94171dedf39f55a29bcbb9cd469f49da8aca78c60b48946"}, {725000, "e4dce12039c887f40bac58f65d401f343d15e20e61c40b955ba577bed313f291"}, {730000, "73d856bfdac0e052f1b9bdf7f157ca6e8cc85fe1c040eca6f529a451034991bb"}, {735000, "d723da51b1663eb9970d61cbd522fcdc2667da971f520e80d22bd9bf6ba86a12"}, {740000, "e8b3b83b494457ed041ff1ad01928dcdee3689ac8a33a9429169fded0ee0cdfc"}, {745000, "1fd0b85a31b64d1631c09672c03c644296439c775f3dc9657bd812c06b98d895"}, {750000, "8b7a9bcb49b8d127723b26b3ab91b9e3ee52ed9bc4c9cc3ef6d9ce1b4f6c9520"}, {755000, "aaabbd901cc90c6f7b86d4573bf96529ff5bd6810ab26e0d7798bab407d9e0e3"}, {760000, "b10a349dd60a1fe0160eba2ea9eaea8b8726919e1533509d025358f42163d34c"}, {765000, "6f0c679f296e24d564e8a4e406fa80c471c5fb31698f23f03728f009ef1f04ef"}, {770000, "d6cea5520251ba57d9aec70711a0156ca9b6b933c68e0fbfc102237b63e0178b"}, {775000, "1b87b145d1b4dc99fc681e93bcd337da1e06c271bae4dc66e8ff9a994768ea09"}, {780000, "2822709e1d827482e0c064dd33c7dcb311ca5e8300a3ec5e5509678c3f9c6363"}, {785000, "1b328f0d30edf12964eafffe7609680c54abf1720ba296f3d6e8131c145e30a2"}, {790000, "e60e00899d841b870c64ab253b6678127f4707ff6568ed1574c3679c7fd2df97"}, {795000, "aebcd0114155d1b99b3bdd0dfda952def566b4f0446a1cac50d7f8e2b988c236"}, {800000, "32df598e8f48bcd100371d70136c3f7287a83d0fffd00277e8b624fb17dfe738"}, {805000, "951d5e97b7a3bfecebe284368f6b5ed09ec94f0efc44f096bb331b25c130e845"}, {810000, "7eb228ffa07d24f8e274d1367342e13169ed83c2659cba95036ecabf0e292f66"}, {815000, "4a41251470cd5da0f6baabfc1aa136c48c7bb0aea8b4c171e4db3687c7a053b7"}, {820000, "52489870b9e7678b88425ae0f9e05cb7e38607374b87f083f89fc2d66d98458a"}, {825000, "4a930cf52eb5a3aed39d471bb6a9ba419ae99efa1a0c20687ad7b1e7ae55320b"}, {830000, "3cdb9d60b02977b24a1a6daea782d7f12e2a3a5bafd5cad2698395a4d59285f4"}, {835000, "7e2298d44d69a5cf46fb5ae59032d9a32044ea54c74b2ec6027e021435c3c325"}, {840000, "475764354a1fb33ea3bf2639ae9683caa77fdb93b4a4ef205c28a12fe3b37d21"}, {845000, "09119e4e03e7ef5f4919d966ffb051a5e8d4a73b277bbc1402a6105bdb11d54b"}, {850000, "d52586efb350fd5c263374fa92e24eec7be928e02a6ddaf95c5c255ec0ff33d5"}, {855000, "43da13e86cf37f78c286b76def50251ffd64483c5194541f98a103aa2ea6f7eb"}, {860000, "3f609c720e1fe206ab466647fb4461916ef3fc2862d086f3fde57a9da195bc64"}, {865000, "db01344e07347bda9d0c74fd9009fb3643c9cd4af0b893ece171e129e6657f08"});

	public const string CRYPTONOTE_NAME = "TurtleCoin";

	public static readonly byte TRANSACTION_VERSION_1 = 1;
	public static readonly byte TRANSACTION_VERSION_2 = 2;
	public static readonly byte CURRENT_TRANSACTION_VERSION = TRANSACTION_VERSION_1;

	public static readonly byte BLOCK_MAJOR_VERSION_1 = 1;
	public static readonly byte BLOCK_MAJOR_VERSION_2 = 2;
	public static readonly byte BLOCK_MAJOR_VERSION_3 = 3;
	public static readonly byte BLOCK_MAJOR_VERSION_4 = 4;

	public static readonly byte BLOCK_MINOR_VERSION_0 = 0;
	public static readonly byte BLOCK_MINOR_VERSION_1 = 1;

	public static readonly uint BLOCKS_IDS_SYNCHRONIZING_DEFAULT_COUNT = 10000; //by default, blocks ids count in synchronizing
	public static readonly uint BLOCKS_SYNCHRONIZING_DEFAULT_COUNT = 100; //by default, blocks count in blocks downloading
	public static readonly uint COMMAND_RPC_GET_BLOCKS_FAST_MAX_COUNT = 1000;

	public static readonly int P2P_DEFAULT_PORT = 11897;
	public static readonly int RPC_DEFAULT_PORT = 11898;
	public static readonly int SERVICE_DEFAULT_PORT = 8070;

	public static readonly uint P2P_LOCAL_WHITE_PEERLIST_LIMIT = 1000;
	public static readonly uint P2P_LOCAL_GRAY_PEERLIST_LIMIT = 5000;

	// P2P Network Configuration Section - This defines our current P2P network version
	// and the minimum version for communication between nodes
	public static readonly byte P2P_CURRENT_VERSION = 4;
	public static readonly byte P2P_MINIMUM_VERSION = 2;
	// This defines the number of versions ahead we must see peers before we start displaying
	// warning messages that we need to upgrade our software.
	public static readonly byte P2P_UPGRADE_WINDOW = 2;

	public static readonly uint P2P_CONNECTION_MAX_WRITE_BUFFER_SIZE = 32 * 1024 * 1024; // 32 MB
	public static readonly uint P2P_DEFAULT_CONNECTIONS_COUNT = 8;
	public static readonly uint P2P_DEFAULT_WHITELIST_CONNECTIONS_PERCENT = 70;
	public static readonly uint P2P_DEFAULT_HANDSHAKE_INTERVAL = 60; // seconds
	public static readonly uint P2P_DEFAULT_PACKET_MAX_SIZE = 50000000; // 50000000 bytes maximum packet size
	public static readonly uint P2P_DEFAULT_PEERS_IN_HANDSHAKE = 250;
	public static readonly uint P2P_DEFAULT_CONNECTION_TIMEOUT = 5000; // 5 seconds
	public static readonly uint P2P_DEFAULT_PING_CONNECTION_TIMEOUT = 2000; // 2 seconds
	public static readonly ulong P2P_DEFAULT_INVOKE_TIMEOUT = 60 * 2 * 1000; // 2 minutes
	public static readonly uint P2P_DEFAULT_HANDSHAKE_INVOKE_TIMEOUT = 5000; // 5 seconds
	public const string P2P_STAT_TRUSTED_PUB_KEY = "";

	public static readonly ulong DATABASE_WRITE_BUFFER_MB_DEFAULT_SIZE = 256;
	public static readonly ulong DATABASE_READ_BUFFER_MB_DEFAULT_SIZE = 10;
	public static readonly uint DATABASE_DEFAULT_MAX_OPEN_FILES = 100;
	public static readonly ushort DATABASE_DEFAULT_BACKGROUND_THREADS_COUNT = 2;

	public const string LATEST_VERSION_URL = "http://latest.turtlecoin.lol";
	public static readonly string LICENSE_URL = "https://github.com/turtlecoin/turtlecoin/blob/master/LICENSE";
	internal boost::uuids.uuid CRYPTONOTE_NETWORK = new boost::uuids.uuid({0xb5, 0x0c, 0x4a, 0x6c, 0xcf, 0x52, 0x57, 0x41, 0x65, 0xf9, 0x91, 0xa4, 0xb6, 0xc1, 0x43, 0xe9});

	public static readonly string[] SEED_NODES = {"206.189.142.142:11897", "145.239.88.119:11999", "142.44.242.106:11897", "165.227.252.132:11897"};
	//{
	//  struct
	//  {
	//	uint blockIndex;
	//	ushort transactionIndex;
	//	ushort outputIndex;
	//  };
	//
	//  ulong packedValue;
	//};

	public static readonly uint INVALID_BLOCK_INDEX = uint.MaxValue;

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void serialize(BlockFullInfo UnnamedParameter, ISerializer UnnamedParameter2);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void serialize(TransactionPrefixInfo UnnamedParameter, ISerializer UnnamedParameter2);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void serialize(BlockShortInfo UnnamedParameter, ISerializer UnnamedParameter2);
//C++ TO C# CONVERTER WARNING: 'const' methods are not available in C#:
//ORIGINAL LINE: bool IntrusiveLinkedList<Value>::iterator::operator !=(const typename IntrusiveLinkedList<Value>::iterator& other) const
	public static bool IntrusiveLinkedList<Value>.iterator.operator != <Value>(IntrusiveLinkedList<Value>.iterator other)
	{
	  return currentElement != other.currentElement;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class Value>
//C++ TO C# CONVERTER WARNING: 'const' methods are not available in C#:
//ORIGINAL LINE: bool IntrusiveLinkedList<Value>::iterator::operator ==(const typename IntrusiveLinkedList<Value>::iterator& other) const
	public static bool IntrusiveLinkedList<Value>.iterator.operator == <Value>(IntrusiveLinkedList<Value>.iterator other)
	{
	  return currentElement == other.currentElement;
	}

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//std::unique_ptr<IUpgradeDetector> makeUpgradeDetector(byte targetVersion, uint upgradeIndex);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//  std::unique_ptr<ITransaction> createTransaction();
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//  std::unique_ptr<ITransaction> createTransaction(ClassicVector<byte> transactionBlob);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//  std::unique_ptr<ITransaction> createTransaction(Transaction tx);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//  std::unique_ptr<ITransactionReader> createTransactionPrefix(TransactionPrefix prefix, Crypto::Hash transactionHash);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//  std::unique_ptr<ITransactionReader> createTransactionPrefix(Transaction fullTransaction);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//TransactionPoolMessage makeAddTransaction(Crypto::Hash hash);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//TransactionPoolMessage makeDelTransaction(Crypto::Hash hash);

	public static string get_protocol_state_string(CryptoNoteConnectionContext.state s)
	{
	  switch (s)
	  {
	  case CryptoNoteConnectionContext.state_befor_handshake:
		return "state_befor_handshake";
	  case CryptoNoteConnectionContext.state_synchronizing:
		return "state_synchronizing";
	  case CryptoNoteConnectionContext.state_idle:
		return "state_idle";
	  case CryptoNoteConnectionContext.state_normal:
		return "state_normal";
	  case CryptoNoteConnectionContext.state_sync_required:
		return "state_sync_required";
	  case CryptoNoteConnectionContext.state_pool_sync_required:
		return "state_pool_sync_required";
	  case CryptoNoteConnectionContext.state_shutdown:
		return "state_shutdown";
	  default:
		return "unknown";
	  }
	}
	  public static bool serialize(boost::uuids.uuid v, Common.StringView name, ISerializer s)
	  {
		return s.binary(v, sizeof(boost::uuids.uuid), new Common.StringView(name));
	  }

	  public static Crypto.Hash get_proof_of_trust_hash(proof_of_trust pot)
	  {
		string s;
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		s.append(reinterpret_cast<const char>(pot.peer_id), sizeof(ulong));
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
		s.append(reinterpret_cast<const char>(pot.time), sizeof(ulong));
		return Crypto.GlobalMembers.cn_fast_hash(s.data(), s.Length);
	  }
	public static BinaryArray storeToBinary<T>(T obj)
	{
	  BinaryArray result = new BinaryArray();
	  Common.VectorOutputStream stream = new Common.VectorOutputStream(result);
	  BinaryOutputStreamSerializer ba = new BinaryOutputStreamSerializer(stream);
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
	  serialize(const_cast<T&>(obj), ba.functorMethod);
	  return result;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static void loadFromBinary<T>(T obj, BinaryArray blob)
	{
	  Common.MemoryInputStream stream = new Common.MemoryInputStream(blob.data(), blob.size());
	  BinaryInputStreamSerializer ba = new BinaryInputStreamSerializer(stream);
	  serialize(obj, ba.functorMethod);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename T>
	public static bool storeToBinaryFile<T>(T obj, string filename)
	{
	  try
	  {
		std::ofstream dataFile = new std::ofstream();
		dataFile.open(filename, std::ios_base.binary | std::ios_base.@out | std::ios.trunc);
		if (dataFile.fail())
		{
		  return false;
		}

		Common.StdOutputStream stream = new Common.StdOutputStream(dataFile);
		BinaryOutputStreamSerializer @out = new BinaryOutputStreamSerializer(stream);
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		CryptoNote.GlobalMembers.serialize(const_cast<T&>(obj), @out.functorMethod);

		if (dataFile.fail())
		{
		  return false;
		}

		dataFile.flush();
	  }
	  catch (System.Exception)
	  {
		return false;
	  }

	  return true;
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template<class T>
	public static bool loadFromBinaryFile<T>(T obj, string filename)
	{
	  try
	  {
		std::ifstream dataFile = new std::ifstream();
		dataFile.open(filename, std::ios_base.binary | std::ios_base.in);
		if (dataFile.fail())
		{
		  return false;
		}

		Common.StdInputStream stream = new Common.StdInputStream(dataFile);
		BinaryInputStreamSerializer in = new BinaryInputStreamSerializer(stream);
		serialize(obj, in.functorMethod);
		return !dataFile.fail();
	  }
	  catch (System.Exception)
	  {
		return false;
	  }
	}

	public static readonly uint PORTABLE_STORAGE_SIGNATUREA = 0x01011101;
	public static readonly uint PORTABLE_STORAGE_SIGNATUREB = 0x01020101; // bender's nightmare
	public static readonly byte PORTABLE_STORAGE_FORMAT_VER = 1;

	public static readonly byte PORTABLE_RAW_SIZE_MARK_MASK = 0x03;
	public static readonly byte PORTABLE_RAW_SIZE_MARK_BYTE = 0;
	public static readonly byte PORTABLE_RAW_SIZE_MARK_WORD = 1;
	public static readonly byte PORTABLE_RAW_SIZE_MARK_DWORD = 2;
	public static readonly byte PORTABLE_RAW_SIZE_MARK_INT64 = 3;


	//data types 

	public static readonly byte BIN_KV_SERIALIZE_TYPE_INT64 = 1;
	public static readonly byte BIN_KV_SERIALIZE_TYPE_INT32 = 2;
	public static readonly byte BIN_KV_SERIALIZE_TYPE_INT16 = 3;
	public static readonly byte BIN_KV_SERIALIZE_TYPE_INT8 = 4;
	public static readonly byte BIN_KV_SERIALIZE_TYPE_UINT64 = 5;
	public static readonly byte BIN_KV_SERIALIZE_TYPE_UINT32 = 6;
	public static readonly byte BIN_KV_SERIALIZE_TYPE_UINT16 = 7;
	public static readonly byte BIN_KV_SERIALIZE_TYPE_UINT8 = 8;
	public static readonly byte BIN_KV_SERIALIZE_TYPE_DOUBLE = 9;
	public static readonly byte BIN_KV_SERIALIZE_TYPE_STRING = 10;
	public static readonly byte BIN_KV_SERIALIZE_TYPE_BOOL = 11;
	public static readonly byte BIN_KV_SERIALIZE_TYPE_OBJECT = 12;
	public static readonly byte BIN_KV_SERIALIZE_TYPE_ARRAY = 13;
	public static readonly byte BIN_KV_SERIALIZE_FLAG_ARRAY = 0x80;

	public static readonly uint UNCONFIRMED_TRANSACTION_GLOBAL_OUTPUT_INDEX = uint.MaxValue;

	public static bool operator == (AccountPublicAddress _v1, AccountPublicAddress _v2)
	{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
	  return memcmp(_v1, _v2, sizeof(AccountPublicAddress)) == 0;
	}

	public static readonly ulong ACCOUNT_CREATE_TIME_ACCURACY = 60 * 60 * 24;

	public static typedef boost::multi_index_container < WalletRecord, boost::multi_index.indexed_by < boost::multi_index.random_access < boost::multi_index.tag <RandomAccessIndex>>, boost::multi_index.hashed_unique < boost::multi_index.tag <KeysIndex>, BOOST_MULTI_INDEX_MEMBER(WalletRecord, Crypto.PublicKey, spendPublicKey)>, boost::multi_index.hashed_unique < boost::multi_index.tag <TransfersContainerIndex>, BOOST_MULTI_INDEX_MEMBER(WalletRecord, CryptoNote.ITransfersContainer*, container) >> > WalletsContainer = new typedef();

	public static typedef boost::multi_index_container < UnlockTransactionJob, boost::multi_index.indexed_by < boost::multi_index.ordered_non_unique < boost::multi_index.tag <BlockHeightIndex>, BOOST_MULTI_INDEX_MEMBER(UnlockTransactionJob, uint, blockHeight) >, boost::multi_index.hashed_non_unique < boost::multi_index.tag <TransactionHashIndex>, BOOST_MULTI_INDEX_MEMBER(UnlockTransactionJob, Crypto.Hash, transactionHash) >> > UnlockTransactionJobs = new typedef();
	}
}

namespace CryptoNote.Utils
{
	public static class GlobalMembers
	{
	public static bool restoreCachedTransactions(List<BinaryArray> binaryTransactions, List<CachedTransaction> transactions)
	{
	  transactions.Capacity = binaryTransactions.Count;

	  foreach (var binaryTransaction in binaryTransactions)
	  {
		Transaction transaction = new Transaction();
		if (!CryptoNote.GlobalMembers.fromBinaryArray(ref transaction, binaryTransaction))
		{
		  return false;
		}

		transactions.emplace_back(std::move(transaction));
	  }

	  return true;
	}
	}
}

namespace CryptoNote.DB
{
	public static class GlobalMembers
	{
	  public static readonly string BLOCK_INDEX_TO_KEY_IMAGE_PREFIX = "0";
	  public static readonly string BLOCK_INDEX_TO_TX_HASHES_PREFIX = "1";
	  public static readonly string BLOCK_INDEX_TO_TRANSACTION_INFO_PREFIX = "2";
	  public static readonly string BLOCK_INDEX_TO_RAW_BLOCK_PREFIX = "4";

	  public static readonly string BLOCK_HASH_TO_BLOCK_INDEX_PREFIX = "5";
	  public static readonly string BLOCK_INDEX_TO_BLOCK_INFO_PREFIX = "6";

	  public static readonly string KEY_IMAGE_TO_BLOCK_INDEX_PREFIX = "7";
	  public static readonly string BLOCK_INDEX_TO_BLOCK_HASH_PREFIX = "8";

	  public static readonly string TRANSACTION_HASH_TO_TRANSACTION_INFO_PREFIX = "a";

	  public static readonly string KEY_OUTPUT_AMOUNT_PREFIX = "b";

	  public static readonly string CLOSEST_TIMESTAMP_BLOCK_INDEX_PREFIX = "e";

	  public static readonly string PAYMENT_ID_TO_TX_HASH_PREFIX = "f";

	  public static readonly string TIMESTAMP_TO_BLOCKHASHES_PREFIX = "g";

	  public static readonly string KEY_OUTPUT_AMOUNTS_COUNT_PREFIX = "h";

	  public static readonly string LAST_BLOCK_INDEX_KEY = "last_block_index";

	  public static readonly string KEY_OUTPUT_AMOUNTS_COUNT_KEY = "key_amounts_count";

	  public static readonly string TRANSACTIONS_COUNT_KEY = "txs_count";

	  public static readonly string KEY_OUTPUT_KEY_PREFIX = "j";

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <class Value>
	  public static string serialize<Value>(Value value, string name)
	  {
		CryptoNote.KVBinaryOutputStreamSerializer serializer = new CryptoNote.KVBinaryOutputStreamSerializer();
		std::stringstream ss = new std::stringstream();
		Common.StdOutputStream stream = new Common.StdOutputStream(ss);

//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		serializer.functorMethod(const_cast<Value&>(value), name);
		serializer.dump(stream);

		return ss.str();
	  }

	  public static string serialize(RawBlock value, string name)
	  {
		std::stringstream ss = new std::stringstream();
		Common.StdOutputStream stream = new Common.StdOutputStream(ss);
		CryptoNote.BinaryOutputStreamSerializer serializer = new CryptoNote.BinaryOutputStreamSerializer(stream);

//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		serializer.functorMethod(const_cast<RawBlock&>(value).block, GlobalMembers.RAW_BLOCK_NAME);
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'const_cast' in C#:
		serializer.functorMethod(const_cast<RawBlock&>(value).transactions, GlobalMembers.RAW_TXS_NAME);

		return ss.str();
	  }

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <class Key, class Value>
	  public static Tuple<string, string> serialize<Key, Value>(string keyPrefix, Key key, Value value)
	  {
		return new Tuple<string, string>(DB.GlobalMembers.serialize(Tuple.Create(keyPrefix, key), keyPrefix), DB.GlobalMembers.serialize(value, keyPrefix));
	  }

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <class Key>
	  public static string serializeKey<Key>(string keyPrefix, Key key)
	  {
		return DB.GlobalMembers.serialize(Tuple.Create(keyPrefix, key), keyPrefix);
	  }

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <class Value>
	  public static void deserialize<Value>(string serialized, Value value, string name)
	  {
		std::stringstream ss = new std::stringstream(serialized);
		Common.StdInputStream stream = new Common.StdInputStream(ss);
		CryptoNote.KVBinaryInputStreamSerializer serializer = new CryptoNote.KVBinaryInputStreamSerializer(stream);
		serializer(value, name);
	  }

	  public static void deserialize(string serialized, RawBlock value, string name)
	  {
		std::stringstream ss = new std::stringstream(serialized);
		Common.StdInputStream stream = new Common.StdInputStream(ss);
		CryptoNote.BinaryInputStreamSerializer serializer = new CryptoNote.BinaryInputStreamSerializer(stream);
		serializer.functorMethod(value.block, GlobalMembers.RAW_BLOCK_NAME);
		serializer.functorMethod(value.transactions, GlobalMembers.RAW_TXS_NAME);
	  }

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <class Key, class Value>
	  public static void serializeKeys<Key, Value>(List<string> rawKeys, string keyPrefix, Dictionary<Key, Value> map)
	  {
		foreach (Tuple<Key, Value> kv in map)
		{
		  rawKeys.emplace_back(DB.GlobalMembers.serializeKey(keyPrefix, kv.Item1));
		}
	  }

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <class Key, class Value, class Iterator>
	  public static void deserializeValues<Key, Value, Iterator>(Dictionary<Key, Value> map, Iterator serializedValuesIter, string name)
	  {
		for (var iter = map.GetEnumerator(); iter != map.end(); ++serializedValuesIter)
		{
		  if (boost::get<1>(*serializedValuesIter))
		  {
			DB.GlobalMembers.deserialize(boost::get<0>(*serializedValuesIter), iter.second, name);
			++iter;
		  }
		  else
		  {
			iter = map.Remove(iter);
		  }
		}
	  }

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <class Value, class Iterator>
	  public static void deserializeValue<Value, Iterator>(ref Tuple<Value, bool> pair, Iterator serializedValuesIter, string name)
	  {
		if (pair.Item2)
		{
		  if (boost::get<1>(*serializedValuesIter))
		  {
			DB.GlobalMembers.deserialize(boost::get<0>(*serializedValuesIter), pair.Item1, name);
		  }
		  else
		  {
			pair = new Tuple<Value, bool>(Value {}, false);
		  }
		  ++serializedValuesIter;
		}
	  }
	}
}

namespace CryptoNote.JsonRpc
{
	public static class GlobalMembers
	{
	public static readonly int errParseError = -32700;
	public static readonly int errInvalidRequest = -32600;
	public static readonly int errMethodNotFound = -32601;
	public static readonly int errInvalidParams = -32602;
	public static readonly int errInternalError = -32603;
	public static readonly int errInvalidPassword = -32604;


	//void invokeJsonRpcCommand(HttpClient httpClient, JsonRpcRequest req, JsonRpcResponse res);Tangible Method Implementation Not FoundCryptoNote.JsonRpc-invokeJsonRpcCommand

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Request, typename Response>
	public static void invokeJsonRpcCommand<Request, Response>(HttpClient httpClient, string method, Request req, Response res)
	{
	  JsonRpcRequest jsReq = new JsonRpcRequest();
	  JsonRpcResponse jsRes = new JsonRpcResponse();

	  jsReq.setMethod(method);
	  jsReq.setParams(req);

	  invokeJsonRpcCommand(httpClient, jsReq, jsRes);

	  jsRes.getResult(res);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Request, typename Response, typename Handler>
	public static bool invokeMethod<Request, Response, Handler>(JsonRpcRequest jsReq, JsonRpcResponse jsRes, Handler handler)
	{
	  Request req = new default(Request);
	  Response res = new default(Response);

	  if (!std::is_same<Request, CryptoNote.EMPTY_STRUCT>.value && !jsReq.loadParams(req))
	  {
		throw new JsonRpcError(JsonRpc.GlobalMembers.errInvalidParams);
	  }

	  bool result = handler(req, res);

	  if (result)
	  {
		if (!jsRes.setResult(res))
		{
		  throw new JsonRpcError(JsonRpc.GlobalMembers.errInternalError);
		}
	  }
	  return result;
	}

	public delegate bool JsonMemberMethod(object UnnamedParameter, JsonRpcRequest req, JsonRpcResponse res);

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Class, typename Params, typename Result>
private delegate bool handlerDelegate(Params UnnamedParameter, Result UnnamedParameter2);

	public static JsonMemberMethod makeMemberMethod<Class, Params, Result>(handlerDelegate handler)
	{
//C++ TO C# CONVERTER TODO TASK: Only lambda expressions having all locals passed by reference can be converted to C#:
//ORIGINAL LINE: return [handler](object* obj, const JsonRpcRequest& req, JsonRpcResponse& res)
  return (object obj, JsonRpcRequest req, JsonRpcResponse res) =>
  {
	return JsonRpc.invokeMethod<Params, Result>(req, res, std::bind(handler, (Class)obj, std::placeholders._1, std::placeholders._2));
  };
	}

	public static readonly int errParseError = -32700;
	public static readonly int errInvalidRequest = -32600;
	public static readonly int errMethodNotFound = -32601;
	public static readonly int errInvalidParams = -32602;
	public static readonly int errInternalError = -32603;
	public static readonly int errInvalidPassword = -32604;


	public static void invokeJsonRpcCommand(HttpClient httpClient, JsonRpcRequest jsReq, JsonRpcResponse jsRes)
	{
	  HttpRequest httpReq = new HttpRequest();
	  HttpResponse httpRes = new HttpResponse();

	  httpReq.addHeader("Content-Type", "application/json");
	  httpReq.setUrl("/json_rpc");
	  httpReq.setBody(jsReq.getBody());

	  httpClient.request(httpReq, httpRes);

	  if (httpRes.getStatus() != HttpResponse.STATUS_200)
	  {
		throw new System.Exception("JSON-RPC call failed, HTTP status = " + Convert.ToString(httpRes.getStatus()));
	  }

	  jsRes.parse(httpRes.getBody());

	  JsonRpcError err = new JsonRpcError();
	  if (jsRes.getError(err))
	  {
		throw err;
	  }
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Request, typename Response>
	public static void invokeJsonRpcCommand<Request, Response>(HttpClient httpClient, string method, Request req, Response res)
	{
	  JsonRpcRequest jsReq = new JsonRpcRequest();
	  JsonRpcResponse jsRes = new JsonRpcResponse();

	  jsReq.setMethod(method);
	  jsReq.setParams(req);

	  JsonRpc.GlobalMembers.invokeJsonRpcCommand(httpClient, jsReq, jsRes);

	  jsRes.getResult(res);
	}

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Request, typename Response, typename Handler>
	public static bool invokeMethod<Request, Response, Handler>(JsonRpcRequest jsReq, JsonRpcResponse jsRes, Handler handler)
	{
	  Request req = new default(Request);
	  Response res = new default(Response);

	  if (!std::is_same<Request, CryptoNote.EMPTY_STRUCT>.value && !jsReq.loadParams(req))
	  {
		throw new JsonRpcError(JsonRpc.GlobalMembers.errInvalidParams);
	  }

	  bool result = handler(req, res);

	  if (result)
	  {
		if (!jsRes.setResult(res))
		{
		  throw new JsonRpcError(JsonRpc.GlobalMembers.errInternalError);
		}
	  }
	  return result;
	}

	public delegate bool JsonMemberMethod(object UnnamedParameter, JsonRpcRequest req, JsonRpcResponse res);

//C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
//ORIGINAL LINE: template <typename Class, typename Params, typename Result>
private delegate bool handlerDelegate(Params UnnamedParameter, Result UnnamedParameter2);

	public static JsonMemberMethod makeMemberMethod<Class, Params, Result>(handlerDelegate handler)
	{
//C++ TO C# CONVERTER TODO TASK: Only lambda expressions having all locals passed by reference can be converted to C#:
//ORIGINAL LINE: return [handler](object* obj, const JsonRpcRequest& req, JsonRpcResponse& res)
  return (object obj, JsonRpcRequest req, JsonRpcResponse res) =>
  {
	return JsonRpc.invokeMethod<Params, Result>(req, res, std::bind(handler, (Class)obj, std::placeholders._1, std::placeholders._2));
  };
	}
	}
}

namespace Logging
{
	public static class GlobalMembers
	{
	public static string formatPattern(string pattern, string category, Level level, boost::posix_time.ptime time)
	{
	  std::stringstream s = new std::stringstream();

	  for (const char * p = pattern; p && p != 0; ++p)
	  {
		if (p == '%')
		{
		  ++p;
		  switch (p)
		  {
		  case 0:
			break;
		  case 'C':
			s << category;
			break;
		  case 'D':
			s << time.date();
			break;
		  case 'T':
			s << time.time_of_day();
			break;
		  case 'L':
			s << std::setw(7) << std::left << ILogger.LEVEL_NAMES[(int)level];
			break;
		  default:
			s << p;
		break;
		  }
		}
		else
		{
		  s << p;
		}
	  }

	  return s.str();
	}

//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string BLUE;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string GREEN;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string RED;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string YELLOW;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string WHITE;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string CYAN;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string MAGENTA;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string BRIGHT_BLUE;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string BRIGHT_GREEN;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string BRIGHT_RED;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string BRIGHT_YELLOW;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string BRIGHT_WHITE;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string BRIGHT_CYAN;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string BRIGHT_MAGENTA;
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const string DEFAULT;

	public static readonly string BLUE = "\x1F""BLUE\x1F";
	public static readonly string GREEN = "\x1F""GREEN\x1F";
	public static readonly string RED = "\x1F""RED\x1F";
	public static readonly string YELLOW = "\x1F""YELLOW\x1F";
	public static readonly string WHITE = "\x1F""WHITE\x1F";
	public static readonly string CYAN = "\x1F""CYAN\x1F";
	public static readonly string MAGENTA = "\x1F""MAGENTA\x1F";
	public static readonly string BRIGHT_BLUE = "\x1F""BRIGHT_BLUE\x1F";
	public static readonly string BRIGHT_GREEN = "\x1F""BRIGHT_GREEN\x1F";
	public static readonly string BRIGHT_RED = "\x1F""BRIGHT_RED\x1F";
	public static readonly string BRIGHT_YELLOW = "\x1F""BRIGHT_YELLOW\x1F";
	public static readonly string BRIGHT_WHITE = "\x1F""BRIGHT_WHITE\x1F";
	public static readonly string BRIGHT_CYAN = "\x1F""BRIGHT_CYAN\x1F";
	public static readonly string BRIGHT_MAGENTA = "\x1F""BRIGHT_MAGENTA\x1F";
	public static readonly string DEFAULT = "\x1F""DEFAULT\x1F";

	public static readonly char ILogger.COLOR_DELIMETER = '\x1F';

	public static readonly List<string> ILogger.LEVEL_NAMES =
	{
		{"FATAL", "ERROR", "WARNING", "INFO", "DEBUG", "TRACE"}
	};
	}
}

namespace Miner
{
	public static class GlobalMembers
	{
	public static MinerEvent BlockMinedEvent()
	{
	  MinerEvent event = new MinerEvent();
	  event.type = MinerEventType.BLOCK_MINED;
	  return event;
	}

	public static MinerEvent BlockchainUpdatedEvent()
	{
	  MinerEvent event = new MinerEvent();
	  event.type = MinerEventType.BLOCKCHAIN_UPDATED;
	  return event;
	}

	public static void adjustMergeMiningTag(BlockTemplate blockTemplate)
	{
	  CachedBlock cachedBlock = new CachedBlock(blockTemplate);
	  if (blockTemplate.majorVersion >= BLOCK_MAJOR_VERSION_2)
	  {
		CryptoNote.TransactionExtraMergeMiningTag mmTag = new CryptoNote.TransactionExtraMergeMiningTag();
		mmTag.depth = 0;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: mmTag.merkleRoot = cachedBlock.getAuxiliaryBlockHeaderHash();
		mmTag.merkleRoot.CopyFrom(cachedBlock.getAuxiliaryBlockHeaderHash());

		blockTemplate.parentBlock.baseTransaction.extra.Clear();
		if (!CryptoNote.appendMergeMiningTagToExtra(blockTemplate.parentBlock.baseTransaction.extra, mmTag))
		{
		  throw new System.Exception("Couldn't append merge mining tag");
		}
	  }
	}


	private void MinerManager.pushEvent(MinerEvent && event)
	{
	  m_events.push(std::move(event));
	  m_eventOccurred.set();
	}
	}
}

namespace Mnemonics
{
	public static class GlobalMembers
	{
		public static Tuple<string, Crypto.SecretKey> MnemonicToPrivateKey(string words)
		{
			List<string> wordsList = new List<string>();

			std::istringstream stream = new std::istringstream(words);

			/* Convert whitespace separated string into vector of words */
			for (string s; stream >> s;)
			{
				wordsList.Add(s);
			}

			return MnemonicToPrivateKey(new List<string>(wordsList));
		}

		/* Note - if the returned string is not empty, it is an error message, and
		   the returned secret key is not initialized. */
		public static Tuple<string, Crypto.SecretKey> MnemonicToPrivateKey(List<string> words)
		{
			Crypto.SecretKey key = new Crypto.SecretKey();

			size_t len = words.Count;

			/* Mnemonics must be 25 words long */
			if (len != 25)
			{
				std::stringstream str = new std::stringstream();

				/* Write out "word" or "words" to make the grammar of the next sentence
				   correct, based on if we have 1 or more words */
				string wordPlural = len == 1 ? "word" : "words";

				str << "Mnemonic seed is wrong length - It should be 25 words " << "long, but it is " << len << " " << wordPlural << " long!";

				return new Tuple<string, Crypto.SecretKey>(str.str(), key);
			}

			/* All words must be present in the word list */
			foreach (var word in words)
			{
				std::transform(word.GetEnumerator(), word.end(), word.GetEnumerator(), global::tolower);
				if (std::find(WordList.English.begin(), WordList.English.end(), word) == WordList.English.end())
				{
					std::stringstream str = new std::stringstream();

					str << "Mnemonic seed has invalid word - " << word << " is not in the English word list!";

					return new Tuple<string, Crypto.SecretKey>(str.str(), key);
				}
			}

			/* The checksum must be correct */
			if (!HasValidChecksum(new List<string>(words)))
			{
				return new Tuple<string, Crypto.SecretKey>("Mnemonic seed has incorrect checksum!", key);
			}

			var wordIndexes = GetWordIndexes(new List<string>(words));

			List<ushort> data = new List<ushort>();

			for (size_t i = 0; i < words.Count - 1; i += 3)
			{
				/* Take the indexes of these three words in the word list */
				uint w1 = wordIndexes[i];
				uint w2 = wordIndexes[i + 1];
				uint w3 = wordIndexes[i + 2];

				/* Word list length */
				size_t wlLen = WordList.English.size();

				/* no idea what this does lol */
				uint val = (uint)(w1 + wlLen * (((wlLen - w1) + w2) % wlLen) + wlLen * wlLen * (((wlLen - w2) + w3) % wlLen));

				/* Don't know what this is testing either */
				if ((val % wlLen == w1) == null)
				{
					return new Tuple<string, Crypto.SecretKey>("Mnemonic seed is invalid!", key);
				}

				/* Interpret val as 4 ushort's */
//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
				var ptr = reinterpret_cast<const ushort>(val);

				/* Append to private key */
				for (int j = 0; j < 4; j++)
				{
					data.Add(ptr[j]);
				}
			}

			/* Copy the data to the secret key */
			std::copy(data.GetEnumerator(), data.end(), key.data);

			return new Tuple<string, Crypto.SecretKey>(string(), key);
		}

		public static string PrivateKeyToMnemonic(Crypto.SecretKey privateKey)
		{
			List<string> words = new List<string>();

			for (int i = 0; i < 32 - 1; i += 4)
			{
				/* Read the array as a uint array */
				var ptr = (uint) privateKey.data[i];

				/* Take the first element of the array (since we have already 
				   done the offset */
				uint val = ptr[0];

				uint wlLen = WordList.English.size();

				uint w1 = val % wlLen;
				uint w2 = ((val / wlLen) + w1) % wlLen;
				uint w3 = (((val / wlLen) / wlLen) + w2) % wlLen;

				words.Add(WordList.English[w1]);
				words.Add(WordList.English[w2]);
				words.Add(WordList.English[w3]);
			}

			words.Add(GetChecksumWord(new List<string>(words)));

			string result;

			foreach (string it in words)
			{
				if (it != words.GetEnumerator())
				{
					result += " ";
				}

				result += it;
			}

			return result;
		}

		/* Assumes the input is 25 words long */
		public static bool HasValidChecksum(List<string> words)
		{
			/* Make a copy since erase() is mutating */
			var wordsNoChecksum = words;

			/* Remove the last checksum word */
//C++ TO C# CONVERTER TODO TASK: There is no direct equivalent to the STL vector 'erase' method in C#:
			wordsNoChecksum.erase(wordsNoChecksum.end() - 1);

			/* Assert the last word (the checksum word) is equal to the derived
			   checksum */
			return words[words.Count - 1] == GetChecksumWord(new List<string>(wordsNoChecksum));
		}

		public static string GetChecksumWord(List<string> words)
		{
			string trimmed;

			/* Take the first 3 char from each of the 24 words */
			foreach (var word in words)
			{
				trimmed += word.Substring(0, 3);
			}

			/* Hash the data */
			ulong hash = CRC32.crc32(trimmed);

			/* Modulus the hash by the word length to get the index of the 
			   checksum word */
			return words[hash % words.Count];
		}

		public static List<int> GetWordIndexes(List<string> words)
		{
			List<int> result = new List<int>();

			foreach (var word in words)
			{
				/* Find the iterator of our word in the wordlist */
				var it = std::find(WordList.English.begin(), WordList.English.end(), word);

				/* Take it away from the beginning of the vector, giving us the
				   index of the item in the vector */
				result.Add((int)std::distance(WordList.English.begin(), it));
			}

			return result;
		}
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//	System.Tuple<string, Crypto::SecretKey> MnemonicToPrivateKey(string words);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//	System.Tuple<string, Crypto::SecretKey> MnemonicToPrivateKey(ClassicVector<string> words);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//	string PrivateKeyToMnemonic(Crypto::SecretKey privateKey);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//	bool HasValidChecksum(ClassicVector<string> words);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//	string GetChecksumWord(ClassicVector<string> words);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//	ClassicVector<int> GetWordIndexes(ClassicVector<string> words);
	}
}

namespace System
{
	public static class GlobalMembers
	{
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//static_assert(Dispatcher::SIZEOF_PTHREAD_MUTEX_T == sizeof(pthread_mutex_t), "invalid pthread mutex size");

	public static readonly size_t STACK_SIZE = 64 * 1024;
	public static string lastErrorMessage()
	{
	  return errorMessage(errno);
	}
	public static string errorMessage(int err)
	{
	  return "result=" + Convert.ToString(err) + ", " + std::strerror(err);
	}

	public static readonly size_t STACK_SIZE = 64 * 1024;

	public static string lastErrorMessage()
	{
	  return errorMessage(errno);
	}

	public static string errorMessage(int err)
	{
	  return "result=" + Convert.ToString(err) + ", " + std::strerror(err);
	}

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static Ipv4Resolver Ipv4Resolver.operator = (Ipv4Resolver && other)
	{
	  dispatcher = other.dispatcher;
	  if (dispatcher != null)
	  {
		other.dispatcher = null;
	  }

	  return this;
	}

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static TcpConnection TcpConnection.operator = (TcpConnection && other)
	{
	  if (dispatcher != null)
	  {
		Debug.Assert(readContext == null);
		Debug.Assert(writeContext == null);
		if (close(connection) == -1)
		{
		  throw new System.Exception("TcpConnection::operator=, close failed, " + lastErrorMessage());
		}
	  }

	  dispatcher = other.dispatcher;
	  if (other.dispatcher != null)
	  {
		Debug.Assert(other.readContext == null);
		Debug.Assert(other.writeContext == null);
		connection = other.connection;
		readContext = null;
		writeContext = null;
		other.dispatcher = null;
	  }

	  return this;
	}

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static TcpConnector TcpConnector.operator = (TcpConnector && other)
	{
	  dispatcher = other.dispatcher;
	  if (other.dispatcher != null)
	  {
		Debug.Assert(other.context == null);
		context = null;
		other.dispatcher = null;
	  }

	  return this;
	}

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static TcpListener TcpListener.operator = (TcpListener && other)
	{
	  if (dispatcher != null)
	  {
		Debug.Assert(context == null);
		if (close(listener) == -1)
		{
		  throw new System.Exception("TcpListener::operator=, close failed, " + lastErrorMessage());
		}
	  }

	  dispatcher = other.dispatcher;
	  if (other.dispatcher != null)
	  {
		Debug.Assert(other.context == null);
		listener = other.listener;
		context = null;
		other.dispatcher = null;
	  }

	  return this;
	}

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static Timer Timer.operator = (Timer && other)
	{
	  Debug.Assert(dispatcher == null || context == null);
	  dispatcher = other.dispatcher;
	  if (other.dispatcher != null)
	  {
		Debug.Assert(other.context == null);
		timer = other.timer;
		context = null;
		other.dispatcher = null;
		other.timer = -1;
	  }

	  return this;
	}

	public static readonly size_t STACK_SIZE = 16384;
	public static readonly size_t RESERVE_STACK_SIZE = 2097152;

	public static string lastErrorMessage()
	{
	  return errorMessage(GetLastError());
	}

	public static string errorMessage(int error)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not allow declaring types within methods:
	//  struct Buffer
	//  {
	//	~Buffer()
	//	{
	//	  if (pointer != null)
	//	  {
	//		LocalFree(pointer);
	//	  }
	//	}
	//
	//	string pointer = null;
	//  }
	//  buffer;

//C++ TO C# CONVERTER TODO TASK: There is no equivalent to 'reinterpret_cast' in C#:
	  var size = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, null, error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), reinterpret_cast<string>(buffer.pointer), 0, null);
	  return "result=" + Convert.ToString(error) + ", " + (string)(buffer.pointer, size);
	}

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static Ipv4Resolver Ipv4Resolver.operator = (Ipv4Resolver && other)
	{
	  dispatcher = other.dispatcher;
	  if (dispatcher != null)
	  {
		other.dispatcher = null;
	  }

	  return this;
	}

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static TcpConnection TcpConnection.operator = (TcpConnection && other)
	{
	  if (dispatcher != null)
	  {
		Debug.Assert(readContext == null);
		Debug.Assert(writeContext == null);
		if (closesocket(connection) != 0)
		{
		  throw new System.Exception("TcpConnection::operator=, closesocket failed, " + errorMessage(WSAGetLastError()));
		}
	  }

	  dispatcher = other.dispatcher;
	  if (dispatcher != null)
	  {
		Debug.Assert(other.readContext == null);
		Debug.Assert(other.writeContext == null);
		connection = other.connection;
		readContext = null;
		writeContext = null;
		other.dispatcher = null;
	  }

	  return this;
	}

	public static LPFN_CONNECTEX connectEx = null;

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static TcpConnector TcpConnector.operator = (TcpConnector && other)
	{
	  Debug.Assert(dispatcher == null || context == null);
	  dispatcher = other.dispatcher;
	  if (dispatcher != null)
	  {
		Debug.Assert(other.context == null);
		context = null;
		other.dispatcher = null;
	  }

	  return this;
	}

	public static LPFN_ACCEPTEX acceptEx = null;

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static TcpListener TcpListener.operator = (TcpListener && other)
	{
	  if (dispatcher != null)
	  {
		Debug.Assert(context == null);
		if (closesocket(listener) != 0)
		{
		  throw new System.Exception("TcpListener::operator=, closesocket failed, " + errorMessage(WSAGetLastError()));
		}
	  }

	  dispatcher = other.dispatcher;
	  if (dispatcher != null)
	  {
		Debug.Assert(other.context == null);
		listener = other.listener;
		context = null;
		other.dispatcher = null;
	  }

	  return this;
	}

//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
//C++ TO C# CONVERTER TODO TASK: The = operator cannot be overloaded in C#:
	public static Timer Timer.operator = (Timer && other)
	{
	  Debug.Assert(dispatcher == null || context == null);
	  dispatcher = other.dispatcher;
	  if (dispatcher != null)
	  {
		Debug.Assert(other.context == null);
		context = null;
		other.dispatcher = null;
	  }

	  return this;
	}

	public static ushort readUint8(string source, ref size_t offset)
	{
	  if (offset == source.Length || source[offset] < '0' || source[offset] > '9')
	  {
		throw new System.Exception("Unable to read value from string");
	  }

	  ushort value = source[offset] - '0';
	  if (offset + 1 == source.Length || source[offset + 1] < '0' || source[offset + 1] > '9')
	  {
		offset = offset + 1;
		return value;
	  }

	  if (value == 0)
	  {
		throw new System.Exception("Unable to read value from string");
	  }

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: value = value * 10 + (source[offset + 1] - '0');
	  value.CopyFrom(value * 10 + (source[offset + 1] - '0'));
	  if (offset + 2 == source.Length || source[offset + 2] < '0' || source[offset + 2] > '9')
	  {
		offset = offset + 2;
		return value;
	  }

	  if ((value == 25 && source[offset + 2] > '5') || value > 25)
	  {
		throw new System.Exception("Unable to read value from string");
	  }

//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: value = value * 10 + (source[offset + 2] - '0');
	  value.CopyFrom(value * 10 + (source[offset + 2] - '0'));
	  offset = offset + 3;
	  return value;
	}

	  // Run other task on dispatcher until future is ready.
//C++ TO C# CONVERTER WARNING: 'const' methods are not available in C#:
//ORIGINAL LINE: void wait() const
	  public static void wait()
	  {
		while (!event.get())
		{
		  try
		  {
			event.wait();
		  }
		  catch (InterruptedException)
		  {
			interrupted = true;
		  }
		}

		if (interrupted)
		{
		  dispatcher.interrupt();
		}
	  }

	  // Wait future to complete.
	  public void Dispose()
	  {
		try
		{
		  wait();
		}
		catch
		{
		}

		try
		{
		  // windows future implementation doesn't wait for completion on destruction
		  if (future.valid())
		  {
			future.wait();
		  }
		}
		catch
		{
		}
	  }

	  // This function is executed in future object
	  public static T asyncProcedure()
	  {
		NotifyOnDestruction guard = new NotifyOnDestruction(dispatcher, event);
		Debug.Assert(procedure != null);
		return procedure();
	  }

	  public static Dispatcher dispatcher;
	  private mutable Event event;
	  public static Func<T> procedure;
	  public static System.Detail.Future<T> future = new System.Detail.Future<T>();
	  public static bool interrupted;
	}
}

namespace PaymentService
{
	public static class GlobalMembers
	{
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void generateNewWallet(CryptoNote::Currency currency, WalletConfiguration conf, Logging::ILogger logger, System::Dispatcher dispatcher);

//C++ TO C# CONVERTER NOTE: C# has no need of forward class declarations:
	//struct TransactionsInBlockInfoFilter;

	public static void generateNewWallet(CryptoNote.Currency currency, WalletConfiguration conf, Logging.ILogger logger, System.Dispatcher dispatcher)
	{
	  Logging.LoggerRef log = new Logging.LoggerRef(logger, "generateNewWallet");

	  CryptoNote.INode nodeStub = NodeFactory.createNodeStub();
	  std::unique_ptr<CryptoNote.INode> nodeGuard = new std::unique_ptr<CryptoNote.INode>(nodeStub);

	  CryptoNote.IWallet wallet = new CryptoNote.WalletGreen(dispatcher, currency, nodeStub, logger);
	  std::unique_ptr<CryptoNote.IWallet> walletGuard = new std::unique_ptr<CryptoNote.IWallet>(wallet);

	  string address;
	  if (string.IsNullOrEmpty(conf.secretSpendKey) && string.IsNullOrEmpty(conf.secretViewKey) && string.IsNullOrEmpty(conf.mnemonicSeed))
	  {
		log.functorMethod(Logging.Level.INFO, Logging.BRIGHT_WHITE) << "Generating new wallet";

		Crypto.SecretKey private_view_key = new Crypto.SecretKey();
		CryptoNote.KeyPair spendKey = new CryptoNote.KeyPair();

		Crypto.generate_keys(spendKey.publicKey, spendKey.secretKey);
		CryptoNote.AccountBase.generateViewFromSpend(spendKey.secretKey, private_view_key);

		wallet.initializeWithViewKey(conf.walletFile, conf.walletPassword, private_view_key, 0, true);
		address = wallet.createAddress(spendKey.secretKey, 0, true);

		  log.functorMethod(Logging.Level.INFO, Logging.BRIGHT_WHITE) << "New wallet is generated. Address: " << address;
	  }
	  else if (!string.IsNullOrEmpty(conf.mnemonicSeed))
	  {
		log.functorMethod(Logging.Level.INFO, Logging.BRIGHT_WHITE) << "Attempting to import wallet from mnemonic seed";

		Crypto.SecretKey private_view_key = new Crypto.SecretKey();

		var (error, private_spend_key) = Mnemonics.MnemonicToPrivateKey(conf.mnemonicSeed);

		if (!error.empty())
		{
			log.functorMethod(Logging.Level.ERROR, Logging.BRIGHT_RED) << error;
			return;
		}

		CryptoNote.AccountBase.generateViewFromSpend(private_spend_key, private_view_key);
		wallet.initializeWithViewKey(conf.walletFile, conf.walletPassword, private_view_key, conf.scanHeight, false);
		address = wallet.createAddress(private_spend_key, conf.scanHeight, false);
		log.functorMethod(Logging.Level.INFO, Logging.BRIGHT_WHITE) << "Imported wallet successfully.";
	  }
	  else
	  {
		  if (string.IsNullOrEmpty(conf.secretSpendKey) || string.IsNullOrEmpty(conf.secretViewKey))
		  {
			  log.functorMethod(Logging.Level.ERROR, Logging.BRIGHT_RED) << "Need both secret spend key and secret view key.";
			  return;
		  }
		else
		{
			  log.functorMethod(Logging.Level.INFO, Logging.BRIGHT_WHITE) << "Attemping to import wallet from keys";
			  Crypto.Hash private_spend_key_hash = new Crypto.Hash();
			  Crypto.Hash private_view_key_hash = new Crypto.Hash();
			  ulong size;
			  if (!Common.fromHex(conf.secretSpendKey, private_spend_key_hash, sizeof(Crypto.Hash), size) || size != sizeof(Crypto.Hash))
			  {
				  log.functorMethod(Logging.Level.ERROR, Logging.BRIGHT_RED) << "Invalid spend key";
				  return;
			  }
			  if (!Common.fromHex(conf.secretViewKey, private_view_key_hash, sizeof(Crypto.Hash), size) || size != sizeof(Crypto.Hash))
			  {
				  log.functorMethod(Logging.Level.ERROR, Logging.BRIGHT_RED) << "Invalid view key";
				  return;
			  }
			  Crypto.SecretKey private_spend_key = (Crypto.SecretKey) private_spend_key_hash;
			  Crypto.SecretKey private_view_key = (Crypto.SecretKey) private_view_key_hash;

			  wallet.initializeWithViewKey(conf.walletFile, conf.walletPassword, private_view_key, conf.scanHeight, false);
			  address = wallet.createAddress(private_spend_key, conf.scanHeight, false);
			  log.functorMethod(Logging.Level.INFO, Logging.BRIGHT_WHITE) << "Imported wallet successfully.";
		}
	  }

	  wallet.save(CryptoNote.WalletSaveLevel.SAVE_KEYS_ONLY);
	  log.functorMethod(Logging.Level.INFO, Logging.BRIGHT_WHITE) << "Wallet is saved";
	}

//C++ TO C# CONVERTER NOTE: C# has no need of forward class declarations:
	//struct TransactionsInBlockInfoFilter;

	public static bool checkPaymentId(string paymentId)
	{
	  if (paymentId.Length != 64)
	  {
		return false;
	  }

  return std::all_of(paymentId.GetEnumerator(), paymentId.end(), (char c) =>
  {
	if (c >= '0' && c <= '9')
	{
	  return true;
	}

	if (c >= 'a' && c <= 'f')
	{
	  return true;
	}

	if (c >= 'A' && c <= 'F')
	{
	  return true;
	}

	return false;
  });
	}

	public static Crypto.Hash parsePaymentId(string paymentIdStr)
	{
	  if (!GlobalMembers.checkPaymentId(paymentIdStr))
	  {
		throw std::system_error(GlobalMembers.make_error_code(CryptoNote.error.WalletServiceErrorCode.WRONG_PAYMENT_ID_FORMAT));
	  }

	  Crypto.Hash paymentId = new Crypto.Hash();
	  bool r = Common.GlobalMembers.podFromHex(paymentIdStr, paymentId);
	  if (r)
	  {
	  }
	  Debug.Assert(r);

	  return paymentId;
	}

	public static bool getPaymentIdFromExtra(string binaryString, Crypto.Hash paymentId)
	{
	  return CryptoNote.getPaymentIdFromTxExtra(Common.asBinaryArray(binaryString), paymentId);
	}

	public static string getPaymentIdStringFromExtra(string binaryString)
	{
	  Crypto.Hash paymentId = new Crypto.Hash();

	  try
	  {
		if (!GlobalMembers.getPaymentIdFromExtra(binaryString, paymentId))
		{
		  return string();
		}
	  }
	  catch (System.Exception)
	  {
		return string();
	  }

	  return Common.GlobalMembers.podToHex(paymentId);
	}

	public static void addPaymentIdToExtra(string paymentId, string extra)
	{
	  List<byte> extraVector = new List<byte>();
	  if (!CryptoNote.createTxExtraWithPaymentId(paymentId, extraVector))
	  {
		throw std::system_error(GlobalMembers.make_error_code(CryptoNote.error.BAD_PAYMENT_ID));
	  }

	  std::copy(extraVector.GetEnumerator(), extraVector.end(), std::back_inserter(extra));
	}

	public static void validatePaymentId(string paymentId, Logging.LoggerRef logger)
	{
	  if (!GlobalMembers.checkPaymentId(paymentId))
	  {
		logger.functorMethod(Logging.Level.WARNING, Logging.BRIGHT_YELLOW) << "Can't validate payment id: " << paymentId;
		throw std::system_error(GlobalMembers.make_error_code(CryptoNote.error.WalletServiceErrorCode.WRONG_PAYMENT_ID_FORMAT));
	  }
	}



	public static Crypto.Hash parseHash(string hashString, Logging.LoggerRef logger)
	{
	  Crypto.Hash hash = new Crypto.Hash();

	  if (!Common.GlobalMembers.podFromHex(hashString, hash))
	  {
		logger.functorMethod(Logging.Level.WARNING, Logging.BRIGHT_YELLOW) << "Can't parse hash string " << hashString;
		throw std::system_error(GlobalMembers.make_error_code(CryptoNote.error.WalletServiceErrorCode.WRONG_HASH_FORMAT));
	  }

	  return hash;
	}

	public static List<CryptoNote.TransactionsInBlockInfo> filterTransactions(List<CryptoNote.TransactionsInBlockInfo> blocks, TransactionsInBlockInfoFilter filter)
	{

	  List<CryptoNote.TransactionsInBlockInfo> result = new List<CryptoNote.TransactionsInBlockInfo>();

	  foreach (var block in blocks)
	  {
		CryptoNote.TransactionsInBlockInfo item = new CryptoNote.TransactionsInBlockInfo();
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: item.blockHash = block.blockHash;
		item.blockHash.CopyFrom(block.blockHash);

		foreach (var transaction in block.transactions)
		{
		  if (transaction.transaction.state != CryptoNote.WalletTransactionState.DELETED && filter.checkTransaction(transaction))
		  {
			item.transactions.Add(transaction);
		  }
		}

		if (block.transactions.Count > 0)
		{
		  result.Add(std::move(item));
		}
	  }

	  return result;
	}

	public static PaymentService.TransactionRpcInfo convertTransactionWithTransfersToTransactionRpcInfo(CryptoNote.WalletTransactionWithTransfers transactionWithTransfers)
	{

	  PaymentService.TransactionRpcInfo transactionInfo = new PaymentService.TransactionRpcInfo();

	  transactionInfo.state = (byte)transactionWithTransfers.transaction.state;
	  transactionInfo.transactionHash = Common.GlobalMembers.podToHex(transactionWithTransfers.transaction.hash);
	  transactionInfo.blockIndex = transactionWithTransfers.transaction.blockHeight;
	  transactionInfo.timestamp = transactionWithTransfers.transaction.timestamp;
	  transactionInfo.isBase = transactionWithTransfers.transaction.isBase;
	  transactionInfo.unlockTime = transactionWithTransfers.transaction.unlockTime;
	  transactionInfo.amount = transactionWithTransfers.transaction.totalAmount;
	  transactionInfo.fee = transactionWithTransfers.transaction.fee;
	  transactionInfo.extra = Common.toHex(transactionWithTransfers.transaction.extra.data(), transactionWithTransfers.transaction.extra.Length);
	  transactionInfo.paymentId = GlobalMembers.getPaymentIdStringFromExtra(transactionWithTransfers.transaction.extra);

	  foreach (CryptoNote  in :WalletTransfer & transfer: transactionWithTransfers.transfers)
	  {
		PaymentService.TransferRpcInfo rpcTransfer = new PaymentService.TransferRpcInfo();
		rpcTransfer.address = transfer.address;
		rpcTransfer.amount = transfer.amount;
		rpcTransfer.type = (byte)transfer.type;

		transactionInfo.transfers.Add(std::move(rpcTransfer));
	  }

	  return transactionInfo;
	}

	public static List<PaymentService.TransactionsInBlockRpcInfo> convertTransactionsInBlockInfoToTransactionsInBlockRpcInfo(List<CryptoNote.TransactionsInBlockInfo> blocks)
	{

	  List<PaymentService.TransactionsInBlockRpcInfo> rpcBlocks = new List<PaymentService.TransactionsInBlockRpcInfo>();
	  rpcBlocks.Capacity = blocks.Count;
	  foreach (var block in blocks)
	  {
		PaymentService.TransactionsInBlockRpcInfo rpcBlock = new PaymentService.TransactionsInBlockRpcInfo();
		rpcBlock.blockHash = Common.GlobalMembers.podToHex(block.blockHash);

		foreach (CryptoNote  in :WalletTransactionWithTransfers & transactionWithTransfers: block.transactions)
		{
		  PaymentService.TransactionRpcInfo transactionInfo = GlobalMembers.convertTransactionWithTransfersToTransactionRpcInfo(transactionWithTransfers);
		  rpcBlock.transactions.Add(std::move(transactionInfo));
		}

		rpcBlocks.Add(std::move(rpcBlock));
	  }

	  return rpcBlocks;
	}

	public static List<PaymentService.TransactionHashesInBlockRpcInfo> convertTransactionsInBlockInfoToTransactionHashesInBlockRpcInfo(List<CryptoNote.TransactionsInBlockInfo> blocks)
	{

	  List<PaymentService.TransactionHashesInBlockRpcInfo> transactionHashes = new List<PaymentService.TransactionHashesInBlockRpcInfo>();
	  transactionHashes.Capacity = blocks.Count;
	  foreach (CryptoNote  in :TransactionsInBlockInfo & block: blocks)
	  {
		PaymentService.TransactionHashesInBlockRpcInfo item = new PaymentService.TransactionHashesInBlockRpcInfo();
		item.blockHash = Common.GlobalMembers.podToHex(block.blockHash);

		foreach (CryptoNote  in :WalletTransactionWithTransfers & transaction: block.transactions)
		{
		  item.transactionHashes.emplace_back(Common.GlobalMembers.podToHex(transaction.transaction.hash));
		}

		transactionHashes.Add(std::move(item));
	  }

	  return transactionHashes;
	}

	public static void validateAddresses(List<string> addresses, CryptoNote.Currency currency, Logging.LoggerRef logger)
	{
	  foreach (var address in addresses)
	  {
		if (!CryptoNote.validateAddress(address, currency))
		{
		  logger.functorMethod(Logging.Level.WARNING, Logging.BRIGHT_YELLOW) << "Can't validate address " << address;
		  throw std::system_error(GlobalMembers.make_error_code(CryptoNote.error.BAD_ADDRESS));
		}
	  }
	}

	public static Tuple<string, string> decodeIntegratedAddress(string integratedAddr, CryptoNote.Currency currency, Logging.LoggerRef logger)
	{
		string decoded;
		ulong prefix;

		/* Need to be able to decode the string as an address */
		if (!Tools.Base58.decode_addr(integratedAddr, prefix, decoded))
		{
			throw std::system_error(GlobalMembers.make_error_code(CryptoNote.error.BAD_ADDRESS));
		}

		/* The prefix needs to be the same as the base58 prefix */
		if (prefix != CryptoNote.parameters.CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX)
		{
			throw std::system_error(GlobalMembers.make_error_code(CryptoNote.error.BAD_ADDRESS));
		}

		const ulong paymentIDLen = 64;
		/* Grab the payment ID from the decoded address */
		string paymentID = decoded.Substring(0, paymentIDLen);

		/* Check the extracted payment ID is good. */
		GlobalMembers.validatePaymentId(paymentID, logger.functorMethod);

		/* The binary array encoded keys are the rest of the address */
		string keys = decoded.Substring(paymentIDLen, -1);

		CryptoNote.AccountPublicAddress addr = new CryptoNote.AccountPublicAddress();
		List<byte> ba = Common.asBinaryArray(keys);

		if (!CryptoNote.GlobalMembers.fromBinaryArray(ref addr, ba))
		{
			throw std::system_error(GlobalMembers.make_error_code(CryptoNote.error.BAD_ADDRESS));
		}

		/* Parse the AccountPublicAddress into a standard wallet address */
		/* Use the calculated prefix from earlier for less typing :p */
		string address = CryptoNote.getAccountAddressAsStr(prefix, addr);

		/* Check the extracted address is good. */
		GlobalMembers.validateAddresses(new List<string>() {address}, currency, logger.functorMethod);

		return Tuple.Create(address, paymentID);
	}

	public static string getValidatedTransactionExtraString(string extraString)
	{
	  List<byte> binary = new List<byte>();
	  if (!Common.fromHex(extraString, binary))
	  {
		throw std::system_error(GlobalMembers.make_error_code(CryptoNote.error.BAD_TRANSACTION_EXTRA));
	  }

	  return Common.asString(binary);
	}

	public static List<string> collectDestinationAddresses(List<PaymentService.WalletRpcOrder> orders)
	{
	  List<string> result = new List<string>();

	  result.Capacity = orders.Count;
	  foreach (var order in orders)
	  {
		result.Add(order.address);
	  }

	  return result;
	}

	public static List<CryptoNote.WalletOrder> convertWalletRpcOrdersToWalletOrders(List<PaymentService.WalletRpcOrder> orders, string nodeAddress, uint nodeFee)
	{
	  List<CryptoNote.WalletOrder> result = new List<CryptoNote.WalletOrder>();

	  if (!string.IsNullOrEmpty(nodeAddress) && nodeFee != 0)
	  {
		result.Capacity = orders.Count + 1;
		result.emplace_back(new CryptoNote.WalletOrder ({nodeAddress, nodeFee}));
	  }
	  else
	  {
		result.Capacity = orders.Count;
	  }

	  foreach (var order in orders)
	  {
		result.emplace_back(new CryptoNote.WalletOrder ({order.address, order.amount}));
	  }

	  return result;
	}

	  public static WalletServiceConfiguration initConfiguration()
	  {
		WalletServiceConfiguration config = new WalletServiceConfiguration();

		config.daemonAddress = "127.0.0.1";
		config.bindAddress = "127.0.0.1";
		config.logFile = "service.log";
		config.daemonPort = CryptoNote.RPC_DEFAULT_PORT;
		config.bindPort = CryptoNote.SERVICE_DEFAULT_PORT;
		config.logLevel = Logging.INFO;
		config.legacySecurity = false;
		config.help = false;
		config.version = false;
		config.dumpConfig = false;
		config.generateNewContainer = false;
		config.daemonize = false;
		config.registerService = false;
		config.unregisterService = false;
		config.printAddresses = false;
		config.syncFromZero = false;

		return config;
	  }

	  public static void handleSettings(int argc, string[] argv, WalletServiceConfiguration config)
	  {
		cxxopts.Options options = new cxxopts.Options(argv[0], CryptoNote.getProjectCLIHeader());

		options.add_options("Core")("h,help", "Display this help message", cxxopts.value<bool>().implicit_value("true"))("v,version", "Output software version information", cxxopts.value<bool>().default_value("false").implicit_value("true"));

		options.add_options("Daemon")("daemon-address", "The daemon host to use for node operations",cxxopts.value<string>().default_value(config.daemonAddress), "<ip>")("daemon-port", "The daemon RPC port to use for node operations", cxxopts.value<int>().default_value(Convert.ToString(config.daemonPort)), "<port>");

		options.add_options("Service")("c,config", "Specify the configuration <file> to use instead of CLI arguments", cxxopts.value<string>(), "<file>")("dump-config", "Prints the current configuration to the screen", cxxopts.value<bool>().default_value("false").implicit_value("true"))("log-file", "Specify log <file> location", cxxopts.value<string>().default_value(config.logFile), "<file>")("log-level", "Specify log level", cxxopts.value<int>().default_value(Convert.ToString(config.logLevel)), "#")("server-root", "The service will use this <path> as the working directory", cxxopts.value<string>(), "<path>")("save-config", "Save the configuration to the specified <file>", cxxopts.value<string>(), "<file>");

		options.add_options("Wallet")("address", "Print the wallet addresses and then exit", cxxopts.value<bool>().default_value("false").implicit_value("true"))("w,container-file", "Wallet container <file>", cxxopts.value<string>(), "<file>")("p,container-password", "Wallet container <password>", cxxopts.value<string>(), "<password>")("g,generate-container", "Generate a new wallet container", cxxopts.value<bool>().default_value("false").implicit_value("true"))("view-key", "Generate a wallet container with this secret view <key>", cxxopts.value<string>(), "<key>")("spend-key", "Generate a wallet container with this secret spend <key>", cxxopts.value<string>(), "<key>")("mnemonic-seed", "Generate a wallet container with this Mnemonic <seed>", cxxopts.value<string>(), "<seed>")("scan-height", "Start scanning for transactions from this Blockchain height", cxxopts.value<ulong>().default_value("0"), "#")("SYNC_FROM_ZERO", "Force the wallet to sync from 0", cxxopts.value<bool>().default_value("false").implicit_value("true"));

		options.add_options("Network")("bind-address", "Interface IP address for the RPC service", cxxopts.value<string>().default_value(config.bindAddress), "<ip>")("bind-port", "TCP port for the RPC service", cxxopts.value<int>().default_value(Convert.ToString(config.bindPort)), "<port>");

		options.add_options("RPC")("enable-cors", "Adds header 'Access-Control-Allow-Origin' to the RPC responses. Uses the value specified as the domain. Use * for all.", cxxopts.value<string>(), "<domain>")("rpc-legacy-security", "Enable legacy mode (no password for RPC). WARNING: INSECURE. USE ONLY AS A LAST RESORT.", cxxopts.value<bool>().default_value("false").implicit_value("true"))("rpc-password", "Specify the <password> to access the RPC server.", cxxopts.value<string>(), "<password>");

	#if WIN32
		options.add_options("Windows Only")("daemonize", "Run the service as a daemon", cxxopts.value<bool>().default_value("false").implicit_value("true"))("register-service", "Registers this program as a Windows service",cxxopts.value<bool>().default_value("false").implicit_value("true"))("unregister-service", "Unregisters this program from being a Windows service", cxxopts.value<bool>().default_value("false").implicit_value("true"));
	#endif

		try
		{
		  var cli = options.parse(argc, argv);

		  if (cli.count("help") > 0)
		  {
			config.help = cli["help"].@as<bool>();
		  }

		  if (cli.count("version") > 0)
		  {
			config.version = cli["version"].@as<bool>();
		  }

		  if (cli.count("config") > 0)
		  {
			config.configFile = cli["config"].@as<string>();
		  }

		  if (cli.count("save-config") > 0)
		  {
			config.outputFile = cli["save-config"].@as<string>();
		  }

		  if (cli.count("dump-config") > 0)
		  {
			config.dumpConfig = cli["dump-config"].@as<bool>();
		  }

		  if (cli.count("daemon-address") > 0)
		  {
			config.daemonAddress = cli["daemon-address"].@as<string>();
		  }

		  if (cli.count("daemon-port") > 0)
		  {
			config.daemonPort = cli["daemon-port"].@as<int>();
		  }

		  if (cli.count("log-file") > 0)
		  {
			config.logFile = cli["log-file"].@as<string>();
		  }

		  if (cli.count("log-level") > 0)
		  {
			config.logLevel = cli["log-level"].@as<int>();
		  }

		  if (cli.count("container-file") > 0)
		  {
			config.containerFile = cli["container-file"].@as<string>();
		  }

		  if (cli.count("container-password") > 0)
		  {
			config.containerPassword = cli["container-password"].@as<string>();
		  }

		  if (cli.count("bind-address") > 0)
		  {
			config.bindAddress = cli["bind-address"].@as<string>();
		  }

		  if (cli.count("bind-port") > 0)
		  {
			config.bindPort = cli["bind-port"].@as<int>();
		  }

		  if (cli.count("enable-cors") > 0)
		  {
			config.corsHeader = cli["enable-cors"].@as<string>();
		  }

		  if (cli.count("rpc-legacy-security") > 0)
		  {
			config.legacySecurity = cli["rpc-legacy-security"].@as<bool>();
		  }

		  if (cli.count("rpc-password") > 0)
		  {
			config.rpcPassword = cli["rpc-password"].@as<string>();
		  }

		  if (cli.count("server-root") > 0)
		  {
			config.serverRoot = cli["server-root"].@as<string>();
		  }

		  if (cli.count("view-key") > 0)
		  {
			config.secretViewKey = cli["view-key"].@as<string>();
		  }

		  if (cli.count("spend-key") > 0)
		  {
			config.secretSpendKey = cli["spend-key"].@as<string>();
		  }

		  if (cli.count("mnemonic-seed") > 0)
		  {
			config.mnemonicSeed = cli["mnemonic-seed"].@as<string>();
		  }

		  if (cli.count("generate-container") > 0)
		  {
			config.generateNewContainer = cli["generate-container"].@as<bool>();
		  }

		  if (cli.count("daemonize") > 0)
		  {
			config.daemonize = cli["daemonize"].@as<bool>();
		  }

		  if (cli.count("register-service") > 0)
		  {
			config.registerService = cli["register-service"].@as<bool>();
		  }

		  if (cli.count("unregister-service") > 0)
		  {
			config.unregisterService = cli["unregister-service"].@as<bool>();
		  }

		  if (cli.count("address") > 0)
		  {
			config.printAddresses = cli["address"].@as<bool>();
		  }

		  if (cli.count("SYNC_FROM_ZERO") > 0)
		  {
			config.syncFromZero = cli["SYNC_FROM_ZERO"].@as<bool>();
		  }

		  if (cli.count("scan-height") > 0)
		  {
			config.scanHeight = cli["scan-height"].@as<ulong>();
		  }

		  if (config.help) // Do we want to display the help message?
		  {
			Console.Write(options.help({}));
			Console.Write("\n");
			Environment.Exit(0);
		  }
		  else if (config.version) // Do we want to display the software version?
		  {
			Console.Write(CryptoNote.getProjectCLIHeader());
			Console.Write("\n");
			Environment.Exit(0);
		  }
		}
		catch (cxxopts.OptionException e)
		{
		  Console.Write("Error: Unable to parse command line argument options: ");
		  Console.Write(e.what());
		  Console.Write("\n");
		  Console.Write("\n");
		  Console.Write(options.help({}));
		  Console.Write("\n");
		  Environment.Exit(1);
		}
	  }

	   public static void handleIniConfig(std::ifstream data, WalletServiceConfiguration config)
	   {
		// find key=value pair, respect whitespace before/after "="
		// g0: full match, g1: match key, g2: match value
		std::regex cfgItem = new std::regex(@"\s*(\S[^ \t=]*)\s*=\s*((\s?\S+)+)\s*$");

		// comments, first non space starts with # or ;
		std::regex cfgComment = new std::regex(@"\s*[;#]");
		std::smatch item = new std::smatch();
		string cfgKey;
		string cfgValue;

		for (string line; getline(data, line);)
		{
		  if (line.empty() || std::regex_match(line, item, cfgComment))
		  {
			continue;
		  }
		  else if (std::regex_match(line, item, cfgItem))
		  {
			if (item.size() == 4)
			{
			  cfgKey = item[1].str();
			  cfgValue = item[2].str();

			  if (cfgKey.CompareTo("daemon-address") == 0)
			  {
				config.daemonAddress = cfgValue;
			  }
			  else if (cfgKey.CompareTo("daemon-port") == 0)
			  {
				config.daemonPort = Convert.ToInt32(cfgValue);
			  }
			  else if (cfgKey.CompareTo("log-file") == 0)
			  {
				config.logFile = cfgValue;
			  }
			  else if (cfgKey.CompareTo("log-level") == 0)
			  {
				config.logLevel = Convert.ToInt32(cfgValue);
			  }
			  else if (cfgKey.CompareTo("container-file") == 0)
			  {
				config.containerFile = cfgValue;
			  }
			  else if (cfgKey.CompareTo("container-password") == 0)
			  {
				config.containerPassword = cfgValue;
			  }
			  else if (cfgKey.CompareTo("bind-address") == 0)
			  {
				config.bindAddress = cfgValue;
			  }
			  else if (cfgKey.CompareTo("bind-port") == 0)
			  {
				config.bindPort = Convert.ToInt32(cfgValue);
			  }
			  else if (cfgKey.CompareTo("enable-cors") == 0)
			  {
				config.corsHeader = cfgValue;
			  }
			  else if (cfgKey.CompareTo("rpc-legacy-security") == 0)
			  {
				config.legacySecurity = cfgValue[0] == '1' ? true : false;
			  }
			  else if (cfgKey.CompareTo("rpc-password") == 0)
			  {
				config.rpcPassword = cfgValue;
			  }
			  else if (cfgKey.CompareTo("server-root") == 0)
			  {
				config.serverRoot = cfgValue;
			  }
			  else
			  {
				throw new System.Exception("One or more options in your config file was invalid!");
			  }
			}
		  }
		}
	   }

	  public static void handleSettings(string configFile, WalletServiceConfiguration config)
	  {
		std::ifstream data = new std::ifstream(configFile);

		if (!data.good())
		{
		  throw new System.Exception("The --config-file you specified does not exist, please check the filename and try again.");
		}

		try
		{
		  json j = new json();
		  data >> j;

		  if (j.find("daemon-address") != j.end())
		  {
			config.daemonAddress = j["daemon-address"].get<string>();
		  }

		  if (j.find("daemon-port") != j.end())
		  {
			config.daemonPort = j["daemon-port"].get<int>();
		  }

		  if (j.find("log-file") != j.end())
		  {
			config.logFile = j["log-file"].get<string>();
		  }

		  if (j.find("log-level") != j.end())
		  {
			config.logLevel = j["log-level"].get<int>();
		  }

		  if (j.find("container-file") != j.end())
		  {
			config.containerFile = j["container-file"].get<string>();
		  }

		  if (j.find("container-password") != j.end())
		  {
			config.containerPassword = j["container-password"].get<string>();
		  }

		  if (j.find("bind-address") != j.end())
		  {
			config.bindAddress = j["bind-address"].get<string>();
		  }

		  if (j.find("bind-port") != j.end())
		  {
			config.bindPort = j["bind-port"].get<int>();
		  }

		  if (j.find("enable-cors") != j.end())
		  {
			config.corsHeader = j["enable-cors"].get<string>();
		  }

		  if (j.find("rpc-legacy-security") != j.end())
		  {
			config.legacySecurity = j["rpc-legacy-security"].get<bool>();
		  }

		  if (j.find("rpc-password") != j.end())
		  {
			config.rpcPassword = j["rpc-password"].get<string>();
		  }

		  if (j.find("server-root") != j.end())
		  {
			config.serverRoot = j["server-root"].get<string>();
		  }
		}
		catch (System.Exception e)
		{
			// when failed reading as json, try reading it as old flat ini
			// clear eof + fail bits
			data.clear();
			// reread from start
			data.seekg(0, std::ios.beg);
			handleIniConfig(data, config);
		}
	  }

	  public static json asJSON(WalletServiceConfiguration config)
	  {
		json j = new json(
		{
			{"daemon-address", config.daemonAddress},
			{"daemon-port", config.daemonPort},
			{"log-file", config.logFile},
			{"log-level", config.logLevel},
			{"container-file", config.containerFile},
			{"container-password", config.containerPassword},
			{"bind-address", config.bindAddress},
			{"bind-port", config.bindPort},
			{"enable-cors", config.corsHeader},
			{"rpc-legacy-security", config.legacySecurity},
			{"rpc-password", config.rpcPassword},
			{"server-root", config.serverRoot}
		});

		return j;
	  }

	  public static string asString(WalletServiceConfiguration config)
	  {
		json j = asJSON(config);
		return j.dump(2);
	  }

	  public static void asFile(WalletServiceConfiguration config, string filename)
	  {
		json j = asJSON(config);
		std::ofstream data = new std::ofstream(filename);
		data << std::setw(2) << j << std::endl;
	  }
	}
}

namespace linenoise.ansi
{
	public static class GlobalMembers
	{
	//C++ TO C# CONVERTER TODO TASK: Typedefs defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//typedef GRM *PGRM;
	public static readonly char SO = '\x0E'; // Shift Out
	public static readonly char SI = '\x0F'; // Shift In

	public static readonly int MAX_ARG = 16; // max number of args in an escape sequence
	public static int state; // automata state
	public static char prefix; // escape sequence prefix ( '[', ']' or '(' );
	public static char prefix2; // secondary prefix ( '?' or '>' );
	public static char suffix; // escape sequence suffix
	public static int es_argc; // escape sequence args count
	public static int[] es_argv = new int[MAX_ARG]; // escape sequence args
	public static string Pt_arg = new string(new char[MAX_PATH * 2]); // text parameter for Operating System Command
	public static int Pt_len;
	public static int shifted;


	// DEC Special Graphics Character Set from
	// http://vt100.net/docs/vt220-rm/table2-4.html
	// Some of these may not look right, depending on the font and code page (in
	// particular, the Control Pictures probably won't work at all).
	public static readonly char[] G1 = {' ', '\x2666', '\x2592', '\x2409', '\x240c', '\x240d', '\x240a', '\x00b0', '\x00b1', '\x2424', '\x240b', '\x2518', '\x2510', '\x250c', '\x2514', '\x253c', '\x00af', '\x25ac', '\x2500', '_', '_', '\x251c', '\x2524', '\x2534', '\x252c', '\x2502', '\x2264', '\x2265', '\x03c0', '\x2260', '\x00a3', '\x00b7'};



	// color constants

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define FOREGROUND_WHITE FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE

	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BACKGROUND_WHITE BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE

	public static readonly byte[] foregroundcolor = {DefineConstants.FOREGROUND_BLACK, FOREGROUND_RED, FOREGROUND_GREEN, FOREGROUND_RED | FOREGROUND_GREEN, FOREGROUND_BLUE, FOREGROUND_BLUE | FOREGROUND_RED, FOREGROUND_BLUE | FOREGROUND_GREEN, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE};

	public static readonly byte[] backgroundcolor = {DefineConstants.BACKGROUND_BLACK, BACKGROUND_RED, BACKGROUND_GREEN, BACKGROUND_RED | BACKGROUND_GREEN, BACKGROUND_BLUE, BACKGROUND_BLUE | BACKGROUND_RED, BACKGROUND_BLUE | BACKGROUND_GREEN, BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE};

	public static readonly byte[] attr2ansi = {0, 4, 2, 6, 1, 5, 3, 7};

	public static GRM grm = new GRM();

	// saved cursor position
	public static COORD SavePos = new COORD();

	// ========== Print Buffer functions


	public static int nCharInBuffer;
	public static string ChBuffer = new string(new char[DefineConstants.BUFFER_SIZE]);

	//-----------------------------------------------------------------------------
	//   FlushBuffer()
	// Writes the buffer to the console and empties it.
	//-----------------------------------------------------------------------------

	public static void FlushBuffer()
	{
		uint nWritten;
		if (GlobalMembers.nCharInBuffer <= 0)
		{
			return;
		}
		WriteConsoleW(hConOut, GlobalMembers.ChBuffer, GlobalMembers.nCharInBuffer, nWritten, null);
		GlobalMembers.nCharInBuffer = 0;
	}

	//-----------------------------------------------------------------------------
	//   PushBuffer( WCHAR c )
	// Adds a character in the buffer.
	//-----------------------------------------------------------------------------

	public static void PushBuffer(char c)
	{
		if (GlobalMembers.shifted != 0 && c >= DefineConstants.FIRST_G1 && c <= DefineConstants.LAST_G1)
		{
			c = GlobalMembers.G1[c - DefineConstants.FIRST_G1];
		}
		GlobalMembers.ChBuffer = StringFunctions.ChangeCharacter(GlobalMembers.ChBuffer, GlobalMembers.nCharInBuffer, c);
		if (++GlobalMembers.nCharInBuffer == DefineConstants.BUFFER_SIZE)
		{
			ansi.GlobalMembers.FlushBuffer();
		}
	}

	//-----------------------------------------------------------------------------
	//   SendSequence( LPCWSTR seq )
	// Send the string to the input buffer.
	//-----------------------------------------------------------------------------

	public static void SendSequence(string seq)
	{
		uint @out;
		INPUT_RECORD in = new INPUT_RECORD();
		IntPtr hStdIn = GetStdHandle(STD_INPUT_HANDLE);

		in.EventType = KEY_EVENT;
		in.Event.KeyEvent.bKeyDown = 1;
		in.Event.KeyEvent.wRepeatCount = 1;
		in.Event.KeyEvent.wVirtualKeyCode = 0;
		in.Event.KeyEvent.wVirtualScanCode = 0;
		in.Event.KeyEvent.dwControlKeyState = 0;
		for (; seq != null; ++seq)
		{
			in.Event.KeyEvent.uChar.UnicodeChar = seq;
			WriteConsoleInput(hStdIn, in, 1, @out);
		}
	}

	// ========== Print functions

	//-----------------------------------------------------------------------------
	//   InterpretEscSeq()
	// Interprets the last escape sequence scanned by ParseAndPrintANSIString
	//   prefix             escape sequence prefix
	//   es_argc            escape sequence args count
	//   es_argv[]          escape sequence args array
	//   suffix             escape sequence suffix
	//
	// for instance, with \e[33;45;1m we have
	// prefix = '[',
	// es_argc = 3, es_argv[0] = 33, es_argv[1] = 45, es_argv[2] = 1
	// suffix = 'm'
	//-----------------------------------------------------------------------------

	public static void InterpretEscSeq()
	{
		int i;
		ushort attribut;
		CONSOLE_SCREEN_BUFFER_INFO Info = new CONSOLE_SCREEN_BUFFER_INFO();
		CONSOLE_CURSOR_INFO CursInfo = new CONSOLE_CURSOR_INFO();
		uint len;
		uint NumberOfCharsWritten;
		COORD Pos = new COORD();
		SMALL_RECT Rect = new SMALL_RECT();
		CHAR_INFO CharInfo = new CHAR_INFO();

		if (GlobalMembers.prefix == '[')
		{
			if (GlobalMembers.prefix2 == '?' && (GlobalMembers.suffix == 'h' || GlobalMembers.suffix == 'l'))
			{
				if (GlobalMembers.es_argc == 1 && GlobalMembers.es_argv[0] == 25)
				{
					GetConsoleCursorInfo(hConOut, CursInfo);
					CursInfo.bVisible = (GlobalMembers.suffix == 'h');
					SetConsoleCursorInfo(hConOut, CursInfo);
					return;
				}
			}
			// Ignore any other \e[? or \e[> sequences.
			if (GlobalMembers.prefix2 != 0)
			{
				return;
			}

			GetConsoleScreenBufferInfo(hConOut, Info);
			switch (GlobalMembers.suffix)
			{
					case 'm':
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 0;
						}
						for (i = 0; i < GlobalMembers.es_argc; i++)
						{
							if (30 <= GlobalMembers.es_argv[i] != 0 && GlobalMembers.es_argv[i] <= 37)
							{
								GlobalMembers.grm.foreground = GlobalMembers.es_argv[i] - 30;
							}
							else if (40 <= GlobalMembers.es_argv[i] != 0 && GlobalMembers.es_argv[i] <= 47)
							{
								GlobalMembers.grm.background = GlobalMembers.es_argv[i] - 40;
							}
							else
							{
								switch (GlobalMembers.es_argv[i])
								{
									case 0:
									case 39:
									case 49:
									{
											string def = new string(new char[4]);
											int a;
											*def = '7';
											def = StringFunctions.ChangeCharacter(def, 1, '\0');
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: GetEnvironmentVariableW("ANSICON_DEF", def, (sizeof(def)/sizeof(*(def))));
											GetEnvironmentVariableW("ANSICON_DEF", def, (def.Length));
											a = wcstol(def, null, 16);
											GlobalMembers.grm.reverse = 0;
											if (a < 0)
											{
												GlobalMembers.grm.reverse = 1;
												a = -a;
											}
											if (GlobalMembers.es_argv[i] != 49)
											{
												GlobalMembers.grm.foreground = GlobalMembers.attr2ansi[a & 7];
											}
											if (GlobalMembers.es_argv[i] != 39)
											{
												GlobalMembers.grm.background = GlobalMembers.attr2ansi[(a >> 4) & 7];
											}
											if (GlobalMembers.es_argv[i] == 0)
											{
												if (GlobalMembers.es_argc == 1)
												{
													GlobalMembers.grm.bold = a & FOREGROUND_INTENSITY;
													GlobalMembers.grm.underline = a & BACKGROUND_INTENSITY;
												}
												else
												{
													GlobalMembers.grm.bold = 0;
													GlobalMembers.grm.underline = 0;
												}
												GlobalMembers.grm.rvideo = 0;
												GlobalMembers.grm.concealed = 0;
											}
									}
											break;

									case 1:
										GlobalMembers.grm.bold = FOREGROUND_INTENSITY;
										break;
									case 5: // blink
									case 4:
										GlobalMembers.grm.underline = BACKGROUND_INTENSITY;
										break;
									case 7:
										GlobalMembers.grm.rvideo = 1;
										break;
									case 8:
										GlobalMembers.grm.concealed = 1;
										break;
									case 21: // oops, this actually turns on double underline
									case 22:
										GlobalMembers.grm.bold = 0;
										break;
									case 25:
									case 24:
										GlobalMembers.grm.underline = 0;
										break;
									case 27:
										GlobalMembers.grm.rvideo = 0;
										break;
									case 28:
										GlobalMembers.grm.concealed = 0;
										break;
								}
							}
						}
						if (GlobalMembers.grm.concealed != 0)
						{
							if (GlobalMembers.grm.rvideo != 0)
							{
								attribut = GlobalMembers.foregroundcolor[GlobalMembers.grm.foreground] | GlobalMembers.backgroundcolor[GlobalMembers.grm.foreground];
								if (GlobalMembers.grm.bold != 0)
								{
									attribut |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
								}
							}
							else
							{
								attribut = GlobalMembers.foregroundcolor[GlobalMembers.grm.background] | GlobalMembers.backgroundcolor[GlobalMembers.grm.background];
								if (GlobalMembers.grm.underline != 0)
								{
									attribut |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
								}
							}
						}
						else if (GlobalMembers.grm.rvideo)
						{
							attribut = GlobalMembers.foregroundcolor[GlobalMembers.grm.background] | GlobalMembers.backgroundcolor[GlobalMembers.grm.foreground];
							if (GlobalMembers.grm.bold != 0)
							{
								attribut |= BACKGROUND_INTENSITY;
							}
							if (GlobalMembers.grm.underline != 0)
							{
								attribut |= FOREGROUND_INTENSITY;
							}
						}
						else
						{
							attribut = GlobalMembers.foregroundcolor[GlobalMembers.grm.foreground] | GlobalMembers.grm.bold | GlobalMembers.backgroundcolor[GlobalMembers.grm.background] | GlobalMembers.grm.underline;
						}
						if (GlobalMembers.grm.reverse != 0)
						{
							attribut = ((attribut >> 4) & 15) | ((attribut & 15) << 4);
						}
						SetConsoleTextAttribute(hConOut, attribut);
						return;

					case 'J':
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 0; // ESC[J == ESC[0J
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						switch (GlobalMembers.es_argv[0])
						{
								case 0: // ESC[0J erase from cursor to end of display
									len = (Info.dwSize.Y - Info.dwCursorPosition.Y - 1) * Info.dwSize.X + Info.dwSize.X - Info.dwCursorPosition.X - 1;
									FillConsoleOutputCharacter(hConOut, ' ', len, Info.dwCursorPosition, NumberOfCharsWritten);
									FillConsoleOutputAttribute(hConOut, Info.wAttributes, len, Info.dwCursorPosition, NumberOfCharsWritten);
									return;

								case 1: // ESC[1J erase from start to cursor.
									Pos.X = 0;
									Pos.Y = 0;
									len = Info.dwCursorPosition.Y * Info.dwSize.X + Info.dwCursorPosition.X + 1;
									FillConsoleOutputCharacter(hConOut, ' ', len, Pos, NumberOfCharsWritten);
									FillConsoleOutputAttribute(hConOut, Info.wAttributes, len, Pos, NumberOfCharsWritten);
									return;

								case 2: // ESC[2J Clear screen and home cursor
									Pos.X = 0;
									Pos.Y = 0;
									len = Info.dwSize.X * Info.dwSize.Y;
									FillConsoleOutputCharacter(hConOut, ' ', len, Pos, NumberOfCharsWritten);
									FillConsoleOutputAttribute(hConOut, Info.wAttributes, len, Pos, NumberOfCharsWritten);
									SetConsoleCursorPosition(hConOut, Pos);
									return;

								default:
									return;
						}

					case 'K':
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 0; // ESC[K == ESC[0K
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						switch (GlobalMembers.es_argv[0])
						{
								case 0: // ESC[0K Clear to end of line
									len = Info.dwSize.X - Info.dwCursorPosition.X + 1;
									FillConsoleOutputCharacter(hConOut, ' ', len, Info.dwCursorPosition, NumberOfCharsWritten);
									FillConsoleOutputAttribute(hConOut, Info.wAttributes, len, Info.dwCursorPosition, NumberOfCharsWritten);
									return;

								case 1: // ESC[1K Clear from start of line to cursor
									Pos.X = 0;
									Pos.Y = Info.dwCursorPosition.Y;
									FillConsoleOutputCharacter(hConOut, ' ', Info.dwCursorPosition.X + 1, Pos, NumberOfCharsWritten);
									FillConsoleOutputAttribute(hConOut, Info.wAttributes, Info.dwCursorPosition.X + 1, Pos, NumberOfCharsWritten);
									return;

								case 2: // ESC[2K Clear whole line.
									Pos.X = 0;
									Pos.Y = Info.dwCursorPosition.Y;
									FillConsoleOutputCharacter(hConOut, ' ', Info.dwSize.X, Pos, NumberOfCharsWritten);
									FillConsoleOutputAttribute(hConOut, Info.wAttributes, Info.dwSize.X, Pos, NumberOfCharsWritten);
									return;

								default:
									return;
						}

					case 'X': // ESC[#X Erase # characters.
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[X == ESC[1X
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						FillConsoleOutputCharacter(hConOut, ' ', GlobalMembers.es_argv[0], Info.dwCursorPosition, NumberOfCharsWritten);
						FillConsoleOutputAttribute(hConOut, Info.wAttributes, GlobalMembers.es_argv[0], Info.dwCursorPosition, NumberOfCharsWritten);
						return;

					case 'L': // ESC[#L Insert # blank lines.
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[L == ESC[1L
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						Rect.Left = 0;
						Rect.Top = Info.dwCursorPosition.Y;
						Rect.Right = Info.dwSize.X - 1;
						Rect.Bottom = Info.dwSize.Y - 1;
						Pos.X = 0;
						Pos.Y = Info.dwCursorPosition.Y + GlobalMembers.es_argv[0];
						CharInfo.Char.UnicodeChar = ' ';
						CharInfo.Attributes = Info.wAttributes;
						ScrollConsoleScreenBuffer(hConOut, Rect, null, Pos, CharInfo);
						return;

					case 'M': // ESC[#M Delete # lines.
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[M == ESC[1M
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						if (GlobalMembers.es_argv[0] > Info.dwSize.Y - Info.dwCursorPosition.Y)
						{
							GlobalMembers.es_argv[0] = Info.dwSize.Y - Info.dwCursorPosition.Y;
						}
						Rect.Left = 0;
						Rect.Top = Info.dwCursorPosition.Y + GlobalMembers.es_argv[0];
						Rect.Right = Info.dwSize.X - 1;
						Rect.Bottom = Info.dwSize.Y - 1;
						Pos.X = 0;
						Pos.Y = Info.dwCursorPosition.Y;
						CharInfo.Char.UnicodeChar = ' ';
						CharInfo.Attributes = Info.wAttributes;
						ScrollConsoleScreenBuffer(hConOut, Rect, null, Pos, CharInfo);
						return;

					case 'P': // ESC[#P Delete # characters.
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[P == ESC[1P
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						if (Info.dwCursorPosition.X + GlobalMembers.es_argv[0] > Info.dwSize.X - 1)
						{
							GlobalMembers.es_argv[0] = Info.dwSize.X - Info.dwCursorPosition.X;
						}
						Rect.Left = Info.dwCursorPosition.X + GlobalMembers.es_argv[0];
						Rect.Top = Info.dwCursorPosition.Y;
						Rect.Right = Info.dwSize.X - 1;
						Rect.Bottom = Info.dwCursorPosition.Y;
						CharInfo.Char.UnicodeChar = ' ';
						CharInfo.Attributes = Info.wAttributes;
						ScrollConsoleScreenBuffer(hConOut, Rect, null, Info.dwCursorPosition, CharInfo);
						return;

					case '@': // ESC[#@ Insert # blank characters.
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[@ == ESC[1@
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						if (Info.dwCursorPosition.X + GlobalMembers.es_argv[0] > Info.dwSize.X - 1)
						{
							GlobalMembers.es_argv[0] = Info.dwSize.X - Info.dwCursorPosition.X;
						}
						Rect.Left = Info.dwCursorPosition.X;
						Rect.Top = Info.dwCursorPosition.Y;
						Rect.Right = Info.dwSize.X - 1 - GlobalMembers.es_argv[0];
						Rect.Bottom = Info.dwCursorPosition.Y;
						Pos.X = Info.dwCursorPosition.X + GlobalMembers.es_argv[0];
						Pos.Y = Info.dwCursorPosition.Y;
						CharInfo.Char.UnicodeChar = ' ';
						CharInfo.Attributes = Info.wAttributes;
						ScrollConsoleScreenBuffer(hConOut, Rect, null, Pos, CharInfo);
						return;

					case 'k': // ESC[#k
					case 'A': // ESC[#A Moves cursor up # lines
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[A == ESC[1A
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						Pos.Y = Info.dwCursorPosition.Y - GlobalMembers.es_argv[0];
						if (Pos.Y < 0)
						{
							Pos.Y = 0;
						}
						Pos.X = Info.dwCursorPosition.X;
						SetConsoleCursorPosition(hConOut, Pos);
						return;

					case 'e': // ESC[#e
					case 'B': // ESC[#B Moves cursor down # lines
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[B == ESC[1B
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						Pos.Y = Info.dwCursorPosition.Y + GlobalMembers.es_argv[0];
						if (Pos.Y >= Info.dwSize.Y)
						{
							Pos.Y = Info.dwSize.Y - 1;
						}
						Pos.X = Info.dwCursorPosition.X;
						SetConsoleCursorPosition(hConOut, Pos);
						return;

					case 'a': // ESC[#a
					case 'C': // ESC[#C Moves cursor forward # spaces
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[C == ESC[1C
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						Pos.X = Info.dwCursorPosition.X + GlobalMembers.es_argv[0];
						if (Pos.X >= Info.dwSize.X)
						{
							Pos.X = Info.dwSize.X - 1;
						}
						Pos.Y = Info.dwCursorPosition.Y;
						SetConsoleCursorPosition(hConOut, Pos);
						return;

					case 'j': // ESC[#j
					case 'D': // ESC[#D Moves cursor back # spaces
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[D == ESC[1D
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						Pos.X = Info.dwCursorPosition.X - GlobalMembers.es_argv[0];
						if (Pos.X < 0)
						{
							Pos.X = 0;
						}
						Pos.Y = Info.dwCursorPosition.Y;
						SetConsoleCursorPosition(hConOut, Pos);
						return;

					case 'E': // ESC[#E Moves cursor down # lines, column 1.
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[E == ESC[1E
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						Pos.Y = Info.dwCursorPosition.Y + GlobalMembers.es_argv[0];
						if (Pos.Y >= Info.dwSize.Y)
						{
							Pos.Y = Info.dwSize.Y - 1;
						}
						Pos.X = 0;
						SetConsoleCursorPosition(hConOut, Pos);
						return;

					case 'F': // ESC[#F Moves cursor up # lines, column 1.
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[F == ESC[1F
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						Pos.Y = Info.dwCursorPosition.Y - GlobalMembers.es_argv[0];
						if (Pos.Y < 0)
						{
							Pos.Y = 0;
						}
						Pos.X = 0;
						SetConsoleCursorPosition(hConOut, Pos);
						return;

					case '`': // ESC[#`
					case 'G': // ESC[#G Moves cursor column # in current row.
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[G == ESC[1G
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						Pos.X = GlobalMembers.es_argv[0] - 1;
						if (Pos.X >= Info.dwSize.X)
						{
							Pos.X = Info.dwSize.X - 1;
						}
						if (Pos.X < 0)
						{
							Pos.X = 0;
						}
						Pos.Y = Info.dwCursorPosition.Y;
						SetConsoleCursorPosition(hConOut, Pos);
						return;

					case 'd': // ESC[#d Moves cursor row #, current column.
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[d == ESC[1d
						}
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						Pos.Y = GlobalMembers.es_argv[0] - 1;
						if (Pos.Y < 0)
						{
							Pos.Y = 0;
						}
						if (Pos.Y >= Info.dwSize.Y)
						{
							Pos.Y = Info.dwSize.Y - 1;
						}
						SetConsoleCursorPosition(hConOut, Pos);
						return;

					case 'f': // ESC[#;#f
					case 'H': // ESC[#;#H Moves cursor to line #, column #
						if (GlobalMembers.es_argc == 0)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[H == ESC[1;1H
						}
						if (GlobalMembers.es_argc == 1)
						{
							GlobalMembers.es_argv[GlobalMembers.es_argc++] = 1; // ESC[#H == ESC[#;1H
						}
						if (GlobalMembers.es_argc > 2)
						{
							return;
						}
						Pos.X = GlobalMembers.es_argv[1] - 1;
						if (Pos.X < 0)
						{
							Pos.X = 0;
						}
						if (Pos.X >= Info.dwSize.X)
						{
							Pos.X = Info.dwSize.X - 1;
						}
						Pos.Y = GlobalMembers.es_argv[0] - 1;
						if (Pos.Y < 0)
						{
							Pos.Y = 0;
						}
						if (Pos.Y >= Info.dwSize.Y)
						{
							Pos.Y = Info.dwSize.Y - 1;
						}
						SetConsoleCursorPosition(hConOut, Pos);
						return;

					case 's': // ESC[s Saves cursor position for recall later
						if (GlobalMembers.es_argc != 0)
						{
							return;
						}
						GlobalMembers.SavePos = Info.dwCursorPosition;
						return;

					case 'u': // ESC[u Return to saved cursor position
						if (GlobalMembers.es_argc != 0)
						{
							return;
						}
						SetConsoleCursorPosition(hConOut, GlobalMembers.SavePos);
						return;

					case 'n': // ESC[#n Device status report
						if (GlobalMembers.es_argc != 1)
						{
							return; // ESC[n == ESC[0n -> ignored
						}
						switch (GlobalMembers.es_argv[0])
						{
								case 5: // ESC[5n Report status
									ansi.GlobalMembers.SendSequence("\x001B[0n"); // "OK"
									return;

								case 6: // ESC[6n Report cursor position
								{
										string buf = new string(new char[32]);
										swprintf(buf, 32, "\x001B[%d;%dR", Info.dwCursorPosition.Y + 1, Info.dwCursorPosition.X + 1);
										ansi.GlobalMembers.SendSequence(buf);
								}
										return;

								default:
									return;
						}

					case 't': // ESC[#t Window manipulation
						if (GlobalMembers.es_argc != 1)
						{
							return;
						}
						if (GlobalMembers.es_argv[0] == 21) // ESC[21t Report xterm window's title
						{
							string buf = new string(new char[MAX_PATH * 2]);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: uint len = GetConsoleTitleW(buf + 3, (sizeof(buf)/sizeof(*(buf))) - 3 - 2);
							uint len = GetConsoleTitleW(buf.Substring(3), (buf.Length) - 3 - 2);
							// Too bad if it's too big or fails.
							buf = StringFunctions.ChangeCharacter(buf, 0, ESC);
							buf = StringFunctions.ChangeCharacter(buf, 1, ']');
							buf = StringFunctions.ChangeCharacter(buf, 2, 'l');
							buf = StringFunctions.ChangeCharacter(buf, 3 + len, ESC);
							buf = StringFunctions.ChangeCharacter(buf, 3 + len + 1, '\\');
							buf = StringFunctions.ChangeCharacter(buf, 3 + len + 2, '\0');
							ansi.GlobalMembers.SendSequence(buf);
						}
						return;

					default:
						return;
			}
		}
		else // (prefix == ']')
		{
			// Ignore any \e]? or \e]> sequences.
			if (GlobalMembers.prefix2 != 0)
			{
				return;
			}

			if (GlobalMembers.es_argc == 1 && GlobalMembers.es_argv[0] == 0) // ESC]0;titleST
			{
				SetConsoleTitleW(GlobalMembers.Pt_arg);
			}
		}
	}

	//-----------------------------------------------------------------------------
	//   ParseAndPrintANSIString(hDev, lpBuffer, nNumberOfBytesToWrite)
	// Parses the string lpBuffer, interprets the escapes sequences and prints the
	// characters in the device hDev (console).
	// The lexer is a three states automata.
	// If the number of arguments es_argc > MAX_ARG, only the MAX_ARG-1 firsts and
	// the last arguments are processed (no es_argv[] overflow).
	//-----------------------------------------------------------------------------

	public static int ParseAndPrintANSIString(IntPtr hDev, LPCVOID lpBuffer, uint nNumberOfBytesToWrite, ref uint lpNumberOfBytesWritten)
	{
		uint i;
		string s;

		if (hDev != hConOut) // reinit if device has changed
		{
			hConOut = hDev;
			GlobalMembers.state = 1;
			GlobalMembers.shifted = 0;
		}
		for (i = nNumberOfBytesToWrite, s = (string)lpBuffer; i > 0; i--, s++)
		{
			if (GlobalMembers.state == 1)
			{
				if (s == ESC)
				{
					GlobalMembers.state = 2;
				}
				else if (s == GlobalMembers.SO)
				{
					GlobalMembers.shifted = 1;
				}
				else if (s == GlobalMembers.SI)
				{
					GlobalMembers.shifted = 0;
				}
				else
				{
					ansi.GlobalMembers.PushBuffer(s);
				}
			}
			else if (GlobalMembers.state == 2)
			{
				if (s == ESC)
				{
					; // \e\e...\e == \e
				}
				else if ((s == '[') || (s == ']'))
				{
					ansi.GlobalMembers.FlushBuffer();
					GlobalMembers.prefix = s;
					GlobalMembers.prefix2 = 0;
					GlobalMembers.state = 3;
					GlobalMembers.Pt_len = 0;
					*GlobalMembers.Pt_arg = '\0';
				}
				else if (s == ')' || s == '(')
				{
					GlobalMembers.state = 6;
				}
				else
				{
					GlobalMembers.state = 1;
				}
			}
			else if (GlobalMembers.state == 3)
			{
				if (is_digit(s))
				{
					GlobalMembers.es_argc = 0;
					GlobalMembers.es_argv[0] = s - '0';
					GlobalMembers.state = 4;
				}
				else if (s == ';')
				{
					GlobalMembers.es_argc = 1;
					GlobalMembers.es_argv[0] = 0;
					GlobalMembers.es_argv[1] = 0;
					GlobalMembers.state = 4;
				}
				else if (s == '?' || s == '>')
				{
					GlobalMembers.prefix2 = s;
				}
				else
				{
					GlobalMembers.es_argc = 0;
					GlobalMembers.suffix = s;
					ansi.GlobalMembers.InterpretEscSeq();
					GlobalMembers.state = 1;
				}
			}
			else if (GlobalMembers.state == 4)
			{
				if (is_digit(s))
				{
					GlobalMembers.es_argv[GlobalMembers.es_argc] = 10 * GlobalMembers.es_argv[GlobalMembers.es_argc] + (s - '0');
				}
				else if (s == ';')
				{
					if (GlobalMembers.es_argc < GlobalMembers.MAX_ARG - 1)
					{
						GlobalMembers.es_argc++;
					}
					GlobalMembers.es_argv[GlobalMembers.es_argc] = 0;
					if (GlobalMembers.prefix == ']')
					{
						GlobalMembers.state = 5;
					}
				}
				else
				{
					GlobalMembers.es_argc++;
					GlobalMembers.suffix = s;
					ansi.GlobalMembers.InterpretEscSeq();
					GlobalMembers.state = 1;
				}
			}
			else if (GlobalMembers.state == 5)
			{
				if (s == BEL)
				{
					GlobalMembers.Pt_arg = StringFunctions.ChangeCharacter(GlobalMembers.Pt_arg, GlobalMembers.Pt_len, '\0');
					ansi.GlobalMembers.InterpretEscSeq();
					GlobalMembers.state = 1;
				}
				else if (s == '\\' && GlobalMembers.Pt_len > 0 && GlobalMembers.Pt_arg[GlobalMembers.Pt_len - 1] == ESC)
				{
					GlobalMembers.Pt_arg = StringFunctions.ChangeCharacter(GlobalMembers.Pt_arg, --GlobalMembers.Pt_len, '\0');
					ansi.GlobalMembers.InterpretEscSeq();
					GlobalMembers.state = 1;
				}
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: else if (Pt_len < (sizeof(Pt_arg)/sizeof(*(Pt_arg))) - 1)
				else if (GlobalMembers.Pt_len < (GlobalMembers.Pt_arg.Length) - 1)
				{
					GlobalMembers.Pt_arg = StringFunctions.ChangeCharacter(GlobalMembers.Pt_arg, GlobalMembers.Pt_len++, s);
				}
			}
			else if (GlobalMembers.state == 6)
			{
				// Ignore it (ESC ) 0 is implicit; nothing else is supported).
				GlobalMembers.state = 1;
			}
		}
		ansi.GlobalMembers.FlushBuffer();
		if (lpNumberOfBytesWritten != null)
		{
			lpNumberOfBytesWritten = nNumberOfBytesToWrite - i;
		}
		return (i == 0);
	}
	}
}

namespace linenoise
{
	public static class GlobalMembers
	{
	public static IntPtr hOut;
	public static IntPtr hIn;
	public static uint consolemodeIn = 0;

	public static int win32read(ref int c)
	{
		uint foo;
		INPUT_RECORD b = new INPUT_RECORD();
		KEY_EVENT_RECORD e = new KEY_EVENT_RECORD();
		int altgr;

		while (true)
		{
			if (!ReadConsoleInput(hIn, b, 1, foo))
			{
				return 0;
			}
			if (foo == 0)
			{
				return 0;
			}

			if (b.EventType == KEY_EVENT && b.Event.KeyEvent.bKeyDown)
			{

				e = b.Event.KeyEvent;
				c = b.Event.KeyEvent.uChar.AsciiChar;

				altgr = e.dwControlKeyState & (LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED);

				if (e.dwControlKeyState & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED) && altgr == 0)
				{

					/* Ctrl+Key */
					switch (c)
					{
						case 'D':
							c = 4;
							return 1;
						case 'C':
							c = 3;
							return 1;
						case 'H':
							c = 8;
							return 1;
						case 'T':
							c = 20;
							return 1;
						case 'B': // ctrl-b, left_arrow
							c = 2;
							return 1;
						case 'F': // ctrl-f right_arrow
							c = 6;
							return 1;
						case 'P': // ctrl-p up_arrow
							c = 16;
							return 1;
						case 'N': // ctrl-n down_arrow
							c = 14;
							return 1;
						case 'U': // Ctrl+u, delete the whole line.
							c = 21;
							return 1;
						case 'K': // Ctrl+k, delete from current to end of line.
							c = 11;
							return 1;
						case 'A': // Ctrl+a, go to the start of the line
							c = 1;
							return 1;
						case 'E': // ctrl+e, go to the end of the line
							c = 5;
							return 1;
					}

					/* Other Ctrl+KEYs ignored */
				}
				else
				{

					switch (e.wVirtualKeyCode)
					{

						case VK_ESCAPE: // ignore - send ctrl-c, will return -1
							c = 3;
							return 1;
						case VK_RETURN: // enter
							c = 13;
							return 1;
						case VK_LEFT: // left
							c = 2;
							return 1;
						case VK_RIGHT: // right
							c = 6;
							return 1;
						case VK_UP: // up
							c = 16;
							return 1;
						case VK_DOWN: // down
							c = 14;
							return 1;
						case VK_HOME:
							c = 1;
							return 1;
						case VK_END:
							c = 5;
							return 1;
						case VK_BACK:
							c = 8;
							return 1;
						case VK_DELETE:
							c = 127;
							return 1;
						default:
							if (c != 0)
							{
								return 1;
							}
					}
				}
			}
		}

		return -1; // Makes compiler happy
	}

	public static int win32_write(int fd, object buffer, uint count)
	{
		if (fd == _fileno(stdout))
		{
			uint bytesWritten = 0;
			if (0 != ansi.GlobalMembers.ParseAndPrintANSIString(GetStdHandle(STD_OUTPUT_HANDLE), buffer, (uint)count, ref bytesWritten))
			{
				return (int)bytesWritten;
			}
			else
			{
				errno = GetLastError();
				return 0;
			}
		}
		else if (fd == _fileno(stderr))
		{
			uint bytesWritten = 0;
			if (0 != ansi.GlobalMembers.ParseAndPrintANSIString(GetStdHandle(STD_ERROR_HANDLE), buffer, (uint)count, ref bytesWritten))
			{
				return (int)bytesWritten;
			}
			else
			{
				errno = GetLastError();
				return 0;
			}
		}
		else
		{
			return _write(fd, buffer, count);
		}
	}
#endif

	internal string[] unsupported_term = {"dumb", "cons25", "emacs", null};
	internal static CompletionCallback completionCallback;

	#if ! _WIN32
	internal static termios orig_termios = new termios(); // In order to restore at exit.
	#endif
	internal static bool rawmode = false; // For atexit() function to check if restore is needed
	internal static bool mlmode = false; // Multi line mode. Default is single line.
	internal static bool atexit_registered = false; // Register atexit just 1 time.
	internal static uint history_max_len = DefineConstants.LINENOISE_DEFAULT_HISTORY_MAX_LEN;
	internal static List<string> history = new List<string>();

/* ================================ History ================================= */

/* At exit we'll try to fix the terminal to the initial conditions. */

	public static void linenoiseAtExit()
	{
		disableRawMode((_fileno(stdin)));
	}

/* This is the API call to add a new entry in the linenoise history.
 * It uses a fixed array of char pointers that are shifted (memmoved)
 * when the history max length is reached in order to remove the older
 * entry and make room for the new one, so it is not exactly suitable for huge
 * histories, but will work well for a few hundred of entries.
 *
 * Using a circular buffer is smarter, but a bit more complex to handle. */
	public static bool AddHistory(string line)
	{
		if (history_max_len == 0)
		{
			return false;
		}

		/* Don't add duplicated lines. */
		if (history.Count > 0 && history[history.Count - 1] == line)
		{
			return false;
		}

		/* If we reached the max length, remove the older line. */
		if (history.Count == history_max_len)
		{
//C++ TO C# CONVERTER TODO TASK: There is no direct equivalent to the STL vector 'erase' method in C#:
			history.erase(history.GetEnumerator());
		}
		history.Add(line);

		return true;
	}

/* Calls the two low level functions refreshSingleLine() or
 * refreshMultiLine() according to the selected mode. */
	public static void refreshLine(linenoiseState l)
	{
		if (mlmode)
		{
			refreshMultiLine(l);
		}
		else
		{
			refreshSingleLine(l);
		}
	}

	/* ============================ UTF8 utilities ============================== */

	internal static uint[,] unicodeWideCharTable =
	{
		{0x1100, 0x115F},
		{0x2329, 0x232A},
		{0x2E80, 0x2E99},
		{0x2E9B, 0x2EF3},
		{0x2F00, 0x2FD5},
		{0x2FF0, 0x2FFB},
		{0x3000, 0x303E},
		{0x3041, 0x3096},
		{0x3099, 0x30FF},
		{0x3105, 0x312D},
		{0x3131, 0x318E},
		{0x3190, 0x31BA},
		{0x31C0, 0x31E3},
		{0x31F0, 0x321E},
		{0x3220, 0x3247},
		{0x3250, 0x4DBF},
		{0x4E00, 0xA48C},
		{0xA490, 0xA4C6},
		{0xA960, 0xA97C},
		{0xAC00, 0xD7A3},
		{0xF900, 0xFAFF},
		{0xFE10, 0xFE19},
		{0xFE30, 0xFE52},
		{0xFE54, 0xFE66},
		{0xFE68, 0xFE6B},
		{0xFF01, 0xFFE6},
		{0x1B000, 0x1B001},
		{0x1F200, 0x1F202},
		{0x1F210, 0x1F23A},
		{0x1F240, 0x1F248},
		{0x1F250, 0x1F251},
		{0x20000, 0x3FFFD}
	};

//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: static int unicodeWideCharTableSize = sizeof(unicodeWideCharTable) / sizeof(unicodeWideCharTable[0]);
	internal static int unicodeWideCharTableSize = unicodeWideCharTable.Length;

	internal static int unicodeIsWideChar(uint cp)
	{
		int i;
		for (i = 0; i < unicodeWideCharTableSize; i++)
		{
			if (unicodeWideCharTable[i, 0] <= cp != 0 && cp <= unicodeWideCharTable[i, 1])
			{
				return 1;
			}
		}
		return 0;
	}

	internal static uint[] unicodeCombiningCharTable = {0x0300, 0x0301, 0x0302, 0x0303, 0x0304, 0x0305, 0x0306, 0x0307, 0x0308, 0x0309, 0x030A, 0x030B, 0x030C, 0x030D, 0x030E, 0x030F, 0x0310, 0x0311, 0x0312, 0x0313, 0x0314, 0x0315, 0x0316, 0x0317, 0x0318, 0x0319, 0x031A, 0x031B, 0x031C, 0x031D, 0x031E, 0x031F, 0x0320, 0x0321, 0x0322, 0x0323, 0x0324, 0x0325, 0x0326, 0x0327, 0x0328, 0x0329, 0x032A, 0x032B, 0x032C, 0x032D, 0x032E, 0x032F, 0x0330, 0x0331, 0x0332, 0x0333, 0x0334, 0x0335, 0x0336, 0x0337, 0x0338, 0x0339, 0x033A, 0x033B, 0x033C, 0x033D, 0x033E, 0x033F, 0x0340, 0x0341, 0x0342, 0x0343, 0x0344, 0x0345, 0x0346, 0x0347, 0x0348, 0x0349, 0x034A, 0x034B, 0x034C, 0x034D, 0x034E, 0x034F, 0x0350, 0x0351, 0x0352, 0x0353, 0x0354, 0x0355, 0x0356, 0x0357, 0x0358, 0x0359, 0x035A, 0x035B, 0x035C, 0x035D, 0x035E, 0x035F, 0x0360, 0x0361, 0x0362, 0x0363, 0x0364, 0x0365, 0x0366, 0x0367, 0x0368, 0x0369, 0x036A, 0x036B, 0x036C, 0x036D, 0x036E, 0x036F, 0x0483, 0x0484, 0x0485, 0x0486, 0x0487, 0x0591, 0x0592, 0x0593, 0x0594, 0x0595, 0x0596, 0x0597, 0x0598, 0x0599, 0x059A, 0x059B, 0x059C, 0x059D, 0x059E, 0x059F, 0x05A0, 0x05A1, 0x05A2, 0x05A3, 0x05A4, 0x05A5, 0x05A6, 0x05A7, 0x05A8, 0x05A9, 0x05AA, 0x05AB, 0x05AC, 0x05AD, 0x05AE, 0x05AF, 0x05B0, 0x05B1, 0x05B2, 0x05B3, 0x05B4, 0x05B5, 0x05B6, 0x05B7, 0x05B8, 0x05B9, 0x05BA, 0x05BB, 0x05BC, 0x05BD, 0x05BF, 0x05C1, 0x05C2, 0x05C4, 0x05C5, 0x05C7, 0x0610, 0x0611, 0x0612, 0x0613, 0x0614, 0x0615, 0x0616, 0x0617, 0x0618, 0x0619, 0x061A, 0x064B, 0x064C, 0x064D, 0x064E, 0x064F, 0x0650, 0x0651, 0x0652, 0x0653, 0x0654, 0x0655, 0x0656, 0x0657, 0x0658, 0x0659, 0x065A, 0x065B, 0x065C, 0x065D, 0x065E, 0x065F, 0x0670, 0x06D6, 0x06D7, 0x06D8, 0x06D9, 0x06DA, 0x06DB, 0x06DC, 0x06DF, 0x06E0, 0x06E1, 0x06E2, 0x06E3, 0x06E4, 0x06E7, 0x06E8, 0x06EA, 0x06EB, 0x06EC, 0x06ED, 0x0711, 0x0730, 0x0731, 0x0732, 0x0733, 0x0734, 0x0735, 0x0736, 0x0737, 0x0738, 0x0739, 0x073A, 0x073B, 0x073C, 0x073D, 0x073E, 0x073F, 0x0740, 0x0741, 0x0742, 0x0743, 0x0744, 0x0745, 0x0746, 0x0747, 0x0748, 0x0749, 0x074A, 0x07A6, 0x07A7, 0x07A8, 0x07A9, 0x07AA, 0x07AB, 0x07AC, 0x07AD, 0x07AE, 0x07AF, 0x07B0, 0x07EB, 0x07EC, 0x07ED, 0x07EE, 0x07EF, 0x07F0, 0x07F1, 0x07F2, 0x07F3, 0x0816, 0x0817, 0x0818, 0x0819, 0x081B, 0x081C, 0x081D, 0x081E, 0x081F, 0x0820, 0x0821, 0x0822, 0x0823, 0x0825, 0x0826, 0x0827, 0x0829, 0x082A, 0x082B, 0x082C, 0x082D, 0x0859, 0x085A, 0x085B, 0x08E3, 0x08E4, 0x08E5, 0x08E6, 0x08E7, 0x08E8, 0x08E9, 0x08EA, 0x08EB, 0x08EC, 0x08ED, 0x08EE, 0x08EF, 0x08F0, 0x08F1, 0x08F2, 0x08F3, 0x08F4, 0x08F5, 0x08F6, 0x08F7, 0x08F8, 0x08F9, 0x08FA, 0x08FB, 0x08FC, 0x08FD, 0x08FE, 0x08FF, 0x0900, 0x0901, 0x0902, 0x093A, 0x093C, 0x0941, 0x0942, 0x0943, 0x0944, 0x0945, 0x0946, 0x0947, 0x0948, 0x094D, 0x0951, 0x0952, 0x0953, 0x0954, 0x0955, 0x0956, 0x0957, 0x0962, 0x0963, 0x0981, 0x09BC, 0x09C1, 0x09C2, 0x09C3, 0x09C4, 0x09CD, 0x09E2, 0x09E3, 0x0A01, 0x0A02, 0x0A3C, 0x0A41, 0x0A42, 0x0A47, 0x0A48, 0x0A4B, 0x0A4C, 0x0A4D, 0x0A51, 0x0A70, 0x0A71, 0x0A75, 0x0A81, 0x0A82, 0x0ABC, 0x0AC1, 0x0AC2, 0x0AC3, 0x0AC4, 0x0AC5, 0x0AC7, 0x0AC8, 0x0ACD, 0x0AE2, 0x0AE3, 0x0B01, 0x0B3C, 0x0B3F, 0x0B41, 0x0B42, 0x0B43, 0x0B44, 0x0B4D, 0x0B56, 0x0B62, 0x0B63, 0x0B82, 0x0BC0, 0x0BCD, 0x0C00, 0x0C3E, 0x0C3F, 0x0C40, 0x0C46, 0x0C47, 0x0C48, 0x0C4A, 0x0C4B, 0x0C4C, 0x0C4D, 0x0C55, 0x0C56, 0x0C62, 0x0C63, 0x0C81, 0x0CBC, 0x0CBF, 0x0CC6, 0x0CCC, 0x0CCD, 0x0CE2, 0x0CE3, 0x0D01, 0x0D41, 0x0D42, 0x0D43, 0x0D44, 0x0D4D, 0x0D62, 0x0D63, 0x0DCA, 0x0DD2, 0x0DD3, 0x0DD4, 0x0DD6, 0x0E31, 0x0E34, 0x0E35, 0x0E36, 0x0E37, 0x0E38, 0x0E39, 0x0E3A, 0x0E47, 0x0E48, 0x0E49, 0x0E4A, 0x0E4B, 0x0E4C, 0x0E4D, 0x0E4E, 0x0EB1, 0x0EB4, 0x0EB5, 0x0EB6, 0x0EB7, 0x0EB8, 0x0EB9, 0x0EBB, 0x0EBC, 0x0EC8, 0x0EC9, 0x0ECA, 0x0ECB, 0x0ECC, 0x0ECD, 0x0F18, 0x0F19, 0x0F35, 0x0F37, 0x0F39, 0x0F71, 0x0F72, 0x0F73, 0x0F74, 0x0F75, 0x0F76, 0x0F77, 0x0F78, 0x0F79, 0x0F7A, 0x0F7B, 0x0F7C, 0x0F7D, 0x0F7E, 0x0F80, 0x0F81, 0x0F82, 0x0F83, 0x0F84, 0x0F86, 0x0F87, 0x0F8D, 0x0F8E, 0x0F8F, 0x0F90, 0x0F91, 0x0F92, 0x0F93, 0x0F94, 0x0F95, 0x0F96, 0x0F97, 0x0F99, 0x0F9A, 0x0F9B, 0x0F9C, 0x0F9D, 0x0F9E, 0x0F9F, 0x0FA0, 0x0FA1, 0x0FA2, 0x0FA3, 0x0FA4, 0x0FA5, 0x0FA6, 0x0FA7, 0x0FA8, 0x0FA9, 0x0FAA, 0x0FAB, 0x0FAC, 0x0FAD, 0x0FAE, 0x0FAF, 0x0FB0, 0x0FB1, 0x0FB2, 0x0FB3, 0x0FB4, 0x0FB5, 0x0FB6, 0x0FB7, 0x0FB8, 0x0FB9, 0x0FBA, 0x0FBB, 0x0FBC, 0x0FC6, 0x102D, 0x102E, 0x102F, 0x1030, 0x1032, 0x1033, 0x1034, 0x1035, 0x1036, 0x1037, 0x1039, 0x103A, 0x103D, 0x103E, 0x1058, 0x1059, 0x105E, 0x105F, 0x1060, 0x1071, 0x1072, 0x1073, 0x1074, 0x1082, 0x1085, 0x1086, 0x108D, 0x109D, 0x135D, 0x135E, 0x135F, 0x1712, 0x1713, 0x1714, 0x1732, 0x1733, 0x1734, 0x1752, 0x1753, 0x1772, 0x1773, 0x17B4, 0x17B5, 0x17B7, 0x17B8, 0x17B9, 0x17BA, 0x17BB, 0x17BC, 0x17BD, 0x17C6, 0x17C9, 0x17CA, 0x17CB, 0x17CC, 0x17CD, 0x17CE, 0x17CF, 0x17D0, 0x17D1, 0x17D2, 0x17D3, 0x17DD, 0x180B, 0x180C, 0x180D, 0x18A9, 0x1920, 0x1921, 0x1922, 0x1927, 0x1928, 0x1932, 0x1939, 0x193A, 0x193B, 0x1A17, 0x1A18, 0x1A1B, 0x1A56, 0x1A58, 0x1A59, 0x1A5A, 0x1A5B, 0x1A5C, 0x1A5D, 0x1A5E, 0x1A60, 0x1A62, 0x1A65, 0x1A66, 0x1A67, 0x1A68, 0x1A69, 0x1A6A, 0x1A6B, 0x1A6C, 0x1A73, 0x1A74, 0x1A75, 0x1A76, 0x1A77, 0x1A78, 0x1A79, 0x1A7A, 0x1A7B, 0x1A7C, 0x1A7F, 0x1AB0, 0x1AB1, 0x1AB2, 0x1AB3, 0x1AB4, 0x1AB5, 0x1AB6, 0x1AB7, 0x1AB8, 0x1AB9, 0x1ABA, 0x1ABB, 0x1ABC, 0x1ABD, 0x1B00, 0x1B01, 0x1B02, 0x1B03, 0x1B34, 0x1B36, 0x1B37, 0x1B38, 0x1B39, 0x1B3A, 0x1B3C, 0x1B42, 0x1B6B, 0x1B6C, 0x1B6D, 0x1B6E, 0x1B6F, 0x1B70, 0x1B71, 0x1B72, 0x1B73, 0x1B80, 0x1B81, 0x1BA2, 0x1BA3, 0x1BA4, 0x1BA5, 0x1BA8, 0x1BA9, 0x1BAB, 0x1BAC, 0x1BAD, 0x1BE6, 0x1BE8, 0x1BE9, 0x1BED, 0x1BEF, 0x1BF0, 0x1BF1, 0x1C2C, 0x1C2D, 0x1C2E, 0x1C2F, 0x1C30, 0x1C31, 0x1C32, 0x1C33, 0x1C36, 0x1C37, 0x1CD0, 0x1CD1, 0x1CD2, 0x1CD4, 0x1CD5, 0x1CD6, 0x1CD7, 0x1CD8, 0x1CD9, 0x1CDA, 0x1CDB, 0x1CDC, 0x1CDD, 0x1CDE, 0x1CDF, 0x1CE0, 0x1CE2, 0x1CE3, 0x1CE4, 0x1CE5, 0x1CE6, 0x1CE7, 0x1CE8, 0x1CED, 0x1CF4, 0x1CF8, 0x1CF9, 0x1DC0, 0x1DC1, 0x1DC2, 0x1DC3, 0x1DC4, 0x1DC5, 0x1DC6, 0x1DC7, 0x1DC8, 0x1DC9, 0x1DCA, 0x1DCB, 0x1DCC, 0x1DCD, 0x1DCE, 0x1DCF, 0x1DD0, 0x1DD1, 0x1DD2, 0x1DD3, 0x1DD4, 0x1DD5, 0x1DD6, 0x1DD7, 0x1DD8, 0x1DD9, 0x1DDA, 0x1DDB, 0x1DDC, 0x1DDD, 0x1DDE, 0x1DDF, 0x1DE0, 0x1DE1, 0x1DE2, 0x1DE3, 0x1DE4, 0x1DE5, 0x1DE6, 0x1DE7, 0x1DE8, 0x1DE9, 0x1DEA, 0x1DEB, 0x1DEC, 0x1DED, 0x1DEE, 0x1DEF, 0x1DF0, 0x1DF1, 0x1DF2, 0x1DF3, 0x1DF4, 0x1DF5, 0x1DFC, 0x1DFD, 0x1DFE, 0x1DFF, 0x20D0, 0x20D1, 0x20D2, 0x20D3, 0x20D4, 0x20D5, 0x20D6, 0x20D7, 0x20D8, 0x20D9, 0x20DA, 0x20DB, 0x20DC, 0x20E1, 0x20E5, 0x20E6, 0x20E7, 0x20E8, 0x20E9, 0x20EA, 0x20EB, 0x20EC, 0x20ED, 0x20EE, 0x20EF, 0x20F0, 0x2CEF, 0x2CF0, 0x2CF1, 0x2D7F, 0x2DE0, 0x2DE1, 0x2DE2, 0x2DE3, 0x2DE4, 0x2DE5, 0x2DE6, 0x2DE7, 0x2DE8, 0x2DE9, 0x2DEA, 0x2DEB, 0x2DEC, 0x2DED, 0x2DEE, 0x2DEF, 0x2DF0, 0x2DF1, 0x2DF2, 0x2DF3, 0x2DF4, 0x2DF5, 0x2DF6, 0x2DF7, 0x2DF8, 0x2DF9, 0x2DFA, 0x2DFB, 0x2DFC, 0x2DFD, 0x2DFE, 0x2DFF, 0x302A, 0x302B, 0x302C, 0x302D, 0x3099, 0x309A, 0xA66F, 0xA674, 0xA675, 0xA676, 0xA677, 0xA678, 0xA679, 0xA67A, 0xA67B, 0xA67C, 0xA67D, 0xA69E, 0xA69F, 0xA6F0, 0xA6F1, 0xA802, 0xA806, 0xA80B, 0xA825, 0xA826, 0xA8C4, 0xA8E0, 0xA8E1, 0xA8E2, 0xA8E3, 0xA8E4, 0xA8E5, 0xA8E6, 0xA8E7, 0xA8E8, 0xA8E9, 0xA8EA, 0xA8EB, 0xA8EC, 0xA8ED, 0xA8EE, 0xA8EF, 0xA8F0, 0xA8F1, 0xA926, 0xA927, 0xA928, 0xA929, 0xA92A, 0xA92B, 0xA92C, 0xA92D, 0xA947, 0xA948, 0xA949, 0xA94A, 0xA94B, 0xA94C, 0xA94D, 0xA94E, 0xA94F, 0xA950, 0xA951, 0xA980, 0xA981, 0xA982, 0xA9B3, 0xA9B6, 0xA9B7, 0xA9B8, 0xA9B9, 0xA9BC, 0xA9E5, 0xAA29, 0xAA2A, 0xAA2B, 0xAA2C, 0xAA2D, 0xAA2E, 0xAA31, 0xAA32, 0xAA35, 0xAA36, 0xAA43, 0xAA4C, 0xAA7C, 0xAAB0, 0xAAB2, 0xAAB3, 0xAAB4, 0xAAB7, 0xAAB8, 0xAABE, 0xAABF, 0xAAC1, 0xAAEC, 0xAAED, 0xAAF6, 0xABE5, 0xABE8, 0xABED, 0xFB1E, 0xFE00, 0xFE01, 0xFE02, 0xFE03, 0xFE04, 0xFE05, 0xFE06, 0xFE07, 0xFE08, 0xFE09, 0xFE0A, 0xFE0B, 0xFE0C, 0xFE0D, 0xFE0E, 0xFE0F, 0xFE20, 0xFE21, 0xFE22, 0xFE23, 0xFE24, 0xFE25, 0xFE26, 0xFE27, 0xFE28, 0xFE29, 0xFE2A, 0xFE2B, 0xFE2C, 0xFE2D, 0xFE2E, 0xFE2F, 0x101FD, 0x102E0, 0x10376, 0x10377, 0x10378, 0x10379, 0x1037A, 0x10A01, 0x10A02, 0x10A03, 0x10A05, 0x10A06, 0x10A0C, 0x10A0D, 0x10A0E, 0x10A0F, 0x10A38, 0x10A39, 0x10A3A, 0x10A3F, 0x10AE5, 0x10AE6, 0x11001, 0x11038, 0x11039, 0x1103A, 0x1103B, 0x1103C, 0x1103D, 0x1103E, 0x1103F, 0x11040, 0x11041, 0x11042, 0x11043, 0x11044, 0x11045, 0x11046, 0x1107F, 0x11080, 0x11081, 0x110B3, 0x110B4, 0x110B5, 0x110B6, 0x110B9, 0x110BA, 0x11100, 0x11101, 0x11102, 0x11127, 0x11128, 0x11129, 0x1112A, 0x1112B, 0x1112D, 0x1112E, 0x1112F, 0x11130, 0x11131, 0x11132, 0x11133, 0x11134, 0x11173, 0x11180, 0x11181, 0x111B6, 0x111B7, 0x111B8, 0x111B9, 0x111BA, 0x111BB, 0x111BC, 0x111BD, 0x111BE, 0x111CA, 0x111CB, 0x111CC, 0x1122F, 0x11230, 0x11231, 0x11234, 0x11236, 0x11237, 0x112DF, 0x112E3, 0x112E4, 0x112E5, 0x112E6, 0x112E7, 0x112E8, 0x112E9, 0x112EA, 0x11300, 0x11301, 0x1133C, 0x11340, 0x11366, 0x11367, 0x11368, 0x11369, 0x1136A, 0x1136B, 0x1136C, 0x11370, 0x11371, 0x11372, 0x11373, 0x11374, 0x114B3, 0x114B4, 0x114B5, 0x114B6, 0x114B7, 0x114B8, 0x114BA, 0x114BF, 0x114C0, 0x114C2, 0x114C3, 0x115B2, 0x115B3, 0x115B4, 0x115B5, 0x115BC, 0x115BD, 0x115BF, 0x115C0, 0x115DC, 0x115DD, 0x11633, 0x11634, 0x11635, 0x11636, 0x11637, 0x11638, 0x11639, 0x1163A, 0x1163D, 0x1163F, 0x11640, 0x116AB, 0x116AD, 0x116B0, 0x116B1, 0x116B2, 0x116B3, 0x116B4, 0x116B5, 0x116B7, 0x1171D, 0x1171E, 0x1171F, 0x11722, 0x11723, 0x11724, 0x11725, 0x11727, 0x11728, 0x11729, 0x1172A, 0x1172B, 0x16AF0, 0x16AF1, 0x16AF2, 0x16AF3, 0x16AF4, 0x16B30, 0x16B31, 0x16B32, 0x16B33, 0x16B34, 0x16B35, 0x16B36, 0x16F8F, 0x16F90, 0x16F91, 0x16F92, 0x1BC9D, 0x1BC9E, 0x1D167, 0x1D168, 0x1D169, 0x1D17B, 0x1D17C, 0x1D17D, 0x1D17E, 0x1D17F, 0x1D180, 0x1D181, 0x1D182, 0x1D185, 0x1D186, 0x1D187, 0x1D188, 0x1D189, 0x1D18A, 0x1D18B, 0x1D1AA, 0x1D1AB, 0x1D1AC, 0x1D1AD, 0x1D242, 0x1D243, 0x1D244, 0x1DA00, 0x1DA01, 0x1DA02, 0x1DA03, 0x1DA04, 0x1DA05, 0x1DA06, 0x1DA07, 0x1DA08, 0x1DA09, 0x1DA0A, 0x1DA0B, 0x1DA0C, 0x1DA0D, 0x1DA0E, 0x1DA0F, 0x1DA10, 0x1DA11, 0x1DA12, 0x1DA13, 0x1DA14, 0x1DA15, 0x1DA16, 0x1DA17, 0x1DA18, 0x1DA19, 0x1DA1A, 0x1DA1B, 0x1DA1C, 0x1DA1D, 0x1DA1E, 0x1DA1F, 0x1DA20, 0x1DA21, 0x1DA22, 0x1DA23, 0x1DA24, 0x1DA25, 0x1DA26, 0x1DA27, 0x1DA28, 0x1DA29, 0x1DA2A, 0x1DA2B, 0x1DA2C, 0x1DA2D, 0x1DA2E, 0x1DA2F, 0x1DA30, 0x1DA31, 0x1DA32, 0x1DA33, 0x1DA34, 0x1DA35, 0x1DA36, 0x1DA3B, 0x1DA3C, 0x1DA3D, 0x1DA3E, 0x1DA3F, 0x1DA40, 0x1DA41, 0x1DA42, 0x1DA43, 0x1DA44, 0x1DA45, 0x1DA46, 0x1DA47, 0x1DA48, 0x1DA49, 0x1DA4A, 0x1DA4B, 0x1DA4C, 0x1DA4D, 0x1DA4E, 0x1DA4F, 0x1DA50, 0x1DA51, 0x1DA52, 0x1DA53, 0x1DA54, 0x1DA55, 0x1DA56, 0x1DA57, 0x1DA58, 0x1DA59, 0x1DA5A, 0x1DA5B, 0x1DA5C, 0x1DA5D, 0x1DA5E, 0x1DA5F, 0x1DA60, 0x1DA61, 0x1DA62, 0x1DA63, 0x1DA64, 0x1DA65, 0x1DA66, 0x1DA67, 0x1DA68, 0x1DA69, 0x1DA6A, 0x1DA6B, 0x1DA6C, 0x1DA75, 0x1DA84, 0x1DA9B, 0x1DA9C, 0x1DA9D, 0x1DA9E, 0x1DA9F, 0x1DAA1, 0x1DAA2, 0x1DAA3, 0x1DAA4, 0x1DAA5, 0x1DAA6, 0x1DAA7, 0x1DAA8, 0x1DAA9, 0x1DAAA, 0x1DAAB, 0x1DAAC, 0x1DAAD, 0x1DAAE, 0x1DAAF, 0x1E8D0, 0x1E8D1, 0x1E8D2, 0x1E8D3, 0x1E8D4, 0x1E8D5, 0x1E8D6, 0xE0100, 0xE0101, 0xE0102, 0xE0103, 0xE0104, 0xE0105, 0xE0106, 0xE0107, 0xE0108, 0xE0109, 0xE010A, 0xE010B, 0xE010C, 0xE010D, 0xE010E, 0xE010F, 0xE0110, 0xE0111, 0xE0112, 0xE0113, 0xE0114, 0xE0115, 0xE0116, 0xE0117, 0xE0118, 0xE0119, 0xE011A, 0xE011B, 0xE011C, 0xE011D, 0xE011E, 0xE011F, 0xE0120, 0xE0121, 0xE0122, 0xE0123, 0xE0124, 0xE0125, 0xE0126, 0xE0127, 0xE0128, 0xE0129, 0xE012A, 0xE012B, 0xE012C, 0xE012D, 0xE012E, 0xE012F, 0xE0130, 0xE0131, 0xE0132, 0xE0133, 0xE0134, 0xE0135, 0xE0136, 0xE0137, 0xE0138, 0xE0139, 0xE013A, 0xE013B, 0xE013C, 0xE013D, 0xE013E, 0xE013F, 0xE0140, 0xE0141, 0xE0142, 0xE0143, 0xE0144, 0xE0145, 0xE0146, 0xE0147, 0xE0148, 0xE0149, 0xE014A, 0xE014B, 0xE014C, 0xE014D, 0xE014E, 0xE014F, 0xE0150, 0xE0151, 0xE0152, 0xE0153, 0xE0154, 0xE0155, 0xE0156, 0xE0157, 0xE0158, 0xE0159, 0xE015A, 0xE015B, 0xE015C, 0xE015D, 0xE015E, 0xE015F, 0xE0160, 0xE0161, 0xE0162, 0xE0163, 0xE0164, 0xE0165, 0xE0166, 0xE0167, 0xE0168, 0xE0169, 0xE016A, 0xE016B, 0xE016C, 0xE016D, 0xE016E, 0xE016F, 0xE0170, 0xE0171, 0xE0172, 0xE0173, 0xE0174, 0xE0175, 0xE0176, 0xE0177, 0xE0178, 0xE0179, 0xE017A, 0xE017B, 0xE017C, 0xE017D, 0xE017E, 0xE017F, 0xE0180, 0xE0181, 0xE0182, 0xE0183, 0xE0184, 0xE0185, 0xE0186, 0xE0187, 0xE0188, 0xE0189, 0xE018A, 0xE018B, 0xE018C, 0xE018D, 0xE018E, 0xE018F, 0xE0190, 0xE0191, 0xE0192, 0xE0193, 0xE0194, 0xE0195, 0xE0196, 0xE0197, 0xE0198, 0xE0199, 0xE019A, 0xE019B, 0xE019C, 0xE019D, 0xE019E, 0xE019F, 0xE01A0, 0xE01A1, 0xE01A2, 0xE01A3, 0xE01A4, 0xE01A5, 0xE01A6, 0xE01A7, 0xE01A8, 0xE01A9, 0xE01AA, 0xE01AB, 0xE01AC, 0xE01AD, 0xE01AE, 0xE01AF, 0xE01B0, 0xE01B1, 0xE01B2, 0xE01B3, 0xE01B4, 0xE01B5, 0xE01B6, 0xE01B7, 0xE01B8, 0xE01B9, 0xE01BA, 0xE01BB, 0xE01BC, 0xE01BD, 0xE01BE, 0xE01BF, 0xE01C0, 0xE01C1, 0xE01C2, 0xE01C3, 0xE01C4, 0xE01C5, 0xE01C6, 0xE01C7, 0xE01C8, 0xE01C9, 0xE01CA, 0xE01CB, 0xE01CC, 0xE01CD, 0xE01CE, 0xE01CF, 0xE01D0, 0xE01D1, 0xE01D2, 0xE01D3, 0xE01D4, 0xE01D5, 0xE01D6, 0xE01D7, 0xE01D8, 0xE01D9, 0xE01DA, 0xE01DB, 0xE01DC, 0xE01DD, 0xE01DE, 0xE01DF, 0xE01E0, 0xE01E1, 0xE01E2, 0xE01E3, 0xE01E4, 0xE01E5, 0xE01E6, 0xE01E7, 0xE01E8, 0xE01E9, 0xE01EA, 0xE01EB, 0xE01EC, 0xE01ED, 0xE01EE, 0xE01EF};

//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: static int unicodeCombiningCharTableSize = sizeof(unicodeCombiningCharTable) / sizeof(unicodeCombiningCharTable[0]);
	internal static int unicodeCombiningCharTableSize = unicodeCombiningCharTable.Length;

	public static int unicodeIsCombiningChar(uint cp)
	{
		int i;
		for (i = 0; i < unicodeCombiningCharTableSize; i++)
		{
			if (unicodeCombiningCharTable[i] == cp)
			{
				return 1;
			}
		}
		return 0;
	}

	/* Get length of previous UTF8 character
	 */
	public static int unicodePrevUTF8CharLen(ref string buf, int pos)
	{
		int end = pos--;
		while (pos >= 0 && ((byte)buf[pos] & 0xC0) == 0x80)
		{
			pos--;
		}
		return end - pos;
	}

	/* Get length of previous UTF8 character
	 */
	public static int unicodeUTF8CharLen(ref string buf, int buf_len, int pos)
	{
		if (pos == buf_len)
		{
			return 0;
		}
		byte ch = buf[pos];
		if (ch < 0x80)
		{
			return 1;
		}
		else if (ch < 0xE0)
		{
			return 2;
		}
		else if (ch < 0xF0)
		{
			return 3;
		}
		else
		{
			return 4;
		}
	}

	/* Convert UTF8 to Unicode code point
	 */
	public static int unicodeUTF8CharToCodePoint(string buf, int len, ref int cp)
	{
		if (len != 0)
		{
			byte @byte = buf[0];
			if ((byte & 0x80) == 0)
			{
				cp = byte;
				return 1;
			}
			else if ((byte & 0xE0) == 0xC0)
			{
				if (len >= 2)
				{
					cp = (((uint)(buf[0] & 0x1F)) << 6) | ((uint)(buf[1] & 0x3F));
					return 2;
				}
			}
			else if ((byte & 0xF0) == 0xE0)
			{
				if (len >= 3)
				{
					cp = (((uint)(buf[0] & 0x0F)) << 12) | (((uint)(buf[1] & 0x3F)) << 6) | ((uint)(buf[2] & 0x3F));
					return 3;
				}
			}
			else if ((byte & 0xF8) == 0xF0)
			{
				if (len >= 4)
				{
					cp = (((uint)(buf[0] & 0x07)) << 18) | (((uint)(buf[1] & 0x3F)) << 12) | (((uint)(buf[2] & 0x3F)) << 6) | ((uint)(buf[3] & 0x3F));
					return 4;
				}
			}
		}
		return 0;
	}

	/* Get length of grapheme
	 */
	public static int unicodeGraphemeLen(ref string buf, int buf_len, int pos)
	{
		if (pos == buf_len)
		{
			return 0;
		}
		int beg = pos;
		pos += unicodeUTF8CharLen(ref buf, buf_len, pos);
		while (pos < buf_len)
		{
			int len = unicodeUTF8CharLen(ref buf, buf_len, pos);
			int cp = 0;
			unicodeUTF8CharToCodePoint(buf.Substring(pos), len, ref cp);
			if (unicodeIsCombiningChar(cp) == 0)
			{
				return pos - beg;
			}
			pos += len;
		}
		return pos - beg;
	}

	/* Get length of previous grapheme
	 */
	public static int unicodePrevGraphemeLen(ref string buf, int pos)
	{
		if (pos == 0)
		{
			return 0;
		}
		int end = pos;
		while (pos > 0)
		{
			int len = unicodePrevUTF8CharLen(ref buf, pos);
			pos -= len;
			int cp = 0;
			unicodeUTF8CharToCodePoint(buf.Substring(pos), len, ref cp);
			if (unicodeIsCombiningChar(cp) == 0)
			{
				return end - pos;
			}
		}
		return 0;
	}

	public static int isAnsiEscape(string buf, int buf_len, ref int len)
	{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
		if (buf_len > 2 && !memcmp("\x001B[", buf, 2))
		{
			int off = 2;
			while (off < buf_len)
			{
				switch (buf[off++])
				{
				case 'A':
			case 'B':
		case 'C':
	case 'D':
				case 'E':
			case 'F':
		case 'G':
	case 'H':
				case 'J':
			case 'K':
		case 'S':
	case 'T':
				case 'f':
			case 'm':
					len = off;
					return 1;
				}
			}
		}
		return 0;
	}

	/* Get column position for the single line mode.
	 */
	public static int unicodeColumnPos(string buf, int buf_len)
	{
		int ret = 0;

		int off = 0;
		while (off < buf_len)
		{
			int len;
			if (isAnsiEscape(buf.Substring(off), buf_len - off, ref len))
			{
				off += len;
				continue;
			}

			int cp = 0;
			len = unicodeUTF8CharToCodePoint(buf.Substring(off), buf_len - off, ref cp);

			if (unicodeIsCombiningChar(cp) == 0)
			{
				ret += unicodeIsWideChar(cp) != 0 ? 2 : 1;
			}

			off += len;
		}

		return ret;
	}

	/* Get column position for the multi line mode.
	 */
	public static int unicodeColumnPosForMultiLine(ref string buf, int buf_len, int pos, int cols, int ini_pos)
	{
		int ret = 0;
		int colwid = ini_pos;

		int off = 0;
		while (off < buf_len)
		{
			int cp = 0;
			int len = unicodeUTF8CharToCodePoint(buf.Substring(off), buf_len - off, ref cp);

			int wid = 0;
			if (unicodeIsCombiningChar(cp) == 0)
			{
				wid = unicodeIsWideChar(cp) != 0 ? 2 : 1;
			}

			int dif = (int)(colwid + wid) - (int)cols;
			if (dif > 0)
			{
				ret += dif;
				colwid = wid;
			}
			else if (dif == 0)
			{
				colwid = 0;
			}
			else
			{
				colwid += wid;
			}

			if (off >= pos)
			{
				break;
			}

			off += len;
			ret += wid;
		}

		return ret;
	}

	/* Read UTF8 character from file.
	 */
	public static int unicodeReadUTF8Char(int fd, ref string buf, ref int cp)
	{
		int nread = _read(fd, buf[0], 1);

		if (nread <= 0)
		{
			return nread;
		}

		byte @byte = buf[0];

		if ((byte & 0x80) == 0)
		{
			;
		}
		else if ((byte & 0xE0) == 0xC0)
		{
			nread = _read(fd, buf[1], 1);
			if (nread <= 0)
			{
				return nread;
			}
		}
		else if ((byte & 0xF0) == 0xE0)
		{
			nread = _read(fd, buf[1], 2);
			if (nread <= 0)
			{
				return nread;
			}
		}
		else if ((byte & 0xF8) == 0xF0)
		{
			nread = _read(fd, buf[1], 3);
			if (nread <= 0)
			{
				return nread;
			}
		}
		else
		{
			return -1;
		}

		return unicodeUTF8CharToCodePoint(buf, 4, ref cp);
	}

	/* ======================= Low level terminal handling ====================== */

	/* Set if to use or not the multi line mode. */
	public static void SetMultiLine(bool ml)
	{
		mlmode = ml;
	}

	/* Return true if the terminal name is in the list of terminals we know are
	 * not able to understand basic escape sequences. */
	public static bool isUnsupportedTerm()
	{
	#if ! _WIN32
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: char *term = getenv("TERM");
		char term = getenv("TERM");
		int j;

		if (term == null)
		{
			return false;
		}
		for (j = 0; unsupported_term[j]; j++)
		{
			if (!strcasecmp(term,unsupported_term[j]))
			{
				return true;
			}
		}
	#endif
		return false;
	}

	/* Raw mode: 1960 magic shit. */
	public static bool enableRawMode(int fd)
	{
	#if ! _WIN32
		termios raw = new termios();

		if (!_isatty((_fileno(stdin))))
		{
			goto fatal;
		}
		if (!atexit_registered)
		{
			atexit(linenoiseAtExit);
			atexit_registered = true;
		}
		if (tcgetattr(fd,orig_termios) == -1)
		{
			goto fatal;
		}

		raw = orig_termios; // modify the original mode
		/* input modes: no break, no CR to NL, no parity check, no strip char,
		 * no start/stop output control. */
		raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
		/* output modes - disable post processing */
		// NOTE: Multithreaded issue #20 (https://github.com/yhirose/cpp-linenoise/issues/20)
		// raw.c_oflag &= ~(OPOST);
		/* control modes - set 8 bit chars */
		raw.c_cflag |= (CS8);
		/* local modes - choing off, canonical off, no extended functions,
		 * no signal chars (^Z,^C) */
		raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
		/* control chars - set return condition: min number of bytes and timer.
		 * We want read to return every single byte, without timeout. */
		raw.c_cc[VMIN] = 1;
		raw.c_cc[VTIME] = 0; // 1 byte, no timer

		/* put terminal in raw mode after flushing */
		if (tcsetattr(fd, TCSAFLUSH, raw) < 0)
		{
			goto fatal;
		}
		rawmode = true;
	#else
		if (!atexit_registered)
		{
			/* Cleanup them at exit */
			atexit(linenoiseAtExit);
			atexit_registered = true;

			/* Init windows console handles only once */
			hOut = GetStdHandle(STD_OUTPUT_HANDLE);
			if (hOut == INVALID_HANDLE_VALUE)
			{
				goto fatal;
			}
		}

		uint consolemodeOut;
		if (!GetConsoleMode(hOut, consolemodeOut))
		{
			CloseHandle(hOut);
			errno = ENOTTY;
			return false;
		};

		hIn = GetStdHandle(STD_INPUT_HANDLE);
		if (hIn == INVALID_HANDLE_VALUE)
		{
			CloseHandle(hOut);
			errno = ENOTTY;
			return false;
		}

		GetConsoleMode(hIn, consolemodeIn);
		uint consolemodeInWithRaw = consolemodeIn & ~ENABLE_PROCESSED_INPUT;
		SetConsoleMode(hIn, consolemodeInWithRaw);

		rawmode = true;
	#endif
		return true;

	fatal:
		errno = ENOTTY;
		return false;
	}

	public static void disableRawMode(int fd)
	{
	#if _WIN32
		if (consolemodeIn)
		{
		  SetConsoleMode(hIn, consolemodeIn);
		  consolemodeIn = 0;
		}
		rawmode = false;
	#else
		/* Don't even check the return value as it's too late. */
		if (rawmode && tcsetattr(fd,TCSAFLUSH,orig_termios) != -1)
		{
			rawmode = false;
		}
	#endif
	}

	/* Use the ESC [6n escape sequence to query the horizontal cursor position
	 * and return it. On error -1 is returned, on success the position of the
	 * cursor. */
	public static int getCursorPosition(int ifd, int ofd)
	{
		string buf = new string(new char[32]);
		int cols;
		int rows;
		uint i = 0;

		/* Report cursor location */
		if (win32_write(ofd, "\x1b[6n", 4) != 4)
		{
			return -1;
		}

		/* Read the response: ESC [ rows ; cols R */
		while (i < sizeof(char) - 1)
		{
			if (_read(ifd,buf.Substring(i),1) != 1)
			{
				break;
			}
			if (buf[i] == 'R')
			{
				break;
			}
			i++;
		}
		buf = StringFunctions.ChangeCharacter(buf, i, '\0');

		/* Parse it. */
		if (buf[0] != KEY_ACTION.ESC || buf[1] != '[')
		{
			return -1;
		}
		if (sscanf(buf.Substring(2), "%d;%d", rows, cols) != 2)
		{
			return -1;
		}
		return cols;
	}

	/* Try to get the number of columns in the current terminal, or assume 80
	 * if it fails. */
	public static int getColumns(int ifd, int ofd)
	{
	#if _WIN32
		CONSOLE_SCREEN_BUFFER_INFO b = new CONSOLE_SCREEN_BUFFER_INFO();

		if (!GetConsoleScreenBufferInfo(hOut, b))
		{
			return 80;
		}
		return b.srWindow.Right - b.srWindow.Left;
	#else
		winsize ws = new winsize();

		if (ioctl(1, TIOCGWINSZ, ws) == -1 || ws.ws_col == 0)
		{
			/* ioctl() failed. Try to query the terminal itself. */
			int start;
			int cols;

			/* Get the initial position so we can restore it later. */
			start = getCursorPosition(ifd, ofd);
			if (start == -1)
			{
				goto failed;
			}

			/* Go to right margin and get position. */
			if (win32_write(ofd, "\x1b[999C", 6) != 6)
			{
				goto failed;
			}
			cols = getCursorPosition(ifd, ofd);
			if (cols == -1)
			{
				goto failed;
			}

			/* Restore position. */
			if (cols > start)
			{
				string seq = new string(new char[32]);
				snprintf(seq,32,"\x1b[%dD",cols - start);
				if (win32_write(ofd, seq, seq.Length) == -1)
				{
					/* Can't recover... */
				}
			}
			return cols;
		}
		else
		{
			return ws.ws_col;
		}

	failed:
		return 80;
	#endif
	}

	/* Clear the screen. Used to handle ctrl+l */
	public static void linenoiseClearScreen()
	{
		if (win32_write(DefineConstants.STDOUT_FILENO, "\x1b[H\x1b[2J", 7) <= 0)
		{
			/* nothing to do, just to avoid warning. */
		}
	}

	/* Beep, used for completion when there is nothing to complete or when all
	 * the choices were already shown. */
	public static void linenoiseBeep()
	{
		Console.Error.Write("\x7");
		fflush(stderr);
	}

	/* ============================== Completion ================================ */

	/* This is an helper function for linenoiseEdit() and is called when the
	 * user types the <tab> key in order to complete the string currently in the
	 * input.
	 *
	 * The state of the editing is encapsulated into the pointed linenoiseState
	 * structure as described in the structure definition. */
	public static int completeLine(linenoiseState ls, ref string cbuf, ref int c)
	{
		List<string> lc = new List<string>();
		int nread = 0;
		int nwritten;
		c = null;

		completionCallback(ls.buf,lc);
		if (lc.Count == 0)
		{
			linenoiseBeep();
		}
		else
		{
			int stop = 0;
			int i = 0;

			while (stop == 0)
			{
				/* Show completion or original buffer */
				if (i < (int)lc.Count)
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: struct linenoiseState saved = *ls;
					linenoiseState saved = new linenoiseState(ls);

					ls.len = ls.pos = (int)(lc[i].Length);
					ls.buf = lc[i][0];
					refreshLine(ls);
					ls.len = saved.len;
					ls.pos = saved.pos;
					ls.buf = saved.buf;
				}
				else
				{
					refreshLine(ls);
				}

				//nread = read(ls->ifd,&c,1);
	#if _WIN32
				nread = win32read(ref c);
				if (nread == 1)
				{
					cbuf[0] = c;
				}
	#else
				nread = unicodeReadUTF8Char(ls.ifd, ref cbuf, ref c);
	#endif
				if (nread <= 0)
				{
					c = -1;
					return nread;
				}

				switch (c)
				{
					case 9: // tab
						i = (i + 1) % (lc.Count + 1);
						if (i == (int)lc.Count)
						{
							linenoiseBeep();
						}
						break;
					case 27: // escape
						/* Re-show original buffer */
						if (i < (int)lc.Count)
						{
							refreshLine(ls);
						}
						stop = 1;
						break;
					default:
						/* Update buffer and return */
						if (i < (int)lc.Count)
						{
							nwritten = snprintf(ls.buf, ls.buflen, "%s", lc[i][0]);
							ls.len = ls.pos = nwritten;
						}
						stop = 1;
						break;
				}
			}
		}

		return nread;
	}

	/* Register a callback function to be called for tab-completion. */
	public static void SetCompletionCallback(CompletionCallback fn)
	{
		completionCallback = fn;
	}

	/* =========================== Line editing ================================= */

	/* Single line low level line refresh.
	 *
	 * Rewrite the currently edited line accordingly to the buffer content,
	 * cursor position, and number of columns of the terminal. */
	public static void refreshSingleLine(linenoiseState l)
	{
		string seq = new string(new char[64]);
		int pcolwid = unicodeColumnPos(l.prompt, (int)l.prompt.Length);
		int fd = l.ofd;
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
		char * buf = l.buf;
		int len = l.len;
		int pos = l.pos;
		string ab;

		while ((pcolwid + unicodeColumnPos(buf, pos)) >= l.cols)
		{
			int glen = unicodeGraphemeLen(ref buf, len, 0);
			buf += glen;
			len -= glen;
			pos -= glen;
		}
		while (pcolwid + unicodeColumnPos(buf, len) > l.cols)
		{
			len -= unicodePrevGraphemeLen(ref buf, len);
		}

		/* Cursor to left edge */
		snprintf(seq,64,"\r");
		ab += seq;
		/* Write the prompt and the current buffer content */
		ab += l.prompt;
		ab.append(buf, len);
		/* Erase to right */
		snprintf(seq,64,"\x1b[0K");
		ab += seq;
		/* Move cursor to original position. */
		snprintf(seq,64,"\r\x1b[%dC", (int)(unicodeColumnPos(buf, pos) + pcolwid));
		ab += seq;
		if (win32_write(fd, ab, (int)ab.Length) == -1)
		{
		} // Can't recover from write error.
	}

	/* Multi line low level line refresh.
	 *
	 * Rewrite the currently edited line accordingly to the buffer content,
	 * cursor position, and number of columns of the terminal. */
	public static void refreshMultiLine(linenoiseState l)
	{
		string seq = new string(new char[64]);
		int pcolwid = unicodeColumnPos(l.prompt, (int)l.prompt.Length);
		int colpos = unicodeColumnPosForMultiLine(ref l.buf, l.len, l.len, l.cols, pcolwid);
		int colpos2; // cursor column position.
		int rows = (pcolwid + colpos + l.cols - 1) / l.cols; // rows used by current buf.
		int rpos = (pcolwid + l.oldcolpos + l.cols) / l.cols; // cursor relative row.
		int rpos2; // rpos after refresh.
		int col; // colum position, zero-based.
		int old_rows = (int)l.maxrows;
		int fd = l.ofd;
		int j;
		string ab;

		/* Update maxrows if needed. */
		if (rows > (int)l.maxrows)
		{
			l.maxrows = rows;
		}

		/* First step: clear all the lines used before. To do so start by
		 * going to the last row. */
		if (old_rows - rpos > 0)
		{
			snprintf(seq,64,"\x1b[%dB", old_rows - rpos);
			ab += seq;
		}

		/* Now for every row clear it, go up. */
		for (j = 0; j < old_rows - 1; j++)
		{
			snprintf(seq,64,"\r\x1b[0K\x1b[1A");
			ab += seq;
		}

		/* Clean the top line. */
		snprintf(seq,64,"\r\x1b[0K");
		ab += seq;

		/* Write the prompt and the current buffer content */
		ab += l.prompt;
		ab.append(l.buf, l.len);

		/* Get text width to cursor position */
		colpos2 = unicodeColumnPosForMultiLine(ref l.buf, l.len, l.pos, l.cols, pcolwid);

		/* If we are at the very end of the screen with our prompt, we need to
		 * emit a newline and move the prompt to the first column. */
		if (l.pos != 0 && l.pos == l.len && (colpos2 + pcolwid) % l.cols == 0)
		{
			ab += "\n";
			snprintf(seq,64,"\r");
			ab += seq;
			rows++;
			if (rows > (int)l.maxrows)
			{
				l.maxrows = rows;
			}
		}

		/* Move cursor to right position. */
		rpos2 = (pcolwid + colpos2 + l.cols) / l.cols; // current cursor relative row.

		/* Go up till we reach the expected positon. */
		if (rows - rpos2 > 0)
		{
			snprintf(seq,64,"\x1b[%dA", rows - rpos2);
			ab += seq;
		}

		/* Set column. */
		col = (pcolwid + colpos2) % l.cols;
		if (col != 0)
		{
			snprintf(seq,64,"\r\x1b[%dC", col);
		}
		else
		{
			snprintf(seq,64,"\r");
		}
		ab += seq;

		l.oldcolpos = colpos2;

		if (win32_write(fd, ab, (int)ab.Length) == -1)
		{
		} // Can't recover from write error.
	}

	/* Insert the character 'c' at cursor current position.
	 *
	 * On error writing to the terminal -1 is returned, otherwise 0. */
	public static int linenoiseEditInsert(linenoiseState l, string cbuf, int clen)
	{
		if (l.len < l.buflen)
		{
			if (l.len == l.pos)
			{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(l.buf[l.pos], cbuf, clen);
				l.pos += clen;
				l.len += clen;
				l.buf = StringFunctions.ChangeCharacter(l.buf, l.len, '\0');
				if ((!mlmode && unicodeColumnPos(l.prompt, (int)l.prompt.Length) + unicodeColumnPos(l.buf, l.len) < l.cols))
				{
					/* Avoid a full update of the line in the
					 * trivial case. */
					if (win32_write(l.ofd, cbuf, clen) == -1)
					{
						return -1;
					}
				}
				else
				{
					refreshLine(l);
				}
			}
			else
			{
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memmove' has no equivalent in C#:
				memmove(l.buf.Substring(l.pos) + clen,l.buf.Substring(l.pos),l.len - l.pos);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
				memcpy(l.buf[l.pos], cbuf, clen);
				l.pos += clen;
				l.len += clen;
				l.buf = StringFunctions.ChangeCharacter(l.buf, l.len, '\0');
				refreshLine(l);
			}
		}
		return 0;
	}

	/* Move cursor on the left. */
	public static void linenoiseEditMoveLeft(linenoiseState l)
	{
		if (l.pos > 0)
		{
			l.pos -= unicodePrevGraphemeLen(ref l.buf, l.pos);
			refreshLine(l);
		}
	}

	/* Move cursor on the right. */
	public static void linenoiseEditMoveRight(linenoiseState l)
	{
		if (l.pos != l.len)
		{
			l.pos += unicodeGraphemeLen(ref l.buf, l.len, l.pos);
			refreshLine(l);
		}
	}

	/* Move cursor to the start of the line. */
	public static void linenoiseEditMoveHome(linenoiseState l)
	{
		if (l.pos != 0)
		{
			l.pos = 0;
			refreshLine(l);
		}
	}

	/* Move cursor to the end of the line. */
	public static void linenoiseEditMoveEnd(linenoiseState l)
	{
		if (l.pos != l.len)
		{
			l.pos = l.len;
			refreshLine(l);
		}
	}

	/* Substitute the currently edited line with the next or previous history
	 * entry as specified by 'dir'. */
	public static void linenoiseEditHistoryNext(linenoiseState l, int dir)
	{
		if (history.Count > 1)
		{
			/* Update the current history entry before to
			 * overwrite it with the next one. */
			history[history.Count - 1 - l.history_index] = l.buf;
			/* Show the new entry */
			l.history_index += (dir == DefineConstants.LINENOISE_HISTORY_PREV) ? 1 : -1;
			if (l.history_index < 0)
			{
				l.history_index = 0;
				return;
			}
			else if (l.history_index >= (int)history.Count)
			{
				l.history_index = (int)history.Count - 1;
				return;
			}
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memset' has no equivalent in C#:
			memset(l.buf, 0, l.buflen);
			l.buf = history[history.Count - 1 - l.history_index];
			l.len = l.pos = (int)l.buf.Length;
			refreshLine(l);
		}
	}

	/* Delete the character at the right of the cursor without altering the cursor
	 * position. Basically this is what happens with the "Delete" keyboard key. */
	public static void linenoiseEditDelete(linenoiseState l)
	{
		if (l.len > 0 && l.pos < l.len)
		{
			int glen = unicodeGraphemeLen(ref l.buf, l.len, l.pos);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memmove' has no equivalent in C#:
			memmove(l.buf.Substring(l.pos),l.buf.Substring(l.pos) + glen,l.len - l.pos - glen);
			l.len -= glen;
			l.buf = StringFunctions.ChangeCharacter(l.buf, l.len, '\0');
			refreshLine(l);
		}
	}

	/* Backspace implementation. */
	public static void linenoiseEditBackspace(linenoiseState l)
	{
		if (l.pos > 0 && l.len > 0)
		{
			int glen = unicodePrevGraphemeLen(ref l.buf, l.pos);
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memmove' has no equivalent in C#:
			memmove(l.buf.Substring(l.pos) - glen,l.buf.Substring(l.pos),l.len - l.pos);
			l.pos -= glen;
			l.len -= glen;
			l.buf = StringFunctions.ChangeCharacter(l.buf, l.len, '\0');
			refreshLine(l);
		}
	}

	/* Delete the previosu word, maintaining the cursor at the start of the
	 * current word. */
	public static void linenoiseEditDeletePrevWord(linenoiseState l)
	{
		int old_pos = l.pos;
		int diff;

		while (l.pos > 0 && l.buf[l.pos - 1] == ' ')
		{
			l.pos--;
		}
		while (l.pos > 0 && l.buf[l.pos - 1] != ' ')
		{
			l.pos--;
		}
		diff = old_pos - l.pos;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memmove' has no equivalent in C#:
		memmove(l.buf.Substring(l.pos),l.buf.Substring(old_pos),l.len - old_pos + 1);
		l.len -= diff;
		refreshLine(l);
	}

	/* This function is the core of the line editing capability of linenoise.
	 * It expects 'fd' to be already in "raw mode" so that every key pressed
	 * will be returned ASAP to read().
	 *
	 * The resulting string is put into 'buf' when the user type enter, or
	 * when ctrl+d is typed.
	 *
	 * The function returns the length of the current buffer. */
	public static int linenoiseEdit(int stdin_fd, int stdout_fd, ref string buf, int buflen, string prompt)
	{
		linenoiseState l = new linenoiseState();

		/* Populate the linenoise state that we pass to functions implementing
		 * specific editing functionalities. */
		l.ifd = stdin_fd;
		l.ofd = stdout_fd;
		l.buf = buf;
		l.buflen = buflen;
		l.prompt = prompt;
		l.oldcolpos = l.pos = 0;
		l.len = 0;
		l.cols = getColumns(stdin_fd, stdout_fd);
		l.maxrows = 0;
		l.history_index = 0;

		/* Buffer starts empty. */
		l.buf = StringFunctions.ChangeCharacter(l.buf, 0, '\0');
		l.buflen--; // Make sure there is always space for the nulterm

		/* The latest history entry is always our current buffer, that
		 * initially is just an empty string. */
		AddHistory("");

		if (win32_write(l.ofd, prompt, (int)l.prompt.Length) == -1)
		{
			return -1;
		}
		while (true)
		{
			int c;
			string cbuf = new string(new char[4]);
			int nread;
			string seq = new string(new char[3]);

	#if _WIN32
			nread = win32read(ref c);
			if (nread == 1)
			{
				cbuf = StringFunctions.ChangeCharacter(cbuf, 0, c);
			}
	#else
			nread = unicodeReadUTF8Char(l.ifd, ref cbuf, ref c);
	#endif
			if (nread <= 0)
			{
				return (int)l.len;
			}

			/* Only autocomplete when the callback is set. It returns < 0 when
			 * there was an error reading from fd. Otherwise it will return the
			 * character that should be handled next. */
			if (c == 9 && completionCallback != null)
			{
				nread = completeLine(l, ref cbuf, ref c);
				/* Return on errors */
				if (c < 0)
				{
					return l.len;
				}
				/* Read next character when 0 */
				if (c == 0)
				{
					continue;
				}
			}

			switch (c)
			{
			case KEY_ACTION.ENTER: // enter
				if (history.Count > 0)
				{
					history.RemoveAt(history.Count - 1);
				}
				if (mlmode)
				{
					linenoiseEditMoveEnd(l);
				}
				return (int)l.len;
			case KEY_ACTION.CTRL_C: // ctrl-c
				errno = EAGAIN;
				return -1;
			case KEY_ACTION.BACKSPACE: // backspace
			case 8: // ctrl-h
				linenoiseEditBackspace(l);
				break;
			case KEY_ACTION.CTRL_D: /* ctrl-d, remove char at right of cursor, or if the
	                            line is empty, act as end-of-file. */
				if (l.len > 0)
				{
					linenoiseEditDelete(l);
				}
				else
				{
					history.RemoveAt(history.Count - 1);
					return -1;
				}
				break;
			case KEY_ACTION.CTRL_T: // ctrl-t, swaps current character with previous.
				if (l.pos > 0 && l.pos < l.len)
				{
					char aux = buf[l.pos - 1];
					buf[l.pos - 1] = buf[l.pos];
					buf[l.pos] = aux;
					if (l.pos != l.len - 1)
					{
						l.pos++;
					}
					refreshLine(l);
				}
				break;
			case KEY_ACTION.CTRL_B: // ctrl-b
				linenoiseEditMoveLeft(l);
				break;
			case KEY_ACTION.CTRL_F: // ctrl-f
				linenoiseEditMoveRight(l);
				break;
			case KEY_ACTION.CTRL_P: // ctrl-p
				linenoiseEditHistoryNext(l, DefineConstants.LINENOISE_HISTORY_PREV);
				break;
			case KEY_ACTION.CTRL_N: // ctrl-n
				linenoiseEditHistoryNext(l, DefineConstants.LINENOISE_HISTORY_NEXT);
				break;
			case KEY_ACTION.ESC: // escape sequence
				/* Read the next two bytes representing the escape sequence.
				 * Use two calls to handle slow terminals returning the two
				 * chars at different times. */
				if (_read(l.ifd,seq,1) == -1)
				{
					break;
				}
				if (_read(l.ifd,seq.Substring(1),1) == -1)
				{
					break;
				}

				/* ESC [ sequences. */
				if (seq[0] == '[')
				{
					if (seq[1] >= '0' && seq[1] <= '9')
					{
						/* Extended escape, read additional byte. */
						if (_read(l.ifd,seq.Substring(2),1) == -1)
						{
							break;
						}
						if (seq[2] == '~')
						{
							switch (seq[1])
							{
							case '3': // Delete key.
								linenoiseEditDelete(l);
								break;
							}
						}
					}
					else
					{
						switch (seq[1])
						{
						case 'A': // Up
							linenoiseEditHistoryNext(l, DefineConstants.LINENOISE_HISTORY_PREV);
							break;
						case 'B': // Down
							linenoiseEditHistoryNext(l, DefineConstants.LINENOISE_HISTORY_NEXT);
							break;
						case 'C': // Right
							linenoiseEditMoveRight(l);
							break;
						case 'D': // Left
							linenoiseEditMoveLeft(l);
							break;
						case 'H': // Home
							linenoiseEditMoveHome(l);
							break;
						case 'F': // End
							linenoiseEditMoveEnd(l);
							break;
						}
					}
				}

				/* ESC O sequences. */
				else if (seq[0] == 'O')
				{
					switch (seq[1])
					{
					case 'H': // Home
						linenoiseEditMoveHome(l);
						break;
					case 'F': // End
						linenoiseEditMoveEnd(l);
						break;
					}
				}
				break;
			default:
				if (linenoiseEditInsert(l, cbuf, nread))
				{
					return -1;
				}
				break;
			case KEY_ACTION.CTRL_U: // Ctrl+u, delete the whole line.
				buf[0] = '\0';
				l.pos = l.len = 0;
				refreshLine(l);
				break;
			case KEY_ACTION.CTRL_K: // Ctrl+k, delete from current to end of line.
				buf[l.pos] = '\0';
				l.len = l.pos;
				refreshLine(l);
				break;
			case KEY_ACTION.CTRL_A: // Ctrl+a, go to the start of the line
				linenoiseEditMoveHome(l);
				break;
			case KEY_ACTION.CTRL_E: // ctrl+e, go to the end of the line
				linenoiseEditMoveEnd(l);
				break;
			case KEY_ACTION.CTRL_L: // ctrl+l, clear screen
				linenoiseClearScreen();
				refreshLine(l);
				break;
			case KEY_ACTION.CTRL_W: // ctrl+w, delete previous word
				linenoiseEditDeletePrevWord(l);
				break;
			}
		}
		return l.len;
	}

	/* This function calls the line editing function linenoiseEdit() using
	 * the STDIN file descriptor set in raw mode. */
	public static bool linenoiseRaw(string prompt, string line)
	{
		bool quit = false;

		if (!_isatty((_fileno(stdin))))
		{
			/* Not a tty: read from file / pipe. */
			line = Console.ReadLine();
		}
		else
		{
			/* Interactive editing. */
			if (enableRawMode((_fileno(stdin))) == false)
			{
				return quit;
			}

			string buf = new string(new char[DefineConstants.LINENOISE_MAX_LINE]);
			var count = linenoiseEdit((_fileno(stdin)), DefineConstants.STDOUT_FILENO, ref buf, DefineConstants.LINENOISE_MAX_LINE, prompt);
			if (count == -1)
			{
				quit = true;
			}
			else
			{
				line.assign(buf, count);
			}

			disableRawMode((_fileno(stdin)));
			Console.Write("\n");
		}
		return quit;
	}

	/* The high level function that is the main API of the linenoise library.
	 * This function checks if the terminal has basic capabilities, just checking
	 * for a blacklist of stupid terminals, and later either calls the line
	 * editing function or uses dummy fgets() so that you will be able to type
	 * something even in the most desperate of the conditions. */
	public static bool Readline(string prompt, string line)
	{
		if (isUnsupportedTerm())
		{
			Console.Write("{0}",prompt);
			fflush(stdout);
			line = Console.ReadLine();
			return false;
		}
		else
		{
			return linenoiseRaw(prompt, line);
		}
	}

	public static string Readline(string prompt, ref bool quit)
	{
		string line;
		quit = Readline(prompt, ref line);
		return line;
	}

	public static string Readline(string prompt)
	{
		bool quit; // dummy
		return Readline(prompt, ref quit);
	}

	/* Set the maximum length for the history. This function can be called even
	 * if there is already some history, the function will make sure to retain
	 * just the latest 'len' elements if the new history length value is smaller
	 * than the amount of items already inside the history. */
	public static bool SetHistoryMaxLen(uint len)
	{
		if (len < 1)
		{
			return false;
		}
		history_max_len = len;
		if (len < history.Count)
		{
			history.Resize(len);
		}
		return true;
	}

	/* Save the history in the specified file. On success *true* is returned
	 * otherwise *false* is returned. */
	public static bool SaveHistory(string path)
	{
		std::ofstream f = new std::ofstream(path); // TODO: need 'std::ios::binary'?
		if (f == null)
		{
			return false;
		}
		foreach (var h in history)
		{
			f << h << std::endl;
		}
		return true;
	}

	/* Load the history from the specified file. If the file does not exist
	 * zero is returned and no operation is performed.
	 *
	 * If the file exists and the operation succeeded *true* is returned, otherwise
	 * on error *false* is returned. */
	public static bool LoadHistory(string path)
	{
		std::ifstream f = new std::ifstream(path);
		if (f == null)
		{
			return false;
		}
		string line;
		while (getline(f, line))
		{
			AddHistory(line);
		}
		return true;
	}

	public static List<string> GetHistory()
	{
		return history;
	}
	}
}

namespace CryptoNote.parameters
{
	public static class GlobalMembers
	{
	public static readonly ulong DIFFICULTY_TARGET = 30; // seconds

	public static readonly uint CRYPTONOTE_MAX_BLOCK_NUMBER = 500000000;
	public static readonly uint CRYPTONOTE_MAX_BLOCK_BLOB_SIZE = 500000000;
	public static readonly uint CRYPTONOTE_MAX_TX_SIZE = 1000000000;
	public static readonly ulong CRYPTONOTE_PUBLIC_ADDRESS_BASE58_PREFIX = 3914525;
	public static readonly uint CRYPTONOTE_MINED_MONEY_UNLOCK_WINDOW = 40;
	public static readonly ulong CRYPTONOTE_BLOCK_FUTURE_TIME_LIMIT = 60 * 60 * 2;
	public static readonly ulong CRYPTONOTE_BLOCK_FUTURE_TIME_LIMIT_V3 = 3 * DIFFICULTY_TARGET;
	public static readonly ulong CRYPTONOTE_BLOCK_FUTURE_TIME_LIMIT_V4 = 6 * DIFFICULTY_TARGET;

	public static readonly uint BLOCKCHAIN_TIMESTAMP_CHECK_WINDOW = 60;
	public static readonly uint BLOCKCHAIN_TIMESTAMP_CHECK_WINDOW_V3 = 11;

	// MONEY_SUPPLY - total number coins to be generated
	public static readonly ulong MONEY_SUPPLY = UINT64_C(100000000000000);
	public static readonly uint ZAWY_DIFFICULTY_BLOCK_INDEX = 187000;
	public static readonly uint ZAWY_DIFFICULTY_V2 = 0;
	public static readonly byte ZAWY_DIFFICULTY_DIFFICULTY_BLOCK_VERSION = 3;

	public static readonly ulong LWMA_2_DIFFICULTY_BLOCK_INDEX = 620000;
	public static readonly ulong LWMA_2_DIFFICULTY_BLOCK_INDEX_V2 = 700000;
	public static readonly ulong LWMA_2_DIFFICULTY_BLOCK_INDEX_V3 = 800000;

	public static readonly ulong LWMA_3_DIFFICULTY_BLOCK_INDEX = 1000000;

	public static readonly uint EMISSION_SPEED_FACTOR = 25;
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//static_assert(EMISSION_SPEED_FACTOR <= 8 * sizeof(ulong), "Bad EMISSION_SPEED_FACTOR");

	/* Premine amount */
	public static readonly ulong GENESIS_BLOCK_REWARD = UINT64_C(0);

	/* How to generate a premine:
	
	* Compile your code
	
	* Run zedwallet, ignore that it can't connect to the daemon, and generate an
	  address. Save this and the keys somewhere safe.
	
	* Launch the daemon with these arguments:
	--print-genesis-tx --genesis-block-reward-address <premine wallet address>
	
	For example:
	TurtleCoind --print-genesis-tx --genesis-block-reward-address TRTLv2Fyavy8CXG8BPEbNeCHFZ1fuDCYCZ3vW5H5LXN4K2M2MHUpTENip9bbavpHvvPwb4NDkBWrNgURAd5DB38FHXWZyoBh4wW
	
	* Take the hash printed, and replace it with the hash below in GENESIS_COINBASE_TX_HEX
	
	* Recompile, setup your seed nodes, and start mining
	
	* You should see your premine appear in the previously generated wallet.
	
	*/
	public const string GENESIS_COINBASE_TX_HEX = "010a01ff000188f3b501029b2e4c0281c0b02e7c53291a94d1d0cbff8883f8024f5142ee494ffbbd088071210142694232c5b04151d9e4c27d31ec7a68ea568b19488cfcb422659a07a0e44dd5";
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//static_assert(sizeof(GENESIS_COINBASE_TX_HEX)/sizeof(*GENESIS_COINBASE_TX_HEX) != 1, "GENESIS_COINBASE_TX_HEX must not be empty.");

	/* This is the unix timestamp of the first "mined" block (technically block 2, not the genesis block)
	   You can get this value by doing "print_block 2" in TurtleCoind. It is used to know what timestamp
	   to import from when the block height cannot be found in the node or the node is offline. */
	public static readonly ulong GENESIS_BLOCK_TIMESTAMP = 1512800692;

	public static readonly uint CRYPTONOTE_REWARD_BLOCKS_WINDOW = 100;
	public static readonly uint CRYPTONOTE_BLOCK_GRANTED_FULL_REWARD_ZONE = 100000; //size of block (bytes) after which reward for block calculated using block size
	public static readonly uint CRYPTONOTE_BLOCK_GRANTED_FULL_REWARD_ZONE_V2 = 20000;
	public static readonly uint CRYPTONOTE_BLOCK_GRANTED_FULL_REWARD_ZONE_V1 = 10000;
	public static readonly uint CRYPTONOTE_BLOCK_GRANTED_FULL_REWARD_ZONE_CURRENT = CRYPTONOTE_BLOCK_GRANTED_FULL_REWARD_ZONE;
	public static readonly uint CRYPTONOTE_COINBASE_BLOB_RESERVED_SIZE = 600;

	public static readonly uint CRYPTONOTE_DISPLAY_DECIMAL_POINT = 2;

	public static readonly ulong MINIMUM_FEE = UINT64_C(10);

	/* This section defines our minimum and maximum mixin counts required for transactions */
	public static readonly ulong MINIMUM_MIXIN_V1 = 0;
	public static readonly ulong MAXIMUM_MIXIN_V1 = 100;

	public static readonly ulong MINIMUM_MIXIN_V2 = 7;
	public static readonly ulong MAXIMUM_MIXIN_V2 = 7;

	public static readonly ulong MINIMUM_MIXIN_V3 = 3;
	public static readonly ulong MAXIMUM_MIXIN_V3 = 3;

	/* The heights to activate the mixin limits at */
	public static readonly uint MIXIN_LIMITS_V1_HEIGHT = 440000;
	public static readonly uint MIXIN_LIMITS_V2_HEIGHT = 620000;
	public static readonly uint MIXIN_LIMITS_V3_HEIGHT = 800000;

	/* The mixin to use by default with zedwallet and turtle-service */
	/* DEFAULT_MIXIN_V0 is the mixin used before MIXIN_LIMITS_V1_HEIGHT is started */
	public static readonly ulong DEFAULT_MIXIN_V0 = 3;
	public static readonly ulong DEFAULT_MIXIN_V1 = MAXIMUM_MIXIN_V1;
	public static readonly ulong DEFAULT_MIXIN_V2 = MAXIMUM_MIXIN_V2;
	public static readonly ulong DEFAULT_MIXIN_V3 = MAXIMUM_MIXIN_V3;

	public static readonly ulong DEFAULT_DUST_THRESHOLD = UINT64_C(10);
	public static readonly ulong DEFAULT_DUST_THRESHOLD_V2 = UINT64_C(0);

	public static readonly uint DUST_THRESHOLD_V2_HEIGHT = MIXIN_LIMITS_V2_HEIGHT;
	public static readonly uint FUSION_DUST_THRESHOLD_HEIGHT_V2 = 800000;
	public static readonly ulong EXPECTED_NUMBER_OF_BLOCKS_PER_DAY = 24 * 60 * 60 / DIFFICULTY_TARGET;

	public static readonly uint DIFFICULTY_WINDOW = 17;
	public static readonly uint DIFFICULTY_WINDOW_V1 = 2880;
	public static readonly uint DIFFICULTY_WINDOW_V2 = 2880;
	public static readonly ulong DIFFICULTY_WINDOW_V3 = 60;
	public static readonly ulong DIFFICULTY_BLOCKS_COUNT_V3 = DIFFICULTY_WINDOW_V3 + 1;

	public static readonly uint DIFFICULTY_CUT = 0; // timestamps to cut after sorting
	public static readonly uint DIFFICULTY_CUT_V1 = 60;
	public static readonly uint DIFFICULTY_CUT_V2 = 60;
	public static readonly uint DIFFICULTY_LAG = 0; // !!!
	public static readonly uint DIFFICULTY_LAG_V1 = 15;
	public static readonly uint DIFFICULTY_LAG_V2 = 15;
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//static_assert(2 * DIFFICULTY_CUT <= DIFFICULTY_WINDOW - 2, "Bad DIFFICULTY_WINDOW or DIFFICULTY_CUT");

	public static readonly uint MAX_BLOCK_SIZE_INITIAL = 100000;
	public static readonly ulong MAX_BLOCK_SIZE_GROWTH_SPEED_NUMERATOR = 100 * 1024;
	public static readonly ulong MAX_BLOCK_SIZE_GROWTH_SPEED_DENOMINATOR = 365 * 24 * 60 * 60 / DIFFICULTY_TARGET;
	public static readonly ulong MAX_EXTRA_SIZE = 140000;

	public static readonly ulong CRYPTONOTE_LOCKED_TX_ALLOWED_DELTA_BLOCKS = 1;
	public static readonly ulong CRYPTONOTE_LOCKED_TX_ALLOWED_DELTA_SECONDS = DIFFICULTY_TARGET * CRYPTONOTE_LOCKED_TX_ALLOWED_DELTA_BLOCKS;

	public static readonly ulong CRYPTONOTE_MEMPOOL_TX_LIVETIME = 60 * 60 * 24; //seconds, one day
	public static readonly ulong CRYPTONOTE_MEMPOOL_TX_FROM_ALT_BLOCK_LIVETIME = 60 * 60 * 24 * 7; //seconds, one week
	public static readonly ulong CRYPTONOTE_NUMBER_OF_PERIODS_TO_FORGET_TX_DELETED_FROM_POOL = 7; // CRYPTONOTE_NUMBER_OF_PERIODS_TO_FORGET_TX_DELETED_FROM_POOL * CRYPTONOTE_MEMPOOL_TX_LIVETIME = time to forget tx

	public static readonly uint FUSION_TX_MAX_SIZE = CRYPTONOTE_BLOCK_GRANTED_FULL_REWARD_ZONE_CURRENT * 30 / 100;
	public static readonly uint FUSION_TX_MIN_INPUT_COUNT = 12;
	public static readonly uint FUSION_TX_MIN_IN_OUT_COUNT_RATIO = 4;

	public static readonly uint KEY_IMAGE_CHECKING_BLOCK_INDEX = 0;

	public static readonly uint UPGRADE_HEIGHT_V2 = 1;
	public static readonly uint UPGRADE_HEIGHT_V3 = 2;
	public static readonly uint UPGRADE_HEIGHT_V4 = 350000; // Upgrade height for CN-Lite Variant 1 switch.
	public static readonly uint UPGRADE_HEIGHT_CURRENT = UPGRADE_HEIGHT_V4;

	public static readonly uint UPGRADE_VOTING_THRESHOLD = 90; // percent
	public static readonly uint UPGRADE_VOTING_WINDOW = EXPECTED_NUMBER_OF_BLOCKS_PER_DAY; // blocks
	public static readonly uint UPGRADE_WINDOW = EXPECTED_NUMBER_OF_BLOCKS_PER_DAY; // blocks
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//static_assert(0 < UPGRADE_VOTING_THRESHOLD && UPGRADE_VOTING_THRESHOLD <= 100, "Bad UPGRADE_VOTING_THRESHOLD");
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//static_assert(UPGRADE_VOTING_WINDOW > 1, "Bad UPGRADE_VOTING_WINDOW");

	/* Block heights we are going to have hard forks at */
	public static readonly ulong[] FORK_HEIGHTS = {187000, 350000, 440000, 620000, 700000, 800000, 1000000, 1200000, 1400000, 1600000, 1800000, 2000000};

	/* MAKE SURE TO UPDATE THIS VALUE WITH EVERY MAJOR RELEASE BEFORE A FORK */
	public static readonly ulong SOFTWARE_SUPPORTED_FORK_INDEX = 6;

	public static readonly ulong FORK_HEIGHTS_SIZE = sizeof(FORK_HEIGHTS) / sizeofFORK_HEIGHTS;

	/* The index in the FORK_HEIGHTS array that this version of the software will
	   support. For example, if CURRENT_FORK_INDEX is 3, this version of the
	   software will support the fork at 600,000 blocks.
	
	   This will default to zero if the FORK_HEIGHTS array is empty, so you don't
	   need to change it manually. */
//C++ TO C# CONVERTER TODO TASK: C# does not allow bit fields:
	public const byte CURRENT_FORK_INDEX = FORK_HEIGHTS_SIZE == 0 ? 0 : SOFTWARE_SUPPORTED_FORK_INDEX;

	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//static_assert(CURRENT_FORK_INDEX >= 0, "CURRENT FORK INDEX must be >= 0");
	/* Make sure CURRENT_FORK_INDEX is a valid index, unless FORK_HEIGHTS is empty */
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
	//static_assert(FORK_HEIGHTS_SIZE == 0 || CURRENT_FORK_INDEX < FORK_HEIGHTS_SIZE, "CURRENT_FORK_INDEX out of range of FORK_HEIGHTS!");

	public const string CRYPTONOTE_BLOCKS_FILENAME = "blocks.bin";
	public const string CRYPTONOTE_BLOCKINDEXES_FILENAME = "blockindexes.bin";
	public const string CRYPTONOTE_POOLDATA_FILENAME = "poolstate.bin";
	public const string P2P_NET_DATA_FILENAME = "p2pstate.bin";
	public const string MINER_CONFIG_FILE_NAME = "miner_conf.json";
	}
}

namespace WalletConfig
{
	public static class GlobalMembers
	{
		/* The prefix your coins address starts with */
		public static readonly string addressPrefix = "TRTL";

		/* Your coins 'Ticker', e.g. Monero = XMR, Bitcoin = BTC */
		public static readonly string ticker = "TRTL";

		/* The filename to output the CSV to in save_csv */
		public static readonly string csvFilename = "transactions.csv";

		/* The filename to read+write the address book to - consider starting with
		   a leading '.' to make it hidden under mac+linux */
		public static readonly string addressBookFilename = ".addressBook.json";

		/* The name of your deamon */
		public static readonly string daemonName = "TurtleCoind";

		/* The name to call this wallet */
		public static readonly string walletName = "zedwallet";

		/* The name of service/walletd, the programmatic rpc interface to a
		   wallet */
		public static readonly string walletdName = "turtle-service";

		/* The full name of your crypto */
		public static readonly string coinName = CryptoNote.CRYPTONOTE_NAME;

		/* Where can your users contact you for support? E.g. discord */
		public static readonly string contactLink = "http://chat.turtlecoin.lol";


		/* The number of decimals your coin has */
		public static readonly int numDecimalPlaces = CryptoNote.parameters.CRYPTONOTE_DISPLAY_DECIMAL_POINT;


		/* The length of a standard address for your coin */
		public static readonly uint standardAddressLength = 99;

		/* The length of an integrated address for your coin - It's the same as
		   a normal address, but there is a paymentID included in there - since
		   payment ID's are 64 chars, and base58 encoding is done by encoding
		   chunks of 8 chars at once into blocks of 11 chars, we can calculate
		   this automatically */
		public static readonly uint integratedAddressLength = standardAddressLength + ((64 * 11) / 8);

		/* The default fee value to use with transactions (in ATOMIC units!) */
		public static readonly ulong defaultFee = CryptoNote.parameters.MINIMUM_FEE;

		/* The minimum fee value to allow with transactions (in ATOMIC units!) */
		public static readonly ulong minimumFee = CryptoNote.parameters.MINIMUM_FEE;

		/* The minimum amount allowed to be sent - usually 1 (in ATOMIC units!) */
		public static readonly ulong minimumSend = 1;

		/* Is a mixin of zero disabled on your network? */
		public static readonly bool mixinZeroDisabled = true;

		/* If a mixin of zero is disabled, at what height was it disabled? E.g.
		   fork height, or 0, if never allowed. This is ignored if a mixin of
		   zero is allowed */
		public static readonly ulong mixinZeroDisabledHeight = CryptoNote.parameters.MIXIN_LIMITS_V2_HEIGHT;
	}
}

namespace CRC32
{
	public static class GlobalMembers
	{
		/* oof */
		public static List<ulong> table = new List<ulong>() {0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918000, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117};

		public static ulong crc32(string input)
		{
			ulong crc = 0xFFFFFFFF;

			foreach (char c in input)
			{
				ulong byteIndex = (c ^ crc) & 0xff;
				crc = ((crc >> 8) ^ table[byteIndex]);
			}

			return crc ^ 0xFFFFFFFF;
		}
	}
}

namespace Mnemonics.WordList
{
	public static class GlobalMembers
	{
			public static readonly List<string> English = new List<string>() {"abbey", "abducts", "ability", "ablaze", "abnormal", "abort", "abrasive", "absorb", "abyss", "academy", "aces", "aching", "acidic", "acoustic", "acquire", "across", "actress", "acumen", "adapt", "addicted", "adept", "adhesive", "adjust", "adopt", "adrenalin", "adult", "adventure", "aerial", "afar", "affair", "afield", "afloat", "afoot", "afraid", "after", "against", "agenda", "aggravate", "agile", "aglow", "agnostic", "agony", "agreed", "ahead", "aided", "ailments", "aimless", "airport", "aisle", "ajar", "akin", "alarms", "album", "alchemy", "alerts", "algebra", "alkaline", "alley", "almost", "aloof", "alpine", "already", "also", "altitude", "alumni", "always", "amaze", "ambush", "amended", "amidst", "ammo", "amnesty", "among", "amply", "amused", "anchor", "android", "anecdote", "angled", "ankle", "annoyed", "answers", "antics", "anvil", "anxiety", "anybody", "apart", "apex", "aphid", "aplomb", "apology", "apply", "apricot", "aptitude", "aquarium", "arbitrary", "archer", "ardent", "arena", "argue", "arises", "army", "around", "arrow", "arsenic", "artistic", "ascend", "ashtray", "aside", "asked", "asleep", "aspire", "assorted", "asylum", "athlete", "atlas", "atom", "atrium", "attire", "auburn", "auctions", "audio", "august", "aunt", "austere", "autumn", "avatar", "avidly", "avoid", "awakened", "awesome", "awful", "awkward", "awning", "awoken", "axes", "axis", "axle", "aztec", "azure", "baby", "bacon", "badge", "baffles", "bagpipe", "bailed", "bakery", "balding", "bamboo", "banjo", "baptism", "basin", "batch", "bawled", "bays", "because", "beer", "befit", "begun", "behind", "being", "below", "bemused", "benches", "berries", "bested", "betting", "bevel", "beware", "beyond", "bias", "bicycle", "bids", "bifocals", "biggest", "bikini", "bimonthly", "binocular", "biology", "biplane", "birth", "biscuit", "bite", "biweekly", "blender", "blip", "bluntly", "boat", "bobsled", "bodies", "bogeys", "boil", "boldly", "bomb", "border", "boss", "both", "bounced", "bovine", "bowling", "boxes", "boyfriend", "broken", "brunt", "bubble", "buckets", "budget", "buffet", "bugs", "building", "bulb", "bumper", "bunch", "business", "butter", "buying", "buzzer", "bygones", "byline", "bypass", "cabin", "cactus", "cadets", "cafe", "cage", "cajun", "cake", "calamity", "camp", "candy", "casket", "catch", "cause", "cavernous", "cease", "cedar", "ceiling", "cell", "cement", "cent", "certain", "chlorine", "chrome", "cider", "cigar", "cinema", "circle", "cistern", "citadel", "civilian", "claim", "click", "clue", "coal", "cobra", "cocoa", "code", "coexist", "coffee", "cogs", "cohesive", "coils", "colony", "comb", "cool", "copy", "corrode", "costume", "cottage", "cousin", "cowl", "criminal", "cube", "cucumber", "cuddled", "cuffs", "cuisine", "cunning", "cupcake", "custom", "cycling", "cylinder", "cynical", "dabbing", "dads", "daft", "dagger", "daily", "damp", "dangerous", "dapper", "darted", "dash", "dating", "dauntless", "dawn", "daytime", "dazed", "debut", "decay", "dedicated", "deepest", "deftly", "degrees", "dehydrate", "deity", "dejected", "delayed", "demonstrate", "dented", "deodorant", "depth", "desk", "devoid", "dewdrop", "dexterity", "dialect", "dice", "diet", "different", "digit", "dilute", "dime", "dinner", "diode", "diplomat", "directed", "distance", "ditch", "divers", "dizzy", "doctor", "dodge", "does", "dogs", "doing", "dolphin", "domestic", "donuts", "doorway", "dormant", "dosage", "dotted", "double", "dove", "down", "dozen", "dreams", "drinks", "drowning", "drunk", "drying", "dual", "dubbed", "duckling", "dude", "duets", "duke", "dullness", "dummy", "dunes", "duplex", "duration", "dusted", "duties", "dwarf", "dwelt", "dwindling", "dying", "dynamite", "dyslexic", "each", "eagle", "earth", "easy", "eating", "eavesdrop", "eccentric", "echo", "eclipse", "economics", "ecstatic", "eden", "edgy", "edited", "educated", "eels", "efficient", "eggs", "egotistic", "eight", "either", "eject", "elapse", "elbow", "eldest", "eleven", "elite", "elope", "else", "eluded", "emails", "ember", "emerge", "emit", "emotion", "empty", "emulate", "energy", "enforce", "enhanced", "enigma", "enjoy", "enlist", "enmity", "enough", "enraged", "ensign", "entrance", "envy", "epoxy", "equip", "erase", "erected", "erosion", "error", "eskimos", "espionage", "essential", "estate", "etched", "eternal", "ethics", "etiquette", "evaluate", "evenings", "evicted", "evolved", "examine", "excess", "exhale", "exit", "exotic", "exquisite", "extra", "exult", "fabrics", "factual", "fading", "fainted", "faked", "fall", "family", "fancy", "farming", "fatal", "faulty", "fawns", "faxed", "fazed", "feast", "february", "federal", "feel", "feline", "females", "fences", "ferry", "festival", "fetches", "fever", "fewest", "fiat", "fibula", "fictional", "fidget", "fierce", "fifteen", "fight", "films", "firm", "fishing", "fitting", "five", "fixate", "fizzle", "fleet", "flippant", "flying", "foamy", "focus", "foes", "foggy", "foiled", "folding", "fonts", "foolish", "fossil", "fountain", "fowls", "foxes", "foyer", "framed", "friendly", "frown", "fruit", "frying", "fudge", "fuel", "fugitive", "fully", "fuming", "fungal", "furnished", "fuselage", "future", "fuzzy", "gables", "gadget", "gags", "gained", "galaxy", "gambit", "gang", "gasp", "gather", "gauze", "gave", "gawk", "gaze", "gearbox", "gecko", "geek", "gels", "gemstone", "general", "geometry", "germs", "gesture", "getting", "geyser", "ghetto", "ghost", "giant", "giddy", "gifts", "gigantic", "gills", "gimmick", "ginger", "girth", "giving", "glass", "gleeful", "glide", "gnaw", "gnome", "goat", "goblet", "godfather", "goes", "goggles", "going", "goldfish", "gone", "goodbye", "gopher", "gorilla", "gossip", "gotten", "gourmet", "governing", "gown", "greater", "grunt", "guarded", "guest", "guide", "gulp", "gumball", "guru", "gusts", "gutter", "guys", "gymnast", "gypsy", "gyrate", "habitat", "hacksaw", "haggled", "hairy", "hamburger", "happens", "hashing", "hatchet", "haunted", "having", "hawk", "haystack", "hazard", "hectare", "hedgehog", "heels", "hefty", "height", "hemlock", "hence", "heron", "hesitate", "hexagon", "hickory", "hiding", "highway", "hijack", "hiker", "hills", "himself", "hinder", "hippo", "hire", "history", "hitched", "hive", "hoax", "hobby", "hockey", "hoisting", "hold", "honked", "hookup", "hope", "hornet", "hospital", "hotel", "hounded", "hover", "howls", "hubcaps", "huddle", "huge", "hull", "humid", "hunter", "hurried", "husband", "huts", "hybrid", "hydrogen", "hyper", "iceberg", "icing", "icon", "identity", "idiom", "idled", "idols", "igloo", "ignore", "iguana", "illness", "imagine", "imbalance", "imitate", "impel", "inactive", "inbound", "incur", "industrial", "inexact", "inflamed", "ingested", "initiate", "injury", "inkling", "inline", "inmate", "innocent", "inorganic", "input", "inquest", "inroads", "insult", "intended", "inundate", "invoke", "inwardly", "ionic", "irate", "iris", "irony", "irritate", "island", "isolated", "issued", "italics", "itches", "items", "itinerary", "itself", "ivory", "jabbed", "jackets", "jaded", "jagged", "jailed", "jamming", "january", "jargon", "jaunt", "javelin", "jaws", "jazz", "jeans", "jeers", "jellyfish", "jeopardy", "jerseys", "jester", "jetting", "jewels", "jigsaw", "jingle", "jittery", "jive", "jobs", "jockey", "jogger", "joining", "joking", "jolted", "jostle", "journal", "joyous", "jubilee", "judge", "juggled", "juicy", "jukebox", "july", "jump", "junk", "jury", "justice", "juvenile", "kangaroo", "karate", "keep", "kennel", "kept", "kernels", "kettle", "keyboard", "kickoff", "kidneys", "king", "kiosk", "kisses", "kitchens", "kiwi", "knapsack", "knee", "knife", "knowledge", "knuckle", "koala", "laboratory", "ladder", "lagoon", "lair", "lakes", "lamb", "language", "laptop", "large", "last", "later", "launching", "lava", "lawsuit", "layout", "lazy", "lectures", "ledge", "leech", "left", "legion", "leisure", "lemon", "lending", "leopard", "lesson", "lettuce", "lexicon", "liar", "library", "licks", "lids", "lied", "lifestyle", "light", "likewise", "lilac", "limits", "linen", "lion", "lipstick", "liquid", "listen", "lively", "loaded", "lobster", "locker", "lodge", "lofty", "logic", "loincloth", "long", "looking", "lopped", "lordship", "losing", "lottery", "loudly", "love", "lower", "loyal", "lucky", "luggage", "lukewarm", "lullaby", "lumber", "lunar", "lurk", "lush", "luxury", "lymph", "lynx", "lyrics", "macro", "madness", "magically", "mailed", "major", "makeup", "malady", "mammal", "maps", "masterful", "match", "maul", "maverick", "maximum", "mayor", "maze", "meant", "mechanic", "medicate", "meeting", "megabyte", "melting", "memoir", "menu", "merger", "mesh", "metro", "mews", "mice", "midst", "mighty", "mime", "mirror", "misery", "mittens", "mixture", "moat", "mobile", "mocked", "mohawk", "moisture", "molten", "moment", "money", "moon", "mops", "morsel", "mostly", "motherly", "mouth", "movement", "mowing", "much", "muddy", "muffin", "mugged", "mullet", "mumble", "mundane", "muppet", "mural", "musical", "muzzle", "myriad", "mystery", "myth", "nabbing", "nagged", "nail", "names", "nanny", "napkin", "narrate", "nasty", "natural", "nautical", "navy", "nearby", "necklace", "needed", "negative", "neither", "neon", "nephew", "nerves", "nestle", "network", "neutral", "never", "newt", "nexus", "nibs", "niche", "niece", "nifty", "nightly", "nimbly", "nineteen", "nirvana", "nitrogen", "nobody", "nocturnal", "nodes", "noises", "nomad", "noodles", "northern", "nostril", "noted", "nouns", "novelty", "nowhere", "nozzle", "nuance", "nucleus", "nudged", "nugget", "nuisance", "null", "number", "nuns", "nurse", "nutshell", "nylon", "oaks", "oars", "oasis", "oatmeal", "obedient", "object", "obliged", "obnoxious", "observant", "obtains", "obvious", "occur", "ocean", "october", "odds", "odometer", "offend", "often", "oilfield", "ointment", "okay", "older", "olive", "olympics", "omega", "omission", "omnibus", "onboard", "oncoming", "oneself", "ongoing", "onion", "online", "onslaught", "onto", "onward", "oozed", "opacity", "opened", "opposite", "optical", "opus", "orange", "orbit", "orchid", "orders", "organs", "origin", "ornament", "orphans", "oscar", "ostrich", "otherwise", "otter", "ouch", "ought", "ounce", "ourselves", "oust", "outbreak", "oval", "oven", "owed", "owls", "owner", "oxidant", "oxygen", "oyster", "ozone", "pact", "paddles", "pager", "pairing", "palace", "pamphlet", "pancakes", "paper", "paradise", "pastry", "patio", "pause", "pavements", "pawnshop", "payment", "peaches", "pebbles", "peculiar", "pedantic", "peeled", "pegs", "pelican", "pencil", "people", "pepper", "perfect", "pests", "petals", "phase", "pheasants", "phone", "phrases", "physics", "piano", "picked", "pierce", "pigment", "piloted", "pimple", "pinched", "pioneer", "pipeline", "pirate", "pistons", "pitched", "pivot", "pixels", "pizza", "playful", "pledge", "pliers", "plotting", "plus", "plywood", "poaching", "pockets", "podcast", "poetry", "point", "poker", "polar", "ponies", "pool", "popular", "portents", "possible", "potato", "pouch", "poverty", "powder", "pram", "present", "pride", "problems", "pruned", "prying", "psychic", "public", "puck", "puddle", "puffin", "pulp", "pumpkins", "punch", "puppy", "purged", "push", "putty", "puzzled", "pylons", "pyramid", "python", "queen", "quick", "quote", "rabbits", "racetrack", "radar", "rafts", "rage", "railway", "raking", "rally", "ramped", "randomly", "rapid", "rarest", "rash", "rated", "ravine", "rays", "razor", "react", "rebel", "recipe", "reduce", "reef", "refer", "regular", "reheat", "reinvest", "rejoices", "rekindle", "relic", "remedy", "renting", "reorder", "repent", "request", "reruns", "rest", "return", "reunion", "revamp", "rewind", "rhino", "rhythm", "ribbon", "richly", "ridges", "rift", "rigid", "rims", "ringing", "riots", "ripped", "rising", "ritual", "river", "roared", "robot", "rockets", "rodent", "rogue", "roles", "romance", "roomy", "roped", "roster", "rotate", "rounded", "rover", "rowboat", "royal", "ruby", "rudely", "ruffled", "rugged", "ruined", "ruling", "rumble", "runway", "rural", "rustled", "ruthless", "sabotage", "sack", "sadness", "safety", "saga", "sailor", "sake", "salads", "sample", "sanity", "sapling", "sarcasm", "sash", "satin", "saucepan", "saved", "sawmill", "saxophone", "sayings", "scamper", "scenic", "school", "science", "scoop", "scrub", "scuba", "seasons", "second", "sedan", "seeded", "segments", "seismic", "selfish", "semifinal", "sensible", "september", "sequence", "serving", "session", "setup", "seventh", "sewage", "shackles", "shelter", "shipped", "shocking", "shrugged", "shuffled", "shyness", "siblings", "sickness", "sidekick", "sieve", "sifting", "sighting", "silk", "simplest", "sincerely", "sipped", "siren", "situated", "sixteen", "sizes", "skater", "skew", "skirting", "skulls", "skydive", "slackens", "sleepless", "slid", "slower", "slug", "smash", "smelting", "smidgen", "smog", "smuggled", "snake", "sneeze", "sniff", "snout", "snug", "soapy", "sober", "soccer", "soda", "software", "soggy", "soil", "solved", "somewhere", "sonic", "soothe", "soprano", "sorry", "southern", "sovereign", "sowed", "soya", "space", "speedy", "sphere", "spiders", "splendid", "spout", "sprig", "spud", "spying", "square", "stacking", "stellar", "stick", "stockpile", "strained", "stunning", "stylishly", "subtly", "succeed", "suddenly", "suede", "suffice", "sugar", "suitcase", "sulking", "summon", "sunken", "superior", "surfer", "sushi", "suture", "swagger", "swept", "swiftly", "sword", "swung", "syllabus", "symptoms", "syndrome", "syringe", "system", "taboo", "tacit", "tadpoles", "tagged", "tail", "taken", "talent", "tamper", "tanks", "tapestry", "tarnished", "tasked", "tattoo", "taunts", "tavern", "tawny", "taxi", "teardrop", "technical", "tedious", "teeming", "tell", "template", "tender", "tepid", "tequila", "terminal", "testing", "tether", "textbook", "thaw", "theatrics", "thirsty", "thorn", "threaten", "thumbs", "thwart", "ticket", "tidy", "tiers", "tiger", "tilt", "timber", "tinted", "tipsy", "tirade", "tissue", "titans", "toaster", "tobacco", "today", "toenail", "toffee", "together", "toilet", "token", "tolerant", "tomorrow", "tonic", "toolbox", "topic", "torch", "tossed", "total", "touchy", "towel", "toxic", "toyed", "trash", "trendy", "tribal", "trolling", "truth", "trying", "tsunami", "tubes", "tucks", "tudor", "tuesday", "tufts", "tugs", "tuition", "tulips", "tumbling", "tunnel", "turnip", "tusks", "tutor", "tuxedo", "twang", "tweezers", "twice", "twofold", "tycoon", "typist", "tyrant", "ugly", "ulcers", "ultimate", "umbrella", "umpire", "unafraid", "unbending", "uncle", "under", "uneven", "unfit", "ungainly", "unhappy", "union", "unjustly", "unknown", "unlikely", "unmask", "unnoticed", "unopened", "unplugs", "unquoted", "unrest", "unsafe", "until", "unusual", "unveil", "unwind", "unzip", "upbeat", "upcoming", "update", "upgrade", "uphill", "upkeep", "upload", "upon", "upper", "upright", "upstairs", "uptight", "upwards", "urban", "urchins", "urgent", "usage", "useful", "usher", "using", "usual", "utensils", "utility", "utmost", "utopia", "uttered", "vacation", "vague", "vain", "value", "vampire", "vane", "vapidly", "vary", "vastness", "vats", "vaults", "vector", "veered", "vegan", "vehicle", "vein", "velvet", "venomous", "verification", "vessel", "veteran", "vexed", "vials", "vibrate", "victim", "video", "viewpoint", "vigilant", "viking", "village", "vinegar", "violin", "vipers", "virtual", "visited", "vitals", "vivid", "vixen", "vocal", "vogue", "voice", "volcano", "vortex", "voted", "voucher", "vowels", "voyage", "vulture", "wade", "waffle", "wagtail", "waist", "waking", "wallets", "wanted", "warped", "washing", "water", "waveform", "waxing", "wayside", "weavers", "website", "wedge", "weekday", "weird", "welders", "went", "wept", "were", "western", "wetsuit", "whale", "when", "whipped", "whole", "wickets", "width", "wield", "wife", "wiggle", "wildly", "winter", "wipeout", "wiring", "wise", "withdrawn", "wives", "wizard", "wobbly", "woes", "woken", "wolf", "womanly", "wonders", "woozy", "worry", "wounded", "woven", "wrap", "wrist", "wrong", "yacht", "yahoo", "yanks", "yard", "yawning", "yearbook", "yellow", "yesterday", "yeti", "yields", "yodel", "yoga", "younger", "yoyo", "zapped", "zeal", "zebra", "zero", "zesty", "zigzags", "zinger", "zippers", "zodiac", "zombie", "zones", "zoom"};
	}
}

namespace std
{
	public static class GlobalMembers
	{
	public static std::ostream operator << (std::ostream s, CryptoNote.CryptoNoteConnectionContext context)
	{
	  return s << "[" << Common.ipAddressToString(context.m_remote_ip) << ":" << (int)context.m_remote_port << (context.m_is_income ? " INC" : " OUT") << "] ";
	}
	}
}

namespace System.Detail
{
	public static class GlobalMembers
	{
//C++ TO C# CONVERTER TODO TASK: 'rvalue references' have no equivalent in C#:
	public static Future<T> async<T>(Func<T>&& operation)
	{
	  return std::async(std::launch.async, std::move(operation));
	}
	}
}